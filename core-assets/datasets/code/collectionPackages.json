{"classes":[],"packages":[{"name":"Collections-Unordered","classes":[{"name":"SmallDictionary","instanceVariables":[{"name":"keys"},{"name":"values"},{"name":"size"}],"methods":[{"name":"at:ifPresent:ifAbsentPut:","linesOfCode":10,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise store and return the result of evaluating the second block as the\r\tnew value of the key.\"\r\r\t^ self\r\t\tat: key\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: [ self at: key put: anAbsentBlock value ]"},{"name":"at:ifAbsentPut:","linesOfCode":9,"sourceCode":"at: key ifAbsentPut: aBlock\r\t\"Return the value at the given key.\r\tIf the key is not included in the receiver store and return the result \r\tof evaluating aBlock as the new value.\"\r\t\r\t| index |\r\tindex := self findIndexForKey:  key.\r\t^ index = 0 \r\t\tifFalse: [values at: index]\r\t\tifTrue: [self privateAt: key put: aBlock value]"},{"name":"associationAt:ifPresent:","linesOfCode":10,"sourceCode":"associationAt: key ifPresent: aBlock\r\t\"Answer the value of evaluating aBlock optionally with an association\r\tfor the given key.\r\tIf the key is not found, return nil.\r\r\tModifying the association won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\r\t| index |\r\t(index := keys indexOf: key) = 0\r\t\tifTrue: [ ^ nil ].\r\t^ aBlock cull: key -> (values at: index)"},{"name":"includesKey:","linesOfCode":3,"sourceCode":"includesKey: key\r\t\"Answer whether the receiver has a key equal to the argument, key.\"\r\r\t^ (self findIndexForKey: key) ~= 0"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: aValue\r\tself do: [:each | aValue = each ifTrue: [^true]].\r\t^false"},{"name":"printElementsOn:","linesOfCode":10,"sourceCode":"printElementsOn: aStream\r\t| noneYet |\r\taStream nextPut: $(.\r\tnoneYet := true.\r\tself associationsDo: [ :each | \r\t\t\tnoneYet\r\t\t\t\tifTrue: [ noneYet := false ]\r\t\t\t\tifFalse: [ aStream space ].\r\t\t\taStream print: each].\r\taStream nextPut: $)"},{"name":"hasBindingThatBeginsWith:","linesOfCode":6,"sourceCode":"hasBindingThatBeginsWith: aString\r\t\"Answer true if the receiver has a key that begins with aString, false otherwise\"\r\t\r\tself keysDo:[:each | \r\t\t(each beginsWith: aString)\r\t\t\tifTrue:[^true]].\r\t^false"},{"name":"stonOn:","linesOfCode":5,"sourceCode":"stonOn: stonWriter\r\t\"I store my instances as maps\"\r\t\r\tstonWriter \r\t\twriteObject: self \r\t\tdo: [ stonWriter encodeMap: self ]"},{"name":"at:update:initial:","linesOfCode":11,"sourceCode":"at: key update: updateBlock initial: initBlocktOrValue\r\t\"I am used to update the value at a given key. The updateBlock is passed \r\tthe existing value, and the result of the block is stored back.\r\tIf the key does not exist, store the value of the initBlocktOrValue.\r\tinitBlocktOrValue can be a block in case the initial value is expencive to compute.\r\tI use findElementOrNil: to avoid looking up the key twice.\"\r\t| index |\r\tindex := self findIndexForKey: key.\r\t(index = 0)\r\t\tifTrue:  [ self at: key put: initBlocktOrValue value]\r\t\tifFalse: [ (values at: index) in: [ :val | values at: index put: (updateBlock value: val) ] ]"},{"name":"collect:","linesOfCode":10,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my values as the argument.  Collect the\r\tresulting values into a collection that is like me. Answer with the new\r\tcollection.\"\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo:[:each |\r\t\tnewCollection at: each key put: (aBlock value: each value).\r\t].\r\t^newCollection"},{"name":"=","linesOfCode":13,"sourceCode":"= aDictionary\r\t\"Two dictionaries are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same set of keys.\r\t (c) for each (common) key, they have the same value.\r\tSee issue 16760 before changing\"\r\r\tself == aDictionary ifTrue: [^true].\r\tself species == aDictionary species ifFalse: [^false].\r\tself size = aDictionary size ifFalse: [^false].\r\tself associationsDo: [:assoc|\r\t\t(aDictionary at: assoc key ifAbsent: [^false]) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true"},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: aKeyedCollection\r\taKeyedCollection == self \r\t\tifFalse: [\r\t\t\taKeyedCollection keysAndValuesDo: [:key :value | self at: key put: value]].\r\t^aKeyedCollection"},{"name":"errorKeyNotFound:","linesOfCode":2,"sourceCode":"errorKeyNotFound: aKey\r\r\tKeyNotFound signalFor: aKey"},{"name":"associationAt:","linesOfCode":5,"sourceCode":"associationAt: key \r\t\"Returns an association for the given key.\r\r\tModifying the association won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\r\t^ self associationAt: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\r\t^ self valuesDo: aBlock."},{"name":"removeKey:ifAbsent:","linesOfCode":17,"sourceCode":"removeKey: key ifAbsent: aBlock \r\t\"Remove key (and its associated value) from the receiver. If key is not in \r\tthe receiver, answer the result of evaluating aBlock. Otherwise, answer \r\tthe value externally named by key.\"\r\r\t| index value |\r\tindex := self findIndexForKey:  key.\r\tindex = 0 ifTrue: [^aBlock value].\r\t\r\tvalue := values at: index.\r\tindex to: size - 1\r\t\tdo: \r\t\t\t[:i | \r\t\t\tkeys at: i put: (keys at: i + 1).\r\t\t\tvalues at: i put: (values at: i + 1)].\r\tkeys at: size put: nil.\r\tvalues at: size put: nil.\r\tsize := size - 1.\r\t^value"},{"name":"includesIdentity:","linesOfCode":4,"sourceCode":"includesIdentity: aValue\r\t\"Answer whether aValue is one of the values of the receiver.  Contrast #includes: in which there is only an equality check, here there is an identity check\"\r\r\tself do: [:each | aValue == each ifTrue: [^ true]].\r\t^ false"},{"name":"keyAtIdentityValue:","linesOfCode":5,"sourceCode":"keyAtIdentityValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer nil.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r\r\t^self keyAtIdentityValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"isDictionary","linesOfCode":2,"sourceCode":"isDictionary\r\t^true"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^size"},{"name":"at:at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey ifAbsentPut: aZeroArgBlock\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. If firstKey is not defined, set a new dictionary for the second key and set the value of aZeroArgBlock execution. If firstKey is defined and not second key set the value of aZeroArgBlock execution. See NestedDictionaryTest for examples.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey ifAbsentPut: aZeroArgBlock"},{"name":"at:ifPresent:ifAbsent:","linesOfCode":7,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself at: key ifPresent: [ :v | ^ aPresentBlock cull: v ].\r\t^ anAbsentBlock value"},{"name":"initialize","linesOfCode":5,"sourceCode":"initialize\r\tsuper initialize.\r\tkeys := Array new: 2.\r\tvalues := Array new: 2.\r\tsize := 0"},{"name":"keyForIdentity:","linesOfCode":4,"sourceCode":"keyForIdentity: aValue\r\t\"If aValue is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check\"\r\r\tself keysAndValuesDo: [:key :value |  value == aValue ifTrue: [^  key]].\r\t^ nil"},{"name":"capacity","linesOfCode":2,"sourceCode":"capacity\r\t^keys size"},{"name":"associationAt:ifAbsent:","linesOfCode":10,"sourceCode":"associationAt: key ifAbsent: aBlock \r\t\"Answer an association for the given key.\r\tIf the key is not found, return the result of evaluating aBlock.\r\r\tModifying the association won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\r\t| index value |\r\tindex := keys indexOf: key.\r\tindex = 0 ifTrue: [ ^ aBlock value].\r\t\r\tvalue := values at: index.\r\t^ key->value."},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeMap: self"},{"name":"setClass","linesOfCode":2,"sourceCode":"setClass\r\t^ Set"},{"name":"at:","linesOfCode":3,"sourceCode":"at: key \r\t\"Answer the value associated with the key.\"\r\r\t^ self at: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"keysAndValuesRemove:","linesOfCode":10,"sourceCode":"keysAndValuesRemove: keyValueBlock\r\t\"Removes all entries for which keyValueBlock returns true.\"\r\t\"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method.\"\r\r\t| removals |\r\tremovals := OrderedCollection new.\r\tself keysAndValuesDo:\r\t\t[:key :value | (keyValueBlock value:  key value:  value)\r\t\t\tifTrue: [removals add:  key]].\r \tremovals do:\r\t\t[:aKey | self removeKey: aKey]"},{"name":"gtInspectorItemsIn:","linesOfCode":26,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self associations ];\r\t\t\"children: [ :each | \r\t\t\t(each value isDictionary) \r\t\t\t\tifTrue: [ each value associations ] \r\t\t\t\tifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])\r\t\t\t\t\t\tifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]\r\t\t\t\t\t\tifFalse: [ #() ] ] ];\"\r\t\t\tcolumn: 'Key' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each key ];\r\t\tcolumn: 'Value' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each value ];\r\t\tselectionAct: [ :table | \r\t\t\ttable rawSelection do: [ :assoc | self removeKey: assoc key ].\r\t\t\ttable update ]\r\t\t\tentitled: 'Remove item(s)';\r\t\tselectionPopulate: #selection entitled: 'Open key' with: [ :table | (table rawSelection collect: [:each | each key]) gtInspectorInterestingObject ];\r\t\tbeMultiple;\r\t\tsend: [ :selection | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'\"\r\t\t\tselection\r\t\t\t\tifNotNil: [ selection size = 1\r\t\t\t\t\t\tifTrue: [ selection anyOne value ]\r\t\t\t\t\t\tifFalse: [ selection collect: #value ] ] ]"},{"name":"errorValueNotFound:","linesOfCode":2,"sourceCode":"errorValueNotFound: value\r\r\tValueNotFound signalFor: value"},{"name":"at:ifAbsent:","linesOfCode":11,"sourceCode":"at: key ifAbsent: aBlock \r\t\"Answer the value associated with the key or, if key isn't found,\r\tanswer the result of evaluating aBlock.\"\r\r\t| index |\r\tindex := self findIndexForKey:  key.\r\tindex = 0 ifTrue: [^ aBlock value].\r\t\r\t^ values at: index.\r\r\t\"| assoc |\r\tassoc := array at: (self findElementOrNil: key).\r\tassoc ifNil: [^ aBlock value].\r\t^ assoc value\""},{"name":"keyAtValue:ifAbsent:","linesOfCode":10,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\t: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast.\"\r\t\r\t| index |\r\tindex := (values indexOf: value).\r\tindex = 0 \r\t\tifTrue: [ ^ exceptionBlock value].\r\t\t\r\t^ keys at: index.\r\r"},{"name":"privateAt:put:","linesOfCode":5,"sourceCode":"privateAt: key put: value \r\tsize == keys size ifTrue: [self growKeysAndValues].\r\tsize := size + 1.\r\tkeys at: size put: key.\r\t^values at: size put: value"},{"name":"associations","linesOfCode":7,"sourceCode":"associations\r\t\"Answer a collection containing associations for the receiver.\r\tSuggested by l. Uzonyi\r\r\tModifying the associations won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\t\r\t^Array new: self size streamContents: [ :stream |\r \t\tself associationsDo: [ :each | stream nextPut: each ] ]"},{"name":"empty","linesOfCode":5,"sourceCode":"empty\r\t1 to: size do: [ :index |\r\t\tkeys at: index put: nil.\r\t\tvalues at: index put: nil ].\r\tsize := 0\r"},{"name":"removeKey:","linesOfCode":4,"sourceCode":"removeKey: key \r\t\"Remove key from the receiver.\r\tIf key is not in the receiver, notify an error.\"\r\r\t^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"findIndexForKey:","linesOfCode":2,"sourceCode":"findIndexForKey: aKey \r\t^ keys indexOf: aKey."},{"name":"growTo:","linesOfCode":11,"sourceCode":"growTo: aSize \r\t| newKeys newValues |\r\tnewKeys := Array new: aSize.\r\tnewValues := Array new: aSize.\r\t1 to: size\r\t\tdo: \r\t\t\t[:i | \r\t\t\tnewKeys at: i put: (keys at: i).\r\t\t\tnewValues at: i put: (values at: i)].\r\tkeys := newKeys.\r\tvalues := newValues"},{"name":"valuesDo:","linesOfCode":3,"sourceCode":"valuesDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's values.\"\r\r1 to: size do: [:i | aBlock value: (values at: i)]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation \r\tself at: anAssociation key put: anAssociation value.\r\t^anAssociation"},{"name":"at:at:ifAbsent:","linesOfCode":6,"sourceCode":"at: firstKey at: secondKey ifAbsent: aZeroArgBlock\r\t\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. Execute aZeroArgBlock in case one of the key is wrong.\"\r\t\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsent: [ ^ aZeroArgBlock value ].\r\t^ subDictionary at: secondKey ifAbsent: aZeroArgBlock"},{"name":"associationsDo:","linesOfCode":5,"sourceCode":"associationsDo: aBlock \r\t\"Evaluate aBlock for each association for the receiver.\r\r\tModifying the associations won't affect the receiver because it\r\tisn't implemented with associations like Dictionary.\"\r\t\r\tself keysAndValuesDo: [:key :value | aBlock value: key -> value]"},{"name":"bindingsDo:","linesOfCode":2,"sourceCode":"bindingsDo: aBlock\r\tself associationsDo: aBlock"},{"name":"declare:from:","linesOfCode":11,"sourceCode":"declare: key from: aDictionary \r\t\"Add key to the receiver. If key already exists, do nothing. If aDictionary \r\tincludes key, then remove it from aDictionary and use its association as \r\tthe element of the receiver.\"\r\r\t(self includesKey: key) ifTrue: [^ self].\r\t(aDictionary includesKey: key)\r\t\tifTrue: \r\t\t\t[self add: (aDictionary associationAt: key).\r\t\t\taDictionary removeKey: key]\r\t\tifFalse: \r\t\t\t[self add: key -> nil]"},{"name":"difference:","linesOfCode":12,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. This is a specialized version for Dictionaries keeping the keys of the objects. At a slightly higher price of an additional Set to track duplicates.\"\r\r\t| other result duplicates |\r\t\r\tother := aCollection asSet.\r\tduplicates := Set new.\r\tresult := self class new: self size.\r\t\r\tself keysAndValuesDo: [ :key :value|\r\t\t((other includes: value) not and: [ (duplicates includes: value) not ])\r\t\t\tifTrue: [ \r\t\t\t\tduplicates add: value.\r\t\t\t\tresult at: key put: value]].\r\t\r\t^ result"},{"name":"keyAtValue:","linesOfCode":4,"sourceCode":"keyAtValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer nil.\"\r\r\t^self keyAtValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"at:update:","linesOfCode":3,"sourceCode":"at: key update: updateBlock \r\t\"I am used to update the value at a given key, or if the key does not exist, to throw an error\"\r\tself at: key update: updateBlock initial: [ self errorKeyNotFound: key ]."},{"name":"keysAndValuesDo:","linesOfCode":2,"sourceCode":"keysAndValuesDo: aBlock\r\t1 to: size do: [:i | aBlock value: (keys at: i) value: (values at: i)]"},{"name":"remove:","linesOfCode":2,"sourceCode":"remove:anAssociation\r\r\tself removeKey:anAssociation key."},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tkeys := keys copy.\r\tvalues := values copy"},{"name":"includesAssociation:","linesOfCode":4,"sourceCode":"includesAssociation: anAssociation\r  ^ (self   \r      associationAt: anAssociation key\r      ifAbsent: [ ^ false ]) value = anAssociation value\r"},{"name":"isHealthy","linesOfCode":13,"sourceCode":"isHealthy\r\t\"Since this dictionary does no hashing, we consider it healthy\r\tif it contains no duplicate keys.\"\r\r\t| uniqueKeys |\r\tuniqueKeys := self setClass new: self size.\r\tkeys\r\t\tdo: [ :each | \r\t\t\teach\r\t\t\t\tifNotNil: [\r\t\t\t\t\t(uniqueKeys includes: each)\r\t\t\t\t\t\tifTrue: [ ^ false ].\r\t\t\t\t\tuniqueKeys add: each ] ].\r\t^ true"},{"name":"at:at:","linesOfCode":10,"sourceCode":"at: firstKey at: secondKey\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey.\"\r\r\t\"\r\t(Dictionary new\r\t\tat: #top at: #below1 put: 1;\r\t\tat: #top at: #below1 put: 2;\r\t\tat: #top at: #below1)\r\t>>>\r\t2\"\r\r\t^ self at: firstKey at: secondKey ifAbsent: [ self errorKeyNotFound: secondKey ]"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\tself removeKey: oldObject key ifAbsent: anExceptionBlock.\r\t^oldObject"},{"name":"growKeysAndValues","linesOfCode":2,"sourceCode":"growKeysAndValues\r\tself growTo: size * 2"},{"name":"keyAtIdentityValue:ifAbsent:","linesOfCode":10,"sourceCode":"keyAtIdentityValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r \t\r\t| index |\r\tindex := (values identityIndexOf: value).\r\tindex = 0 \r\t\tifTrue: [ ^ exceptionBlock value].\r\t^ keys at: index.\r"},{"name":"keysDo:","linesOfCode":2,"sourceCode":"keysDo: aBlock \r\t1 to: size do: [:i | aBlock value: (keys at: i)]"},{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\tself initialize."},{"name":"keys","linesOfCode":3,"sourceCode":"keys\r\t\"Answer an Array containing the receiver's keys.\"\r\t\r\t^ keys copyFrom: 1 to: size"},{"name":"values","linesOfCode":5,"sourceCode":"values\r\t\"Answer a Collection containing the receiver's values.\"\r\t^Array \r\t\tnew: self size \r\t\tstreamContents: [ :out | self valuesDo: [:value | out nextPut: value]]"},{"name":"at:at:put:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey put: aValue\r\t\"Set a value at secondKey in the dictionary returned by firstKey.\"\r\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey put: aValue\r"},{"name":"keysSortedSafely","linesOfCode":14,"sourceCode":"keysSortedSafely\r\t\"Answer a SortedCollection containing the receiver's keys.\"\r\t| sortedKeys |\r\tsortedKeys := SortedCollection new: self size.\r\tsortedKeys sortBlock:\r\t\t[:x :y |  \"Should really be use <obj, string, num> compareSafely...\"\r\t\t((x isString and: [y isString])\r\t\t\tor: [x isNumber and: [y isNumber]])\r\t\t\tifTrue: [x < y]\r\t\t\tifFalse: [x class == y class\r\t\t\t\tifTrue: [x printString < y printString]\r\t\t\t\tifFalse: [x class name < y class name]]].\r\tself keysDo: [:each | sortedKeys addLast: each].\r\t^ sortedKeys reSort"},{"name":"storeOn:","linesOfCode":14,"sourceCode":"storeOn: aStream\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new)'.\r\tnoneYet := true.\r\tself associationsDo: [ :each | \r\t\t\tnoneYet\r\t\t\t\tifTrue: [ noneYet := false ]\r\t\t\t\tifFalse: [ aStream nextPut: $; ].\r\t\t\taStream nextPutAll: ' add: '.\r\t\t\taStream store: each].\r\tnoneYet ifFalse: [ aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"associationsSelect:","linesOfCode":10,"sourceCode":"associationsSelect: aBlock \r\t\"Evaluate aBlock with each of my associations as the argument. Collect\r\tinto a new dictionary, only those associations for which aBlock evaluates\r\tto true.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo: \r\t\t[:each | \r\t\t(aBlock value: each) ifTrue: [newCollection add: each]].\r\t^newCollection"},{"name":"at:ifPresent:","linesOfCode":8,"sourceCode":"at: key ifPresent: aBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the given block optionally with the value associated\r\twith the key.\r\tOtherwise, answer nil.\"\r\r\t| v |\r\tv := self at: key ifAbsent: [^ nil].\r\t^ aBlock cull: v\r"},{"name":"associationAt:ifPresent:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the association for the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself associationAt: key ifPresent: [:assoc | ^ aPresentBlock cull: assoc].\r\t^ anAbsentBlock value"},{"name":"select:","linesOfCode":10,"sourceCode":"select: aBlock \r\t\"Evaluate aBlock with each of my values as the argument. Collect into a\r\tnew dictionary, only those associations for which aBlock evaluates to\r\ttrue.\"\r\r\t| newCollection |\r\tnewCollection := self copyEmpty.\r\tself associationsDo: \r\t\t[:each | \r\t\t(aBlock value: each value) ifTrue: [newCollection add: each]].\r\t^newCollection"},{"name":"at:put:","linesOfCode":8,"sourceCode":"at: key put: value \r\t\"Set the value at key to be anObject.  If key is not found, create a\r\tnew entry for key and set is value to anObject. Answer anObject.\"\r\r\t| index |\r\tindex := self findIndexForKey:  key.\r\t^ index = 0\r\t\tifFalse: [values at: index put: value]\r\t\tifTrue: [self privateAt: key put: value]\t\r\t"},{"name":"bindingOf:","linesOfCode":2,"sourceCode":"bindingOf: varName\r\t^self associationAt: varName ifAbsent:[nil]"}],"meta":{"name":"SmallDictionary class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: aSize \r\t\"Ignore the size\"\r\r\t^self basicNew initialize"},{"name":"newFromKeys:andValues:","linesOfCode":7,"sourceCode":"newFromKeys: keys andValues: values\r\t\"Create a dictionary from the keys and values arguments which should have the same length.\"\r\t\r\t\"(SmallDictionary newFromKeys: #(#x #y) andValues: #(3 6)) >>> (SmallDictionary new at: #x put: 3; at: #y put: 6 ;yourself)\"\r\t\r\t| dict |\r\tdict := self new.\r\tkeys with: values do: [ :k :v | dict at: k put: v ].\r\t^ dict"},{"name":"newFromPairs:","linesOfCode":8,"sourceCode":"newFromPairs: anArray \r\t\"Answer an instance of me associating (anArray at:i) to (anArray at: i+i) for each odd i.  anArray must have an even number of entries.\"\r\r\t| newDictionary |\r\r\tnewDictionary := self new: (anArray size/2).\r\t1 to: (anArray size-1) by: 2 do: [ :i|\r\t\tnewDictionary at: (anArray at: i) put: (anArray at: i+1).\r\t].\r\t^ newDictionary"},{"name":"newFrom:","linesOfCode":11,"sourceCode":"newFrom: aDict \r\t\"Answer an instance of me containing the same associations as aDict.\r\t Error if any key appears twice.\"\r\t| newDictionary |\r\tnewDictionary := self new: aDict size.\r\taDict associationsDo:\r\t\t[:x |\r\t\t(newDictionary includesKey: x key)\r\t\t\tifTrue: [self error: 'Duplicate key: ', x key printString]\r\t\t\tifFalse: [newDictionary add: x]].\r\t^ newDictionary"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r    ^ EyeDictionaryInspector"},{"name":"fromSton:","linesOfCode":7,"sourceCode":"fromSton: stonReader\r\t\"My instances are stored as maps.\"\r\t\r\t| dictionary |\r\tdictionary := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tdictionary at: key put: value ].\r\t^ dictionary"}],"meta":null}},{"name":"SmallIdentityDictionary","instanceVariables":[],"methods":[{"name":"findIndexForKey:","linesOfCode":2,"sourceCode":"findIndexForKey: aKey \r\t^ keys identityIndexOf: aKey"},{"name":"setClass","linesOfCode":2,"sourceCode":"setClass\r\t^ IdentitySet"}],"meta":{"name":"SmallIdentityDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ManifestCollectionsUnordered","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsUnordered class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'Collections-Streams' #'Math-Operations-Extensions' #'System-Support')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Strings' #'Collections-Support' #Kernel #'Collections-Sequenceable' #'Collections-Abstract')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Unordered'"}],"meta":null}},{"name":"PluggableDictionary","instanceVariables":[{"name":"hashBlock"},{"name":"equalBlock"}],"methods":[{"name":"=","linesOfCode":15,"sourceCode":"= aDictionary\r\t\"Two dictionaries are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same set of keys.\r\t (c) for each (common) key, they have the same value.\r\tSee issue 16760 before changing\"\r\r\tself == aDictionary ifTrue: [^true].\r\tself species == aDictionary species ifFalse: [^false].\r\tself size = aDictionary size ifFalse: [^false].\r\tself equalBlock = aDictionary equalBlock ifFalse: [^false].\r\tself hashBlock = aDictionary hashBlock ifFalse: [^false].\r\tself associationsDo: [:assoc|\r\t\t(aDictionary at: assoc key ifAbsent: [^false]) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true"},{"name":"hashBlock","linesOfCode":3,"sourceCode":"hashBlock\r\t\"Return the block used for hashing the keys in the receiver.\"\r\t^hashBlock"},{"name":"equalBlock","linesOfCode":3,"sourceCode":"equalBlock\r\t\"Return the block used for comparing the elements in the receiver.\"\r\t^equalBlock"},{"name":"equalBlock:","linesOfCode":3,"sourceCode":"equalBlock: aBlock\r\t\"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise\"\r\tequalBlock := aBlock."},{"name":"scanFor:","linesOfCode":25,"sourceCode":"scanFor: anObject \r\t\"Scan the key array for the first slot containing either a nil\r(indicating \r\t  an empty slot) or an element that matches anObject. Answer the index \r\t  \r\tof that slot or zero if no slot is found. This  method will be\roverridden   \r\tin various subclasses that have different interpretations for matching \r \r\telements.\"\r\t| element start finish |\r\tstart := (hashBlock ifNil: [anObject hash]\r\t\t\t\tifNotNil: [hashBlock value: anObject])\r\t\t\t\t\\\\ array size + 1.\r\tfinish := array size.\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do: [:index | ((element := array at: index) == nil or:\r[equalBlock ifNil: [element key = anObject]\r\t\t\t\tifNotNil: [equalBlock value: element key value: anObject]])\r\t\t\tifTrue: [^ index]].\r\t\"Search from 1 to where we started.\"\r\t1 to: start - 1 do: [:index | ((element := array at: index) == nil or:\r[equalBlock ifNil: [element key = anObject]\r\t\t\t\tifNotNil: [equalBlock value: element key value: anObject]])\r\t\t\tifTrue: [^ index]].\r\t^ 0\"No match AND no empty slot\""},{"name":"copyEmpty","linesOfCode":4,"sourceCode":"copyEmpty\r\t^super copyEmpty\r\t\thashBlock: hashBlock;\r\t\tequalBlock: equalBlock"},{"name":"hash","linesOfCode":4,"sourceCode":"hash\r\t\"hashBlock is used to hash keys for lookup, not the dictionary itself, but its hash is still\r\tconsidered.\"\r\t^ (super hash bitXor: self equalBlock hash) bitXor: self hashBlock hash"},{"name":"scanForEmptySlotFor:","linesOfCode":10,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := (hashBlock\r\t\tifNil: [ aKey hash ]\r\t\tifNotNil: [ hashBlock value: aKey ]) \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"hashBlock:","linesOfCode":3,"sourceCode":"hashBlock: aBlock\r\t\"Set a new hash block. The block must accept one argument and must return the hash value of the given argument.\"\r\thashBlock := aBlock."}],"meta":{"name":"PluggableDictionary class","instanceVariables":[],"methods":[{"name":"integerDictionary","linesOfCode":2,"sourceCode":"integerDictionary\r\t^ self new hashBlock: [:integer | integer hash \\\\ 1064164 * 1009]"}],"meta":null}},{"name":"ValueNotFound","instanceVariables":[],"methods":[{"name":"standardMessageText","linesOfCode":7,"sourceCode":"standardMessageText\r\t\"Generate a standard textual description\"\r\t\r\t^ String streamContents: [ :stream |\r\t\tstream << 'value '.\r\t\tstream print: self object.\r\t\tstream << ' not found in '.\r\t\tstream print: self collection class]"},{"name":"value","linesOfCode":2,"sourceCode":"value\r\t^ self object"},{"name":"value:","linesOfCode":2,"sourceCode":"value: aValue\r\t^ self object: aValue"}],"meta":{"name":"ValueNotFound class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentityBag","instanceVariables":[],"methods":[{"name":"asSet","linesOfCode":2,"sourceCode":"asSet\r\t^contents keys asIdentitySet"}],"meta":{"name":"IdentityBag class","instanceVariables":[],"methods":[{"name":"contentsClass","linesOfCode":2,"sourceCode":"contentsClass\r\t^IdentityDictionary"}],"meta":null}},{"name":"IdentitySet","instanceVariables":[],"methods":[{"name":"fuelReplacement","linesOfCode":6,"sourceCode":"fuelReplacement\r\t| copy |\r\tcopy := self copyEmpty addAll: self.\r\t^ (self size ~= copy size)\r\t\tifTrue: [ copy ]\r\t\tifFalse: [ self ]"},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"scanFor:","linesOfCode":11,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start hash |\r\thash := anObject identityHash.\r\tindex := start := hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == nil or: [ element enclosedElement == anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"asIdentitySet","linesOfCode":2,"sourceCode":"asIdentitySet\r\t^self"}],"meta":{"name":"IdentitySet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Bag","instanceVariables":[{"name":"contents"}],"methods":[{"name":"add:","linesOfCode":3,"sourceCode":"add: newObject \r\t\"Include newObject as one of the receiver's elements. Answer newObject.\"\r\r\t^ self add: newObject withOccurrences: 1"},{"name":"includes:","linesOfCode":5,"sourceCode":"includes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t\"(#(1 2 2 3 1 1 1) includes: 5) >>> false\"\r\t\"(#(1 2 2 3 1 1 1) includes: 1) >>> true\"\r\t\r\t^ contents includesKey: anObject"},{"name":"add:withOccurrences:","linesOfCode":4,"sourceCode":"add: newObject withOccurrences: anInteger \r\t\"Add newObject anInteger times to the receiver. Answer newObject.\"\r\r\tcontents at: newObject put: (contents at: newObject ifAbsent: [0]) + anInteger.\r\t^ newObject"},{"name":"associationsDo:","linesOfCode":4,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).  Provided for compatibility with Dictionaries\"\r\r\tcontents associationsDo: aBlock"},{"name":"occurrencesOf:","linesOfCode":6,"sourceCode":"occurrencesOf: anObject \r\t\"Answer how many of the receiver's elements are equal to anObject.\"\r\t\r\t\"(#(1 2 2 3 1 1 1) asBag occurrencesOf: 1) >>> 4\"\r\t\r\t^ (self includes: anObject)\r\t\tifTrue: [ contents at: anObject]\r\t\tifFalse: [ 0 ]"},{"name":"keysAndValuesDo:","linesOfCode":4,"sourceCode":"keysAndValuesDo: aTwoArgBlock \r    \"Iterate over the receiver and apply a two argument block on the element and its occurrences.\"\r     \r    contents associationsDo: [:assoc | aTwoArgBlock value: assoc key value: assoc value ]"},{"name":"stonOn:","linesOfCode":5,"sourceCode":"stonOn: stonWriter\r\t\"Use a map with element-occurrences pairs as representation\"\r\r\tstonWriter \r\t\twriteObject: self \r\t\tdo: [ stonWriter encodeMap: contents ]"},{"name":"=","linesOfCode":11,"sourceCode":"= aBag\r\t\"Two bags are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same size.\r\t (c) each element occurs the same number of times in both of them\"\r\r\t(aBag isKindOf: Bag) ifFalse: [^false].\r\tself size = aBag size ifFalse: [^false].\r\tcontents associationsDo: [:assoc|\r\t\t(aBag occurrencesOf: assoc key) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true\r\r"},{"name":"asSet","linesOfCode":4,"sourceCode":"asSet\r\t\"Answer a set with the elements of the receiver.\"\r\t\"#(1 2 2 3 1 1 1) asBag asSet >>> #(1 2 2 3 1 1 1) asSet\"\r\t\r\t^ contents keys asSet"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tcontents := contents copy"},{"name":"asBag","linesOfCode":2,"sourceCode":"asBag\r\t^ self"},{"name":"cumulativeCounts","linesOfCode":7,"sourceCode":"cumulativeCounts\r\t\"Answer with a collection of cumulative percents covered by elements so far.\"\r\t\r\t\"#(1 2 2 3 1 1 1) asBag cumulativeCounts >>> {57.1->1 . 85.7->2 . 100.0->3}\"\r\t\r\t| s n |\r\ts := self size / 100.0. n := 0.\r\t^ self sortedCounts asArray collect:\r\t\t[:a | n := n + a key. (n / s roundTo: 0.1) -> a value]"},{"name":"sortedCounts","linesOfCode":9,"sourceCode":"sortedCounts\r\t\"Answer with a collection of counts with elements, sorted by decreasing\r\tcount.\"\r\t\"Suggested by l. Uzonyi\"\r\r\t^(Array new: contents size streamContents: [ :stream |\r \t\t\tcontents associationsDo: [ :each |\r \t\t\t\tstream nextPut: each value -> each key ] ])\r \t\tsort: [:x :y | x >= y ];\r \t\tyourself"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\r\tcontents associationsDo: [:assoc | assoc value timesRepeat: [aBlock value: assoc key]]"},{"name":"valuesAndCounts","linesOfCode":2,"sourceCode":"valuesAndCounts\r\r\t^ contents"},{"name":"remove:ifAbsent:","linesOfCode":11,"sourceCode":"remove: oldObject ifAbsent: exceptionBlock \r\t\"Remove oldObject from the receiver's elements. If several of the \r\telements are equal to oldObject, only one is removed. If no element is \r\tequal to oldObject, answer the result of evaluating anExceptionBlock. \r\tOtherwise, answer the argument, oldObject.\"\r\r\t| count |\r\tcount := contents at: oldObject ifAbsent: [^ exceptionBlock value].\r\tcount = 1\r\t\tifTrue: [contents removeKey: oldObject]\r\t\tifFalse: [contents at: oldObject put: count - 1].\r\t^ oldObject"},{"name":"sortedElements","linesOfCode":6,"sourceCode":"sortedElements\r\t\"Answer with a collection of elements with counts, sorted by element.\"\r\t\r\t\"#(1 2 2 3 1 1 1) asBag sortedElements >>> {1->4. 2->2. 3->1}\"\r\t\r\t^contents associations\r \t\tsort;\r \t\tyourself"},{"name":"removeAll","linesOfCode":5,"sourceCode":"removeAll\r\t\"Implementation Note: as contents will be overwritten, a shallowCopy of self would be modified.\r\tAn alternative implementation preserving capacity would be to create a new contents:\r\tself setContents: (self class contentsClass new: contents size).\"\r\t\r\tcontents removeAll"},{"name":"size","linesOfCode":7,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t\"#(1 2 2 3 1 1 1) asBag size >>> 7\"\r\t\r\t| tally |\r\ttally := 0.\r\tcontents do: [:each | tally := tally + each].\r\t^ tally"},{"name":"sum","linesOfCode":12,"sourceCode":"sum\r\t\"Return the sum (+) of the elements held in the receiver.\"\r\t\"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag).\"\r\t\r\t\"#(1 2 2 3 1 1 1) sum >>> 11\"\r\t\r\t| sum first |\r\tfirst := true.\r\tcontents keysAndValuesDo: [ :value :count |\r\t\tfirst \r\t\t\tifTrue: [ sum := value * count. first := false ]\r\t\t\tifFalse: [ sum := sum + (value * count) ] ].\r\tfirst ifTrue: [ self errorEmptyCollection ].\r\t^ sum"},{"name":"atRandom:","linesOfCode":11,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver. Uses aGenerator which\r\tshould be kept by the user in a variable and used every time. Use\r\tthis instead of #atRandom for better uniformity of random numbers because \r\tonly you use the generator. Causes an error if self has no elements.\"\r\r\t| index |\r \tself emptyCheck.\r \tindex := aGenerator nextInteger: self size.\r \t\"overwritten to use a faster enumeration\"\r \tself doWithOccurrences: [ :key :count | \r \t\t(index := index - count) <= 0 ifTrue: [ ^key ] ]"},{"name":"setContents:","linesOfCode":2,"sourceCode":"setContents: aDictionary\r\tcontents := aDictionary"},{"name":"gtInspectorOccurrencesIn:","linesOfCode":16,"sourceCode":"gtInspectorOccurrencesIn: composite\r\t<gtInspectorPresentationOrder: 1>  \r\t^ (composite fastTable)\r\t\ttitle: 'Occurrences';\r\t\tdisplay: [ :aCollection | self asSet asOrderedCollection ];\r\t\tcolumn: 'Item' \r\t\t\tevaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each ];\r\t\tcolumn: 'Occurrences' \r\t\t\tevaluated: [ :each | self occurrencesOf: each ]\r\t\t\tsortedBy: [ :a :b | (self occurrencesOf: a) > (self occurrencesOf: b)];\r\t\tbeMultiple;\r\t\t\"withSmalltalkSearch;\"\r\t\tshowOnly: 50;\r\t\tsend: [ :result |\r\t\t\t\tresult ];\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'."},{"name":"gtInspectorItemsIn:","linesOfCode":3,"sourceCode":"gtInspectorItemsIn: composite\r\t\"Disable the Items presentation for a bag.\r\tThis avoid showing all duplicated items.\""},{"name":"doWithOccurrences:","linesOfCode":4,"sourceCode":"doWithOccurrences: aTwoArgBlock \r    \"Iterate over the receiver and apply a two argument block on the element and its occurrences.\"\r        \r    contents associationsDo: [:assoc | aTwoArgBlock value: assoc key value: assoc value ]"}],"meta":{"name":"Bag class","instanceVariables":[],"methods":[{"name":"fromSton:","linesOfCode":7,"sourceCode":"fromSton: stonReader\r\t\"Read a map representation containing element/occurrences pairs\"\r\t\r\t| bag |\r\tbag := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tbag add: key withOccurrences: value ].\r\t^ bag"},{"name":"new:","linesOfCode":2,"sourceCode":"new: nElements\r\t^ super new setContents: (self contentsClass new: nElements)"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: 4"},{"name":"newFrom:","linesOfCode":6,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r\t^ self withAll: aCollection\r\r\"Examples:\r\tBag newFrom: {1. 2. 3. 3}\r\t{1. 2. 3. 3} as: Bag\r\""},{"name":"contentsClass","linesOfCode":2,"sourceCode":"contentsClass\r\t^Dictionary"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeBagInspector"}],"meta":null}},{"name":"PluggableSet","instanceVariables":[{"name":"hashBlock"},{"name":"equalBlock"}],"methods":[{"name":"hashBlock","linesOfCode":3,"sourceCode":"hashBlock\r\t\"Return the block used for hashing the elements in the receiver.\"\r\t^hashBlock"},{"name":"equalBlock","linesOfCode":3,"sourceCode":"equalBlock\r\t\"Return the block used for comparing the elements in the receiver.\"\r\t^equalBlock"},{"name":"equalBlock:","linesOfCode":3,"sourceCode":"equalBlock: aBlock\r\t\"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise\"\r\tequalBlock := aBlock."},{"name":"scanFor:","linesOfCode":12,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := (hashBlock ifNil: [anObject hash] ifNotNil: [ hashBlock value: anObject]) \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == nil or: [ \r\t\t\tequalBlock ifNil: [element enclosedElement = anObject] ifNotNil: [ \r\t\t\t\tequalBlock value: element enclosedElement value: anObject ]])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"copyEmpty","linesOfCode":4,"sourceCode":"copyEmpty\r\t^super copyEmpty\r\t\thashBlock: hashBlock;\r\t\tequalBlock: equalBlock"},{"name":"scanForEmptySlotFor:","linesOfCode":10,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := (hashBlock\r\t\tifNil: [ aKey hash ]\r\t\tifNotNil: [ hashBlock value: aKey ]) \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"hashBlock:","linesOfCode":3,"sourceCode":"hashBlock: aBlock\r\t\"Set a new hash block. The block must accept one argument and return the hash value of the given argument.\"\r\thashBlock := aBlock."}],"meta":{"name":"PluggableSet class","instanceVariables":[],"methods":[{"name":"integerSet","linesOfCode":2,"sourceCode":"integerSet\r\t^self new hashBlock: [:integer | integer hash \\\\ 1064164 * 1009]"}],"meta":null}},{"name":"KeyedTree","instanceVariables":[],"methods":[{"name":"atPath:put:","linesOfCode":9,"sourceCode":"atPath: anArray put: aBlock\r\t\"Answer the value of aBlock after creating its path.\"\r\r\t|element|\r\tanArray isEmpty\r\t\tifTrue: [^self].\r\telement := self.\r\tanArray allButLastDo: [:key |\r\t\telement := element at: key ifAbsentPut: [self species new]].\r\t^element at: anArray last put: aBlock"},{"name":"atPath:ifAbsent:","linesOfCode":8,"sourceCode":"atPath: anArray ifAbsent: aBlock\r\t\"Answer the element referenced by the given key path.\r\tAnswer the value of aBlock if not found.\"\r\r\t|element|\r\telement := self.\r\tanArray do: [:key |\r\t\telement := element at: key ifAbsent: [^aBlock value]].\r\t^element"},{"name":"atPath:ifAbsentPut:","linesOfCode":10,"sourceCode":"atPath: anArray ifAbsentPut: aBlock\r\t\"Answer the element referenced by the given key path.\r\tAnswer the value of aBlock if not found after creating its path.\"\r\r\t|element|\r\tanArray isEmpty\r\t\tifTrue: [^self].\r\telement := self.\r\tanArray allButLastDo: [:key |\r\t\telement := element at: key ifAbsentPut: [self species new]].\r\t^element at: anArray last ifAbsentPut: aBlock"},{"name":"putFormattedTextOn:level:indentString:","linesOfCode":13,"sourceCode":"putFormattedTextOn: aStream level: indentLevel indentString: aString\r\t\"Place a description of the receiver on the given stream with the given indentation level.\"\r\r\t\r\t(self keys asSortedCollection: self sortBlock) do: [:k | | v |\r\t\tindentLevel timesRepeat: [aStream nextPutAll: aString].\r\t\taStream nextPutAll: k printString.\r\t\tv := self at: k.\r\t\t(v isKindOf: self class)\r\t\t\tifTrue: [aStream cr.\r\t\t\t\t\tv putFormattedTextOn: aStream level: indentLevel + 1 indentString: aString]\r\t\t\tifFalse: [aStream\r\t\t\t\t\t\tnextPutAll: ' : ';\r\t\t\t\t\t\tnextPutAll: v printString.\r\t\t\t\t\taStream cr]]"},{"name":"atPath:","linesOfCode":4,"sourceCode":"atPath: anArray\r\t\"Answer the element referenced by the give key path.\r\tSignal an error if not found.\"\r\r\t^self atPath: anArray ifAbsent: [self errorKeyNotFound: anArray]"},{"name":"formattedTextWithDescriptions:","linesOfCode":8,"sourceCode":"formattedTextWithDescriptions: aKeyedTree\r\t\"Answer a string or text representing the receiver with indentation and, possibly, markup.\r\tDescriptions of each item are taken from the given tree with\r\tthe same key structure as the receiver.\"\r\t\r\t|str|\r\tstr := String new writeStream.\r\tself putFormattedTextOn: str withDescriptions: aKeyedTree level: 0 indentString: '  '.\r\t^str contents"},{"name":"merge:","linesOfCode":11,"sourceCode":"merge: aKeyedTree\r\t\"Merge the given tree into the receiver, overwriting or extending elements as needed.\"\r\r\taKeyedTree keysAndValuesDo: [ :k :v | \r\t\t\t| subtree |\r\t\t\t(v isKindOf: KeyedTree)\r\t\t\t\tifTrue: [ \r\t\t\t\t\tsubtree := self at: k ifAbsentPut: [ v species new ].\r\t\t\t\t\t(subtree isKindOf: KeyedTree)\r\t\t\t\t\t\tifFalse: [ subtree := self at: k put: v species new ].\r\t\t\t\t\tsubtree merge: v ]\r\t\t\t\tifFalse: [ self at: k put: v ] ]"},{"name":"postCopy","linesOfCode":13,"sourceCode":"postCopy\r\t\"Must copy the associations, or later store will affect both the\r\t\toriginal and the copy.\r\tCopy any subtrees too!\"\r\r\tarray := array\r\t\tcollect: [ :assoc | \r\t\t\tassoc\r\t\t\t\tifNotNil: [ Association\r\t\t\t\t\t\tkey: assoc key\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((assoc value isKindOf: KeyedTree)\r\t\t\t\t\t\t\t\tifTrue: [ assoc value copy ]\r\t\t\t\t\t\t\t\tifFalse: [ assoc value ]) ] ]"},{"name":"formattedText","linesOfCode":6,"sourceCode":"formattedText\r\t\"Answer a string or text representing the receiver with indentation and, possibly, markup.\"\r\r\t|str|\r\tstr := String new writeStream.\r\tself putFormattedTextOn: str level: 0 indentString: '  '.\r\t^str contents"},{"name":"removePath:ifAbsent:","linesOfCode":10,"sourceCode":"removePath: anArray ifAbsent: aBlock\r\t\"Remove and answer the element referenced by the given path.\r\tAnswer the value of aBlock if not found.\"\r\r\t|element|\r\tanArray isEmpty\r\t\tifTrue: [^self].\r\telement := self.\r\tanArray allButLastDo: [:key |\r\t\telement := element at: key ifAbsent: [^aBlock value]].\r\t^element removeKey: anArray last ifAbsent: aBlock\t"},{"name":"sortBlock","linesOfCode":3,"sourceCode":"sortBlock\r\t\"Answer the block to sort tree keys with.\"\r\r\t^[:a :b | [a <= b] on: Error do: [a class name <= b class name]]"},{"name":"allKeys","linesOfCode":9,"sourceCode":"allKeys\r\t\"Answer an ordered collection of the keys of the receiver and any subtrees.\r\t\tPlease no circular references!\"\r\r\t|answer|\r\tanswer := OrderedCollection new.\r\tanswer addAll: self keys.\r\tself subtrees do: [:t |\r\t\tanswer addAll: t allKeys].\r\t^answer"},{"name":"removePath:","linesOfCode":4,"sourceCode":"removePath: anArray\r\t\"Remove and answer the element referenced by the given path.\r\tSignal an error if not found.\"\r\r\t^self removePath: anArray ifAbsent: [self errorKeyNotFound: anArray]"},{"name":"subtrees","linesOfCode":3,"sourceCode":"subtrees\r\t\"Answer the subtrees of the receiver.\"\r\r\t^(self select: [:v | v isKindOf: KeyedTree]) values"},{"name":"putFormattedTextOn:withDescriptions:level:indentString:","linesOfCode":19,"sourceCode":"putFormattedTextOn: aStream withDescriptions: aKeyedTree level: indentLevel indentString: aString\r\t\"Place a print of the receiver and associated description on the given stream with the given indentation level.\"\r\r\t\r\t(self keys asSortedCollection: self sortBlock) do: [:k | | v |\r\t\tindentLevel timesRepeat: [aStream nextPutAll: aString].\r\t\taStream nextPutAll: k printString.\r\t\tv := self at: k.\r\t\t(v isKindOf: self class)\r\t\t\tifTrue: [aStream cr.\r\t\t\t\t\tv\r\t\t\t\t\t\tputFormattedTextOn: aStream\r\t\t\t\t\t\twithDescriptions: (aKeyedTree at: k ifAbsent: [self class new])\r\t\t\t\t\t\tlevel: indentLevel + 1\r\t\t\t\t\t\tindentString: aString]\r\t\t\tifFalse: [aStream\r\t\t\t\t\t\tnextPutAll: ' : ';\r\t\t\t\t\t\tnextPutAll: v printString;\r\t\t\t\t\t\ttab; tab;\r\t\t\t\t\t\tnextPutAll: (aKeyedTree at: k ifAbsent: ['nondescript']) printString.\r\t\t\t\t\taStream cr]]"}],"meta":{"name":"KeyedTree class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentityDictionary","instanceVariables":[],"methods":[{"name":"slvmEncodeAsSExpression","linesOfCode":6,"sourceCode":"slvmEncodeAsSExpression\r\t^ { #identityDictionary } , (Array streamContents: [:out |\r\t\tself keysAndValuesDo: [ :key :value |\r\t\t\tout nextPut: key slvmEncodeAsSExpression; nextPut: value slvmEncodeAsSExpression\r\t\t]\r\t])"},{"name":"keyAtValue:ifAbsent:","linesOfCode":6,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\"\r \r\tself associationsDo: \r\t\t[:association | value == association value ifTrue: [^ association key]].\r\t^ exceptionBlock value"},{"name":"scanFor:","linesOfCode":14,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| finish start element |\r\tfinish := array size.\r\tstart := (anObject identityHash \\\\ finish) + 1.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"}],"meta":{"name":"IdentityDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Dictionary","instanceVariables":[],"methods":[{"name":"at:ifPresent:ifAbsentPut:","linesOfCode":10,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise store and return the result of evaluating the second block as the\r\tnew value of the key.\"\r\r\t^ self\r\t\tat: key\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: [self at: key put: anAbsentBlock value]"},{"name":"at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: key ifAbsentPut: aBlock\r\t\"Return the value at the given key.\r\tIf the key is not included in the receiver store and return the result \r\tof evaluating aBlock as the new value.\"\r\r\t^ self at: key ifAbsent: [self at: key put: aBlock value]"},{"name":"associationAt:ifPresent:","linesOfCode":5,"sourceCode":"associationAt: key ifPresent: aBlock\r\t\"Answer the value of evaluating aBlock optionally with the association\r\tfor the given key. If the key is not found, return nil.\"\r\r\t^ (array at: (self findElementOrNil: key))\r\t\tifNotNil: [ :assoc | aBlock cull: assoc ]"},{"name":"includesKey:","linesOfCode":4,"sourceCode":"includesKey: key \r\t\"Answer whether the receiver has a key equal to the argument, key.\"\r\t\r\t^ (array at: (self scanFor: key)) ~~ nil \r\t\"We could use #notNil here, but ProtoObject doesn't understand it.\""},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject\r\r\tself do: [:each | anObject = each ifTrue: [^true]].\r\t^false"},{"name":"printElementsOn:","linesOfCode":11,"sourceCode":"printElementsOn: aStream \r\taStream nextPut: $(.\r\tself size > 100\r\t\tifTrue: [aStream nextPutAll: 'size '.\r\t\t\tself size printOn: aStream]\r\t\tifFalse: [self keysSortedSafely\r\t\t\t\tdo: [:key | aStream print: key;\r\t\t\t\t\t\t nextPutAll: '->';\t\t\t\t\r\t\t\t\t\t\t print: (self at: key);\r\t\t\t\t\t\t space]].\r\taStream nextPut: $)"},{"name":"hasBindingThatBeginsWith:","linesOfCode":6,"sourceCode":"hasBindingThatBeginsWith: aString\r\t\"Answer true if the receiver has a key that begins with aString, false otherwise\"\r\t\r\tself keysDo:[:each | \r\t\t(each beginsWith: aString)\r\t\t\tifTrue:[^true]].\r\t^false"},{"name":"stonOn:","linesOfCode":10,"sourceCode":"stonOn: stonWriter\r\t\"Instances of STON mapClass will be encoded directly, without a class tag.\r\tOther (sub)classes will be encoded with a class tag and will use a map representation. \"\r\t\r\tself class == STON mapClass\r\t\tifTrue: [ \r\t\t\tstonWriter writeMap: self ]\r\t\tifFalse: [ \r\t\t\tstonWriter \r\t\t\t\twriteObject: self \r\t\t\t\tdo: [ stonWriter encodeMap: self ] ]"},{"name":"at:update:initial:","linesOfCode":11,"sourceCode":"at: key update: updateBlock initial: initBlocktOrValue\r\t\"I am used to update the value at a given key. The updateBlock is passed \r\tthe existing value, and the result of the block is stored back.\r\tIf the key does not exist, store the value of the initBlocktOrValue.\r\tinitBlocktOrValue can be a block in case the initial value is expencive to compute.\r\tI use findElementOrNil: to avoid looking up the key twice.\"\r\t| index |\r\tindex := self findElementOrNil: key.\r\t(array at: index)\r\t\tifNil: [ self atNewIndex: index put: key -> initBlocktOrValue value]\r\t\tifNotNil: [ :assoc | assoc value: (updateBlock value: assoc value) ]"},{"name":"collect:","linesOfCode":10,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my values as the argument.  Collect the\r\tresulting values into a collection that is like me. Answer with the new\r\tcollection.\"\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo:[:each |\r\t\tnewCollection at: each key put: (aBlock value: each value).\r\t].\r\t^newCollection"},{"name":"flatCollect:","linesOfCode":6,"sourceCode":"flatCollect: aBlock \r\t\"Evaluate aBlock for each of the receiver's values (by opposition to keys) and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\"If you want to have keys use associations collect: or associations flatCollect: \"\r\t\r\t^ self flatCollect: aBlock as: OrderedCollection"},{"name":"=","linesOfCode":13,"sourceCode":"= aDictionary\r\t\"Two dictionaries are equal if\r\t (a) they are the same 'kind' of thing.\r\t (b) they have the same set of keys.\r\t (c) for each (common) key, they have the same value.\r\tSee issue 16760 before changing\"\r\r\tself == aDictionary ifTrue: [^true].\r\tself species == aDictionary species ifFalse: [^false].\r\tself size = aDictionary size ifFalse: [^false].\r\tself associationsDo: [:assoc|\r\t\t(aDictionary at: assoc key ifAbsent: [^false]) = assoc value\r\t\t\tifFalse: [^false]].\r\t^true"},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: aKeyedCollection\r\taKeyedCollection == self ifFalse: [\r\t\taKeyedCollection keysAndValuesDo: [:key :value |\r\t\t\tself at: key put: value]].\r\t^aKeyedCollection"},{"name":"removeKeyAtValue:","linesOfCode":5,"sourceCode":"removeKeyAtValue: aValue\r\t| key |\r\tkey := self keyAtValue: aValue ifAbsent: [ nil ].\r\tkey ifNotNil: [ self removeKey: key ].\r\t^ key"},{"name":"errorKeyNotFound:","linesOfCode":2,"sourceCode":"errorKeyNotFound: aKey\r\r\tKeyNotFound signalFor: aKey"},{"name":"gtDebuggerSUnitPrint","linesOfCode":9,"sourceCode":"gtDebuggerSUnitPrint\r\r\t^ String streamContents: [ :aStream | \r\t\tself keysSortedSafely\r\t\t\t\tdo: [:key | aStream print: key;\r\t\t\t\t\t\t space;\r\t\t\t\t\t\t nextPutAll: '->';\t\r\t\t\t\t\t\t space;\t\t\t\r\t\t\t\t\t\t print: (self at: key);\r\t\t\t\t\t\t cr]]."},{"name":"associationAt:","linesOfCode":3,"sourceCode":"associationAt: key \r\t\"Returns the association for the given key.\"\r\r\t^ self associationAt: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\r\t^self valuesDo: aBlock"},{"name":"removeKey:ifAbsent:","linesOfCode":12,"sourceCode":"removeKey: key ifAbsent: aBlock \r\t\"Remove key (and its associated value) from the receiver. If key is not in \r\tthe receiver, answer the result of evaluating aBlock. Otherwise, answer \r\tthe value externally named by key.\"\r\r\t| index assoc |\r\tindex := self findElementOrNil: key.\r\tassoc := array at: index.\r\tassoc == nil ifTrue: [ ^ aBlock value ].\r\tarray at: index put: nil.\r\ttally := tally - 1.\r\tself fixCollisionsFrom: index.\r\t^ assoc value"},{"name":"includesIdentity:","linesOfCode":4,"sourceCode":"includesIdentity: anObject\r\t\"Answer whether anObject is one of the values of the receiver.  Contrast #includes: in which there is only an equality check, here there is an identity check\"\r\r\tself do: [:each | anObject == each ifTrue: [^ true]].\r\t^ false"},{"name":"keyAtIdentityValue:","linesOfCode":5,"sourceCode":"keyAtIdentityValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer nil.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r\r\t^self keyAtIdentityValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"isDictionary","linesOfCode":2,"sourceCode":"isDictionary\r\t^true"},{"name":"at:at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey ifAbsentPut: aZeroArgBlock\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. If firstKey is not defined, set a new dictionary for the second key and set the value of aZeroArgBlock execution. If firstKey is defined and not second key set the value of aZeroArgBlock execution. See NestedDictionaryTest for examples.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey ifAbsentPut: aZeroArgBlock"},{"name":"at:ifPresent:ifAbsent:","linesOfCode":7,"sourceCode":"at: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the value associated\r\twith the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself at: key ifPresent: [:v | ^ aPresentBlock cull: v].\r\t^ anAbsentBlock value"},{"name":"keyForIdentity:","linesOfCode":4,"sourceCode":"keyForIdentity: anObject\r\t\"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check\"\r\r\tself associationsDo: [:assoc | assoc value == anObject ifTrue: [^ assoc key]].\r\t^ nil"},{"name":"gtInspectorKeysIn:","linesOfCode":5,"sourceCode":"gtInspectorKeysIn: composite\r\t<gtInspectorPresentationOrder: 1>\r\r\t^ composite fastList\r\t\ttitle: 'Keys';\r\t\tdisplay: [ self keys ]"},{"name":"associationAt:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifAbsent: aBlock\r\t\"Answer the association with the given key.\r\tIf the key is not found, return the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key))\r\t\tifNil: [ aBlock value ]\r\t\tifNotNil: [ :assoc | assoc ]"},{"name":"noCheckAdd:","linesOfCode":4,"sourceCode":"noCheckAdd: anObject\r\t\"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association.\"\r\r\tarray at: (self findElementOrNil: anObject key) put: anObject.\r\ttally := tally + 1"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeMap: self"},{"name":"fixCollisionsFrom:","linesOfCode":10,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by nil.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one.\"\r\t| element index |\r\tindex := start.\r\t[ (element := array at: (index := index \\\\ array size + 1)) == nil ] whileFalse: [\r\t\t| newIndex |\r\t\t(newIndex := self findElementOrNil: element key) = index ifFalse: [\r\t\t\tarray swap: index with: newIndex ] ]"},{"name":"fillFrom:with:","linesOfCode":5,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollections's elements as the argument.  \r\tCollect the resulting values into self. Answer self.\"\r\r\taCollection keysAndValuesDo: [ :key :value |\r\t\tself at: key put: (aBlock value: value) ]"},{"name":"unreferencedKeys","linesOfCode":4,"sourceCode":"unreferencedKeys\r\t\"This is private code for the Undeclared handling\"\r\r\t^self keys select: [ :key | \r\t\t\t(self systemNavigation allReferencesTo: (self associationAt: key)) isEmpty ]"},{"name":"at:","linesOfCode":3,"sourceCode":"at: key \r\t\"Answer the value associated with the key.\"\r\r\t^ self at: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"keysAndValuesRemove:","linesOfCode":10,"sourceCode":"keysAndValuesRemove: keyValueBlock\r\t\"Removes all entries for which keyValueBlock returns true.\"\r\t\"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method.\"\r\r\t| removals |\r\tremovals := OrderedCollection new.\r\tself associationsDo:\r\t\t[:assoc | (keyValueBlock value: assoc key value: assoc value)\r\t\t\tifTrue: [removals add: assoc key]].\r \tremovals do:\r\t\t[:aKey | self removeKey: aKey]"},{"name":"gtInspectorItemsIn:","linesOfCode":26,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self associations ];\r\t\t\"children: [ :each | \r\t\t\t(each value isDictionary) \r\t\t\t\tifTrue: [ each value associations ] \r\t\t\t\tifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])\r\t\t\t\t\t\tifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]\r\t\t\t\t\t\tifFalse: [ #() ] ] ];\"\r\t\t\tcolumn: 'Key' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each key ];\r\t\tcolumn: 'Value' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each value ];\r\t\tselectionAct: [ :table | \r\t\t\ttable rawSelection do: [ :assoc | self removeKey: assoc key ].\r\t\t\ttable update ]\r\t\t\tentitled: 'Remove item(s)';\r\t\tselectionPopulate: #selection entitled: 'Open key' with: [ :table | (table rawSelection collect: [:each | each key]) gtInspectorInterestingObject ];\r\t\tbeMultiple;\r\t\tsend: [ :selection | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'\"\r\t\t\tselection\r\t\t\t\tifNotNil: [ selection size = 1\r\t\t\t\t\t\tifTrue: [ selection anyOne value ]\r\t\t\t\t\t\tifFalse: [ selection collect: #value ] ] ]"},{"name":"errorValueNotFound:","linesOfCode":2,"sourceCode":"errorValueNotFound: value\r\r\tValueNotFound signalFor: value"},{"name":"fuelAfterMaterialization","linesOfCode":7,"sourceCode":"fuelAfterMaterialization\r\t| class |\r\t\"Since for Set and IdentitySet we are recreating the collection with #add: we do not need to rehash.\"\r\tclass := self class.\r\t^ (((class == Dictionary) or: [ class == IdentityDictionary ]) ) \r\t\tifFalse: [ self rehash ] \r\t\tifTrue: [ self ]"},{"name":"at:ifAbsent:","linesOfCode":6,"sourceCode":"at: key ifAbsent: aBlock \r\t\"Answer the value associated with the key or, if key isn't found,\r\tanswer the result of evaluating aBlock.\"\r\r\t^((array at: (self findElementOrNil: key)) \r\t\t\tifNil: [aBlock] \r\t\t\tifNotNil: [:assoc | assoc]) value."},{"name":"keyAtValue:ifAbsent:","linesOfCode":7,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\t: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast.\"\r \r\tself associationsDo: \r\t\t[:association | value = association value ifTrue: [^association key]].\r\t^exceptionBlock value"},{"name":"removeKey:","linesOfCode":4,"sourceCode":"removeKey: key \r\t\"Remove key from the receiver.\r\tIf key is not in the receiver, notify an error.\"\r\r\t^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]"},{"name":"associations","linesOfCode":5,"sourceCode":"associations\r\t\"Answer a collection containing the receiver's associations.\"\r\t\"Suggested by l. Uzonyi\"\r\t\r\t^Array new: self size streamContents: [ :stream |\r\t\tself associationsDo: [ :each | stream nextPut: each ] ]"},{"name":"scanFor:","linesOfCode":14,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| element start finish |\r\tfinish := array size.\r\tstart := (anObject hash \\\\ finish) + 1.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [element key = anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [element key = anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"valuesDo:","linesOfCode":10,"sourceCode":"valuesDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's values.  Implemented with == checks\r\tmerely for the sake of maximum efficiency\"\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: array size do:\r\t\t[ :eachIndex | \r\t\t\t| eachAssociation |\r\t\t\teachAssociation := array at: eachIndex.\r\t\t\tnil == eachAssociation ifFalse: [ aBlock value: eachAssociation value ]\r\t\t]"},{"name":"asValueHolder","linesOfCode":2,"sourceCode":"asValueHolder\r\r\t^ DictionaryValueHolder value: self"},{"name":"add:","linesOfCode":8,"sourceCode":"add: anAssociation\r\t| index element |\r\tindex := self findElementOrNil: anAssociation key.\r\telement := array at: index.\r\telement\r\t\tifNil: [ self atNewIndex: index put: anAssociation ]\r\t\tifNotNil: [ element value: anAssociation value ].\r\t^ anAssociation"},{"name":"at:at:ifAbsent:","linesOfCode":6,"sourceCode":"at: firstKey at: secondKey ifAbsent: aZeroArgBlock\r\t\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. Execute aZeroArgBlock in case one of the key is wrong.\"\r\t\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsent: [ ^ aZeroArgBlock value ].\r\t^ subDictionary at: secondKey ifAbsent: aZeroArgBlock"},{"name":"associationsDo:","linesOfCode":7,"sourceCode":"associationsDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).\"\r\r\ttally = 0 ifTrue: [^ self].\r\tarray do:\r\t\t[:each |\r\t\teach ifNotNil: [aBlock value: each]]"},{"name":"bindingsDo:","linesOfCode":2,"sourceCode":"bindingsDo: aBlock\r\tself associationsDo: aBlock"},{"name":"declare:from:","linesOfCode":11,"sourceCode":"declare: key from: aDictionary \r\t\"Add key to the receiver. If key already exists, do nothing. If aDictionary \r\tincludes key, then remove it from aDictionary and use its association as \r\tthe element of the receiver.\"\r\r\t(self includesKey: key) ifTrue: [^ self].\r\t(aDictionary includesKey: key)\r\t\tifTrue: \r\t\t\t[self add: (aDictionary associationAt: key).\r\t\t\taDictionary removeKey: key]\r\t\tifFalse: \r\t\t\t[self add: key -> nil]"},{"name":"difference:","linesOfCode":12,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. This is a specialized version for Dictionaries keeping the keys of the objects. At a slightly higher price of an additional Set to track duplicates.\"\r\r\t| other result duplicates |\r\t\r\tother := aCollection asSet.\r\tduplicates := Set new.\r\tresult := self class new: self size.\r\t\r\tself keysAndValuesDo: [ :key :value|\r\t\t((other includes: value) not and: [ (duplicates includes: value) not ])\r\t\t\tifTrue: [ \r\t\t\t\tduplicates add: value.\r\t\t\t\tresult at: key put: value]].\r\t\r\t^ result"},{"name":"keyAtValue:","linesOfCode":4,"sourceCode":"keyAtValue: value \r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, signal an error.\"\r\r\t^self keyAtValue: value ifAbsent: [self errorValueNotFound: value]"},{"name":"at:update:","linesOfCode":3,"sourceCode":"at: key update: updateBlock \r\t\"I am used to update the value at a given key, or if the key does not exist, to throw an error\"\r\tself at: key update: updateBlock initial: [ self errorKeyNotFound: key ]."},{"name":"keysAndValuesDo:","linesOfCode":3,"sourceCode":"keysAndValuesDo: aBlock\r\t^self associationsDo:[:assoc|\r\t\taBlock value: assoc key value: assoc value]."},{"name":"rehash","linesOfCode":6,"sourceCode":"rehash\r\t\"Smalltalk rehash.\"\r\t| newSelf |\r\tnewSelf := self species new: self size.\r\tself associationsDo: [:each | newSelf noCheckAdd: each].\r\tarray := newSelf array"},{"name":"remove:","linesOfCode":2,"sourceCode":"remove: anObject\r\r\tself shouldNotImplement"},{"name":"postCopy","linesOfCode":5,"sourceCode":"postCopy\r\t\"Must copy the associations, or later store will affect both the\roriginal and the copy\"\r\r\tarray := array collect: [ :association |\r\t\tassociation ifNotNil: [ association copy ] ]"},{"name":"includesAssociation:","linesOfCode":4,"sourceCode":"includesAssociation: anAssociation\r  ^ (self   \r      associationAt: anAssociation key\r      ifAbsent: [ ^ false ]) value = anAssociation value\r"},{"name":"valueAtNewKey:put:atIndex:declareFrom:","linesOfCode":11,"sourceCode":"valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary \r\t\"Support for coordinating class variable and global declarations\r\twith variables that have been put in Undeclared so as to\r\tredirect all references to the undeclared variable.\"\r\r\t(aDictionary includesKey: aKey)\r\t\tifTrue: \r\t\t\t[self atNewIndex: index \r\t\t\t\tput: ((aDictionary associationAt: aKey) value: anObject).\r\t\t\taDictionary removeKey: aKey]\r\t\tifFalse: \r\t\t\t[self atNewIndex: index put: (Association key: aKey value: anObject)]"},{"name":"isHealthy","linesOfCode":14,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in set's array,\r\tanswer true if everything ok, false otherwise\r\t\r\tDictionary allInstances select: [:dict |\r\t\tdict isHealthy not ]\r\tDictionary allSubInstances select: [:dict |\r\t\tdict isHealthy not ]\r\t\"\r\tarray withIndexDo: [:elem :i |\r\t\telem ifNotNil: [\r\t\t\t(self scanFor: elem key) == i ifFalse: [ ^ false ]\r\t\t\t]\r\t].\r\t^ true"},{"name":"stonPostReferenceResolution","linesOfCode":4,"sourceCode":"stonPostReferenceResolution\r\t\"When references were resolved in me, the hash of my keys might have changed.\r\tCheck if I am still healthy and rehash me if not.\"\r\t\r\tself isHealthy ifFalse: [ self rehash ]"},{"name":"spotterForKeysFor:","linesOfCode":7,"sourceCode":"spotterForKeysFor: aStep\r\t<spotterOrder: 15>\r\taStep listProcessor\r\t\t\ttitle: 'Keys';\r\t\t\tallCandidates: [ self keys ];\r\t\t\tcandidatesLimit: 5;\r\t\t\tfilter: GTFilterSubstring"},{"name":"at:at:","linesOfCode":10,"sourceCode":"at: firstKey at: secondKey\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey.\"\r\r\t\"\r\t(Dictionary new\r\t\tat: #top at: #below1 put: 1;\r\t\tat: #top at: #below1 put: 2;\r\t\tat: #top at: #below1)\r\t>>>\r\t2\"\r\r\t^ self at: firstKey at: secondKey ifAbsent: [self errorKeyNotFound: secondKey]"},{"name":"inspectionItems:","linesOfCode":11,"sourceCode":"inspectionItems: aBuilder\r\t<inspectorPresentationOrder: 0 title: 'Items'> \r\t\r\t^ aBuilder newTable \r\t\taddColumn: (SpStringTableColumn \r\t\t\ttitle: 'Key'\r\t\t\tevaluated: [ :each | StObjectPrinter asTruncatedTextFrom: each key ]);\r\t\taddColumn: (SpStringTableColumn \r\t\t\ttitle: 'Value' \r\t\t\tevaluated: [ :each | StObjectPrinter asTruncatedTextFrom: each value ]);\r\t\titems: self associations;\r\t\tyourself"},{"name":"remove:ifAbsent:","linesOfCode":2,"sourceCode":"remove: anObject ifAbsent: exceptionBlock\r\r\tself shouldNotImplement"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":7,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :association |\r\t\t\tarray\r\t\t\t\tat: (self scanForEmptySlotFor: association key)\r\t\t\t\tput: association ] ]"},{"name":"keyAtIdentityValue:ifAbsent:","linesOfCode":7,"sourceCode":"keyAtIdentityValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\r\tNote: There can be multiple keys with the same value. Only one is returned.\"\r \r\tself associationsDo: \r\t\t[:association | value == association value ifTrue: [^association key]].\r\t^exceptionBlock value"},{"name":"keysDo:","linesOfCode":3,"sourceCode":"keysDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's keys.\"\r\r\tself associationsDo: [:association | aBlock value: association key]"},{"name":"keys","linesOfCode":3,"sourceCode":"keys\r\t\"Answer an Array containing the receiver's keys.\"\r\t\r\t^Array new: self size streamContents: [:s| self keysDo: [:key| s nextPut: key]]"},{"name":"values","linesOfCode":5,"sourceCode":"values\r\t\"Answer a Collection containing the receiver's values.\"\r\t^Array \r\t\tnew: self size \r\t\tstreamContents: [ :out | self valuesDo: [:value | out nextPut: value]]"},{"name":"at:at:put:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey put: aValue\r\t\"Set a value at secondKey in the dictionary returned by firstKey.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey put: aValue"},{"name":"keysSortedSafely","linesOfCode":17,"sourceCode":"keysSortedSafely\r\t\"Answer an Array containing the receiver's keys.\"\r \t\"Suggested by l. Uzonyi\"\r\t\r \t| sortedKeys |\r \tsortedKeys := Array \r\t\t\t\t\t\tnew: self size \r\t\t\t\t\t\tstreamContents: [ :stream |\r \t\t\t\t\t\t\t\tself keysDo: [ :each | stream nextPut: each ] ].\r \tsortedKeys sort: [ :x :y |\r \t\t\"Should really be use <obj, string, num> compareSafely...\"\r \t\t((x isString and: [ y isString ])\r \t\t\tor: [ x isNumber and: [ y isNumber ] ])\r \t\t\tifTrue: [ x < y ]\r \t\t\tifFalse: [ x class == y class\r \t\t\t\tifTrue: [ x printString < y printString ]\r \t\t\t\tifFalse: [ x class name < y class name ] ] ].\r \t^sortedKeys"},{"name":"fuelAccept:","linesOfCode":7,"sourceCode":"fuelAccept: aGeneralMapper\r\t| class |\r\t\"Since we have subclasses of Dictionary that behave differently, we cannot use the visitDictionary: for all of them.\t We could also use MethodDictionary for this case, but its materialization is much slower with this cluster than with the default action.\"\r\tclass := self class.\r\t^ (((class == Dictionary) or: [class == IdentityDictionary ])) \r\t\tifTrue: [ aGeneralMapper visitDictionary: self ]\r\t\tifFalse: [ super fuelAccept: aGeneralMapper ] \r\t"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeMap: self"},{"name":"storeOn:","linesOfCode":15,"sourceCode":"storeOn: aStream\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new)'.\r\tnoneYet := true.\r\tself associationsDo: \r\t\t\t[:each | \r\t\t\tnoneYet\r\t\t\t\tifTrue: [noneYet := false]\r\t\t\t\tifFalse: [aStream nextPut: $;].\r\t\t\taStream nextPutAll: ' add: '.\r\t\t\taStream store: each].\r\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"associationsSelect:","linesOfCode":10,"sourceCode":"associationsSelect: aBlock \r\t\"Evaluate aBlock with each of my associations as the argument. Collect\r\tinto a new dictionary, only those associations for which aBlock evaluates\r\tto true.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself associationsDo: \r\t\t[:each | \r\t\t(aBlock value: each) ifTrue: [newCollection add: each]].\r\t^newCollection"},{"name":"at:ifPresent:","linesOfCode":7,"sourceCode":"at: key ifPresent: aBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the given block optionally with the value associated\r\twith the key.\r\tOtherwise, answer nil.\"\r\r\t^(array at: (self findElementOrNil: key))\r\t\tifNotNil: [:assoc | aBlock cull: assoc value]"},{"name":"associationAt:ifPresent:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the first block optionally with the association for the key.\r\tOtherwise answer the value of the second block.\"\r\r\tself associationAt: key ifPresent: [:assoc | ^ aPresentBlock cull: assoc].\r\t^ anAbsentBlock value"},{"name":"removeUnreferencedKeys","linesOfCode":4,"sourceCode":"removeUnreferencedKeys\r\t\"This is private code for the Undeclared handling, not a general API.\" \r\t\"Undeclared removeUnreferencedKeys\"\r\r\t^ self unreferencedKeys do: [ :key | self removeKey: key ]"},{"name":"select:","linesOfCode":8,"sourceCode":"select: aBlock \r\t\"Evaluate aBlock with each of my values as the argument. Collect into a new dictionary, only those associations for which aBlock evaluates to true.\"\r\r\t| newCollection |\r\tnewCollection := self copyEmpty.\r\tself associationsDo: [ :each |\r\t\t(aBlock value: each value) ifTrue: [\r\t\t\tnewCollection add: each copy ] ].\r\t^newCollection"},{"name":"at:put:","linesOfCode":10,"sourceCode":"at: key put: anObject \r\t\"Set the value at key to be anObject.  If key is not found, create a\r\tnew entry for key and set is value to anObject. Answer anObject.\"\r\r\t| index assoc |\r\tindex := self findElementOrNil: key.\r\tassoc := array at: index.\r\tassoc\r\t\tifNil: [self atNewIndex: index put: (Association key: key value: anObject)]\r\t\tifNotNil: [assoc value: anObject].\r\t^ anObject"},{"name":"bindingOf:","linesOfCode":2,"sourceCode":"bindingOf: varName\r\t^self associationAt: varName ifAbsent:[nil]"}],"meta":{"name":"Dictionary class","instanceVariables":[],"methods":[{"name":"newFromKeys:andValues:","linesOfCode":7,"sourceCode":"newFromKeys: keys andValues: values\r\t\"Create a dictionary from the keys and values arguments which should have the same length.\"\r\t\"(Dictionary newFromKeys: #(#x #y) andValues: #(3 6)) >>> (Dictionary new at: #x put: 3; at: #y put: 6 ;yourself)\"\r\t\r\t| dict |\r\tdict := self new.\r\tkeys with: values do: [ :k :v | dict at: k put: v ].\r\t^ dict"},{"name":"newFromPairs:","linesOfCode":8,"sourceCode":"newFromPairs: anArray\r\t\"Answer an instance of me associating (anArray at: i) to (anArray at: i+1)\r\t for each odd i.  anArray must have an even number of entries.\"\r\r\t\"Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}.\"\r\r\t| newDictionary |\r\tnewDictionary := self new: anArray size / 2.\r\t1 to: anArray size - 1 by: 2 do: [ :i | newDictionary at: (anArray at: i) put: (anArray at: i + 1) ].\r\t^ newDictionary"},{"name":"newFrom:","linesOfCode":15,"sourceCode":"newFrom: aDict \r\t\"Answer an instance of me containing the same associations as aDict.\r\t Error if any key appears twice.\"\r\t| newDictionary |\r\tnewDictionary := self new: aDict size.\r\taDict associationsDo:\r\t\t[:x |\r\t\t(newDictionary includesKey: x key)\r\t\t\tifTrue: [self error: 'Duplicate key: ', x key printString]\r\t\t\tifFalse: [newDictionary add: x]].\r\t^ newDictionary\r\r\"\tNewDictionary newFrom: {1->#a. 2->#b. 3->#c}\r\t{1->#a. 2->#b. 3->#c} as: NewDictionary\r\tNewDictionary newFrom: {1->#a. 2->#b. 1->#c}\r\t{1->#a. 2->#b. 1->#c} as: NewDictionary\r\""},{"name":"newFromAssociations:","linesOfCode":6,"sourceCode":"newFromAssociations: anAssocCollection\r\t\"return a dictionary with the Associations in anAssocCollection.\r\tIf the same key appears twice in anAssocCollection, the last one enumerated will win\"\r\t\r\t^ anAssocCollection \r\t\tinject: Dictionary new \r\t\tinto: [ :dict :assoc | dict add: assoc. dict ]"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeDictionaryInspector"},{"name":"fromSton:","linesOfCode":8,"sourceCode":"fromSton: stonReader\r\t\"Instances of STON mapClass will be read directly and won't arrive here.\r\tOther (sub)classes will use this method.\"\r\t\r\t| dictionary |\r\tdictionary := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tdictionary at: key put: value ].\r\t^ dictionary"}],"meta":null}},{"name":"HashTableSizes","instanceVariables":[{"name":"candidate"},{"name":"goodPrimes"},{"name":"primesToAvoid"},{"name":"valuesNotToDivide"}],"methods":[{"name":"candidateIsGoodPrime","linesOfCode":14,"sourceCode":"candidateIsGoodPrime\r\t\"Answer true if candidate will make a good hash table size.\r\tSome integers are rejected:\r\t* Non-primes\r\t* Primes which are close to dividing 1664525, the hashMultiply constant\r\t* Primes which divide 256**k +- a, for small k and a\r\tSee Andres Valloud's hashing book, and Knuth TAOCP volume 3.\"\r\r\tcandidate isPrime\r\t\tifFalse: [ ^ false ].\r\t(primesToAvoid includes: candidate)\r\t\tifTrue: [ ^ false ].\r\tcandidate < 256\r\t\tifTrue: [ ^ true ].\t\"Small primes cannot satisify divisibility constraints\"\r\t^ valuesNotToDivide allSatisfy: [ :dividend | dividend \\\\ candidate ~~ 0 ]"},{"name":"numValuesPerPower","linesOfCode":4,"sourceCode":"numValuesPerPower\r\t\"Answer the number of values that should be available in the cached table of primes\r\tfor each power-of-two range.\"\r\t\r\t^self class numValuesPerPower\r"},{"name":"primeAlmostFactorsOf:","linesOfCode":11,"sourceCode":"primeAlmostFactorsOf: anInteger\r\t\"Answer primes less than anInteger whose remainder when dividing anInteger is small\"\r\r\t| factors |\r\tfactors := OrderedCollection new.\r\tanInteger even ifTrue: [factors add: 2].\r\t3 to: anInteger // 2 + 2 by: 2 do: [:i | \r\t\t(i isPrime and: [| remainder | \r\t\t\t\t\t\tremainder := anInteger \\\\ i.\r\t\t\t\t\t\tremainder <= 1 or: [remainder = (i - 1)]])\r\t\t\tifTrue: [factors add: i]].\r\t^factors asArray\t\r"},{"name":"initialize","linesOfCode":12,"sourceCode":"initialize\r\t\"Can't use any hashed collections, if sizes is being initialized might get infinite recursion\"\r\r\tgoodPrimes := OrderedCollection new.\t\r\t\"Must contain a value less than any prime to avoid extra work in binary search\"\r\tgoodPrimes add: 0.\r\tvaluesNotToDivide := OrderedCollection new.\r\t1 to: 8 do:\r\t\t\t[ :k | \r\t\t\t| n |\r\t\t\tn := 256 raisedToInteger: k.\r\t\t\t-32 to: 32 do: [ :a | valuesNotToDivide add: n + a ] ].\r\tprimesToAvoid := self primeAlmostFactorsOf: 1 hashMultiply"},{"name":"goodPrimeForExp:","linesOfCode":16,"sourceCode":"goodPrimeForExp: exp\r\t\"Answer the next prime integer >= 2**exp that will make a good hash table size,\r\tSome primes are rejected:\r\t* Primes close to a power of two.\r\t* Primes which divide 256**k +- a, for small k and a\r\t* Primes which are close to dividing 1664525, the hashMultiply constant\r\tSee Andres Valloud's hashing book, and Knuth TAOCP volume 3.\"\r\r\t| limit |\r\r\tcandidate := self firstCandidateForExp: exp.\r\tlimit := self limitForExp: exp.\r\t[ self candidateIsGoodPrime ]\r\t\twhileFalse:\r\t\t\t[ candidate := candidate + 2.\r\t\t\tcandidate > limit\r\t\t\t\tifTrue: [ ^ nil ] ].\r\t^ candidate"},{"name":"limitForExp:","linesOfCode":5,"sourceCode":"limitForExp: exp\r\t\"Answer the largest integer that isn't too close to the next higher power of 2 than exp.\"\r\t\r\t| expLimit |\r\texpLimit := exp ceiling - (0.5 / self numValuesPerPower).\r\t^(2 raisedTo: expLimit) rounded.\r\t"},{"name":"firstCandidateForExp:","linesOfCode":7,"sourceCode":"firstCandidateForExp: exp\r\t\"Answer the smallest odd integer greater 2**exp.\"\r\t\r\t| n |\r\tn := (2 raisedTo: exp) rounded.\r\t^n odd \r\t\tifTrue: [n]\r\t\tifFalse: [n + 1]"},{"name":"computeSizes","linesOfCode":18,"sourceCode":"computeSizes\r\t\"Answer an array of integers that make good hash table sizes.\r\tIn each power of two, there are about five primes to choose from.\r\tSome primes are rejected:\r\t* Primes close to a power of two.\r\t* Primes which divide 256**k +- a, for small k and a\r\t* Primes which are close to dividing 1664525, the hashMultiply constant\r\tSee Andres Valloud's hashing book, and Knuth TAOCP volume 3.\"\r\r\t| logInterval |\r\tlogInterval := 0.5 / self numValuesPerPower.\r\t2 + logInterval to: 30 by: 2 * logInterval do:\r\t\t\t[ :exp | \r\t\t\t(self goodPrimeForExp: exp)\r\t\t\t\tifNotNil:\r\t\t\t\t\t[ :prime | \r\t\t\t\t\tgoodPrimes last ~~ prime\r\t\t\t\t\t\tifTrue: [ goodPrimes add: prime ] ] ].\r\t^ goodPrimes asArray"}],"meta":{"name":"HashTableSizes class","instanceVariables":[{"name":"sizes"},{"name":"smallSizesLookupTable"}],"methods":[{"name":"atLeast:","linesOfCode":11,"sourceCode":"atLeast: lowerLimit\r\t\"Answer the next good size >= lowerlimit.\r\tIf lowerLimit is larger than the largest known good prime,\r\tjust make it odd.\"\r\r\t^ lowerLimit <= self maxSmallSize\r\t\tifTrue: [\r\t\t\tself smallSizesLookupTable at:\r\t\t\t\t(lowerLimit <= 0\r\t\t\t\t\tifTrue: [ 1 ]\r\t\t\t\t\tifFalse: [ lowerLimit ceiling + 1 ]) ]\r\t\tifFalse: [ self basicAtLeast: lowerLimit ]"},{"name":"sizes","linesOfCode":7,"sourceCode":"sizes\r\tsizes\r\t\tifNil: [\r\t\t\t\"Compute a sorted Array of known good table sizes that can be\r\t\t\tbinary searched with #basicAtLeast:.\"\r\t\t\tsizes := self new computeSizes ].\r\t^ sizes"},{"name":"basicAtLeast:","linesOfCode":20,"sourceCode":"basicAtLeast: lowerLimit\r\t\"Binary search for the next good size >= lowerlimit.\r\tIf lowerLimit is larger than the largest known good prime,\r\tjust make it odd.\"\r\r\t| primes low mid high prime |\r\tprimes := self sizes.\r\tlow := 1.\r\thigh := primes size.\r\tlowerLimit > (primes at: high)\r\t\tifTrue:\r\t\t\t[ ^ lowerLimit even\r\t\t\t\tifTrue: [ lowerLimit + 1 ]\r\t\t\t\tifFalse: [ lowerLimit ] ].\r\t[ mid := (high - low) // 2 + low.\r\tprime := primes at: mid.\r\tprime < lowerLimit\r\t\tifTrue: [ low := mid ]\r\t\tifFalse: [ high := mid ].\r\thigh - low <= 1\r\t\tifTrue: [ ^ primes at: high ] ] repeat"},{"name":"numValuesPerPower","linesOfCode":5,"sourceCode":"numValuesPerPower\r\t\"Answer the number of values that should be available in the cached table of primes\r\tfor each power-of-two range. A larger number allows closer sizing for pre-sized collections,\r\tbut results in a larger table that takes longer to search.\"\r\t\r\t^5 \"Chosen so there will be fewer than 128 primes in the sizes table\""},{"name":"smallSizesLookupTable","linesOfCode":10,"sourceCode":"smallSizesLookupTable\r\tsmallSizesLookupTable\r\t\tifNil: [\r\t\t\t\"Compute a lookup table of known good table sizes by caching the\r\t\t\tresult of binary searching 'sizes' with #basicAtLeast: for a range\r\t\t\tof small sizes from 0 to #maxSmallSize.\"\r\t\t\tsmallSizesLookupTable :=\r\t\t\t\t(0 to: self maxSmallSize) asArray collect: [ :each |\r\t\t\t\t\tself basicAtLeast: each ] ].\r\t^ smallSizesLookupTable"},{"name":"initialize","linesOfCode":7,"sourceCode":"initialize\r\t\"Throw away any previously-cached sizes, then compute and cache the sizes.\"\r\t\"self initialize\"\r\r\tsizes := nil.\r\tself sizes.\r\r\tsmallSizesLookupTable := nil.\r\tself smallSizesLookupTable"},{"name":"maxSmallSize","linesOfCode":2,"sourceCode":"maxSmallSize\r\t^ 255"}],"meta":null}},{"name":"Set","instanceVariables":[],"methods":[{"name":"grow","linesOfCode":11,"sourceCode":"grow\r\t\"Grow the elements array and reinsert the old elements\"\r\r\t| oldElements |\r\toldElements := array.\r\tarray := Array new: (HashTableSizes atLeast: oldElements size * 2).\r\ttally := 0.\r\toldElements\r\t\tdo:\r\t\t\t[ :each | \r\t\t\teach == nil\r\t\t\t\tifFalse: [ self noCheckAdd: each enclosedElement] ]"},{"name":"scanFor:","linesOfCode":10,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := anObject hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == nil or: [ element enclosedElement = anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"addIfNotPresent:ifPresentDo:","linesOfCode":17,"sourceCode":"addIfNotPresent: anObject ifPresentDo: aBlock\r\t\"Include anObject as one of the receiver's elements and then value aBlock, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t| index |\r\tindex := self scanFor: anObject.\r\t(array at: index) \r\t\tifNil: [self atNewIndex: index put: anObject asCollectionElement]\r\t\tifNotNil: [ aBlock value ].\r\t^ anObject\r\r\t\"Sets in Pharo 1.2 can't' contain nil, so this implementation is wrong in that version. This is the right one (in Pharo 1.2):\r\r\t| index |\r\tanObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].\r\tindex := self findElementOrNil: anObject.\r\t(array at: index) \r\t\tifNil: [ self atNewIndex: index put: anObject ]\r\t\tifNotNil: [ aBlock value ].\r\t^ anObject\""},{"name":"add:","linesOfCode":7,"sourceCode":"add: newObject\r\t\"Include newObject as one of the receiver's elements, but only if\r\tnot already present. Answer newObject.\"\r\r\t| index |\r\tindex := self scanFor: newObject.\r\t(array at: index) ifNil: [self atNewIndex: index put: newObject asCollectionElement].\r\t^ newObject"},{"name":"includes:","linesOfCode":2,"sourceCode":"includes: anObject \r\t^ (array at: (self findElementOrNil: anObject)) ~~ nil"},{"name":"intersection:","linesOfCode":10,"sourceCode":"intersection: aCollection\r\t\"Answer the set theoretic intersection of two collections.\r\tOptimized version for Sets where no intermediate Set is necessary\"\r\r\t\"(#(1 2 3 4) asSet intersection: #(3 4 5) asSet) >>> #(3 4) asSet\"\r\r\t\"(#(1 2 3 4) asSet intersection: #() asSet) >>> Set new\"\r\r\t\"( #() asSet intersection: #(1 2 3 4) asSet) >>> Set new\"\r\r\t| outputSet |\r\toutputSet := self class new.\r\taCollection do: [ :each | (self includes: each) ifTrue: [ outputSet add: each ] ].\r\t^ outputSet"},{"name":"occurrencesOf:","linesOfCode":2,"sourceCode":"occurrencesOf: anObject \r\t^ (self includes: anObject) ifTrue: [1] ifFalse: [0]"},{"name":"difference:","linesOfCode":11,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. Optimized version for Sets where no intermediate Set is necessary\"\r\r\t\"#(a b c d e f) difference:  #(a b z k)\r\t=> #(#f #d #e #c)\r\t\r\t#(a b z k) difference: #(a b c d e f) \r\t=> #(#k #z) \r\t\"\r\r\t| set |\r\tset := self copy.\r\taCollection do: [ :each | set remove: each ifAbsent: [  ] ].\r\t^ set"},{"name":"like:ifAbsent:","linesOfCode":6,"sourceCode":"like: anObject ifAbsent: aBlock\r\t\"Answer an object in the receiver that is equal to anObject,\r\tor evaluate the block if not found. Relies heavily on hash properties\"\r\t| element |\r\telement := array at: (self scanFor: anObject).\r\t^ element ifNil: [ aBlock value ] ifNotNil: [ element enclosedElement ]"},{"name":"collect:","linesOfCode":8,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newSet |\r\tnewSet := self species new: self size.\r\tarray do: [:each | each ifNotNil: [newSet add: (aBlock value: each enclosedElement)]].\r\t^ newSet"},{"name":"rehash","linesOfCode":5,"sourceCode":"rehash\r\t| newSelf |\r\tnewSelf := self species new: self size.\r\tself do: [:each | newSelf noCheckAdd: each].\r\tarray := newSelf array"},{"name":"=","linesOfCode":6,"sourceCode":"= aSet\r\tself == aSet ifTrue: [^ true].\t\"stop recursion\"\r\t(aSet isKindOf: Set) ifFalse: [^ false].\r\tself size = aSet size ifFalse: [^ false].\r\tself do: [:each | (aSet includes: each) ifFalse: [^ false]].\r\t^ true"},{"name":"comeFullyUpOnReload:","linesOfCode":5,"sourceCode":"comeFullyUpOnReload: smartRefStream\r\t\"Symbols have new hashes in this image.\"\r\r\t^self \r\t\trehash; \r\t\tyourself\r"},{"name":"asSet","linesOfCode":2,"sourceCode":"asSet\r\t^self"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tarray := array copy"},{"name":"stonPostReferenceResolution","linesOfCode":4,"sourceCode":"stonPostReferenceResolution\r\t\"When references were resolved in me, the hash of my elements might have changed.\r\tCheck if I am still healthy and rehash me if not.\"\r\t\r\tself isHealthy ifFalse: [ self rehash ]"},{"name":"isHealthy","linesOfCode":11,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in set's array,\r\tanswer true if everything ok, false otherwise\r\t\r\tSet allSubInstances select: [:badSet |\r\t\tbadSet isHealthy not ]\r\t\"\r\tarray withIndexDo: [ :element :index |\r\t\telement ifNotNil: [\r\t\t\t(self scanFor: element enclosedElement) == index\r\t\t\t\tifFalse: [ ^ false ]]].\r\t^ true"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock \r\ttally = 0 ifTrue: [^ self].\r\t1 to: array size do:\r\t\t[:index |\r\t\t| each |\r\t\t(each := array at: index) ifNotNil: [aBlock value: each enclosedElement]]"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #Set earlyFields: self size fields: [self collect: [:each | each encodeGraphForMessagePackWith: graphEncoder]]"},{"name":"remove:ifAbsent:","linesOfCode":8,"sourceCode":"remove: oldObject ifAbsent: aBlock\r\r\t| index |\r\tindex := self findElementOrNil: oldObject.\r\t(array at: index) == nil ifTrue: [ ^ aBlock value ].\r\tarray at: index put: nil.\r\ttally := tally - 1.\r\tself fixCollisionsFrom: index.\r\t^ oldObject"},{"name":"metaLinkOptions","linesOfCode":5,"sourceCode":"metaLinkOptions\r\t^{\r\t#parseOptions: -> #( + optionCompileOnLinkInstallation).\r\t#metaLinkOptions -> #( + optionCompileOnLinkInstallation)\r\t}"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":7,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :object |\r\t\t\tarray\r\t\t\t\tat: (self scanForEmptySlotFor: object enclosedElement)\r\t\t\t\tput: object ] ]"},{"name":"max:","linesOfCode":3,"sourceCode":"max: aBlock\r\tself ifEmpty: [ ^ nil ].\r\t^ self inject: 0 into: [ :max :each | (aBlock value: each) max: max ]"},{"name":"withArray:","linesOfCode":4,"sourceCode":"withArray: anArray\r\t\"private -- for use only in copy\"\r\t\"I want to get a conflict\"\r\tarray := anArray"},{"name":"atRandom:","linesOfCode":10,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver. Uses aGenerator which\r    should be kept by the user in a variable and used every time. Use\r    this instead of #atRandom for better uniformity of random numbers because \r\tonly you use the generator. Causes an error if self has no elements.\"\r\t| index |\r\r\tself emptyCheck.\r\tindex := aGenerator nextInteger: array size.\r\t[ (array at: index) isNil ] whileTrue: [ index := index \\\\ array size + 1 ].\r\t^ array at: index."},{"name":"parseOptions:","linesOfCode":19,"sourceCode":"parseOptions: anArray\r\r\t\"parse an array, which is a sequence of options in a form of: \r\t\r\t#( + option1 option2 - option3 ... )\r\t\r\teach time the #+ is seen, the options which follow it will be subject for inclusion\r\tand, correspondingly, if #- seen, then they will be excluded\t.\r\r\tBy default, (if none of #+ or #- specified initially), all options are subject for inclusion.\r\t\"\r\t| include |\r\t\r\tinclude := true.\r\tanArray do: [:option |\r\t\toption == #+ \r\t\t\tifTrue: [ include := true ]\r\t\t\tifFalse: [\r\t\t\t\toption == #- \r\t\t\t\t\tifTrue: [ include := false ]\r\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\tinclude ifTrue: [ self add: option ] \r\t\t\t\t\t\tifFalse: [ self remove: option ifAbsent:[] ]]]\r\t\t]."},{"name":"copyWithout:","linesOfCode":6,"sourceCode":"copyWithout: oldElement \r\t\"Answer a copy of the receiver that does not contain any\r\telements equal to oldElement.\"\r\r\t^ self copy\r\t\tremove: oldElement ifAbsent: [];\r\t\tyourself"},{"name":"noCheckAdd:","linesOfCode":4,"sourceCode":"noCheckAdd: anObject\r\t\"This method should be deprecated\"\r\tarray at: (self findElementOrNil: anObject) put: anObject asCollectionElement.\r\ttally := tally + 1"},{"name":"fixCollisionsFrom:","linesOfCode":10,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by nil.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one\"\r\r\t| element index |\r\tindex := start.\r\t[ (element := array at: (index := index \\\\ array size + 1)) == nil ] whileFalse: [\r\t\t| newIndex |\r\t\t(newIndex := self scanFor: element enclosedElement) = index ifFalse: [\r\t\t\tarray swap: index with: newIndex ] ]"},{"name":"fuelAccept:","linesOfCode":5,"sourceCode":"fuelAccept: aGeneralMapper\r\t\"Since we have subclasses of Set that behave differently, we cannot use the visitSimpleCollection: for all of them.\"\r\t^ ((self class == Set) or: [ self class == IdentitySet ] ) \r\t\tifTrue: [ aGeneralMapper visitSimpleCollection: self ]\r\t\tifFalse: [ super fuelAccept: aGeneralMapper ] \r\t"},{"name":"gtInspectorItemsIn:","linesOfCode":4,"sourceCode":"gtInspectorItemsIn: composite\r\t\"we override this because sets do not work well in morph tree morphs\"\r\r\t^ (super gtInspectorItemsIn: composite)\r\t\tdisplay: [ :set | set asOrderedCollection ]"},{"name":"like:","linesOfCode":5,"sourceCode":"like: anObject\r\t\"Answer an object in the receiver that is equal to anObject,\r\tnil if no such object is found. Relies heavily on hash properties.\r\tNote, use #like:ifAbsent: if you need to match against nil as element\"\r\r\t^ self like: anObject ifAbsent: [ nil ]"},{"name":"fuelAfterMaterialization","linesOfCode":5,"sourceCode":"fuelAfterMaterialization\r\r\t\"Since for Set and IdentitySet we are recreating the collection with #add: (see FLSimpleCollectionCluster) we do not need to rehash\"\r\t^ ((self class == Set) or: [ self class == IdentitySet ] ) \r\t\tifFalse: [ self rehash ] \r\t\tifTrue: [ self ]"}],"meta":{"name":"Set class","instanceVariables":[],"methods":[{"name":"sizeFor:","linesOfCode":3,"sourceCode":"sizeFor: nElements\r\t\"Large enough size to hold nElements with some slop (see fullCheck)\"\r\r\t^ HashTableSizes atLeast: nElements * 4 // 3"},{"name":"newFrom:","linesOfCode":8,"sourceCode":"newFrom: aCollection\r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\t\"(Set newFrom: {1. 2. 3}) >>> #( 1 2 3) asSet\"\r\t\"({1. 2. 3} as: Set) >>> #( 1 2 3) asSet\"\r\t\r\t| newCollection |\r\tnewCollection := self new: aCollection size.\r\tnewCollection addAll: aCollection.\r\t^ newCollection\r"},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #Set ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext do: [ :eachValue |\r\t\t\tresult add: eachValue\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeSetInspector"}],"meta":null}},{"name":"KeyNotFound","instanceVariables":[],"methods":[{"name":"standardMessageText","linesOfCode":7,"sourceCode":"standardMessageText\r\t\"Generate a standard textual description\"\r\t\r\t^ String streamContents: [ :stream |\r\t\tstream << 'key '.\r\t\tstream print: self object.\r\t\tstream << ' not found in '.\r\t\tstream print: self collection class ]"},{"name":"key:","linesOfCode":2,"sourceCode":"key: aKey\r\tself object: aKey"},{"name":"key","linesOfCode":2,"sourceCode":"key\r\t^ self object"}],"meta":{"name":"KeyNotFound class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Weak-Tests","classes":[{"name":"WeakIdentitySetTest","instanceVariables":[],"methods":[{"name":"testAddEqualElements","linesOfCode":14,"sourceCode":"testAddEqualElements\r\t| ws o2 o3 |\r\to2 := 1 / 2.\r\to3 := '123' copy.\r\tws := self classToBeTested new.\r\tws add: o2.\r\tws add: o3.\r\tself assert: ws size equals: 2.\r\tself assert: (ws includes: o2).\r\tself assert: (ws includes: o3).\r\r\t\"inclusion test does use identity, not equality\"\r\tself deny: (ws includes: o3 copy).\r\r\tws add: o3 copy.\r\tself assert: ws size equals: 3"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ WeakIdentitySet"},{"name":"testCollisions","linesOfCode":4,"sourceCode":"testCollisions\r\t\"It is complex test in superclass to check how collisions are resolved.\r\tThe logic is based on WeakSet and it is not compatible to WeakIdentitySet.\r\tAdopting this test for WeakIdentitySest is not simple task\""},{"name":"testAddIncludesSizeReclaim","linesOfCode":5,"sourceCode":"testAddIncludesSizeReclaim\r\t\"It is complex test in superclass to check how elements are garbage collected.\r\tAnd how #includes: behavios after that.\r\tThe logic is based on WeakSet and it is not compatible to WeakIdentitySet.\r\tAdopting this test for WeakIdentitySest is not simple task\""},{"name":"testAddIdenticalElements","linesOfCode":12,"sourceCode":"testAddIdenticalElements\r\t| identitySet aString anOtherString |\r\taString := 'hello'.\r\tanOtherString := aString copy.\r\r\tself assert: aString equals: anOtherString.\r\tself deny: aString identicalTo: anOtherString.\r\r\tidentitySet := self classToBeTested new.\r\tidentitySet add: aString.\r\r\tself assert: (identitySet occurrencesOf: aString) equals: 1.\r\tself assert: (identitySet occurrencesOf: anOtherString) equals: 0.\r\r\tself assert: (identitySet includes: aString).\r\tself deny: (identitySet includes: anOtherString) equals: 0"}],"meta":{"name":"WeakIdentitySetTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakRegistryTest","instanceVariables":[{"name":"errorWasHere"}],"methods":[{"name":"testVileFinalizer","linesOfCode":16,"sourceCode":"testVileFinalizer\r\t\" this test checks that manipulation (or accessing) a weak registry \r\tdoes not lead to deadlocks when performed from within a #finalize implementation\"\r\r\t| reg villian proc locked |\r\treg := WeakRegistry new.\r\tWeakArray removeWeakDependent: reg.\t\"to prevent test interference with finalization process\"\r\r\tvillian := VileFinalizer new initialize: reg.\t\"add object with vile finalization to registry\"\r\r\tlocked := true.\r\r\tproc := [ reg finalizeValues.\r\tlocked := false ] newProcess.\r\tvillian := nil.\r\tSmalltalk garbageCollect.\r\r\tproc resume.\r\t100 milliSeconds wait.\t\"give chance for created process to run \"\r\r\tproc isTerminated ifFalse: [ proc terminate ].\r\r\tself assert: locked identicalTo: false"},{"name":"testFinalizationWithOnFork","linesOfCode":22,"sourceCode":"testFinalizationWithOnFork\r\t\" Test that if error occurs during finalization, the finalization process continues to run normally.\r\t\r\tWe addting two executors into weak registry:\r\t the faulty one, which causing an error\r\t and good one, which signals semaphore\r\t\r\ttest shows that both finalizers are evaluated and error doesn't prevents a good finalizer from execution\r\t\"\r\r\t| reg obj1 obj2 sema timedOut |\r\treg := WeakRegistry new.\r\tsema := Semaphore new.\r\tWeakArray removeWeakDependent: reg.\r\tobj1 := Array new: 1.\r\tobj2 := Array new: 2.\r\r\treg add: obj1 executor: (MockFinalizerAction new finalizationAction: [ self signalMockException ]).\r\treg add: obj2 executor: (MockFinalizerAction new finalizationAction: [ sema signal ]).\r\r\terrorWasHere := false.\r\r\tobj1 := obj2 := nil.\r\tSmalltalk garbageCollect.\r\r\treg finalizeValues.\r\r\ttimedOut := sema waitTimeoutSeconds: 1.\r\r\tself assert: errorWasHere identicalTo: true.\r\tself assert: timedOut identicalTo: false"},{"name":"testFinalization","linesOfCode":18,"sourceCode":"testFinalization\r\t| w finalized block object |\r\tw := WeakRegistry new: 1.\r\tfinalized := false.\r\tblock := [ :v | finalized := v ].\r\tobject := ObjectFinalizer receiver: block selector: #value: argument: true.\t\"an object that responds to #finalize\"\r\tw add: object.\r\tobject := nil.\t\"let it go\"\r\tSmalltalk garbageCollect.\t\"finalize it\"\r\r\t\"This is an odd issue. It seems that in some situations the finalization\r\tprocess doesn't run 'in time' for the isEmpty assertion below to succeed.\r\tThis really *shouldn't* happen since isEmpty is full of real sends and\r\tthere ought to be an interrupt check in there somewhere. However,\r\tsince there are no real-time guarantees about finalization, it's fair to\r\tjust wait a little to ensure that the finalization process has been run.\"\r\t(Delay forMilliseconds: 100) wait.\r\r\tself assertEmpty: w.\r\tself assert: finalized"},{"name":"testRemovingByAHighPriorityProcessDoesntLeak","linesOfCode":18,"sourceCode":"testRemovingByAHighPriorityProcessDoesntLeak\r\t| w finalized block hash object executor semaphore |\r\tw := WeakRegistry new: 1.\r\tfinalized := false.\r\tblock := [ :v | finalized := v ].\r\tobject := Object new.\r\texecutor := ObjectFinalizer receiver: block selector: #value: argument: true.\r\thash := object hash.\r\tw add: hash.\r\tw add: object executor: executor.\r\tsemaphore := Semaphore new.\r\t[ object := nil.\t\"let it go\"\r\tw remove: hash.\r\tsemaphore signal ] forkAt: WeakArray runningFinalizationProcess priority + 1.\r\tsemaphore wait.\r\tSmalltalk garbageCollect.\t\"finalize it\"\r\tself assertEmpty: w.\r\tself assert: finalized"},{"name":"signalMockException","linesOfCode":4,"sourceCode":"signalMockException\r\tMockExceptionWithPassAction new\r\t\tpassAction: [ errorWasHere := true];\r\t\tsignal"},{"name":"testFinalizationWithMultipleFinalizersPerObject","linesOfCode":12,"sourceCode":"testFinalizationWithMultipleFinalizersPerObject\r\t| object registry counter |\r\tregistry := WeakRegistry new.\r\tobject := Object new.\r\tcounter := 0.\r\t5 timesRepeat: [ registry add: object executor: (ObjectFinalizer receiver: [ counter := counter + 1 ] selector: #value) ].\r\tself assert: registry size equals: 1.\r\tobject := nil.\r\tSmalltalk garbageCollect.\r\tregistry finalizeValues.\r\tself assertEmpty: registry.\r\tself assert: counter equals: 5"},{"name":"testGrowingDoesntLeak","linesOfCode":13,"sourceCode":"testGrowingDoesntLeak\r\t| w finalized block object executor |\r\tw := WeakRegistry new: 1.\r\tfinalized := false.\r\tblock := [ :v | finalized := v ].\r\tobject := Object new.\r\texecutor := ObjectFinalizer receiver: block selector: #value: argument: true.\r\tw add: object executor: executor.\r\tobject := nil.\t\"let it go\"\r\tw addAll: (1 to: 1000).\t\"force growing\"\r\tSmalltalk garbageCollect.\t\"finalize it\"\r\tself assert: w size equals: 1000.\r\tself assert: finalized"},{"name":"testRemovingDoesntLeak","linesOfCode":15,"sourceCode":"testRemovingDoesntLeak\r\t| w finalized block hash object executor |\r\tw := WeakRegistry new: 1.\r\tfinalized := false.\r\tblock := [ :v | finalized := v ].\r\tobject := Object new.\r\texecutor := ObjectFinalizer receiver: block selector: #value: argument: true.\r\thash := object hash.\r\tw add: hash.\r\tw add: object executor: executor.\r\tobject := nil.\t\"let it go\"\r\tw remove: hash.\r\tSmalltalk garbageCollect.\t\"finalize it\"\r\tself assertEmpty: w.\r\tself assert: finalized"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ WeakRegistry "},{"name":"testFinalizationWithBadFinalizer","linesOfCode":17,"sourceCode":"testFinalizationWithBadFinalizer\r\t\" Test that if error occurs during finalization, the finalization process continues to run normally.\r\r\t\tThis test tests that if we adding a faulty finalizer to WeakArray's finalization dependants,\r\t\tits not causing troubles to the finalization process.\t\r\t\"\r\r\t| mock1 mock2 sema timedOut |\r\tmock1 := MockFinalizerAction new finalizationAction: [ self signalMockException ].\r\tmock2 := MockFinalizerAction new finalizationAction: [ sema signal ].\r\tsema := Semaphore new.\r\r\tWeakArray\r\t\taddWeakDependent: mock1;\r\t\taddWeakDependent: mock2.\r\r\terrorWasHere := false.\r\r\tSmalltalk garbageCollect.\r\r\ttimedOut := sema waitTimeoutSeconds: 1.\r\r\tself assert: errorWasHere identicalTo: true.\r\tself assert: timedOut identicalTo: false"},{"name":"testGrowingByAHighPriorityProcessDoesntLeak","linesOfCode":16,"sourceCode":"testGrowingByAHighPriorityProcessDoesntLeak\r\t| w finalized block object executor semaphore |\r\tw := WeakRegistry new: 1.\r\tfinalized := false.\r\tblock := [ :v | finalized := v ].\r\tobject := Object new.\r\texecutor := ObjectFinalizer receiver: block selector: #value: argument: true.\r\tw add: object executor: executor.\r\tsemaphore := Semaphore new.\r\t[ object := nil.\t\"let it go\"\r\tw addAll: (1 to: 1000).\t\"force growing\"\r\tsemaphore signal ] forkAt: WeakArray runningFinalizationProcess priority + 1.\r\tsemaphore wait.\r\tSmalltalk garbageCollect.\t\"finalize it\"\r\tself assert: w size equals: 1000.\r\tself assert: finalized"}],"meta":{"name":"WeakRegistryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakIdentityValueDictionaryTest","instanceVariables":[],"methods":[{"name":"canBeUnhealthy","linesOfCode":2,"sourceCode":"canBeUnhealthy\r\t^ false"},{"name":"testIdentity","linesOfCode":8,"sourceCode":"testIdentity\r\t| dict key |\r\tdict := self classToBeTested new.\r\tkey := 'key'.\r\tdict at: key put: 2.5.\r\t \r\t\r\tself assert: (dict includesKey: key).\r\tself deny: (dict includesKey: key copy)."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ WeakIdentityValueDictionary "}],"meta":{"name":"WeakIdentityValueDictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"MockExceptionWithPassAction","instanceVariables":[{"name":"passAction"}],"methods":[{"name":"pass","linesOfCode":2,"sourceCode":"pass\r\t^ passAction cull: self"},{"name":"passAction:","linesOfCode":2,"sourceCode":"passAction: aValuable\r\tpassAction := aValuable"}],"meta":{"name":"MockExceptionWithPassAction class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakSetTest","instanceVariables":[],"methods":[{"name":"testIncludes","linesOfCode":14,"sourceCode":"testIncludes\t\r\t\r\t| weakSet transientFakeNilObject |\r\tweakSet := self classToBeTested new.\r\t#(true nil 1) do: [ :each | self deny: (weakSet includes: each) ].\r\tweakSet add: true.\r\tself assert: (weakSet includes: true).\r \tweakSet remove: true.\r\tself deny: (weakSet includes: true).\r\ttransientFakeNilObject := ((1 to: 1000) detect: [ :each | each asString hash - nil hash \\\\ weakSet capacity = 0 ]) asString. \"this string will occupy the same slot as nil would\"\r\r\tweakSet add: transientFakeNilObject.\r\ttransientFakeNilObject := transientFakeNilObject copy.\r\tSmalltalk garbageCollect. \"get rid of transientFakeNilObject\"\r\tself deny: (weakSet includes: transientFakeNilObject).\r\tself deny: (weakSet includes: nil)"},{"name":"testAddEqualElements","linesOfCode":15,"sourceCode":"testAddEqualElements\r\t| ws o2 o3 |\r\to2 := 1 / 2.\r\to3 := '123' copy.\r\tws := self classToBeTested new.\r\tws add: o2.\r\tws add: o3.\r\tself assert: ws size equals: 2.\r\tself assert: (ws includes: o2).\r\tself assert: (ws includes: o3).\r\r\t\"inclusion test does use equality, not identity\"\r\tself assert: (ws includes: o3 copy) description: 'WeakSet is not WeakIdentitySet'.\r\r\t\"only one copy is added\"\r\tws add: o3 copy.\r\tself assert: ws size equals: 2"},{"name":"testGrowWithNil","linesOfCode":7,"sourceCode":"testGrowWithNil\r\t\"This test covers that grow take into account that nil are wrapped elements of sets\"\r\t| set |\r\tset := self classToBeTested new.\r\tset add: nil.\r\tset grow.\r\tself assert: (set includes: nil)"},{"name":"testAddNil","linesOfCode":5,"sourceCode":"testAddNil\r\t| ws |\r\tws := self classToBeTested new.\r\tws add: nil.\r\tself assert: (ws includes: nil)"},{"name":"testAddIncludesSizeReclaim","linesOfCode":23,"sourceCode":"testAddIncludesSizeReclaim\r\t| ws o2 o3 |\r\to2 := 1 / 2.\r\to3 := '123' copy.\r\tws := self classToBeTested new.\r\tws add: o2.\r\tws add: o3.\r\tself assert: ws size equals: 2.\r\tself assert: (ws includes: o2).\r\tself assert: (ws includes: o3).\r\r\t\"inclusion test does use equality, not identity\"\r\tself assert: (ws includes: o3 copy) description: 'WeakSet are not WeakIdentitySet'.\r\r\t\"only one copy is added\"\r\tws add: o3 copy.\r\tself assert: ws size equals: 2.\r\r\t\"reclame objects so that slots of ws are nilled out\"\r\to2 := o3 := nil.\r\tSmalltalk garbageCollect.\r\tself deny: (ws includes: 1 / 2).\r\tself deny: (ws includes: '123' copy).\r\r\t\"fast #size is not updated automatically by dead object reclamation\r\tBut there is a slowSize trying to tell the truth\"\r\tself assert: ws slowSize equals: 0"},{"name":"testGrowWhenNecessary","linesOfCode":8,"sourceCode":"testGrowWhenNecessary\r\t| ws objs initialSize |\r\tobjs := (2 to: 20) collect: [:i | 1 / i].\r\tws := self classToBeTested new: 5.\r\tinitialSize := ws array size.\r\t1 to: objs size do: [:k | ws add: (objs at: k)].\r\tself assert: ws array size > initialSize\r\t\tdescription: 'The WeakSet grown because not enough room were preallocated'."},{"name":"testDoAfter","linesOfCode":10,"sourceCode":"testDoAfter\r\t| input weakSet array |\r\tinput := (1 to: 11) collect: [ :each | each asString asSymbol ].\t\"Some symbols might be garbage collected without this variable\"\r\tweakSet := self classToBeTested withAll: input.\r\tarray := weakSet asArray.\t\"Assume that the elements will have the same order as the internal array of the weakset\"\r\t0 to: array size do: [ :index | \r\t\t| element result |\r\t\telement := array at: index ifAbsent: nil.\r\t\tresult := Array new: weakSet size - index streamContents: [ :stream | weakSet do: [ :each | stream nextPut: each ] after: element ].\r\t\tself assert: result sort equals: (array allButFirst: index) sort ]"},{"name":"testCollisions","linesOfCode":40,"sourceCode":"testCollisions\r\r\t| ws o1 o2 o5 on remember forget |\r\r\t\"create a weak set\"\r\tws := self classToBeTested new: 15.\r\t\r\t\"select some fractions wanting same place in ws array\"\r\to1 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 1].\r\to2 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 2].\r\to5 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 5].\r\ton := (2 to: 200) select: [:i | (ws scanFor: 1 / i) = (ws array size - 1)].\r\t\r\t\"Add some fractions to the weak set, and remember a pointer for a few of them\"\r\tremember := OrderedCollection new.\r\tforget := OrderedCollection new.\r\tws add: (remember add: 1 / o1 first).\r\tws add: (forget add: 1 / on second).\r\tws add: (forget add: 1 / o1 second).\r\tws add: (forget add: 1 / o5 second).\r\tws add: (forget add: 1 / o2 second).\r\tws add: (forget add: 1 / o1 third).\r\tws add: (remember add: 1 / o2 first).\r\tws add: (forget add: 1 / o5 third).\r\tws add: (forget add: 1 / on third).\r\tws add: (remember add: 1 / o2 fourth).\r\tws add: (remember add: 1 / on first).\r\tws add: (remember add: 1 / o5 first).\r\t\r\t\"forget and reclaim all entries but those in remember\"\r\tforget := nil.\r\tSmalltalk garbageCollect.\r\t\r\tremember do: [:m | self assert: (ws includes: m)].\r\tws add: 1/on second.\r\tremember do: [:m | self assert: (ws includes: m)].\r\t\r\tws add: (remember add: 1 / o1 fourth).\r\tws add: (remember add: 1 / on fourth).\r\tremember remove: (ws remove: (1 / o5 first)).\r\tremember remove: (ws remove: (1 / on first)).\r\tremember remove: (ws remove: (1 / o2 first)).\r\tremember remove: (ws remove: (1 / o1 first)).\r\tremember do: [:m | self assert: (ws includes: m)].\r\tws add: 1/on second.\r\tws add: 1/o5 second.\r\tremember do: [:m | self assert: (ws includes: m)].\r\t"},{"name":"testAsArray","linesOfCode":10,"sourceCode":"testAsArray\r\t| item set |\r\tset := self classToBeTested new.\r\r\tself assert: set asArray equals: #().\r\r\titem := Object new.\r\tset add: item.\r\r\tself assert: set asArray equals: {item}.\r\r\titem := nil.\r\tSmalltalk garbageCollect.\r\r\tself assert: set asArray equals: #()"},{"name":"testAnyOneWhenAllContentsWasGarbaged","linesOfCode":7,"sourceCode":"testAnyOneWhenAllContentsWasGarbaged\r\t| ws o |\r\to := Object new.\r\tws := self classToBeTested with: o.\r\to := nil.\r\tSmalltalk garbageCollect.\r\tself assert: ws anyOne equals: nil"},{"name":"testDoDontIterateOnReclaimedObjects","linesOfCode":17,"sourceCode":"testDoDontIterateOnReclaimedObjects\r\t| ws o1 o2 size |\r\tws := self classToBeTested new.\r\t2 to: 20 do: [ :i | ws add: 1 / i ].\r\r\to1 := 3.0.\r\to2 := 4.0.\r\tws\r\t\tadd: o1;\r\t\tadd: o2.\r\r\t\"Reclaim memory\"\r\tSmalltalk garbageCollect.\r\r\tsize := 0.\r\tws\r\t\tdo: [ :each | \r\t\t\tsize := size + 1.\r\t\t\tself deny: each isNil ].\r\r\tself assert: size equals: 2"},{"name":"testDontGrowWhenUnecessary","linesOfCode":14,"sourceCode":"testDontGrowWhenUnecessary\r\t| ws objs initialSize |\r\tobjs := (2 to: 20) collect: [:i | 1 / i].\r\t\r\tws := self classToBeTested new: 20.\r\tinitialSize := ws array size.\r\tobjs do: [:k | ws add: k].\r\tobjs do: [:k | ws remove: k].\r\tself assert: ws array size = initialSize\r\t\tdescription: 'The WeakSet did not have to grow because enough room were preallocated'.\r\t\r\tobjs do: [:k | ws add: k + 1].\r\tSmalltalk garbageCollect.\r\tobjs do: [:k | ws add: k].\r\tself assert: ws array size = initialSize\r\t\tdescription: 'The WeakSet did not have to grow because slots of reclaimed objects were recycled'."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ WeakSet"},{"name":"testIncludesNil","linesOfCode":9,"sourceCode":"testIncludesNil\r\r\t| ws |\r\tws := self classToBeTested new.\r\tself deny: (ws includes: nil).\r\t\r\t\"After reclamation, should not includes nil: nil counts for nothing\"\r\tws add: 1/2.\r\tws add: 1/3.\r\tSmalltalk garbageCollect.\r\tself deny: (ws includes: nil)."}],"meta":{"name":"WeakSetTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r^true"}],"meta":null}},{"name":"WeakValueDictionaryTest","instanceVariables":[],"methods":[{"name":"testAtGarbageCollectedValueRaisesNotFound","linesOfCode":4,"sourceCode":"testAtGarbageCollectedValueRaisesNotFound\r\r\tself\r\t\tshould: [ self dictionaryWithGarbageCollectedValue at: self keyWithGarbageCollectedValue ]\r\t\traise: NotFound\r"},{"name":"testSizeWithGarbageCollectedValue","linesOfCode":4,"sourceCode":"testSizeWithGarbageCollectedValue\r\r\tself\r\t\tassert: self dictionaryWithGarbageCollectedValue size\r\t\tequals: 0.\r"},{"name":"testSize","linesOfCode":7,"sourceCode":"testSize\r\t| d |\r\td := self classToBeTested new.\r\tself assert: d size equals: 0.\r\td at: 1 put: 2.\r\td at: 2 put: nil.\r\tself assert: d size equals: 2"},{"name":"testAtIfPresent","linesOfCode":6,"sourceCode":"testAtIfPresent\r\t\"Non regression test. Before we were sending #value on the value while giving it to the block to evaluate.\"\r\r\t| d block |\r\td := self classToBeTested new.\r\td at: 1 put: (block := [ 2 ]).\r\r\td at: 1 ifPresent: [ :v | self assert: v identicalTo: block ]"},{"name":"testAtIfAbsentWithGarbageCollectedValue","linesOfCode":7,"sourceCode":"testAtIfAbsentWithGarbageCollectedValue\r\r\tself\r\t\tassert:\r\t\t\t(self dictionaryWithGarbageCollectedValue\r\t\t\t\tat: self keyWithGarbageCollectedValue\r\t\t\t\tifAbsent: [ 42 ])\r\t\tequals: 42\r"},{"name":"testAtIfPresentWithGarbageCollectedValue","linesOfCode":9,"sourceCode":"testAtIfPresentWithGarbageCollectedValue\r\r\t| dictionary |\r\tdictionary := self dictionaryWithGarbageCollectedValue.\r\r\tself\r\t\tassert:\r\t\t\t(dictionary\r\t\t\t\tat: self keyWithGarbageCollectedValue\r\t\t\t\tifPresent: [ 42 ])\r\t\tequals: nil.\r"},{"name":"testDoesNotIncludeNilAfterGarbageCollection","linesOfCode":2,"sourceCode":"testDoesNotIncludeNilAfterGarbageCollection\r\r\tself deny: (self dictionaryWithGarbageCollectedValue includes: nil)"},{"name":"testAtIfPresentIfAbsentWithGarbageCollectedValue","linesOfCode":8,"sourceCode":"testAtIfPresentIfAbsentWithGarbageCollectedValue\r\r\tself\r\t\tassert:\r\t\t\t(self dictionaryWithGarbageCollectedValue\r\t\t\t\tat: self keyWithGarbageCollectedValue\r\t\t\t\tifPresent: [ 41 ]\r\t\t\t\tifAbsent: [ 42 ])\r\t\tequals: 42\r"},{"name":"testReturnedAssociationsAreRight","linesOfCode":7,"sourceCode":"testReturnedAssociationsAreRight\r\t| dictionary |\r\tdictionary := self classToBeTested new.\r\tdictionary at: 'test' put: nil.\r\tdictionary at: 'test2' put: 1.\r\tself assert: (dictionary associationAt: 'test') value isNil.\r\tself assert: (dictionary associationAt: 'test2') value equals: 1"},{"name":"dictionaryWithGarbageCollectedValue","linesOfCode":6,"sourceCode":"dictionaryWithGarbageCollectedValue\r\r\t| dictionary |\r\tdictionary := self classToBeTested new.\r\tdictionary at: self keyWithGarbageCollectedValue put: Object new.\r\tSmalltalk garbageCollect.\r\t^ dictionary\r"},{"name":"keyWithGarbageCollectedValue","linesOfCode":2,"sourceCode":"keyWithGarbageCollectedValue\r\r\t^ #a"},{"name":"testIncludesKeyAnswerFalseForGarbageCollectedValues","linesOfCode":3,"sourceCode":"testIncludesKeyAnswerFalseForGarbageCollectedValues\r\t\"This test should not be called #testIncludesKey to not override that test of the same name in the superclass.\"\r\r\tself deny: (self dictionaryWithGarbageCollectedValue includesKey: self keyWithGarbageCollectedValue)"},{"name":"testKeysAndValuesDoWithGarbageCollectedValue","linesOfCode":2,"sourceCode":"testKeysAndValuesDoWithGarbageCollectedValue\r\r\tself dictionaryWithGarbageCollectedValue keysAndValuesDo: [:key :value | self fail ]\r"},{"name":"testAtIfAbsentPutWithGarbageCollectedValue","linesOfCode":11,"sourceCode":"testAtIfAbsentPutWithGarbageCollectedValue\r\r\t| dictionary |\r\tdictionary := self dictionaryWithGarbageCollectedValue.\r\r\tself\r\t\tassert:\r\t\t\t(dictionary\r\t\t\t\tat: self keyWithGarbageCollectedValue\r\t\t\t\tifAbsentPut: [ 42 ])\r\t\tequals: 42.\r\t\t\r\tself assert: (dictionary includes: 42).\r"},{"name":"testAssociationsWithGarbageCollectedValue","linesOfCode":2,"sourceCode":"testAssociationsWithGarbageCollectedValue\r\tself assertEmpty: self dictionaryWithGarbageCollectedValue associations"},{"name":"testRehashDoesNotTransformAssociations","linesOfCode":7,"sourceCode":"testRehashDoesNotTransformAssociations\r\t| d |\r\td := self classToBeTested new.\r\td at: 1 put: 2.\r\tself assert: (d privateAssociations anyOne isKindOf: WeakValueAssociation).\r\td rehash.\r\tself assert: (d privateAssociations anyOne isKindOf: WeakValueAssociation)"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ WeakValueDictionary"}],"meta":{"name":"WeakValueDictionaryTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r^true"}],"meta":null}},{"name":"WeakIdentityKeyDictionaryTest","instanceVariables":[],"methods":[{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ WeakIdentityKeyDictionary "},{"name":"testNoNils","linesOfCode":7,"sourceCode":"testNoNils\r\t| d |\r\td := WeakIdentityKeyDictionary new\r\tat: 'hello' copy put: 'world';\r\t\tyourself.\r\tSmalltalk garbageCollect.\r\tself deny: (d keys includes: nil)"},{"name":"testFinalizeValuesWhenLastChainContinuesAtFront","linesOfCode":25,"sourceCode":"testFinalizeValuesWhenLastChainContinuesAtFront\r\t| objectWithHashModulo dictionary capacity a b c |\r\tobjectWithHashModulo := [ :requestedHash :modulo | \r\t| object |\r\t[ object := Object new.\r\tobject hash \\\\ modulo = requestedHash ] whileFalse.\r\tobject ].\r\r\tdictionary := self classToBeTested new.\r\tcapacity := dictionary capacity.\r\ta := objectWithHashModulo value: capacity - 2 value: capacity.\r\tdictionary at: a put: 1.\r\tb := objectWithHashModulo value: capacity - 1 value: capacity.\r\tdictionary at: b put: 2.\r\tc := objectWithHashModulo value: capacity - 2 value: capacity.\r\tdictionary at: c put: 3.\r\tself assert: dictionary capacity equals: capacity.\r\tself assert: (dictionary array at: capacity - 1) key identicalTo: a.\r\tself assert: (dictionary array at: capacity) key identicalTo: b.\r\tself assert: (dictionary array at: 1) key identicalTo: c.\r\ta := nil.\r\tSmalltalk garbageCollect.\r\tdictionary finalizeValues.\r\tself assert: (dictionary includesKey: b).\r\tself assert: (dictionary includesKey: c).\r\tself assert: dictionary slowSize equals: 2"},{"name":"canBeUnhealthy","linesOfCode":2,"sourceCode":"canBeUnhealthy\r\t^ false"}],"meta":{"name":"WeakIdentityKeyDictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"MockFinalizerAction","instanceVariables":[{"name":"finalizationAction"}],"methods":[{"name":"finalize","linesOfCode":2,"sourceCode":"finalize\r\tfinalizationAction value"},{"name":"finalizationAction:","linesOfCode":2,"sourceCode":"finalizationAction: aValuable\r\tfinalizationAction := aValuable"},{"name":"finalizeValues","linesOfCode":2,"sourceCode":"finalizeValues\r\tfinalizationAction value"}],"meta":{"name":"MockFinalizerAction class","instanceVariables":[],"methods":[],"meta":null}},{"name":"VileFinalizer","instanceVariables":[{"name":"weakRegistry"}],"methods":[{"name":"finalize","linesOfCode":2,"sourceCode":"finalize\r\tweakRegistry remove: self ifAbsent: []."},{"name":"initialize:","linesOfCode":3,"sourceCode":"initialize: registry\r\tweakRegistry := registry.\r\tweakRegistry add: self."}],"meta":{"name":"VileFinalizer class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakKeyToCollectionDictionaryTest","instanceVariables":[],"methods":[{"name":"testKeysAndValuesRemove","linesOfCode":11,"sourceCode":"testKeysAndValuesRemove\r\t\" should be tested with collection keys\"\r\t\r\t\"| oldSize collection keyIn |\r\t\r\t\r\tcollection := self nonEmptyDict .\r\toldSize := collection  size.\r\tkeyIn := collection keys anyOne.\r\t\r\tcollection  keysAndValuesRemove: [:key :value | key == self keyNotInNonEmptyDict ].\r\tself assert: (collection  size = (oldSize )).\r\t\r\tcollection  keysAndValuesRemove: [:key :value | key == keyIn ].\r\tself assert: (collection  size = (oldSize - 1)).\r\tself should: [ collection at: keyIn  ] raise: Error.\""},{"name":"testRemoveKeyIfAbsent","linesOfCode":11,"sourceCode":"testRemoveKeyIfAbsent\r\t\r\t\"| collection oldSize keyIn value result |\r\tcollection := self nonEmptyDict .\r\toldSize := collection size.\r\tkeyIn := collection  keys anyOne.\r\tvalue := collection at: keyIn .\r\t\r\tresult := collection removeKey: keyIn ifAbsent: [888].\r\t\r\tself assert: result = value.\r\tself assert: (collection  size = (oldSize - 1)).\r\tself should: [ (collection  at: keyIn )] raise: Error.\r\t\r\tself assert: (collection removeKey: self keyNotInNonEmptyDict ifAbsent: [888] ) = 888.\""},{"name":"testRemoveKey","linesOfCode":9,"sourceCode":"testRemoveKey\t\r\r\"\t| collection oldSize keyIn |\r\tcollection := self nonEmptyDict .\r\toldSize := collection size.\r\tkeyIn := collection  keys anyOne.\r\t\r\tcollection removeKey: keyIn .\r\tself assert: (collection  size = (oldSize - 1)).\r\tself should: [ (collection  at: keyIn )] raise: Error.\r\t\r\tself should: [collection removeKey: self keyNotInNonEmptyDict ] raise: Error\""},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r \r\t^ WeakKeyToCollectionDictionary"}],"meta":{"name":"WeakKeyToCollectionDictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakOrderedCollectionTest","instanceVariables":[],"methods":[{"name":"testWeakOrderedCollectionSomeGarbageCollected","linesOfCode":19,"sourceCode":"testWeakOrderedCollectionSomeGarbageCollected\r\t| anArray anotherObject weakOrderedCollection |\r\tanArray := OrderedCollection new.\r\tanotherObject := Time new.\r\tanotherObject seconds: 40.\r\tanArray add: Duration new.\r\tanArray add: anotherObject.\r\r\tweakOrderedCollection := WeakOrderedCollection new.\r\tweakOrderedCollection\r\t\tadd: anArray;\r\t\tadd: anotherObject.\r\r\t\"Let's add lot of stuff to be sure #grow is send.\"\r\t(1 to: 1000) do: [ :index | weakOrderedCollection add: Date today ].\r\r\tanArray := nil.\r\r\t3 timesRepeat: [ Smalltalk garbageCollect ].\r\tself assert: weakOrderedCollection asSet size equals: 2.\r\tself assert: (weakOrderedCollection asSet includes: anotherObject).\r\tself assertEmpty: (weakOrderedCollection asSet select: [ :each | each class = Duration ]).\r\tself assertEmpty: (weakOrderedCollection asSet select: [ :each | each class = OrderedCollection ])"},{"name":"testWeakOrderedCollectionAllGarbageCollected","linesOfCode":19,"sourceCode":"testWeakOrderedCollectionAllGarbageCollected\r\t| anArray anotherObject weakOrderedCollection |\r\t\r\tanArray := OrderedCollection new.\r\tanotherObject := Time new. \r\tanotherObject seconds: 40.\r\tanArray add: Date today.\r\tanArray add: anotherObject.\r\r\tweakOrderedCollection := WeakOrderedCollection new.\r\tweakOrderedCollection \r\t\tadd: anArray;\r\t\tadd: anotherObject.\r\t\t\r\t\"Let's add lot of stuff to be sure #grow is send.\"\r\t(1 to: 1000) do: [:index | weakOrderedCollection add: Date today ].\r\t\r\tanotherObject := nil.\r\tanArray := nil.\r\t\r\t3 timesRepeat: [Smalltalk garbageCollect].\r\tself assert: weakOrderedCollection asSet size equals: 1.\r\tself assert: (weakOrderedCollection asSet includes: nil)\r\r"}],"meta":{"name":"WeakOrderedCollectionTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakKeyDictionaryTest","instanceVariables":[{"name":"keys"},{"name":"dict"}],"methods":[{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"Answer the number of keys that should be used in testing.\"\r\t^1000"},{"name":"testGrow","linesOfCode":6,"sourceCode":"testGrow\r\tkeys := nil.\r\tdict at: self put: nil.\r\tSmalltalk garbageCollect.\r\r\t\"Keys are gone but not yet finalized.\"\r\tdict grow."},{"name":"testStoreOnWithNegativeInteger","linesOfCode":6,"sourceCode":"testStoreOnWithNegativeInteger\r\t| dictionary |\r\tdictionary := { 'x' -> -1 } as: self classToBeTested.\r\t\r\tself\r\t\tassert: (String streamContents: [ :s | dictionary storeOn: s ])\r\t\tequals: '((',self classToBeTested name,' new) add: (WeakKeyAssociation key: ''x'' value: -1); yourself)'"},{"name":"setUp","linesOfCode":6,"sourceCode":"setUp\r\tsuper setUp.\r\tkeys := (1 to: 1000) collect:[:n| 'key', n asString].\r\tdict := WeakKeyDictionary new.\r\tkeys do:[:n| dict at: n put: n,n].\r\tsuper setUp."},{"name":"testClearing","linesOfCode":11,"sourceCode":"testClearing\r\tkeys := nil.\r\tdict at: self put: nil.\r\tself assert: dict size equals: self size + 1.\r\r\tSmalltalk garbageCollect.\r\r\t\"Keys are gone but not yet finalized.\"\r\tself assert: dict size equals: self size + 1.\r\tself assert: dict keys size equals: 1.\r\r\tdict finalizeValues.\r\r\t\"Now the size should be adjusted.\"\r\tself assert: dict size equals: 1"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ WeakKeyDictionary"},{"name":"supportsNilKey","linesOfCode":2,"sourceCode":"supportsNilKey\r\t^ false"}],"meta":{"name":"WeakKeyDictionaryTest class","instanceVariables":[],"methods":[{"name":"timingMany","linesOfCode":17,"sourceCode":"timingMany\r\t| dicts keys size loops count |\r\t\r\tsize := 10.\r\tcount := 10000.\r\tloops := 10.\r\t\r\tkeys := (1 to: size) collect:[:n| 'foo',n asString].\r\t\r\tdicts := OrderedCollection new.\r\tcount timesRepeat:[ | dict |\r\t\tdict := WeakKeyDictionary new.\r\t\tkeys do:[:k| dict at: k put: k].\r\t\tdicts add: dict.\r\t].\r\tSmalltalk garbageCollect.\r\t^Time millisecondsToRun: [\r\t\t\tloops timesRepeat:[\r\t\t\t\tdicts do: [:d| d finalizeValues].\r\t\t\t]].\r"},{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r^true"},{"name":"timingLarge","linesOfCode":15,"sourceCode":"timingLarge\r\t| dict keys size loops |\r\t\r\tsize := 100000.\r\tloops := 10.\r\t\r\tkeys := (1 to: size) collect:[:n| 'foo',n asString].\r\tSmalltalk garbageCollect.\r\tdict := WeakKeyDictionary new.\r\tkeys do:[:k| dict at: k put: k].\r\tSmalltalk garbageCollect.\r\t^Time millisecondsToRun: [\r\t\tloops timesRepeat:[\r\t\t\tdict at: 'bar','0' put: 100.\r\t\t\tSmalltalk garbageCollectMost.\r\t\t\tdict finalizeValues.\r\t\t]].\r"}],"meta":null}}]},{"name":"Collections-Sequenceable-Tests","classes":[{"name":"OrderedDictionaryTest","instanceVariables":[{"name":"nonIdentityOrderedAssociations"},{"name":"identityOrderedAssociations"}],"methods":[{"name":"newValue","linesOfCode":2,"sourceCode":"newValue\r\t\r\t^ 'newValue'"},{"name":"testEqualsDictionary","linesOfCode":7,"sourceCode":"testEqualsDictionary\r\tself\r\t\tassertDictionary: self emptyDictionary\r\t\tdoesNotEqual: self emptyInternalDictionary.\r\r\tself\r\t\tassertDictionary: self dictionaryWithOrderedAssociations\r\t\tdoesNotEqual: self internalDictionaryWithAssociations."},{"name":"testDictionary","linesOfCode":10,"sourceCode":"testDictionary\r\t| dictionary |\r\tdictionary := self emptyDictionary.\r\tself\r\t\tassert: dictionary dictionary class identicalTo: self internalDictionaryClass;\r\t\tassert: dictionary dictionary equals: self emptyInternalDictionary.\r\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tself\r\t\tassert: dictionary dictionary class identicalTo: self internalDictionaryClass;\r\t\tassert: dictionary dictionary equals: self internalDictionaryWithAssociations"},{"name":"testAtIfPresent","linesOfCode":10,"sourceCode":"testAtIfPresent\r\t| dictionary |\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations\r\t\tdo: [ :each | \r\t\t\tself assert: (dictionary at: each key ifPresent: [ self fail ]) isNil.\r\r\t\t\tdictionary add: each.\r\t\t\tself assert: (dictionary at: each key ifPresent: [ :value | self newValue -> value ]) equals: self newValue -> each value.\r\t\t\t\"ensure cull: is used\"\r\t\t\tself assert: (dictionary at: each key ifPresent: [ self newValue ]) equals: self newValue ]"},{"name":"emptyInternalDictionary","linesOfCode":2,"sourceCode":"emptyInternalDictionary\r\r\t^ self internalDictionaryClass new"},{"name":"testAtPut","linesOfCode":21,"sourceCode":"testAtPut\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tput: each value) equals: each value.\r\t\tself\r\t\t\tassertIsDictionary: dictionary\r\t\t\twithOrderedAssociations: (self orderedAssociationsFirst: i)].\r\r\tself changedOrderedAssociations withIndexDo: [:each :i |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tput: each value) equals: each value.\r\t\tself\r\t\t\tassertIsDictionary: dictionary\r\t\t\twithOrderedAssociations:\r\t\t\t\t(self changedOrderedAssociationsFirst: i),\r\t\t\t\t(self orderedAssociationsAllButFirst: i)]."},{"name":"testBindingsDo","linesOfCode":11,"sourceCode":"testBindingsDo\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tshould: [:block | dictionary bindingsDo: block]\r\t\tenumerate: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tshould: [:block | dictionary bindingsDo: block]\r\t\t\tenumerate: (self orderedAssociationsFirst: i)]."},{"name":"absentValue","linesOfCode":2,"sourceCode":"absentValue\r\t^ 'absentValue'"},{"name":"testCollect","linesOfCode":9,"sourceCode":"testCollect\r\t| dictionary |\r\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tself\r\t\tassertIsDictionary:\r\t\t\t(dictionary collect: [:each | each hash])\r\t\tcopiedFrom: dictionary\r\t\twithOrderedAssociations:\r\t\t\t(self orderedAssociations collect: [:each | each key -> each value hash])."},{"name":"testEquals","linesOfCode":27,"sourceCode":"testEquals\r\t| dictionaryOne dictionaryTwo |\r\r\tdictionaryOne := self emptyDictionary.\r\tdictionaryTwo := self emptyDictionary.\r\tself\r\t\tassertDictionary: dictionaryOne\r\t\tequals: dictionaryTwo.\r\r\t\"For equality, order will not matter\"\r\tself orderedAssociations\r\t\twith: self orderedAssociations reversed\r\t\tdo: [:firstAssociation :secondAssociation |\r\t\t\tdictionaryOne add: firstAssociation.\r\t\t\tdictionaryTwo add: secondAssociation.\r\t\t\tself\r\t\t\t\tassertDictionary: dictionaryOne\r\t\t\t\tdoesNotEqual: self emptyDictionary.\r\t\t\tself\r\t\t\t\tassertDictionary: dictionaryTwo\r\t\t\t\tdoesNotEqual: self emptyDictionary.\r\t\t\tdictionaryOne size < self orderedAssociations size\r\t\t\t\tifTrue: [\r\t\t\t\t\tself\r\t\t\t\t\t\tassertDictionary: dictionaryOne\r\t\t\t\t\t\tdoesNotEqual: dictionaryTwo]].\r\r\tself\r\t\tassertDictionary: dictionaryOne\r\t\tequals: dictionaryTwo."},{"name":"testValuesDo","linesOfCode":11,"sourceCode":"testValuesDo\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tshould: [:block | dictionary valuesDo: block]\r\t\tenumerate: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tshould: [:block | dictionary valuesDo: block]\r\t\t\tenumerate: (self orderedValuesFirst: i)]."},{"name":"assertDictionary:equals:","linesOfCode":7,"sourceCode":"assertDictionary: aFirstDictionary equals: aSecondDictionary\r\t\"Test reflixive and symmetric equality.\"\r\t\r\tself\r\t\tassert: aFirstDictionary equals: aFirstDictionary;\r\t\tassert: aFirstDictionary equals: aSecondDictionary;\r\t\tassert: aSecondDictionary equals: aSecondDictionary;\r\t\tassert: aSecondDictionary equals: aFirstDictionary"},{"name":"testKeysAndValuesDo","linesOfCode":13,"sourceCode":"testKeysAndValuesDo\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tshould: [:block | dictionary keysAndValuesDo: block]\r\t\tenumerate: #()\r\t\tand: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tshould: [:block | dictionary keysAndValuesDo: block]\r\t\t\tenumerate: (self orderedKeysFirst: i)\r\t\t\tand: (self orderedValuesFirst: i)]."},{"name":"testAssociations","linesOfCode":11,"sourceCode":"testAssociations\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tassertIsArray: dictionary associations\r\t\twithElements: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tassertIsArray: dictionary associations\r\t\t\twithElements: (self orderedAssociationsFirst: i)]."},{"name":"testKeyAtIndex","linesOfCode":12,"sourceCode":"testKeyAtIndex\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tshould: [dictionary keyAtIndex: 0]\r\t\traise: Error.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself\r\t\t\tshould: [dictionary keyAtIndex: i]\r\t\t\traise: Error.\r\r\t\tdictionary add: each.\r\t\tself assert: (dictionary keyAtIndex: i) equals: each key]."},{"name":"testKeyAtValue","linesOfCode":9,"sourceCode":"testKeyAtValue\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself\r\t\t\tshould: [dictionary keyAtValue: each value]\r\t\t\traise: Error.\r\r\t\tdictionary add: each.\r\t\tself assert: (dictionary keyAtValue: each value) equals: each key]."},{"name":"testIncludesIdentity","linesOfCode":9,"sourceCode":"testIncludesIdentity\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself deny: (dictionary includesIdentity: each value).\r\r\t\tdictionary add: each.\r\t\tself\r\t\t\tassert: (dictionary includesIdentity: each value);\r\t\t\tdeny: (dictionary includesIdentity: each value copy)]."},{"name":"testAssociationAtIfPresent","linesOfCode":18,"sourceCode":"testAssociationAtIfPresent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tassociationAt: each key\r\t\t\t\tifPresent: [self fail]) isNil.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tassociationAt: each key\r\t\t\t\tifPresent: [:assoc | self newValue -> assoc]) equals: (self newValue -> each).\r\t\t\"ensure cull: is used\"\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tassociationAt: each key\r\t\t\t\tifPresent: [self newValue]) equals: self newValue]."},{"name":"testNewFromKeysAndValues2","linesOfCode":9,"sourceCode":"testNewFromKeysAndValues2\r \r\t| dict newDict |\r\tdict := self dictionaryClass new\r\t       at: #a put: 1;\r\t\t\t at: #b put: 2;\r\t\t\t at: #c put: 3; yourself.\r\tnewDict := self dictionaryClass newFromKeys: dict keys andValues: dict values.\r\tdict keysAndValuesDo: [:k :v|\r\t\tself assert: (newDict at: k) equals: v ]. "},{"name":"testAtUpdate","linesOfCode":6,"sourceCode":"testAtUpdate\r\t| dict |\r\tdict := OrderedDictionary newFrom: {2->10. 100->5} .\r\t\r\tdict at: 2 update: [ :v | v+10 ].\r\tself assert: (dict at: 2) equals: 20.\r\tself should: [ dict at: 5 update: [ :v | v+1 ] ] raise: KeyNotFound .\r\t\r"},{"name":"testAssociationsDo","linesOfCode":11,"sourceCode":"testAssociationsDo\r\r\t| dictionary |\r\tdictionary := self emptyDictionary.\r\tself\r\t\tshould: [:block | dictionary associationsDo: block]\r\t\tenumerate: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tshould: [:block | dictionary associationsDo: block]\r\t\t\tenumerate: (self orderedAssociationsFirst: i)]."},{"name":"testSelect","linesOfCode":13,"sourceCode":"testSelect\r\t| dictionary |\r\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tself orderedValues do: [:value | | selectedValues |\r\t\tselectedValues := self orderedValues copyWithout: value.\r\t\tself\r\t\t\tassertIsDictionary:\r\t\t\t\t(dictionary select: [:each |\r\t\t\t\t\tselectedValues includes: each])\r\t\t\tcopiedFrom: dictionary\r\t\t\twithOrderedAssociations:\r\t\t\t\t(self orderedAssociations select: [:each |\r\t\t\t\t\tselectedValues includes: each value])]."},{"name":"orderedKeysFirst:","linesOfCode":2,"sourceCode":"orderedKeysFirst: anInteger\r\r\t^ self orderedKeys first: anInteger"},{"name":"testIndexOfKeyIfAbsent","linesOfCode":13,"sourceCode":"testIndexOfKeyIfAbsent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tindexOfKey: each key\r\t\t\t\tifAbsent: [self absentValue]) equals: self absentValue.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tindexOfKey: each key\r\t\t\t\tifAbsent: [self fail]) equals: i]."},{"name":"testAssociationsSelect","linesOfCode":13,"sourceCode":"testAssociationsSelect\r\t| dictionary |\r\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tself orderedAssociations do: [:assoc | | selectedAssociations |\r\t\tselectedAssociations := self orderedAssociations copyWithout: assoc.\r\t\tself\r\t\t\tassertIsDictionary:\r\t\t\t\t(dictionary associationsSelect: [:each |\r\t\t\t\t\tselectedAssociations includes: each])\r\t\t\tcopiedFrom: dictionary\r\t\t\twithOrderedAssociations:\r\t\t\t\t(self orderedAssociations select: [:each |\r\t\t\t\t\tselectedAssociations includes: each])]."},{"name":"testKeyAtIdentityValue","linesOfCode":12,"sourceCode":"testKeyAtIdentityValue\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself\r\t\t\tshould: [dictionary keyAtIdentityValue: each value]\r\t\t\traise: Error.\r\r\t\tdictionary add: each.\r\t\tself assert: (dictionary keyAtIdentityValue: each value) equals: each key.\r\t\tself\r\t\t\tshould: [dictionary keyAtIdentityValue: each value copy]\r\t\t\traise: Error]"},{"name":"testKeys","linesOfCode":11,"sourceCode":"testKeys\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tassertIsArray: dictionary keys\r\t\twithElements: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tassertIsArray: dictionary keys\r\t\t\twithElements: (self orderedKeysFirst: i)]."},{"name":"orderedAssociations","linesOfCode":4,"sourceCode":"orderedAssociations\r\t^self isTestingIdentityDictionary\r\t\tifTrue: [ self identityOrderedAssociations ]\r\t\tifFalse: [ self nonIdentityOrderedAssociations ]"},{"name":"testIndexOfKey","linesOfCode":7,"sourceCode":"testIndexOfKey\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert: (dictionary indexOfKey: each key) equals: 0.\r\r\t\tdictionary add: each.\r\t\tself assert: (dictionary indexOfKey: each key) equals: i]."},{"name":"testRemoveAll","linesOfCode":9,"sourceCode":"testRemoveAll\r\t| dictionary removedKeys |\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tremovedKeys := dictionary keys.\r\tself\r\t\tdenyEmpty: dictionary;\r\t\tassert: dictionary removeAll identicalTo: dictionary;\r\t\tassertEmpty: dictionary.\r\tremovedKeys do: [ :each | self assertKey: each wasRemovedfrom: dictionary ]"},{"name":"testKeyAtIdentityValueIfAbsent","linesOfCode":17,"sourceCode":"testKeyAtIdentityValueIfAbsent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tkeyAtIdentityValue: each value\r\t\t\t\tifAbsent: [self absentKey]) equals: self absentKey.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tkeyAtIdentityValue: each value\r\t\t\t\tifAbsent: [self fail]) equals: each key.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tkeyAtIdentityValue: each value copy\r\t\t\t\tifAbsent: [self absentKey]) equals: self absentKey]."},{"name":"testDo","linesOfCode":11,"sourceCode":"testDo\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tshould: [:block | dictionary do: block]\r\t\tenumerate: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tshould: [:block | dictionary do: block]\r\t\t\tenumerate: (self orderedValuesFirst: i)]."},{"name":"testDeclareFrom","linesOfCode":12,"sourceCode":"testDeclareFrom\r\t| dictionary otherDictionary |\r\tdictionary := self emptyDictionary.\r\totherDictionary := self dictionaryWithOrderedAssociations.\r\tself orderedKeys do: [ :each | self assert: (dictionary declare: each from: otherDictionary) identicalTo: dictionary ].\r\tself assertIsDictionary: dictionary withOrderedAssociations: self orderedAssociations.\r\tself assertEmpty: otherDictionary.\r\r\tself orderedKeys\r\t\tdo: [ :each | \r\t\t\totherDictionary add: each -> self newValue.\r\t\t\tself assert: (dictionary declare: each from: otherDictionary) identicalTo: dictionary ].\r\tself assertIsDictionary: dictionary withOrderedAssociations: self orderedAssociations"},{"name":"changedOrderedAssociations","linesOfCode":2,"sourceCode":"changedOrderedAssociations\r\r\t^ self orderedAssociations collect: [:each | each key -> self newValue]"},{"name":"testCapacity","linesOfCode":18,"sourceCode":"testCapacity\r\t\"The current Dictionary implementation allocates more than specified.\r\tThe amount allocated may change in the future but it likely won't ever\r\tbe less than specified, so a >= test is used throughout.\"\r\r\t| defaultCapacity dictionary |\r\r\tdefaultCapacity := self defaultCapacity.\r\tdictionary := self dictionaryClass new.\r\tself assert: dictionary capacity >= defaultCapacity.\r\r\tdictionary := self dictionaryClass new: (defaultCapacity / 2) asInteger.\r\tself assert: dictionary capacity >= (defaultCapacity / 2) asInteger.\r\r\tdictionary := self dictionaryClass newFrom: self orderedAssociations.\r\tself assert: dictionary capacity >= self orderedAssociations size.\r\r\tself orderedAssociations size to: 0 by: -1 do: [:i |\r\t\tself\r\t\t\tshouldnt: [\r\t\t\t\tdictionary := self dictionaryClass new: i.\r\t\t\t\tdictionary addAll: self orderedAssociations]\r\t\t\traise: Error]."},{"name":"testNewFrom","linesOfCode":14,"sourceCode":"testNewFrom\r\t| dictionary |\r\t\r\tdictionary := self dictionaryClass newFrom: self orderedAssociations.\r\tself\r\t\tassertIsDictionary: dictionary\r\t\twithOrderedAssociations: self orderedAssociations.\r\tself\r\t\tassertIsDictionary: (self dictionaryClass newFrom: dictionary)\r\t\tcopiedFrom: dictionary\r\t\twithOrderedAssociations: self orderedAssociations.\r\tself\r\t\tassertIsDictionary:\r\t\t\t(self dictionaryClass newFrom: self internalDictionaryWithAssociations)\r\t\twithUnorderedAssociations: self orderedAssociations."},{"name":"testRemoveKeyIfAbsent","linesOfCode":9,"sourceCode":"testRemoveKeyIfAbsent\r\t| dictionary |\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tself orderedAssociations\r\t\twithIndexDo: [ :each :i | \r\t\t\tself assert: (dictionary removeKey: each key ifAbsent: [ self fail ]) equals: each value.\r\t\t\tself assertKey: each key wasRemovedfrom: dictionary.\r\t\t\tself assertIsDictionary: dictionary withOrderedAssociations: (self orderedAssociationsAllButFirst: i).\r\r\t\t\tself assert: (dictionary removeKey: each key ifAbsent: [ self absentValue ]) equals: self absentValue ]"},{"name":"testEqualsOtherOrderedDictionaries","linesOfCode":8,"sourceCode":"testEqualsOtherOrderedDictionaries\r\tself otherOrderedDictionaryClasses do: [:each |\r\t\tself\r\t\t\tassertDictionary: self emptyDictionary\r\t\t\tdoesNotEqual: each new.\r\t\tself\r\t\t\tassertDictionary: self dictionaryWithOrderedAssociations\r\t\t\tdoesNotEqual: (each newFrom: self orderedAssociations)]"},{"name":"internalDictionaryClass","linesOfCode":4,"sourceCode":"internalDictionaryClass\r\r\t^self isTestingIdentityDictionary\r\t\tifTrue: [ IdentityDictionary]\r\t\tifFalse: [ Dictionary]"},{"name":"testAtIfAbsentPut","linesOfCode":15,"sourceCode":"testAtIfAbsentPut\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifAbsentPut: [each value]) equals: each value.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifAbsentPut: [self fail]) equals: each value.\r\t\tself\r\t\t\tassertIsArray: dictionary keys\r\t\t\twithElements: (self orderedKeysFirst: i) ]"},{"name":"testAssociationAt","linesOfCode":8,"sourceCode":"testAssociationAt\r\t| dictionary |\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations\r\t\tdo: [ :each | \r\t\t\tself should: [ dictionary associationAt: each key ] raise: Error.\r\r\t\t\tdictionary add: each.\r\t\t\tself assert: (dictionary associationAt: each key) equals: each ]"},{"name":"testAt","linesOfCode":9,"sourceCode":"testAt\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself\r\t\t\tshould: [dictionary at: each key]\r\t\t\traise: Error.\r\r\t\tdictionary add: each.\r\t\tself assert: (dictionary at: each key) equals: each value]."},{"name":"orderedAssociationsFirst:","linesOfCode":2,"sourceCode":"orderedAssociationsFirst: anInteger\r\r\t^ self orderedAssociations first: anInteger"},{"name":"testKeyAtIndexIfAbsent","linesOfCode":17,"sourceCode":"testKeyAtIndexIfAbsent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself assert:\r\t\t(dictionary\r\t\t\tkeyAtIndex: 0\r\t\t\tifAbsent: [self absentKey]) equals: self absentKey.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tkeyAtIndex: i\r\t\t\t\tifAbsent: [self absentKey]) equals: self absentKey.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tkeyAtIndex: i\r\t\t\t\tifAbsent: [self fail]) equals: each key]."},{"name":"orderedValuesFirst:","linesOfCode":2,"sourceCode":"orderedValuesFirst: anInteger\r\r\t^ self orderedValues first: anInteger"},{"name":"testKeysDo","linesOfCode":11,"sourceCode":"testKeysDo\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tshould: [:block | dictionary keysDo: block]\r\t\tenumerate: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tshould: [:block | dictionary keysDo: block]\r\t\t\tenumerate: (self orderedKeysFirst: i)]."},{"name":"testIncludes","linesOfCode":7,"sourceCode":"testIncludes\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself deny: (dictionary includes: each value).\r\r\t\tdictionary add: each.\r\t\tself assert: (dictionary includes: each value)]."},{"name":"internalDictionaryWithAssociations","linesOfCode":2,"sourceCode":"internalDictionaryWithAssociations\r\r\t^ self internalDictionaryClass newFrom: self orderedAssociations"},{"name":"collectClass","linesOfCode":2,"sourceCode":"collectClass\r\r\t^ Array"},{"name":"identityAbsentKey","linesOfCode":2,"sourceCode":"identityAbsentKey\r\r\t^ self orderedKeys first copy"},{"name":"orderedAssociationsAllButFirst:","linesOfCode":2,"sourceCode":"orderedAssociationsAllButFirst: anInteger\r\r\t^ self orderedAssociations allButFirst: anInteger"},{"name":"testKeyForIdentity","linesOfCode":9,"sourceCode":"testKeyForIdentity\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself assert: (dictionary keyForIdentity: each value) isNil.\r\r\t\tdictionary add: each.\r\t\tself\r\t\t\tassert: (dictionary keyForIdentity: each value) equals: each key;\r\t\t\tassert: (dictionary keyForIdentity: each value copy) isNil]."},{"name":"testRemoveKey","linesOfCode":14,"sourceCode":"testRemoveKey\r\t| dictionary |\r\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert: (dictionary removeKey: each key) equals: each value.\r\t\tself\r\t\t\tassertKey: each key\r\t\t\twasRemovedfrom: dictionary.\r\t\tself\r\t\t\tassertIsDictionary: dictionary\r\t\t\twithOrderedAssociations: (self orderedAssociationsAllButFirst: i).\r\r\t\tself\r\t\t\tshould: [dictionary removeKey: each key]\r\t\t\traise: Error]"},{"name":"assertIsDictionary:copiedFrom:withOrderedAssociations:","linesOfCode":8,"sourceCode":"assertIsDictionary: aFirstDictionary copiedFrom: aSecondDictionary withOrderedAssociations: anAssociationCollection\r\tself\r\t\tdeny: aFirstDictionary identicalTo: aSecondDictionary;\r\t\tdeny: aFirstDictionary dictionary identicalTo: aSecondDictionary dictionary;\r\t\tdeny: aFirstDictionary orderedKeys identicalTo: aSecondDictionary orderedKeys.\r\r\t\"esnure the associations were copied (the keys and values can be shared)\"\r\taFirstDictionary associations do: [ :each | self deny: (aSecondDictionary associations identityIncludes: each) ].\r\r\tself assertIsDictionary: aFirstDictionary withOrderedAssociations: anAssociationCollection"},{"name":"testRemoveKeys","linesOfCode":9,"sourceCode":"testRemoveKeys\r\t0 to: self orderedAssociations size do: [ :i | \r\t\t| dictionary keysToRemove |\r\t\tdictionary := self dictionaryWithOrderedAssociations.\r\r\t\t\"make it a set to ensure it supports non-Sequenceable collections\"\r\t\tkeysToRemove := (self isTestingIdentityDictionary ifTrue: [ IdentitySet ] ifFalse: [ Set ]) withAll: (self orderedKeysFirst: i).\r\t\tself assert: (dictionary removeKeys: keysToRemove) identicalTo: dictionary.\r\t\tkeysToRemove do: [ :each | self assertKey: each wasRemovedfrom: dictionary ].\r\r\t\tself assertIsDictionary: dictionary withOrderedAssociations: (self orderedAssociationsAllButFirst: i) ]"},{"name":"testAtRandom","linesOfCode":6,"sourceCode":"testAtRandom\r\t| dict random |\r\tdict := { #one -> 1 . #two -> 2 . #three -> 3  } asOrderedDictionary.\r\trandom := dict atRandom.\r\tself assert: (#(1 2 3) includes: random).\r\tself assert: (dict includes: random).\r\t"},{"name":"isTestingIdentityDictionary","linesOfCode":2,"sourceCode":"isTestingIdentityDictionary\r\r\t^ false"},{"name":"testKeyAtValueIfAbsent","linesOfCode":13,"sourceCode":"testKeyAtValueIfAbsent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tkeyAtValue: each value\r\t\t\t\tifAbsent: [self absentKey]) equals: self absentKey.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tkeyAtValue: each value\r\t\t\t\tifAbsent: [self fail]) equals: each key]."},{"name":"testKeysSortedSafely","linesOfCode":12,"sourceCode":"testKeysSortedSafely\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tassertIsArray: dictionary keysSortedSafely\r\t\twithElements: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\t\"The keys are all strings, so the default #sorted implementation is OK.\"\r\t\tself\r\t\t\tassertIsArray: dictionary keysSortedSafely\r\t\t\twithElements: (self orderedKeysFirst: i) sorted]."},{"name":"testValues","linesOfCode":11,"sourceCode":"testValues\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself\r\t\tassertIsArray: dictionary values\r\t\twithElements: #().\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself\r\t\t\tassertIsArray: dictionary values\r\t\t\twithElements: (self orderedValuesFirst: i)]."},{"name":"assertKey:wasRemovedfrom:","linesOfCode":7,"sourceCode":"assertKey: aKey wasRemovedfrom: aDictionary\r\r\tself deny: (aDictionary includesKey: aKey).\r\taDictionary keys asArray, aDictionary orderedKeys asArray do: [:each |\r\t\tself deny:\r\t\t\t(self isTestingIdentityDictionary\r\t\t\t\tifTrue: [each == aKey]\r\t\t\t\tifFalse: [each = aKey])]."},{"name":"testIdentityIndexOfKey","linesOfCode":9,"sourceCode":"testIdentityIndexOfKey\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert: (dictionary identityIndexOfKey: each key) equals: 0.\r\r\t\tdictionary add: each.\r\t\tself\r\t\t\tassert: (dictionary identityIndexOfKey: each key) equals: i;\r\t\t\tassert: (dictionary identityIndexOfKey: each key copy) equals: 0]."},{"name":"testCopy","linesOfCode":11,"sourceCode":"testCopy\r\t| dictionary copy |\r\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tcopy := dictionary copy.\r\tself\r\t\tassertIsDictionary: dictionary\r\t\twithOrderedAssociations: self orderedAssociations.\r\tself\r\t\tassertIsDictionary: copy\r\t\tcopiedFrom: dictionary\r\t\twithOrderedAssociations: self orderedAssociations."},{"name":"identityOrderedAssociations","linesOfCode":17,"sourceCode":"identityOrderedAssociations\r\t\"Returns ordered associations to use for identity dictionaries.\r\tThe keys are all #= equal but #== different, so only an\r\tidentity dictionary will be able to distinguish them.\"\r\tidentityOrderedAssociations\r\t\tifNil: [| key |\r\t\t\tkey := 'testKey'.\r\t\t\tidentityOrderedAssociations :=\r\t\t\t\tArray\r\t\t\t\t\twith: (key := key copy) -> 'testValue'\r\t\t\t\t\twith: (key := key copy) -> 'testValue3'\r\t\t\t\t\twith: (key := key copy) -> 'testValue2'\r\t\t\t\t\twith: (key := key copy) -> 'testValue4'].\r\t\"Return copies of the associations so they can be safely modified\r\tin one test without affecting another, but do not copy the keys\r\tand values\"\r\t^ identityOrderedAssociations collect: [:each | each copy]."},{"name":"testSize","linesOfCode":10,"sourceCode":"testSize\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself assert: dictionary size equals: 0.\r\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tdictionary add: each.\r\t\tself assert: dictionary size equals: i].\r\r\tself orderedAssociations size to: 1 by: -1 do: [:i |\r\t\tdictionary removeKey: (self orderedKeys at: i).\r\t\tself assert: dictionary size equals: (i - 1)]."},{"name":"testStoreOn","linesOfCode":6,"sourceCode":"testStoreOn\r\t| print |\r\tprint := String streamContents: [ :s | self orderedAssociations storeOn: s ].\r\tself assertDictionary: (self class compiler evaluate: print) equals: self orderedAssociations.\r\tprint := String streamContents: [ :s | self emptyDictionary storeOn: s ].\r\tself assertDictionary: (self class compiler evaluate: print) equals: self emptyDictionary"},{"name":"otherOrderedDictionaryClasses","linesOfCode":2,"sourceCode":"otherOrderedDictionaryClasses\r\r\t^ OrderedDictionary withAllSubclasses copyWithout: self dictionaryClass"},{"name":"orderedValues","linesOfCode":2,"sourceCode":"orderedValues\r\r\t^ self orderedAssociations collect: [:each | each value]"},{"name":"should:enumerate:and:","linesOfCode":10,"sourceCode":"should: aBlock enumerate: aFirstCollection and: aSecondCollection\r\t| firstEnumerated secondEnumerated |\r\r\tfirstEnumerated := OrderedCollection new.\r\tsecondEnumerated := OrderedCollection new.\r\taBlock value: [:first :second |\r\t\tfirstEnumerated addLast: first.\r\t\tsecondEnumerated addLast: second].\r\tself\r\t\tassert: firstEnumerated equals: aFirstCollection asOrderedCollection;\r\t\tassert: secondEnumerated equals: aSecondCollection asOrderedCollection."},{"name":"defaultCapacity","linesOfCode":2,"sourceCode":"defaultCapacity\r\r\t^ self emptyInternalDictionary capacity"},{"name":"testKeysAndValuesRemove","linesOfCode":22,"sourceCode":"testKeysAndValuesRemove\r\t| dictionary |\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tself orderedAssociations\r\t\twithIndexDo: [ :removedAssociation :i | \r\t\t\t| unremovedAssociations |\r\t\t\tunremovedAssociations := (self orderedAssociationsAllButFirst: i) asOrderedCollection.\r\t\t\tdictionary\r\t\t\t\tkeysAndValuesRemove: [ :key :value | \r\t\t\t\t\t(self isTestingIdentityDictionary ifTrue: [ key == removedAssociation key ] ifFalse: [ key = removedAssociation key ])\r\t\t\t\t\t\tifTrue: [ self assert: value equals: removedAssociation value.\r\t\t\t\t\t\t\ttrue ]\r\t\t\t\t\t\tifFalse: [ | unremovedAssociation |\r\t\t\t\t\t\t\tunremovedAssociation := unremovedAssociations removeFirst.\r\t\t\t\t\t\t\tself isTestingIdentityDictionary\r\t\t\t\t\t\t\t\tifTrue: [ self assert: key identicalTo: unremovedAssociation key ]\r\t\t\t\t\t\t\t\tifFalse: [ self assert: key equals: unremovedAssociation key ].\r\t\t\t\t\t\t\tself assert: value equals: unremovedAssociation value.\r\t\t\t\t\t\t\tfalse ] ].\r\t\t\tself assertEmpty: unremovedAssociations.\r\t\t\tself assertKey: removedAssociation key wasRemovedfrom: dictionary ].\r\tself assertEmpty: dictionary"},{"name":"testCopyEmpty","linesOfCode":11,"sourceCode":"testCopyEmpty\r\t| dictionary copy |\r\r\tdictionary := self dictionaryWithOrderedAssociations.\r\tcopy := dictionary copyEmpty.\r\tself\r\t\tassertIsDictionary: dictionary\r\t\twithOrderedAssociations: self orderedAssociations.\r\tself\r\t\tassertIsDictionary: copy\r\t\tcopiedFrom: dictionary\r\t\twithOrderedAssociations: #()."},{"name":"absentKey","linesOfCode":4,"sourceCode":"absentKey\r\r\t^self isTestingIdentityDictionary\r\t\tifTrue: [ self identityAbsentKey ]\r\t\tifFalse: [ self nonIdentityAbsentKey ]"},{"name":"testDictionaryPublicProtocolCompatibility","linesOfCode":13,"sourceCode":"testDictionaryPublicProtocolCompatibility\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\t{dictionary -> Dictionary.\r\tdictionary class -> Dictionary class}\r\t\tdo: [:assoc | \r\t\t\tassoc value protocols\r\t\t\t\treject: [:protocol | \r\t\t\t\t\t#('private' 'print' 'undeclared' 'copy' 'compar' '*')\r\t\t\t\t\t\tanySatisfy: [:each | protocol asString beginsWith: each]]\r\t\t\t\tthenDo: [:protocol | \r\t\t\t\t\t(assoc value selectorsInProtocol: protocol)\r\t\t\t\t\t\tdo: [:each | self assert: (assoc key respondsTo: each)]]]."},{"name":"nonIdentityOrderedAssociations","linesOfCode":16,"sourceCode":"nonIdentityOrderedAssociations\r\t\"Returns ordered associations to use for non-identity dictionaries.\r\tThe keys are all #= and #== different and are returned out of their\r\tnatural sort order.\"\r\tnonIdentityOrderedAssociations\r\t\tifNil: [\r\t\t\tnonIdentityOrderedAssociations :=\r\t\t\t\tArray\r\t\t\t\t\twith: 'testKey' -> 'testValue'\r\t\t\t\t\twith: 'testKey3' -> 'testValue3'\r\t\t\t\t\twith: 'testKey2' -> 'testValue2'\r\t\t\t\t\twith: 'testKey4' -> 'testValue4'].\r\t\"return copies of the associations so they can be safely modified\r\tin one test without affecting another, but do not copy the keys\r\tand values\"\r\t^ nonIdentityOrderedAssociations collect: [:each | each copy]."},{"name":"testAtIfAbsent","linesOfCode":13,"sourceCode":"testAtIfAbsent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifAbsent: [self absentValue]) equals: self absentValue.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifAbsent: [self fail]) equals: each value]."},{"name":"testAdd","linesOfCode":24,"sourceCode":"testAdd\r\t| dictionary |\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations\r\t\twithIndexDo: [ :each :i | \r\t\t\tself\r\t\t\t\tdeny: (dictionary includesAssociation: each);\r\t\t\t\tassert: (dictionary add: each) identicalTo: each;\r\t\t\t\tassert: (dictionary includesAssociation: each).\r\t\t\tself assertIsDictionary: dictionary withOrderedAssociations: (self orderedAssociationsFirst: i) ].\r\r\t\"ensure adding the same associations doesn't change the order\"\r\tself orderedAssociations\r\t\treverseDo: [ :each | \r\t\t\tself assert: (dictionary add: each) identicalTo: each.\r\t\t\tself assertIsDictionary: dictionary withOrderedAssociations: self orderedAssociations ].\r\r\tself changedOrderedAssociations\r\t\twithIndexDo: [ :each :i | \r\t\t\t| old |\r\t\t\told := self orderedAssociations at: i.\r\t\t\tself\r\t\t\t\tassert: (dictionary add: each) identicalTo: each;\r\t\t\t\tassert: (dictionary includesAssociation: each);\r\t\t\t\tdeny: (dictionary includesAssociation: old).\r\t\t\tself assertIsDictionary: dictionary withOrderedAssociations: (self changedOrderedAssociationsFirst: i) , (self orderedAssociationsAllButFirst: i) ]"},{"name":"nonIdentityAbsentKey","linesOfCode":2,"sourceCode":"nonIdentityAbsentKey\r\r\t^ 'absentKey'"},{"name":"testAtUpdateInitial","linesOfCode":7,"sourceCode":"testAtUpdateInitial\r\t| dict |\r\tdict := OrderedDictionary  newFrom: {2->10. 100->5} .\r\tdict at: 5 update: [ :v | v+1 ] initial: 17.\r\tdict at: 2 update: [ :v | v+10 ] initial: [0].\r\tself assert: (dict at: 5) equals: 17.\r\tself assert: (dict at: 2) equals: 20\r\t"},{"name":"emptyDictionary","linesOfCode":2,"sourceCode":"emptyDictionary\r\r\t^ self dictionaryClass new"},{"name":"testOccurrencesOf","linesOfCode":9,"sourceCode":"testOccurrencesOf\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself assert: (dictionary occurrencesOf: self newValue) equals: 0.\r\tself orderedKeys withIndexDo: [:each :i |\r\t\tdictionary\r\t\t\tat: each\r\t\t\tput: self newValue.\r\t\tself assert: (dictionary occurrencesOf: self newValue) equals: i]"},{"name":"dictionaryClass","linesOfCode":2,"sourceCode":"dictionaryClass\r\r\t^ OrderedDictionary"},{"name":"assertDictionary:doesNotEqual:","linesOfCode":5,"sourceCode":"assertDictionary: aFirstDictionary doesNotEqual: aSecondDictionary\r\t\"Test symmetric inequality\"\r\r\tself\r\t\tdeny: aFirstDictionary equals: aSecondDictionary;\r\t\tdeny: aSecondDictionary equals: aFirstDictionary"},{"name":"testIncludesAssociation","linesOfCode":11,"sourceCode":"testIncludesAssociation\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself\r\t\t\tdeny: (dictionary includesAssociation: each);\r\t\t\tdeny: (dictionary includesAssociation: each key -> each value).\r\r\t\tdictionary add: each.\r\t\tself\r\t\t\tassert: (dictionary includesAssociation: each);\r\t\t\tassert: (dictionary includesAssociation: each key -> each value)]."},{"name":"testAtIfPresentIfAbsent","linesOfCode":21,"sourceCode":"testAtIfPresentIfAbsent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifPresent: [self fail]\r\t\t\t\tifAbsent: [self absentValue]) equals: self absentValue.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifPresent: [:value | self newValue -> value]\r\t\t\t\tifAbsent: [self fail]) equals: (self newValue -> each value).\r\t\t\"ensure cull: is used\"\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifPresent: [self newValue]\r\t\t\t\tifAbsent: [self fail]) equals: self newValue]."},{"name":"testIdentityIndexOfKeyIfAbsent","linesOfCode":9,"sourceCode":"testIdentityIndexOfKeyIfAbsent\r\t| dictionary |\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations\r\t\twithIndexDo: [ :each :i | \r\t\t\tself assert: (dictionary identityIndexOfKey: each key ifAbsent: [ self absentValue ]) equals: self absentValue.\r\r\t\t\tdictionary add: each.\r\t\t\tself assert: (dictionary identityIndexOfKey: each key ifAbsent: [ self fail ]) equals: i.\r\t\t\tself assert: (dictionary identityIndexOfKey: each key copy ifAbsent: [ self absentValue ]) equals: self absentValue ]"},{"name":"assertIsDictionary:withOrderedAssociations:","linesOfCode":17,"sourceCode":"assertIsDictionary: anObject withOrderedAssociations: anAssociationCollection\r\t\"Tests that anObject is an instance of the correct dictionary class\r\twith the specified ordered associations\"\r\r\tself\r\t\tassert: anObject class identicalTo: self dictionaryClass;\r\t\tassert: anObject orderedKeys size >= anAssociationCollection size;\r\t\tassert: anObject associations size equals: anAssociationCollection size.\r\r\tanAssociationCollection\r\t\twithIndexDo: [ :each :i | \r\t\t\tself isTestingIdentityDictionary\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\tassert: (anObject orderedKeys at: i) identicalTo: each key;\r\t\t\t\t\t\tassert: (anObject associations at: i) key identicalTo: each key ]\r\t\t\t\tifFalse: [ self\r\t\t\t\t\t\tassert: (anObject orderedKeys at: i) equals: each key;\r\t\t\t\t\t\tassert: (anObject associations at: i) key equals: each key ].\r\t\t\tself assert: (anObject associations at: i) value equals: each value ]"},{"name":"orderedKeys","linesOfCode":2,"sourceCode":"orderedKeys\r\r\t^ self orderedAssociations collect: [:each | each key]"},{"name":"testIncludesKey","linesOfCode":7,"sourceCode":"testIncludesKey\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself deny: (dictionary includesKey: each key).\r\r\t\tdictionary add: each.\r\t\tself assert: (dictionary includesKey: each key)]."},{"name":"changedOrderedAssociationsFirst:","linesOfCode":2,"sourceCode":"changedOrderedAssociationsFirst: anInteger\r\r\t^ self changedOrderedAssociations first: anInteger"},{"name":"testNewFromPairs","linesOfCode":13,"sourceCode":"testNewFromPairs\r\t| pairs |\r\r\tpairs := OrderedCollection new.\r\tself orderedAssociations do: [:each |\r\t\tpairs\r\t\t\taddLast: each key;\r\t\t\taddLast: each value].\r\r\t0 to: pairs size do: [:i |\r\t\tself\r\t\t\tassertIsDictionary:\r\t\t\t\t(self dictionaryClass newFromPairs: (pairs copyFrom: 1 to: i))\r\t\t\twithOrderedAssociations:\r\t\t\t\t(self orderedAssociationsFirst: (i / 2) floor)]."},{"name":"assertIsArray:withElements:","linesOfCode":4,"sourceCode":"assertIsArray: anArray withElements: aCollection\r\r\tself\r\t\tassert: anArray isArray;\r\t\tassert: anArray equals: aCollection asArray"},{"name":"dictionaryWithOrderedAssociations","linesOfCode":2,"sourceCode":"dictionaryWithOrderedAssociations\r\r\t^ self dictionaryClass newFrom: self orderedAssociations"},{"name":"testAssociationAtIfAbsent","linesOfCode":13,"sourceCode":"testAssociationAtIfAbsent\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [:each |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tassociationAt: each key\r\t\t\t\tifAbsent: [self absentValue]) equals: self absentValue.\r\r\t\tdictionary add: each.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tassociationAt: each key\r\t\t\t\tifAbsent: [self fail]) equals: each]."},{"name":"testAddAll","linesOfCode":14,"sourceCode":"testAddAll\r\t| dictionary addedAssociations |\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations do: [ :each | self deny: (dictionary includesAssociation: each) ].\r\r\taddedAssociations := self orderedAssociations.\r\tself assert: (dictionary addAll: addedAssociations) identicalTo: addedAssociations.\r\tself assertIsDictionary: dictionary withOrderedAssociations: self orderedAssociations.\r\r\t\"ensure adding the same associations doesn't change the order\"\r\taddedAssociations := self orderedAssociations reversed.\r\tself assert: (dictionary addAll: addedAssociations) identicalTo: addedAssociations.\r\tself assertIsDictionary: dictionary withOrderedAssociations: self orderedAssociations.\r\r\taddedAssociations := self changedOrderedAssociations.\r\tself assert: (dictionary addAll: addedAssociations) identicalTo: addedAssociations.\r\tself assertIsDictionary: dictionary withOrderedAssociations: self changedOrderedAssociations"},{"name":"testHash","linesOfCode":17,"sourceCode":"testHash\r\t| dictionary otherDictionary internalDictionary otherInternalDictionary |\r\tdictionary := self emptyDictionary.\r\totherDictionary := self emptyDictionary.\r\tinternalDictionary := self emptyInternalDictionary.\r\totherInternalDictionary := self emptyInternalDictionary.\r\tself assert: dictionary hash equals: otherDictionary hash.\r\tself orderedAssociations\r\t\tdo: [ :each | \r\t\t\tdictionary add: each.\r\t\t\tinternalDictionary add: each copy.\r\t\t\t\"if the internal hashes differ after adding to one, the external should too\"\r\t\t\tinternalDictionary hash = otherInternalDictionary hash ifFalse: [ self deny: dictionary hash equals: otherDictionary hash ].\r\r\t\t\totherDictionary add: each copy.\r\t\t\totherInternalDictionary add: each copy.\r\t\t\t\"should be equal regardless now\"\r\t\t\tself assert: dictionary hash equals: otherDictionary hash ]"},{"name":"testAtIfPresentIfAbsentPut","linesOfCode":17,"sourceCode":"testAtIfPresentIfAbsentPut\r\t| dictionary |\r\r\tdictionary := self emptyDictionary.\r\tself orderedAssociations withIndexDo: [:each :i |\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifPresent: [ self fail ]\r\t\t\t\tifAbsentPut: [ each value ]) equals: each value.\r\t\tself assert:\r\t\t\t(dictionary\r\t\t\t\tat: each key\r\t\t\t\tifPresent: [ :it | self newValue -> it ]\r\t\t\t\tifAbsentPut: [self fail]) equals: (self newValue -> each value).\r\t\tself\r\t\t\tassertIsArray: dictionary keys\r\t\t\twithElements: (self orderedKeysFirst: i) ]"},{"name":"testIsDictionary","linesOfCode":2,"sourceCode":"testIsDictionary\r\tself assert: self dictionaryClass new isDictionary"},{"name":"assertIsDictionary:withUnorderedAssociations:","linesOfCode":7,"sourceCode":"assertIsDictionary: anObject withUnorderedAssociations: anAssociationCollection\r\t\"Tests that anObject is an instance of the correct dictionary class\r\twith the specified associations, but ignoring the order\"\r\r\tself\r\t\tassert: anObject class identicalTo: self dictionaryClass;\r\t\tassert: anObject size equals: anAssociationCollection size.\r\tanAssociationCollection do: [ :each | self assert: (anObject includesAssociation: each) ]"},{"name":"should:enumerate:","linesOfCode":5,"sourceCode":"should: aBlock enumerate: aCollection\r\t| enumerated |\r\r\tenumerated := OrderedCollection new.\r\taBlock value: [:each | enumerated add: each].\r\tself assert: enumerated equals: aCollection asOrderedCollection."}],"meta":{"name":"OrderedDictionaryTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r\t^ true"}],"meta":null}},{"name":"IntervalTest","instanceVariables":[{"name":"empty"},{"name":"nonEmpty"},{"name":"one"},{"name":"elementIn"},{"name":"elementNotIn"},{"name":"subCollectionNotIn"},{"name":"collectionOfFloat"},{"name":"anotherCollection"},{"name":"nonEmpty1Element"},{"name":"subCollection"},{"name":"collectionWithSubCollection"},{"name":"subCollectionInNonEmpty"},{"name":"collectionWithoutNil"},{"name":"collectResult"},{"name":"collectionOfLargeIntegers"}],"methods":[{"name":"nonEmptyMoreThan1Element","linesOfCode":2,"sourceCode":"nonEmptyMoreThan1Element\r\t^nonEmpty ."},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\t^ nonEmpty "},{"name":"testEquals4","linesOfCode":7,"sourceCode":"testEquals4\r\tself assert: (3 to: 5 by: 2) equals: #(3 5).\r\tself deny: (3 to: 5 by: 2) equals: #(3 4 5).\r\tself deny: (3 to: 5 by: 2) equals: #().\r\r\tself assert: #(3 5) equals: (3 to: 5 by: 2).\r\tself deny: #(3 4 5) equals: (3 to: 5 by: 2).\r\tself deny: #() equals: (3 to: 5 by: 2)"},{"name":"testMinus","linesOfCode":2,"sourceCode":"testMinus\r\tself assert: (1 to: 10) - 5 equals: (-4 to: 5)"},{"name":"testReverseDo","linesOfCode":8,"sourceCode":"testReverseDo\r\t| s i |\r\ts := OrderedCollection new.\r\ti := 10 to: 20.\r\ti\r\t\treverseDo: [:each | s addFirst: each].\r\tself\r\t\tassert: (s hasEqualElements: i)"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":2,"sourceCode":"integerCollectionWithoutEqualElements\r\t^ 1 to: 23."},{"name":"subCollectionNotIn","linesOfCode":2,"sourceCode":"subCollectionNotIn\r\r\t^subCollectionNotIn "},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ collectionOfLargeIntegers"},{"name":"collectionWithElementsToRemove","linesOfCode":2,"sourceCode":"collectionWithElementsToRemove\r\t\r\t^ subCollectionInNonEmpty ."},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ self nonEmpty "},{"name":"testEquals","linesOfCode":7,"sourceCode":"testEquals\r\tself assert: (3 to: 5) equals: #(3 4 5).\r\tself deny: (3 to: 5) equals: #(3 5).\r\tself deny: (3 to: 5) equals: #().\r\r\tself assert: #(3 4 5) equals: (3 to: 5).\r\tself deny: #(3 5) equals: (3 to: 5).\r\tself deny: #() equals: (3 to: 5)"},{"name":"testInclusion","linesOfCode":3,"sourceCode":"testInclusion\r\t\"Non regression test for another bug of fuzzy inclusion\"\r\tself deny: ((1.0 to: 3.0 by: 1.0 successor) includes: 3.0) description: 'The last element of this Interval is closed to 2'"},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":2,"sourceCode":"indexInForCollectionWithoutDuplicates\r\t^ 2."},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ 9"},{"name":"testAdd","linesOfCode":2,"sourceCode":"testAdd\r\tself assert: (1 to: 10) + 5 equals: (6 to: 15)"},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\t\r\t^ 2"},{"name":"testExtent","linesOfCode":4,"sourceCode":"testExtent\r\tself assert: (1 to: 10) extent equals: 9.\r\tself assert: (1 to: 10 by: 2) extent equals: 9.\r\tself assert: (1 to: -1) extent equals: -2"},{"name":"testIntervalStoreOn","linesOfCode":6,"sourceCode":"testIntervalStoreOn\r\t\"this is a test for http://bugs.squeak.org/view.php?id=4378\"\r\r\t| interval1 interval2 |\r\tinterval1 := 0 to: 1 by: 0.5s1 squared.\r\tinterval2 := self class compiler evaluate: interval1 storeString.\r\tself assert: interval1 size equals: interval2 size"},{"name":"accessCollection","linesOfCode":2,"sourceCode":"accessCollection\r\t^ -2 to: 14 by: 4"},{"name":"elementInForIndexAccess","linesOfCode":2,"sourceCode":"elementInForIndexAccess\r\t^ self accessCollection  anyOne"},{"name":"elementNotIn","linesOfCode":2,"sourceCode":"elementNotIn\r\t^elementNotIn"},{"name":"nonEmpty1Element","linesOfCode":2,"sourceCode":"nonEmpty1Element\r\r\t^ nonEmpty1Element  "},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\" return an element not included in 'accessCollection' \"\r\t^ elementNotIn "},{"name":"result","linesOfCode":2,"sourceCode":"result\r\t^ {SmallInteger . SmallInteger . SmallInteger . SmallInteger . SmallInteger . SmallInteger}"},{"name":"testAllButFirstElements","linesOfCode":6,"sourceCode":"testAllButFirstElements\r\t| abf col |\r\tcol := self accessCollection.\r\tabf := col allButFirst: 2.\r\t1 to: abf size do: [ :i | self assert: (abf at: i) equals: (col at: i + 2) ].\r\tself assert: abf size + 2 equals: col size"},{"name":"testAllButLastElements","linesOfCode":6,"sourceCode":"testAllButLastElements\r\t| abf col |\r\tcol := self accessCollection.\r\tabf := col allButLast: 2.\r\t1 to: abf size do: [ :i | self assert: (abf at: i) equals: (col at: i) ].\r\tself assert: abf size + 2 equals: col size"},{"name":"elementInForIndexAccessing","linesOfCode":2,"sourceCode":"elementInForIndexAccessing\r\r\t^ elementIn "},{"name":"testEquals3","linesOfCode":4,"sourceCode":"testEquals3\r\tself assert: (3 to: 5 by: 2) first equals: (3 to: 6 by: 2) first.\r\tself assert: (3 to: 5 by: 2) last equals: (3 to: 6 by: 2) last.\r\tself assert: (3 to: 5 by: 2) equals: (3 to: 6 by: 2)"},{"name":"testIdentityIncludes","linesOfCode":8,"sourceCode":"testIdentityIncludes\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\r\t| collection element |\r\tself collectionWithCopyNonIdentical.\r\tcollection := self collectionWithCopyNonIdentical.\r\telement := collection anyOne copy.\t\"self assert: (collection includes: element).\"\r\tself deny: (collection identityIncludes: element)"},{"name":"testUnevenDo","linesOfCode":8,"sourceCode":"testUnevenDo\r\t| s i |\r\ts := OrderedCollection new.\r\ti := 10 to: 20 by: 3.\r\ti\r\t\tdo: [:each | s addLast: each].\r\tself\r\t\tassert: (s hasEqualElements: i)"},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\t^ nonEmpty"},{"name":"collectionOfFloat","linesOfCode":2,"sourceCode":"collectionOfFloat\r\t^collectionOfFloat "},{"name":"elementNotInForIndexAccessing","linesOfCode":2,"sourceCode":"elementNotInForIndexAccessing\r\r\t^elementNotIn "},{"name":"testAsInterval","linesOfCode":8,"sourceCode":"testAsInterval\r\t\"This is the same as newFrom:\"\r\r\tself assert: (#(1 2 3) as: Interval) equals: (1 to: 3).\r\tself assert: (#(33 5 -23) as: Interval) equals: (33 to: -23 by: -28).\r\tself assert: (#[2 4 6] as: Interval) equals: (2 to: 6 by: 2).\r\r\tself should: [#(33 5 -22) as: Interval]\r\t\traise: Error\r\t\tdescription: 'This is not an arithmetic progression'\r"},{"name":"elementInCollectionOfFloat","linesOfCode":2,"sourceCode":"elementInCollectionOfFloat\r\t^ collectionOfFloat anyOne"},{"name":"secondCollection","linesOfCode":2,"sourceCode":"secondCollection\r\t^anotherCollection "},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ empty\r"},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^ Array"},{"name":"testDo","linesOfCode":6,"sourceCode":"testDo\r\t| s i |\r\ts := OrderedCollection new.\r\ti := (10 to: 20).\r\ti do: [ :each | s addLast: each].\r\tself assert: (s hasEqualElements: i)"},{"name":"testIndexOfBug6455","linesOfCode":6,"sourceCode":"testIndexOfBug6455\r\t\"This test is about mantis bug http://bugs.squeak.org/view.php?id=6455\r\tIt should work as long as Fuzzy inclusion test feature for Interval of Float is maintained.\r\tThis is a case when tested element is near ones of actual value, but by default.\r\tCode used to work only in the case of close numbers by excess...\"\r\r\tself assert: ((0 to: Float pi by: Float pi / 100) indexOf: Float pi * (3 / 100)) equals: 4"},{"name":"testIsInterval","linesOfCode":3,"sourceCode":"testIsInterval\r\tself assert: (1 to: 10) isInterval.\r\tself assert: (1 to: 10 by: 2) isInterval"},{"name":"firstCollection","linesOfCode":2,"sourceCode":"firstCollection\r\t^ nonEmpty."},{"name":"integerCollection","linesOfCode":2,"sourceCode":"integerCollection\r\t^ nonEmpty "},{"name":"testAtWrap","linesOfCode":11,"sourceCode":"testAtWrap\r\t\"\r\tself assert: (self accessCollection at: 1) = 1.\r\tself assert: (self accessCollection at: 2) = 2.\r\t\"\r\r\t| index |\r\tindex := self accessCollection indexOf: self elementInForIndexAccessing.\r\tself assert: (self accessCollection atWrap: index) equals: self elementInForIndexAccessing.\r\tself assert: (self accessCollection atWrap: index + self accessCollection size) equals: self elementInForIndexAccessing.\r\tself assert: (self accessCollection atWrap: index - self accessCollection size) equals: self elementInForIndexAccessing.\r\tself assert: (self accessCollection atWrap: 1 + self accessCollection size) equals: (self accessCollection at: 1)"},{"name":"testEquals2","linesOfCode":7,"sourceCode":"testEquals2\r\tself assert: (3 to: 5) equals: #(3 4 5).\r\tself deny: (3 to: 5) equals: #(3 5).\r\tself deny: (3 to: 5) equals: #().\r\r\tself assert: #(3 4 5) equals: (3 to: 5).\r\tself deny: #(3 5) equals: (3 to: 5).\r\tself deny: #() equals: (3 to: 5)"},{"name":"testInclusionBug1603","linesOfCode":6,"sourceCode":"testInclusionBug1603\r\t\"This test is by german morales.\r\tIt is about mantis bug 1603\"\r\t\r\tself shouldnt: ((1 to: 5 by: 1) includes: 2.5). \"obvious\"\r\tself shouldnt: ((100000000000000 to: 500000000000000 by: 100000000000000)\r \t\t  includes: 250000000000000). \"same as above with 14 zeros appended\""},{"name":"expectedSizeAfterReject","linesOfCode":3,"sourceCode":"expectedSizeAfterReject\r\t\"Number of even elements in #collection\"\r\t^ 3"},{"name":"collectionWithoutEqualElements","linesOfCode":2,"sourceCode":"collectionWithoutEqualElements\r\t^ nonEmpty "},{"name":"sizeCollection","linesOfCode":3,"sourceCode":"sizeCollection\r\t\"Answers a collection whose #size is 4\"\r\t^ 1 to: 4."},{"name":"testLast","linesOfCode":3,"sourceCode":"testLast\r\tself assert: (1 to: 10) last equals: 10.\r\tself assert: (1 to: 10 by: 2) last equals: 9"},{"name":"testNewFrom","linesOfCode":4,"sourceCode":"testNewFrom\r\tself assert: (Interval newFrom: (1 to: 1)) equals: (1 to: 1).\r\tself assert: (Interval newFrom: #(1)) equals: (1 to: 1).\r\tself assert: (Interval newFrom: #()) equals: (1 to: 0)"},{"name":"testRangeIncludes","linesOfCode":12,"sourceCode":"testRangeIncludes\r\r\tself assert: ((1 to: 10) rangeIncludes: 3).\r\tself assert: ((1 to: 10 by: 2) rangeIncludes: 3).\r\tself assert: ((10 to: 1 by: -2) rangeIncludes: 3).\r\tself assert: ((1 to: 10 by: 2) rangeIncludes: 4).\r\tself assert: ((1 to: 10) rangeIncludes: 3.5).\r\t\r\tself deny: ((1 to: 10) rangeIncludes: 0).\r\tself deny: ((1 to: 10) rangeIncludes: 11).\r\tself deny: ((1 to: 10 by: 2) rangeIncludes: 0).\r\tself deny: ((1 to: 10 by: 2) rangeIncludes: 11).\r\tself deny: ((10 to: 1) rangeIncludes: 3).\r\tself deny: ((10 to: 1) rangeIncludes: -3)"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^ collectionWithoutNil "},{"name":"doWithoutNumber","linesOfCode":2,"sourceCode":"doWithoutNumber\r\r\t^ 6"},{"name":"testAt","linesOfCode":5,"sourceCode":"testAt\r\tself assert: ((1 to: 10) at: 1) equals: 1.\r\tself assert: ((1 to: 10) at: 3) equals: 3.\r\tself assert: ((1 to: 10 by: 2) at: 1) equals: 1.\r\tself assert: ((1 to: 10 by: 2) at: 3) equals: 5"},{"name":"testIndexOfBug1602","linesOfCode":6,"sourceCode":"testIndexOfBug1602\r\t\"This test is by german morales.\r\tIt is about mantis bug 1602\"\r\t\r\tself should: ((1 to: 5 by: 1) indexOf: 2.5) = 0. \"obvious\"\r\tself should: ((100000000000000 to: 500000000000000 by: 100000000000000)\r \t\t  indexOf: 250000000000000) = 0. \"same as above with 14 zeros appended\""},{"name":"testInfiniteLoopBug6456","linesOfCode":10,"sourceCode":"testInfiniteLoopBug6456\r\t\"This is a non regression test against mantis bug #6456.\r\tSome Float interval size was not consistent with do: loop.\r\tSome Float Interval used to do: infinite loops\"\r\r\t| x interval counter size |\r\tx := (1.0 timesTwoPower: Float precision). \"Note: x+1 = x due to inexact arithmetic\"\r\tinterval := x to: x+4.\r\tsize := interval size.\r\tcounter := 0.\r\tinterval do: [:each | self assert: (counter := counter + 1) <= size]\r"},{"name":"firstOdd","linesOfCode":3,"sourceCode":"firstOdd\r\t\"Returns the first odd number of #collection\"\r\t^ -5"},{"name":"firstEven","linesOfCode":3,"sourceCode":"firstEven\r\t\"Returns the first even number of #collection\"\r\t^ -2"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ nonEmpty"},{"name":"replacementCollection","linesOfCode":2,"sourceCode":"replacementCollection\r\t^ 5 to: 7."},{"name":"testInvalid","linesOfCode":12,"sourceCode":"testInvalid\r\t\"empty, impossible ranges\"\r\r\tself assert: (1 to: 0) equals: #().\r\tself assert: (1 to: -1) equals: #().\r\tself assert: (-1 to: -2) equals: #().\r\tself assert: (1 to: 5 by: -1) equals: #().\r\r\t\"always contains only start value.\"\r\tself assert: (1 to: 1) equals: #(1).\r\tself assert: (1 to: 5 by: 10) equals: #(1).\r\tself assert: (1 to: 0 by: -2) equals: #(1).\r\r\t\"zero steps are not allowed\"\r\tself should: [ 1 to: 1 by: 0 ] raise: DomainError"},{"name":"collectionWith1TimeSubcollection","linesOfCode":2,"sourceCode":"collectionWith1TimeSubcollection\r\t^ collectionWithSubCollection "},{"name":"elementInForIncludesTest","linesOfCode":2,"sourceCode":"elementInForIncludesTest\r\r\t^ elementIn "},{"name":"testNumericTypes","linesOfCode":7,"sourceCode":"testNumericTypes\r\r\tself assert: ((3 asNumber) to: 5) equals: #(3 4 5).\r\t\r\tself assert: (3.0 to: 5.0) equals: #(3.0 4.0 5.0).\r\tself assert: (3.0 to: 5.0 by: 0.5) equals: #(3.0 3.5 4.0 4.5 5.0).\r\t\r\tself assert: (3/1 to: 5/1) equals: #(3 4 5).\r\r\t\"dynamic array, because fractions aren't literals\"\r\tself assert: (1/2 to: 5/2 by: 1/2) equals: {1/2 . 1 . 3/2 . 2 . 5/2}."},{"name":"collectionInForIncluding","linesOfCode":2,"sourceCode":"collectionInForIncluding\r\t^ nonEmpty copyWithout: (self nonEmpty last)."},{"name":"testShuffled","linesOfCode":8,"sourceCode":"testShuffled\r\r\t| i is |\r\ti := (1 to: 20).\r\tis := i shuffled.\r\tself assert: i ~= is.\r\tself assert: i size equals: is size.\r\tself assert: (is includesAll: i).\r\tself assert: (i includesAll: is)."},{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotInForOccurrences)"},{"name":"testInclusionBug6455","linesOfCode":6,"sourceCode":"testInclusionBug6455\r\t\"This test is about mantis bug http://bugs.squeak.org/view.php?id=6455\r\tIt should work as long as Fuzzy inclusion test feature for Interval of Float is maintained.\r\tThis is a case when tested element is near ones of actual value, but by default.\r\tCode used to work only in the case of close numbers by excess...\"\r\t\r\tself assert: ((0 to: Float pi by: Float pi / 100) includes: Float pi * (3/100))"},{"name":"testIsEvaluating","linesOfCode":3,"sourceCode":"testIsEvaluating\r\tself assert: (1 to: 10) isSelfEvaluating.\r\tself assert: (1 to: 10 by: 2) isSelfEvaluating"},{"name":"test0IndexAccessingTest","linesOfCode":11,"sourceCode":"test0IndexAccessingTest\r\tself accessCollection.\r\tself assert: self accessCollection size equals: 5.\r\tself subCollectionNotIn.\r\tself subCollectionNotIn detect: [ :each | (self accessCollection includes: each) not ] ifNone: [ self assert: false ].\r\tself elementNotInForIndexAccessing.\r\tself deny: (self accessCollection includes: self elementNotInForIndexAccessing).\r\tself elementInForIndexAccessing.\r\tself assert: (self accessCollection includes: self elementInForIndexAccessing).\r\tself collectionOfFloat.\r\tself collectionOfFloat do: [ :each | self deny: each class equals: SmallInteger ]"},{"name":"testOtherNewFrom","linesOfCode":11,"sourceCode":"testOtherNewFrom\r\tself assert: (Interval newFrom: #(1 2 3)) equals: (1 to: 3).\r\tself assert: (Interval newFrom: #(33 5 -23)) equals: (33 to: -23 by: -28).\r\tself should: [ Interval newFrom: #(33 5 -22) ] raise: Error.\r\tself assert: (#(33 5 -23) as: Interval) equals: (33 to: -23 by: -28).\r\tself should: [ #(33 5 -22) as: Interval ] raise: Error.\r\r\tself assert: ((-4 to: -12 by: -1) as: Interval) equals: (-4 to: -12 by: -1).\r\tself assert: (Interval newFrom: (1 to: 1)) equals: (1 to: 1).\r\tself assert: (Interval newFrom: (1 to: 0)) equals: (1 to: 0).\r\tself assert: (#(1) as: Interval) equals: (1 to: 1).\r\tself assert: (#() as: Interval) equals: (1 to: 0)"},{"name":"elementToAdd","linesOfCode":2,"sourceCode":"elementToAdd\r\t^ elementNotIn "},{"name":"testPermutationsDo","linesOfCode":7,"sourceCode":"testPermutationsDo\r\t| i oc |\r\ti := 1.234 to: 4.234.\r\toc := OrderedCollection new.\r\ti permutationsDo: [ :e | oc add: e ].\r\tself assert: oc size equals: i size factorial.\r\t^ oc"},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\" return a collection including at leat 4 elements\"\r\t^ nonEmpty "},{"name":"testCollectThenSelectLocal","linesOfCode":5,"sourceCode":"testCollectThenSelectLocal\r\t| letters vowels |\r\tletters := 'abcdefghijklmnopqrstuvwxyz'.\r\tvowels := (1 to: 26) collect: [:index | letters at: index] thenSelect: [:char | char isVowel].\r\tself assert: (vowels hasEqualElements: 'aeiou')."},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t^ 42"},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\" return an element inculded in 'accessCollection '\"\r\t^ self accessCollection anyOne"},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ Interval"},{"name":"oldSubCollection","linesOfCode":2,"sourceCode":"oldSubCollection\r\t^ subCollection "},{"name":"setUp","linesOfCode":17,"sourceCode":"setUp\r\tsuper setUp.\r\tempty := (1 to: 0).\r\tone := (1 to:1).\r\tnonEmpty := -5 to: 10 by: 3.\r\tsubCollectionInNonEmpty := -2 to: 4 by: 3.\r\tnonEmpty1Element:= 1to:1.\r\tanotherCollection:= 2 to: 15.\r\tcollectionWithoutNil := 1 to: 3.\r\tcollectResult := { SmallInteger. SmallInteger. SmallInteger.}.\r\telementIn :=-2.\r\telementNotIn:= 12.\r\tsubCollectionNotIn:= -2 to: 1.\r\tcollectionOfFloat := 1.5 to: 7.5 by: 1.\r\tsubCollection := 2 to: 8.\r\tcollectionWithSubCollection := 1 to: 10.\r\tcollectionOfLargeIntegers := 100 factorial to: 100 factorial + 5."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ Interval"},{"name":"sortedInAscendingOrderCollection","linesOfCode":3,"sourceCode":"sortedInAscendingOrderCollection\r\t\"Return a collection sorted in ascending order\"\r\t^ anotherCollection"},{"name":"testReverseUnevenDo","linesOfCode":8,"sourceCode":"testReverseUnevenDo\r\t| s i |\r\ts := OrderedCollection new.\r\ti := 10 to: 20 by: 3.\r\ti\r\t\treverseDo: [:each | s addFirst: each].\r\tself\r\t\tassert: (s hasEqualElements: i)"},{"name":"unsortedCollection","linesOfCode":3,"sourceCode":"unsortedCollection\r\" retur a collection that is not yat sorted\"\r\t^ (10 to: 1 by: -2)"},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size 5 without equal elements\"\r\t^ nonEmpty "},{"name":"collectionNotIncluded","linesOfCode":2,"sourceCode":"collectionNotIncluded\r\t^ (nonEmpty last + 1) to: (nonEmpty last +5)"}],"meta":{"name":"IntervalTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"OrderedIdentityDictionaryTest","instanceVariables":[],"methods":[{"name":"isTestingIdentityDictionary","linesOfCode":2,"sourceCode":"isTestingIdentityDictionary\r\t^ true"},{"name":"dictionaryClass","linesOfCode":2,"sourceCode":"dictionaryClass\r\t^ OrderedIdentityDictionary"}],"meta":{"name":"OrderedIdentityDictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"OrderedCollectionTest","instanceVariables":[{"name":"empty"},{"name":"nonEmpty"},{"name":"collectResult"},{"name":"emptyButAllocatedWith20"},{"name":"otherCollection"},{"name":"indexCollection"},{"name":"collectionWithElement"},{"name":"collectionOfFloat"},{"name":"elementNotIn"},{"name":"indexArray"},{"name":"withoutEqualElements"},{"name":"duplicateElement"},{"name":"collectionWithDuplicateElement"},{"name":"collection5Elements"},{"name":"collectionWith4Elements"},{"name":"collectionOfCollectionsOfInts"},{"name":"collectionOfCollectionsOfStrings"},{"name":"withCharacters"},{"name":"simpleCollection"},{"name":"collectionOfString"},{"name":"collectionWithSameBeginingEnd"}],"methods":[{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size 5 without equal elements\"\r\t^ withoutEqualElements "},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\t^ indexCollection "},{"name":"collectionNotIncluded","linesOfCode":2,"sourceCode":"collectionNotIncluded\r\t^ OrderedCollection new add: elementNotIn ; add: elementNotIn ; yourself."},{"name":"testAddAllLast","linesOfCode":7,"sourceCode":"testAddAllLast\r\t\"Allows one to add each element of an OrderedCollection at the beginning of another OrderedCollection\"\r\r\t| c1 c2 |\r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc2 := #(5 6 7 8 9) asOrderedCollection.\r\tc1 addAllLast: c2.\r\tself assert: c1 equals: #(1 2 3 4 5 6 7 8 9) asOrderedCollection"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":3,"sourceCode":"integerCollectionWithoutEqualElements\r\" return a collection of integer without equal elements\"\r\t^ withoutEqualElements "},{"name":"testAtPut","linesOfCode":8,"sourceCode":"testAtPut\r\t\"Allows one to replace an element but not at an off range index\"\r\r\t| c |\r\tc := #(1 2 3 4) asOrderedCollection.\r\tc at: 2 put: 5.\r\tself assert: c equals: #(1 5 3 4) asOrderedCollection.\r\tself should: [ c at: 5 put: 8 ] raise: Error.\r\tself deny: c equals: #(1 5 3 4 8) asOrderedCollection"},{"name":"subCollectionNotIn","linesOfCode":2,"sourceCode":"subCollectionNotIn\r\r\t^ self collectionNotIncluded ."},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ collectionOfString"},{"name":"collectionWithElementsToRemove","linesOfCode":2,"sourceCode":"collectionWithElementsToRemove\r\t^ nonEmpty copyWithoutFirst."},{"name":"testCollect","linesOfCode":7,"sourceCode":"testCollect\r\t\"Allows one to collect some element of a collection into another collection\"\r\t| c1 c2 res |\r\tc1 := #(-1 2 -3 4) asOrderedCollection.\r\tc2 := #(1 2 3 4) asOrderedCollection.\r\tres := c1 collect: [:each | each abs].\r\tself assert: c2 equals: res"},{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\" return a collection without equal elements \"\r\t^ withoutEqualElements "},{"name":"collectionOfCollectionsOfStrings","linesOfCode":2,"sourceCode":"collectionOfCollectionsOfStrings\r\t^collectionOfCollectionsOfStrings."},{"name":"testCopyWith","linesOfCode":6,"sourceCode":"testCopyWith\r\t\"Allows one to create a copy of the receiver that contains the new element at the end\"\r\t\r\t| c1 | \r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc1 := c1 copyWith: 6.\r\tself assert: c1 equals: #(1 2 3 4 6) asOrderedCollection\r\t\r\t\r\r\t\r\t\r\t\r"},{"name":"testReversed","linesOfCode":6,"sourceCode":"testReversed\r\t| collection1 collection2 |\r\tcollection1 := #('Jim' 'Mary' 'John' 'Andrew') asOrderedCollection.\r\tcollection2 := collection1 reversed.\r\tself assert: collection2 first equals: 'Andrew'.\r\tself assert: collection2 last equals: 'Jim'"},{"name":"testAddDuplicateItem1","linesOfCode":11,"sourceCode":"testAddDuplicateItem1\r\t| collection |\r\tcollection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.\r\tcollection add: 'John' before: 'John'.\r\tself\r\t\tassert: ((collection asBag occurrencesOf: 'John')\r\t\t\t\t\t= 2\r\t\t\t\tand: [(collection at: (collection indexOf: 'John')\r\t\t\t\t\t\t\t+ 1)\r\t\t\t\t\t\t= (collection\r\t\t\t\t\t\t\t\tat: (collection indexOf: 'John'))])"},{"name":"selectorToAccessValuePutIn","linesOfCode":3,"sourceCode":"selectorToAccessValuePutIn\r\t\"return the selector of the method that should be invoked to access an element\"\r\t\r\t^ #first"},{"name":"testAddBefore","linesOfCode":7,"sourceCode":"testAddBefore\r\t| l |\r\tl := #(1 2 3 4) asOrderedCollection.\r\tl add: 88 before: 1.\r\tself assert: l equals: #(88 1 2 3 4) asOrderedCollection.\r\tl add: 99 before: 2.\r\tself assert: l equals: #(88 1 99 2 3 4) asOrderedCollection"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ 666"},{"name":"testAsOrderedCollectionKeepsIdentity","linesOfCode":5,"sourceCode":"testAsOrderedCollectionKeepsIdentity\r\t| x y |\r\tx := (1 to: 5) asOrderedCollection.\r\ty := x asOrderedCollection.\r\tself assert: y identityHash equals: x identityHash"},{"name":"collectionWith5Elements","linesOfCode":3,"sourceCode":"collectionWith5Elements\r\" return a collection of size 5 including 5 elements\"\r^ indexCollection "},{"name":"accessCollection","linesOfCode":2,"sourceCode":"accessCollection\r\r\t^ indexCollection"},{"name":"collectionWith2TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith2TimeSubcollection\r\" return a collection including 'oldSubCollection'  two or many time \"\r\t^ (((OrderedCollection new add: elementNotIn; yourself),self oldSubCollection ) add: elementNotIn;yourself),self  oldSubCollection"},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^ OrderedCollection new add:( self nonEmpty anyOne); yourself."},{"name":"testSort","linesOfCode":8,"sourceCode":"testSort\t\r\t| ord |\r\tord := OrderedCollection new addAll: #(2 1 3 6 7 10 6); yourself.\r\tself assert: ord sort asArray equals: #(1 2 3 6 6 7 10). \r\tself assert: ord sort equals: (OrderedCollection new addAll:#(1 2 3 6 6 7 10); yourself). \r\tself assert: (ord sort: [:a :b | a > b]) asArray equals: #(10 7 6 6 3 2 1).\r\tord := OrderedCollection new.\r\tself assert: ord sort asArray equals: #(). \r"},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\" return an element not included in 'accessCollection' \"\r\t^ elementNotIn "},{"name":"otherCollection","linesOfCode":2,"sourceCode":"otherCollection\r\t^ otherCollection"},{"name":"result","linesOfCode":2,"sourceCode":"result\r\r^ collectResult "},{"name":"elementInForIndexAccessing","linesOfCode":2,"sourceCode":"elementInForIndexAccessing\r\r^ self accessCollection  anyOne."},{"name":"testWithCollect","linesOfCode":7,"sourceCode":"testWithCollect\r\t\"Allows one to collect some element of two collections into another collection with element corresponding to the condition in the blocks\"\r\t\r\t| c1 c2 res |\r\tc1 := #(-1 2 -3 4 -5 6 -7 8) asOrderedCollection.\r\tc2 := #(-9 10 -11 12 -13 14 -15 16) asOrderedCollection.\r\tres := c1 with: c2 collect: [:each1 :each2 | each1 min: each2 ].\r\tself assert: res equals: #(-9 2 -11 4 -13 6 -15 8) asOrderedCollection"},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\r\t^ collectionWith4Elements"},{"name":"elementNotInForIndexAccessing","linesOfCode":2,"sourceCode":"elementNotInForIndexAccessing\r\r\t^ elementNotIn "},{"name":"anotherValue","linesOfCode":2,"sourceCode":"anotherValue\r\r\t^ 66"},{"name":"testRemoveAll","linesOfCode":10,"sourceCode":"testRemoveAll\r\t\"Allows one to remove all elements of a collection\"\r\r\t| c1 c2 s2 |\r\tc1 := #(2 3 4 6) asOrderedCollection.\r\tc1 addAll: (1 to: 200).\r\tc2 := c1 copy.\r\ts2 := c2 size.\r\r\tc1 removeAll.\r\r\tself assert: c1 size equals: 0.\r\tself assert: c2 size = s2 description: 'the copy has not been modified'"},{"name":"elementInCollectionOfFloat","linesOfCode":2,"sourceCode":"elementInCollectionOfFloat\r\t^ collectionOfFloat anyOne."},{"name":"aValue","linesOfCode":2,"sourceCode":"aValue\r\r\t^ 33"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r\t^ empty"},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\t^ collectionWith4Elements "},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^ OrderedCollection"},{"name":"anIndex","linesOfCode":2,"sourceCode":"anIndex\r\r\t^ 2"},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\t^ nonEmpty \t"},{"name":"integerCollection","linesOfCode":3,"sourceCode":"integerCollection\r\" return a collection only including SmallInteger elements\"\r\t^ indexCollection "},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ elementNotIn "},{"name":"element","linesOfCode":3,"sourceCode":"element\r\t\"Returns an object that can be added to the collection returned by #collection.\"\r\t^ 5"},{"name":"indexArray","linesOfCode":2,"sourceCode":"indexArray\r\t^ indexArray ."},{"name":"sizeCollection","linesOfCode":2,"sourceCode":"sizeCollection\r\r\t^ collectionWith4Elements"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\t\"Returns a collection that already includes what is returned by #element.\"\r\t^ collectionWithElement"},{"name":"testCopyNonEmptyWithoutAllNotIncluded","linesOfCode":1,"sourceCode":"testCopyNonEmptyWithoutAllNotIncluded\r\t"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^ withoutEqualElements "},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\" return a collection including at least 5 elements\"\r\t\r\t^collection5Elements "},{"name":"testAddBeforeAndRemove","linesOfCode":11,"sourceCode":"testAddBeforeAndRemove\r\t| l initialCollection |\r\tl := #(1 2 3 4) asOrderedCollection.\r\tinitialCollection := l shallowCopy.\r\tl add: 88 before: 1.\r\tself assert: l equals: #(88 1 2 3 4) asOrderedCollection.\r\tl add: 99 before: 2.\r\tself assert: l equals: #(88 1 99 2 3 4) asOrderedCollection.\r\tl remove: 99.\r\tl remove: 88.\r\tself assert: l equals: initialCollection"},{"name":"testAt","linesOfCode":5,"sourceCode":"testAt\r\t| collection |\r\tcollection := #('Jim' 'Mary' 'John' 'Andrew') asOrderedCollection.\r\tself assert: (collection at: 1) equals: 'Jim'.\r\tself assert: (collection at: 2) equals: 'Mary'"},{"name":"secondIndex","linesOfCode":3,"sourceCode":"secondIndex\r\" return an index between 'nonEmpty' bounds that is > to 'second index' \"\r\t^2"},{"name":"testAddLast","linesOfCode":7,"sourceCode":"testAddLast\r\t| l |\r\tl := #(1 2 3 4) asOrderedCollection.\r\tl addLast: 88.\r\tself assert: l equals: #(1 2 3 4 88) asOrderedCollection.\r\tl addLast: 99.\r\tself assert: l equals: #(1 2 3 4 88 99) asOrderedCollection"},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\" return a collection that will be used to replace 'oldSubcollection' in ' collectionWith1TimeSubcollection'  \" \r\t^ collectionWith4Elements"},{"name":"testAtIfAbsentPut","linesOfCode":10,"sourceCode":"testAtIfAbsentPut\r\t\"Allows one to add an element at an index if no element exist at this index\"\r\r\t| c |\r\tc := #(1 2 3 4) asOrderedCollection.\r\tc at: 2 ifAbsentPut: [ 5 ].\r\tself assert: c equals: #(1 2 3 4) asOrderedCollection.\r\tc at: 5 ifAbsentPut: [ 5 ].\r\tself assert: c equals: #(1 2 3 4 5) asOrderedCollection.\r\tc at: 7 ifAbsentPut: [ 7 ].\r\tself assert: c equals: #(1 2 3 4 5 nil 7) asOrderedCollection"},{"name":"collectionWith1TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith1TimeSubcollection\r\" return a collection including 'oldSubCollection'  only one time \"\r\t^ ((OrderedCollection new add: elementNotIn; yourself),self oldSubCollection) add: elementNotIn;yourself   "},{"name":"elementInForIncludesTest","linesOfCode":3,"sourceCode":"elementInForIncludesTest\r\" return an element included in nonEmpty \"\r\t^ self nonEmpty anyOne"},{"name":"collectionInForIncluding","linesOfCode":2,"sourceCode":"collectionInForIncluding\r\t^ self nonEmpty copyWithoutFirst."},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\" return a collection with elements at end and begining equals .\r(others elements of the collection are not equal to those elements)\"\r\t^ collectionWithSameBeginingEnd "},{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotInForOccurrences)"},{"name":"testCompact","linesOfCode":18,"sourceCode":"testCompact\r\t| collection |\r\tcollection := OrderedCollection new.\r\tself assertEmpty: collection.\r\tself assert: collection capacity equals: 10.\r\tcollection compact.\r\tself assert: collection capacity equals: 0.\r\r\tcollection := OrderedCollection new.\r\tcollection add: 1.\r\tcollection compact.\r\tself assert: collection capacity equals: 1.\r\r\tcollection growAtLast.\r\tcollection compact.\r\tself assert: collection capacity equals: 1.\r\r\t\"we do not shrink the start for now\"\r\tcollection growAtFirst.\r\tcollection compact.\r\tself assert: collection capacity equals: 2"},{"name":"testRemoveAt","linesOfCode":8,"sourceCode":"testRemoveAt\r\t\"Allows one to remove an element from a collection at an index\"\r\t\r\t| c1 |\r\tc1 := #(2 3 4 6) asOrderedCollection.\r\tc1 removeAt: 2.\r\tself assert: c1 equals: #(2 4 6) asOrderedCollection.\r\tself should: [ c1 removeAt: 10 ] raise: Error.\r\tself should: [ c1 removeAt: -1 ] raise: Error\r\t"},{"name":"testAddAllFirst","linesOfCode":7,"sourceCode":"testAddAllFirst\r\t\"Allows one to add each element of an OrderedCollection at the beginning of another OrderedCollection \"\r\t\r\t| c1 c2 |\r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc2 := #(5 6 7 8 9) asOrderedCollection.\r\tc2 addAllFirst: c1.\r\tself assert: c2 equals: #(1 2 3 4 5 6 7 8 9) asOrderedCollection"},{"name":"elementToAdd","linesOfCode":2,"sourceCode":"elementToAdd\r\t^ 55"},{"name":"testAddItem2","linesOfCode":7,"sourceCode":"testAddItem2\r\t| collection |\r\tcollection := #('Jim' 'Mary' 'John' 'Andrew') asOrderedCollection.\r\tcollection add: 'James' before: 'Jim'.\r\tcollection add: 'Margaret' before: 'Andrew'.\r\tself assert: (collection indexOf: 'James') + 1 equals: (collection indexOf: 'Jim').\r\tself assert: (collection indexOf: 'Margaret') + 1 equals: (collection indexOf: 'Andrew')"},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t^ 42"},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\" return an element inculded in 'accessCollection '\"\r\t^ self accessCollection anyOne"},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass \r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ OrderedCollection"},{"name":"testCopyFromTo","linesOfCode":10,"sourceCode":"testCopyFromTo\r\t\"Allows one to create a copy of the receiver that contains elements from position start to end\"\r\r\t| c1 c2 c3 |\r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc2 := c1 copyFrom: 1 to: 2.\r\tself assert: c2 equals: #(1 2) asOrderedCollection.\r\tself should: [ c1 copyFrom: 10 to: 20 ] raise: Error.\r\r\tc3 := c1 copyFrom: 4 to: 2.\r\tself assertEmpty: c3.\r\r\tself should: [ c1 copyFrom: 4 to: 5 ] raise: Error"},{"name":"testCapacityFromAsOrderedCollection","linesOfCode":10,"sourceCode":"testCapacityFromAsOrderedCollection\r\t\"Allows one to check the current capacity of an Ordered collection\"\r\t\r\t| c1 c2 c3 |\r\tc1 := #(1 2 ) asOrderedCollection.\r\tself assert: c1 capacity equals: 2.\r\tc2 := OrderedCollection new: 10.\r\tc2 add: 3.\r\tself assert: c2 capacity equals: 10.\t\r\tc3 := OrderedCollection new.\r\tself deny: c3 capacity equals: 0"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ OrderedCollection "},{"name":"firstIndex","linesOfCode":3,"sourceCode":"firstIndex\r\" return an index between 'nonEmpty' bounds that is < to 'second index' \"\r\t^1"},{"name":"testAddBeforeIndex","linesOfCode":16,"sourceCode":"testAddBeforeIndex\r\r\t| coll |\r\tcoll := #(1 2 3 4) asOrderedCollection.\r\tcoll add: 77 beforeIndex: 1.\r\tself assert: coll equals: #(77 1 2 3 4) asOrderedCollection.\r\tcoll add: 88 beforeIndex: 3.\r\tself assert: coll equals: #(77 1 88 2 3 4) asOrderedCollection. \r\tcoll add: 99 beforeIndex: coll size+1.\r\tself assert: coll equals: #(77 1 88 2 3 4 99) asOrderedCollection. \r\tself should:[ coll add: 666 beforeIndex: 0 ] raise: Error.\r\tself should:[ coll add: 666 beforeIndex: coll size+2 ] raise: Error.\r\t\r\t\"Now make room by removing first two and last two elements,\r\tand see if the illegal bounds test still fails\"\r\t(coll first: 2), (coll last: 2) reversed do: [:e | coll remove: e].\r\tself should:[ coll add: 666 beforeIndex: 0 ] raise: Error.\r\tself should:[ coll add: 666 beforeIndex: coll size+2 ] raise: Error"},{"name":"sortedInAscendingOrderCollection","linesOfCode":9,"sourceCode":"sortedInAscendingOrderCollection\r\t\"Return a collection sorted in ascending order\"\r\r\t^ OrderedCollection new\r\t\tadd: 1;\r\t\tadd: 2;\r\t\tadd: 3;\r\t\tadd: 4;\r\t\tadd: 5;\r\t\tyourself"},{"name":"unsortedCollection","linesOfCode":8,"sourceCode":"unsortedCollection\r\t^ OrderedCollection new\r\t\tadd: 3;\r\t\tadd: 1;\r\t\tadd: 20;\r\t\tadd: 4;\r\t\tadd: 2;\r\t\tyourself"},{"name":"collectionWithCharacters","linesOfCode":2,"sourceCode":"collectionWithCharacters\r\t^withCharacters."},{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\" return a collection with more than one element\"\r\t^ withoutEqualElements  ."},{"name":"elementsCopyNonIdenticalWithoutEqualElements","linesOfCode":3,"sourceCode":"elementsCopyNonIdenticalWithoutEqualElements\r\t\" return a collection that does niot incllude equal elements ( classic equality )\"\r\t^ collectionOfString"},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\" return a collection of float including equal elements (classic equality)\"\r\t^ collectionOfFloat , collectionOfFloat"},{"name":"testCopyEmptyOld","linesOfCode":6,"sourceCode":"testCopyEmptyOld\r\t\"Allows one to create a copy of the receiver that contains no elements\"\r\r\t| c1 c2 |\r\tc1 := #(1 2 3 4 ) asOrderedCollection.\r\tc2 := c1 copyEmpty.\r\tself assert: c2 size equals: 0"},{"name":"simpleCollection","linesOfCode":2,"sourceCode":"simpleCollection\r\t^simpleCollection."},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ collectionOfFloat "},{"name":"testAddFirst","linesOfCode":7,"sourceCode":"testAddFirst\r\t| l |\r\tl := #(1 2 3 4) asOrderedCollection.\r\tl addFirst: 88.\r\tself assert: l equals: #(88 1 2 3 4) asOrderedCollection.\r\tl addFirst: 99.\r\tself assert: l equals: #(99 88 1 2 3 4) asOrderedCollection"},{"name":"testBeginsWithAnyOf","linesOfCode":12,"sourceCode":"testBeginsWithAnyOf\r\t\"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants.\"\r\t\r\t| la oc |\r\tla := #(1 2 3 4 5 6).\r\toc := OrderedCollection new.\r\toc add: 1; add: 2; add: 3.\r\t\r\tself assert: (la beginsWithAnyOf: #((17) (1) (42))).\r\tself assert: (la beginsWithAnyOf: #((17) (1 2) (42))).\r\tself assert: (la beginsWithAnyOf: #((17) (1 2 3) (42))).\r\tself deny: (la beginsWithAnyOf: #()).\r\tself deny: (la beginsWithAnyOf: #(())).\r\tself deny: (la beginsWithAnyOf: #((42)))."},{"name":"newElement","linesOfCode":3,"sourceCode":"newElement\r\"return an element that will be put in the collection in place of another\"\r\t^999"},{"name":"testRemoveFirst","linesOfCode":9,"sourceCode":"testRemoveFirst\r\t\"Allows one to remove n element of a collection at the first\"\r\t\r\t| c1 |\r\tc1 := #(2 3 4 6) asOrderedCollection.\r\tc1 removeFirst: 1.\r\tself assert: c1 equals: #(3 4 6) asOrderedCollection.\r\tc1 removeFirst: 2.\r\tself assert: c1 equals: #(6) asOrderedCollection.\r\tself should: [c1 removeFirst: 10] raise: Error\r\t"},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\" return an index between 'collectionWithoutEqualsElements'  bounds\"\r\t^ 2"},{"name":"collectionWithEqualElements","linesOfCode":3,"sourceCode":"collectionWithEqualElements\r\" return a collecition including atLeast two elements equal\"\r\r^collectionWithDuplicateElement "},{"name":"testAddItem1","linesOfCode":7,"sourceCode":"testAddItem1\r\t| collection size |\r\tcollection := #('Jim' 'Mary' 'John' 'Andrew') asOrderedCollection.\r\tsize := collection size.\r\tcollection add: 'James' before: 'Jim'.\r\tcollection add: 'Margaret' before: 'Andrew'.\r\tself assert: size + 2 equals: collection size"},{"name":"collectionOfCollectionsOfInts","linesOfCode":2,"sourceCode":"collectionOfCollectionsOfInts\r\t^collectionOfCollectionsOfInts."},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection  anyOne"},{"name":"testAdd","linesOfCode":7,"sourceCode":"testAdd\r\t| l |\r\tl := #(1 2 3 4) asOrderedCollection.\r\tl add: 88.\r\tself assert: l equals: #(1 2 3 4 88) asOrderedCollection.\r\tl add: 99.\r\tself assert: l equals: #(1 2 3 4 88 99) asOrderedCollection"},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^ 2"},{"name":"elementNotIn","linesOfCode":2,"sourceCode":"elementNotIn\r\t^ elementNotIn "},{"name":"testIdentityIncludes","linesOfCode":8,"sourceCode":"testIdentityIncludes\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\r\t| collection element |\r\tself collectionWithCopyNonIdentical.\r\tcollection := self collectionWithCopyNonIdentical.\r\telement := collection anyOne copy.\t\"self assert: (collection includes: element).\"\r\tself deny: (collection identityIncludes: element)"},{"name":"elementTwiceIn","linesOfCode":2,"sourceCode":"elementTwiceIn\r\t^ super elementTwiceIn"},{"name":"test0FixtureTConvertAsSetForMultiplinessTest","linesOfCode":13,"sourceCode":"test0FixtureTConvertAsSetForMultiplinessTest\r\t\"a collection ofFloat with equal elements:\"\r\r\t| res |\r\tself withEqualElements.\r\tself withEqualElements do: [ :each | self assert: each isFloat ].\r\tres := true.\r\tself withEqualElements detect: [ :each | (self withEqualElements occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself assert: res equals: true.\t\"a collection of Float without equal elements:\"\r\tres := true.\r\tself elementsCopyNonIdenticalWithoutEqualElements\r\t\tdetect: [ :each | (self elementsCopyNonIdenticalWithoutEqualElements occurrencesOf: each) > 1 ]\r\t\tifNone: [ res := false ].\r\tself assert: res equals: false"},{"name":"testEndsWithAnyOf","linesOfCode":12,"sourceCode":"testEndsWithAnyOf\r\t\"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants.\"\r\t\r\t| la oc |\r\tla := #(6 5 4 3 2 1).\r\toc := OrderedCollection new.\r\toc add: 3; add: 2; add: 1.\r\t\r\tself assert: (la endsWithAnyOf: #((17) (1) (42))).\r\tself assert: (la endsWithAnyOf: #((17) (2 1) (42))).\r\tself assert: (la endsWithAnyOf: #((17) (3 2 1) (42))).\r\tself deny: (la endsWithAnyOf: #()).\r\tself deny: (la endsWithAnyOf: #(())).\r\tself deny: (la endsWithAnyOf: #((42)))."},{"name":"testDifferencePreservesOrder","linesOfCode":7,"sourceCode":"testDifferencePreservesOrder\r\t| n even odd odd2 |\r\tn := OrderedCollection with: 5 with: 3 with: 4.\r\teven := OrderedCollection with: 4.\r\todd := n difference: even.\r\todd2 := n reject: [ :i | i even ].\r\tself assert: odd equals: odd2\r\r\t"},{"name":"testAddAfter","linesOfCode":7,"sourceCode":"testAddAfter\r\t| l |\r\tl := #(1 2 3 4) asOrderedCollection.\r\tl add: 88 after: 1.\r\tself assert: l equals: #(1 88 2 3 4) asOrderedCollection.\r\tl add: 99 after: 2.\r\tself assert: l equals: #(1 88 2 99 3 4) asOrderedCollection"},{"name":"testRemoveLast","linesOfCode":9,"sourceCode":"testRemoveLast\r\t\"Allows one to remove n element of a collection at the end\"\r\t\r\t| c1 |\r\tc1 := #(2 3 4 6) asOrderedCollection.\r\tc1 removeLast: 1.\r\tself assert: c1 equals: #(2 3 4) asOrderedCollection.\r\tc1 removeLast: 2.\r\tself assert: c1 equals: #(2) asOrderedCollection.\r\tself should: [ c1 removeLast: 10 ] raise: Error"},{"name":"testIndexOfWithDuplicates","linesOfCode":11,"sourceCode":"testIndexOfWithDuplicates\r\t| collection indices bagOfIndices |\r\tcollection := #('Jim' 'Mary' 'John' 'Andrew' 'Mary' 'John' 'Jim' 'Micheal') asOrderedCollection.\r\tindices := collection collect: [ :item | collection indexOf: item ].\r\tself assert: indices asSet size equals: collection asSet size.\r\tbagOfIndices := indices asBag.\r\tself assert:\r\t\t(indices asSet allSatisfy: [ :index | (bagOfIndices occurrencesOf: index) = (collection occurrencesOf: (collection at: index)) ])\r\r\t\"  indexOf:  returns the index of the first occurrence of an item.\r     For an item with n occurrences, the index of its first occurrence\r     is found  n  times. \""},{"name":"expectedSizeAfterReject","linesOfCode":2,"sourceCode":"expectedSizeAfterReject\r\t^1"},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\r\" return a collection not including equal elements \"\r\t^ withoutEqualElements "},{"name":"testRemoveAllSuchThat","linesOfCode":5,"sourceCode":"testRemoveAllSuchThat\r\t| collection |\r\tcollection := (1 to: 10) asOrderedCollection.\r\tcollection removeAllSuchThat: [ :e | e even ].\r\tself assert: collection equals: (1 to: 10 by: 2) asOrderedCollection"},{"name":"testAsOrderedCollectionReturnsOrderedCollection","linesOfCode":2,"sourceCode":"testAsOrderedCollectionReturnsOrderedCollection\r\tself assert: #(5 4 3) asSortedCollection asOrderedCollection species identicalTo: OrderedCollection"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r\t^ nonEmpty"},{"name":"testRemoveIfAbsent","linesOfCode":12,"sourceCode":"testRemoveIfAbsent\r\t\"Allows one to remove an element from a collection and to copy it in another collection.\"\r\t\"If the element isn't in the first collection, the second collection copy the element after ifAbsent\"\r\t\r\t| c1 c2 |\r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc2 := OrderedCollection new.\r\t\r\tc2 add: (c1 remove: 2 ifAbsent: [6]).\r\tself assert: c1 equals: #(1 3 4) asOrderedCollection.\r\tself assert: c2 equals: #(2) asOrderedCollection.\r\t\r\tc2 add: (c1 remove: 18 ifAbsent: [6]).\r\tself assert: c1 equals: #(1 3 4) asOrderedCollection.\r\tself assert: c2 equals: #(2 6) asOrderedCollection"},{"name":"testAddAll","linesOfCode":8,"sourceCode":"testAddAll\r\t\"Allows one to add each element of an OrderedCollection at the end of another\r\t OrderedCollection\"\r\r\t| c1 c2 |\r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc2 := #(5 6 7 8 9) asOrderedCollection.\r\tc1 addAll: c2.\r\tself assert: c1 equals: #(1 2 3 4 5 6 7 8 9) asOrderedCollection"},{"name":"testAddAllFirstUnlessAlreadyPresent","linesOfCode":12,"sourceCode":"testAddAllFirstUnlessAlreadyPresent\r\t\"Allows one to add each element of an orderedCollection at the beginning of\r\tanother orderedCollection preserving the order but no duplicate element\"\r\r\t| c1 c2 c3 |\r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc2 := #(5 6 7 8 9) asOrderedCollection.\r\tc3 := #(0 1) asOrderedCollection.\r\tc2 addAllFirstUnlessAlreadyPresent: c1.\r\tself assert: c2 equals: #(1 2 3 4 5 6 7 8 9) asOrderedCollection.\r\tc1 addAllFirstUnlessAlreadyPresent: c3.\r\tself deny: c1 equals: #(0 1 1 2 3 4) asOrderedCollection.\r\tself assert: c1 equals: #(0 1 2 3 4) asOrderedCollection"},{"name":"replacementCollectionSameSize","linesOfCode":10,"sourceCode":"replacementCollectionSameSize\r\" return a collection of size (secondIndex - firstIndex + 1)\"\r\r| res |\rres := OrderedCollection new.\r1 to: (self secondIndex - self firstIndex + 1) do:\r\t[\r\t:i |\r\tres add: 99.\r\t].\r\t^res."},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\" return a collection including at leat 4 elements\"\r\t^ indexCollection "},{"name":"collectionWithNonIdentitySameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithNonIdentitySameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals only with classic equality (they are not the same object).\r(others elements of the collection are not equal to those elements)\"\r\t^ collectionWithSameBeginingEnd "},{"name":"testBind","linesOfCode":7,"sourceCode":"testBind\r\t\r\t| aCollection |\r\t\r\taCollection := #(1 2 3).\r\t\r\tself assertCollection: (aCollection bind: [ :first :second :third | { first. second. third } ]) equals: aCollection.\r\t\r\tself assert: (#() bind: [ #blockResult ]) equals: #blockResult .\r\t\r\tself should: [#() bind: [ :arg | #blockResult ]] raise: ArgumentsCountMismatch.\r\tself should: [#(1 2) bind: [ :arg | #blockResult ]] raise: ArgumentsCountMismatch"},{"name":"testRemoveDuplicates","linesOfCode":3,"sourceCode":"testRemoveDuplicates\r\tself assert: #(7 42 7 42 9) asOrderedCollection removeDuplicates equals: #(7 42 9) asOrderedCollection.\r\tself assert: #(1 2 3) asOrderedCollection removeDuplicates equals: #(1 2 3) asOrderedCollection"},{"name":"setUp","linesOfCode":23,"sourceCode":"setUp\r\r\tsuper setUp.\r\tnonEmpty := OrderedCollection new  add: self valuePutIn; add: self elementTwiceIn; add: self elementTwiceIn; yourself.\r\tempty := OrderedCollection new. \r\telementNotIn := 99.\r\tcollectionWith4Elements := OrderedCollection new add: 1; add: -2; add: 3; add: 1; yourself.\r\tindexArray := { 3. 1.}.\r\tindexCollection := OrderedCollection new add: 1; add: 2;add: 3; add: 4; add:5;  yourself.\r\totherCollection := OrderedCollection new add: 1;add: 20; add: 30; yourself.\r\twithoutEqualElements := OrderedCollection new add: 1;add: 20; add: 30; yourself.\r\tcollectResult := OrderedCollection new add: SmallInteger; add: SmallInteger; add: SmallInteger; yourself.\r\tcollectionOfCollectionsOfStrings:= OrderedCollection new add: (OrderedCollection new add: (OrderedCollection new add: 'foo'; yourself); add: (OrderedCollection new add: 'bar'; yourself); yourself); add: 'zorg'; yourself.\r\tsimpleCollection := OrderedCollection new add: 1; add: 8; add: 3; yourself.\r\tcollectionOfCollectionsOfInts := OrderedCollection new add: 1; add: (OrderedCollection new add: 2; add: 3; yourself); add: (OrderedCollection new add: 4; add: (OrderedCollection new add: 5; add: 6; yourself); yourself); yourself.\r\twithCharacters := OrderedCollection new add: $a; add: $x; add: $d; add: $c; add: $m; yourself.\r\temptyButAllocatedWith20 := OrderedCollection new: 20. \r\tcollectionWithElement := OrderedCollection new add: self element; yourself.\r\tcollectionOfFloat := OrderedCollection new add: 4.1; add: 7.2; add: 2.5; yourself.\r\tcollectionOfString := OrderedCollection new add: 'a'; add: 'b'; add: 'c'; yourself.\r\tcollectionWithSameBeginingEnd := OrderedCollection new add: 'a'; add: 'b'; add: 'a' copy ; yourself.\r\tduplicateElement := 2.\r\tcollectionWithDuplicateElement := OrderedCollection new add: duplicateElement ; add: duplicateElement ; add:4 ; yourself.\t\r\r\tcollection5Elements := OrderedCollection new add: 1; add: 2;  add: 3;  add: 4;  add: 5; yourself."},{"name":"oldSubCollection","linesOfCode":4,"sourceCode":"oldSubCollection\r\" return a subCollection included in collectionWith1TimeSubcollection .\rex :   subCollection := #( 2 3 4) and collectionWith1TimeSubcollection := #(1 2 3 4 5)\"\r\t^ nonEmpty "},{"name":"testAddAfterIndex","linesOfCode":16,"sourceCode":"testAddAfterIndex\r\t| coll |\r\tcoll := #(1 2 3 4) asOrderedCollection.\r\tcoll add: 77 afterIndex: 0.\r\tself assert: coll equals: #(77 1 2 3 4) asOrderedCollection.\r\tcoll add: 88 afterIndex: 2.\r\tself assert: coll equals: #(77 1 88 2 3 4) asOrderedCollection. \r\tcoll add: 99 afterIndex: coll size.\r\tself assert: coll equals: #(77 1 88 2 3 4 99) asOrderedCollection. \r\tself should: [ coll add: 666 afterIndex: -1 ] raise: Error.\r\tself should: [ coll add: 666 afterIndex: coll size+1 ] raise: Error.\r\t\r\t\"Now make room by removing first two and last two elements,\r\tand see if the illegal bounds test still fails\"\r\t(coll first: 2), (coll last: 2) reversed do: [:e | coll remove: e].\r\tself should: [ coll add: 666 afterIndex: -1 ] raise: Error.\r\tself should: [ coll add: 666 afterIndex: coll size+1 ] raise: Error"},{"name":"testCollectFromTo","linesOfCode":8,"sourceCode":"testCollectFromTo\r\t\"Allows one to collect some element of a collection into another collection between a first index and an end index for the collect\"\r\t\r\t| c1 res |\r\tc1 := #(-1 2 -3 4 -5 6 -7 8) asOrderedCollection.\r\tres := c1 collect: [:each | each abs] from: 1 to: 3.\r\tself assert: res equals: #(1 2 3) asOrderedCollection.\r\tself should: [c1 collect: [:each | each abs] from: 10 to: 13] raise: Error.\r\tself should: [c1 collect: [:each | each abs] from: 5 to: 2] raise: Error."},{"name":"testCopyReplaceFromToWith","linesOfCode":10,"sourceCode":"testCopyReplaceFromToWith\r\t\"Allows one to create a copy from the receiver which elements between start and end of the receiver being replace by element of the collection after with:\"\r\r\t| c1 c2 c3 c4 |\r\tc1 := #(1 2 3 4) asOrderedCollection.\r\tc2 := #(5 6 7 8 9) asOrderedCollection.\r\tc3 := (c2 copyReplaceFrom: 1 to: 2 with: c1).\r\tself assert: c3 equals: #(1 2 3 4 7 8 9) asOrderedCollection.\r\tself should: [c2 copyReplaceFrom: 3 to: 1 with: c1] raise: Error.\r\t\r\tc4 := (c2 copyReplaceFrom: 10 to: 25 with: c1).\r\tself assert: c4 equals: #(5 6 7 8 9 1 2 3 4) asOrderedCollection"},{"name":"emptyButAllocatedWith20","linesOfCode":2,"sourceCode":"emptyButAllocatedWith20 \r\r\t^ emptyButAllocatedWith20"},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\" return an element included exactly two time in # collectionWithEqualElements\"\r^ duplicateElement "}],"meta":{"name":"OrderedCollectionTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"HeapTest","instanceVariables":[{"name":"collectionWithElement"},{"name":"otherCollection"},{"name":"nonEmpty"},{"name":"empty"},{"name":"elementNotIn"},{"name":"collectResult"},{"name":"expectedElementByDetect"},{"name":"speciesClass"},{"name":"elementTwiceIn"},{"name":"doWithoutNumber"},{"name":"element"},{"name":"expectedSizeAfterReject"},{"name":"collectionNotIncluded"},{"name":"nonEmpty5ElementsWithoutDuplicate"},{"name":"sameAtEndAndBegining"},{"name":"nonEmpty1Element"},{"name":"indexArray"},{"name":"subCollection"},{"name":"duplicateElement"},{"name":"collectionWithDuplicateElement"},{"name":"collectionWith4Elements"},{"name":"stringCollection"}],"methods":[{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\t\" return a collection that don't includes equal elements'\" \r\t^nonEmpty5ElementsWithoutDuplicate ."},{"name":"elementsCopyNonIdenticalWithoutEqualElements","linesOfCode":4,"sourceCode":"elementsCopyNonIdenticalWithoutEqualElements\r\t\" return a collection that does niot incllude equal elements ( classic equality )\r\tall elements included are elements for which copy is not identical to the element  \"\r\t^ stringCollection "},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"testSortBlock","linesOfCode":6,"sourceCode":"testSortBlock\r\r\t| heap |\r\theap := Heap withAll: #(1 3 5).\r\tself assert: heap asArray equals: #(1 3 5).\r\t\r\theap sortBlock: [ :e1 :e2 | e1 >= e2 ].\r\tself assert: heap asArray equals: #(5 3 1)\r"},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\t\" return an element included exactly two time in # collectionWithEqualElements\"\r^ duplicateElement "},{"name":"withEqualElements","linesOfCode":2,"sourceCode":"withEqualElements\r\t^ sameAtEndAndBegining "},{"name":"integerCollectionWithoutEqualElements","linesOfCode":3,"sourceCode":"integerCollectionWithoutEqualElements\r\t\" return a collection of integer without equal elements\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"subCollectionNotIn","linesOfCode":3,"sourceCode":"subCollectionNotIn\r\t\" return a collection for which at least one element is not included in 'moreThan4Elements' \"\r\t^ collectionNotIncluded "},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ stringCollection "},{"name":"collectionWithElementsToRemove","linesOfCode":3,"sourceCode":"collectionWithElementsToRemove\r\t\" return a collection of elements included in 'nonEmpty'  \"\r\t^ self nonEmpty "},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\t\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\t\" return a collection without equal elements \"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"test0FixtureRequirementsOfTGrowableTest","linesOfCode":9,"sourceCode":"test0FixtureRequirementsOfTGrowableTest\r\tself empty.\r\tself nonEmpty.\r\tself element.\r\tself elementNotInForOccurrences.\r\tself assertEmpty: self empty.\r\tself denyEmpty: self nonEmpty.\r\tself assert: (self nonEmpty includes: self element).\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences)"},{"name":"newElement","linesOfCode":3,"sourceCode":"newElement\r\t\"return an element that will be put in the collection in place of another\"\r\t^ elementNotIn "},{"name":"test1","linesOfCode":11,"sourceCode":"test1\r\t| data |\r\r\t\"The first element of each array is the sort value, and the second will be updated by the heap with the index of the element within the heap.\"\r\tdata :=  (1 to: 8) collect: [:i | {i*2. 0}].\r\r\t\"Repeat with different data ordering.\"\r\t5 timesRepeat: [ | h |\r\t\th := Heap new sortBlock: [:e1 :e2 | e1 first < e2 first].\r\t\th indexUpdateBlock: [:array :index | array at: 2 put: index].\r\r\t\tdata shuffled do: [:d | h add: d].\r\t\tdata do: [:d | self should: (h asArray at: d second) == d].\r\t]"},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\t\" return an index between 'collectionWithoutEqualsElements'  bounds\"\r\t^ 2"},{"name":"testAddNonEmptyGrowsWhenNewElement","linesOfCode":6,"sourceCode":"testAddNonEmptyGrowsWhenNewElement\r\t\r\t| oldSize |\r\toldSize := self nonEmpty size.\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself nonEmpty add: self elementNotInForOccurrences.\r\tself assert: self nonEmpty size > oldSize"},{"name":"collectionWithEqualElements","linesOfCode":3,"sourceCode":"collectionWithEqualElements\r\t\" return a collection including atLeast two elements equal\"\r\r\t^ collectionWithDuplicateElement "},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection anyOne"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ elementNotIn"},{"name":"testAdd","linesOfCode":11,"sourceCode":"testAdd\r\t\r\t| heap |\r\theap := Heap new.\r\tself assert: heap size equals: 0.\r\theap add: 3.\r\tself assert: heap size equals: 1.\r\tself deny: heap isEmpty.\r\tself assert: heap first equals: 3.\r\theap add: 2.\r\tself assert: heap size equals: 2.\r\tself assert: heap first equals: 2"},{"name":"collectionWith5Elements","linesOfCode":3,"sourceCode":"collectionWith5Elements\r\t\" return a collection of size 5 including 5 elements\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^ 2"},{"name":"accessCollection","linesOfCode":2,"sourceCode":"accessCollection\r\t^ nonEmpty5ElementsWithoutDuplicate"},{"name":"elementNotIn","linesOfCode":2,"sourceCode":"elementNotIn\r\t^ elementNotIn "},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\t\" return a collection of size 1 including one element\"\r\t^ nonEmpty1Element "},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\t\" return an element not included in 'moreThan4Elements' \"\r\t^ elementNotIn "},{"name":"elementTwiceIn","linesOfCode":2,"sourceCode":"elementTwiceIn\r\t^elementTwiceIn"},{"name":"otherCollection","linesOfCode":2,"sourceCode":"otherCollection\r\t^ otherCollection"},{"name":"result","linesOfCode":2,"sourceCode":"result\r\t^ collectResult."},{"name":"elementInForIndexAccessing","linesOfCode":3,"sourceCode":"elementInForIndexAccessing\r\t\" return an element included in 'collectionMoreThan1NoDuplicates' \"\r\t^ self collectionMoreThan1NoDuplicates anyOne."},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\t^ collectionWith4Elements"},{"name":"elementNotInForIndexAccessing","linesOfCode":3,"sourceCode":"elementNotInForIndexAccessing\r\t\" return an element not included in 'collectionMoreThan1NoDuplicates' \"\r\t^ elementNotIn "},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^ speciesClass"},{"name":"aValue","linesOfCode":3,"sourceCode":"aValue\r\t\" return a value to put into nonEmpty\"\r\t^ self nonEmpty anyOne "},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^empty."},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\t\" return a collection that will be the second part of the concatenation\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"testDo","linesOfCode":6,"sourceCode":"testDo\r\r\t| heap coll |\r\theap := Heap withAll: #(1 3 5).\r\tcoll := OrderedCollection new.\r\t\r\theap do: [:each | coll add: each].\r\t\r\tself assert: coll equals: #(1 3 5) asOrderedCollection"},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\t^nonEmpty "},{"name":"testHeap","linesOfCode":7,"sourceCode":"testHeap\r\t| heap |\r\theap := Heap new.\r\tself assert: heap isHeap.\r\r\tself assertEmpty: heap.\r\theap add: 1.\r\tself denyEmpty: heap"},{"name":"testIfEqualIsTransitive","linesOfCode":9,"sourceCode":"testIfEqualIsTransitive\r\t\"This is http://bugs.squeak.org/view.php?id=6943\"\r\r    | anArray heap1 heap2 |\r    anArray := #(1 2 3).\r    heap1 := Heap withAll: (1 to: 3) sortBlock: [:a :b | a < b].\r    heap2 := Heap withAll: (1 to: 3) sortBlock: [:a :b | b > a].\r    self\r\t\tassert: (heap1 = anArray) & (heap2 = anArray) ==> (heap1 = heap2)\r\t\tdescription: 'Heap equality should be transitive'"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ elementNotIn "},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\r\t\" return a collection not including equal elements \"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ element"},{"name":"expectedSizeAfterReject","linesOfCode":3,"sourceCode":"expectedSizeAfterReject\r\t\"Number of even elements in #collection\"\r\t^ expectedSizeAfterReject."},{"name":"collectionWithElement","linesOfCode":2,"sourceCode":"collectionWithElement\r\t^ collectionWithElement"},{"name":"indexArray","linesOfCode":3,"sourceCode":"indexArray\r\t\" return a Collection including indexes between bounds of 'nonEmpty' \"\r\r\t^ indexArray "},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\t\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\t\" return a collection including at least 5 elements\"\r\t\r\t^nonEmpty5ElementsWithoutDuplicate "},{"name":"sizeCollection","linesOfCode":3,"sourceCode":"sizeCollection\r\t\"Answers a collection whose #size is 4\"\r\t^collectionWith4Elements "},{"name":"testExamples","linesOfCode":3,"sourceCode":"testExamples\r\tHeap heapExample.\r\tHeap heapSortExample"},{"name":"secondIndex","linesOfCode":3,"sourceCode":"secondIndex\r\t\" return an index between 'nonEmpty' bounds that is > to 'second index' \"\r\t^3"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^nonEmpty."},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\t\" return a collection including elements of type 'collectionOfSize5' elements'type\"\r\t^ collectionWith4Elements "},{"name":"testFirst","linesOfCode":9,"sourceCode":"testFirst\r\t| heap | \r\theap := Heap new.\r\theap add: 5.\r\theap add: 12.\r\theap add: 1.\r\tself assert: heap first equals: 1.\r\theap removeFirst.\r\tself assert: heap first equals: 5."},{"name":"valuePutIn","linesOfCode":3,"sourceCode":"valuePutIn\r\t\"the value that we will put in the non empty collection\"\r\t\r\t^ 7"},{"name":"replacementCollectionSameSize","linesOfCode":3,"sourceCode":"replacementCollectionSameSize\r\t\" return a collection of size (secondIndex - firstIndex + 1)\"\r\t^subCollection "},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals .\r(others elements of the collection are not equal to those elements)\"\r\t^ sameAtEndAndBegining "},{"name":"elementToAdd","linesOfCode":3,"sourceCode":"elementToAdd\r\t\" return an element of type 'nonEmpy' elements'type'\"\r\t^ elementNotIn "},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\t\" return a collection including at leat 4 elements\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"collectionWithNonIdentitySameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithNonIdentitySameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals only with classic equality (they are not the same object).\r(others elements of the collection are not equal to those elements)\"\r\t^ sameAtEndAndBegining "},{"name":"anotherElementNotIn","linesOfCode":3,"sourceCode":"anotherElementNotIn\r\t\" return an element different of 'elementNotIn'  not included in 'nonEmpty' \"\r\t^ 9999"},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\t\" return an element inculded in 'moreThan4Elements'\"\r\t^ self moreThan4Elements anyOne."},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ Heap"},{"name":"elementInForOccurrences","linesOfCode":2,"sourceCode":"elementInForOccurrences\r\t^self nonEmpty anyOne"},{"name":"expectedElementByDetect","linesOfCode":3,"sourceCode":"expectedElementByDetect\r\t\"Returns the first even element of #collection\"\r\t^ expectedElementByDetect.\r\t\r\t"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ Heap"},{"name":"testRemove","linesOfCode":9,"sourceCode":"testRemove\r\r\t| heap |\r\theap := Heap new.\r\tself should: [ heap removeFirst ] raise: Error.\r\theap add: 5.\r\theap removeFirst.\r\tself assert: heap size equals: 0.\r\theap add: 5.\r\tself should: [ heap removeAt: 2 ] raise: Error"},{"name":"firstIndex","linesOfCode":3,"sourceCode":"firstIndex\r\t\" return an index between 'nonEmpty' bounds that is < to 'second index' \"\r\t^2"},{"name":"setUp","linesOfCode":52,"sourceCode":"setUp\r\tsuper setUp.\r\telement := 33.\r\telementNotIn := 666.\r\telementTwiceIn := 3.\r\texpectedSizeAfterReject := 1.\r\texpectedElementByDetect := -2.\r\tnonEmpty5ElementsWithoutDuplicate := Heap\r\t\tnew \r\t\tadd: 2;\r\t\tadd: 98;\r\t\tadd: 4;\r\t\tadd: 25;\r\t\tadd: 1;\r\t\tyourself.\r\tcollectionWithElement := Heap new.\r\t{  4. 5. 6. 2. 1. 1. (self element)  } do: [ :nb | collectionWithElement add: nb ].\r\tcollectionWith4Elements := Heap\r\t\tnew\r\t\tadd: 1;\r\t\tadd: -2;\r\t\tadd: 3;\r\t\tadd: 1;\r\t\tyourself.\r\totherCollection := Heap new\r\t\tadd: 1;\r\t\tadd: 20;\r\t\tadd: 30;\r\t\tyourself.\r\tempty := Heap new.\r\tnonEmpty := Heap\r\t\tnew\r\t\tadd: self valuePutIn;\r\t\tadd: self element;\r\t\tadd: self elementTwiceIn;\r\t\tadd: self elementTwiceIn;\r\t\tyourself.\r\tcollectionNotIncluded := Heap new\r\t\tadd: elementNotIn;\r\t\tadd: elementNotIn;\r\t\tyourself.\r\tdoWithoutNumber := 3.\r\tcollectResult := collectionWith4Elements collect: [ :each | each + 1 ].\r\tspeciesClass := Heap.\r\tsameAtEndAndBegining := Heap new add: 1.5 ;  add: 1.5 copy ; yourself.\r\tnonEmpty1Element := Heap new add: 5 ; yourself.\r\tstringCollection := Heap new add: 'a' ; add: 'b' ; add: 'c' ; yourself.\r\tindexArray := #( 1 3).\r\tsubCollection := Heap new.\r\tduplicateElement := 1.\r\tcollectionWithDuplicateElement := Heap new add: duplicateElement ; add: duplicateElement ; add:4 ; yourself.\r\tself firstIndex to: self secondIndex do: [:each | subCollection add: elementNotIn  ].\t\t\r"},{"name":"collectionOfSize5","linesOfCode":3,"sourceCode":"collectionOfSize5\r\t\" return a collection of size 5\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size > 1 without equal elements\"\r\t^ nonEmpty5ElementsWithoutDuplicate "},{"name":"collectionNotIncluded","linesOfCode":3,"sourceCode":"collectionNotIncluded\r\t\" return a collection for wich each element is not included in 'nonEmpty' \"\r\t^ collectionNotIncluded "}],"meta":{"name":"HeapTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SortedCollectionTest","instanceVariables":[{"name":"nonEmpty"},{"name":"elementExistsTwice"},{"name":"empty"},{"name":"collectResult"},{"name":"nonEmpty1Element"},{"name":"collectionOfFloat"},{"name":"accessCollection"},{"name":"elementNoteIn"},{"name":"oldSubcollection"},{"name":"withoutEqualElements"},{"name":"collectionOfFloatWithDuplicate"},{"name":"collectionIncluded"},{"name":"collectionNotIncluded"},{"name":"collectionWithoutNil"},{"name":"duplicateFloat"},{"name":"nonEmpty5Elements"},{"name":"collectionWith4Elements"},{"name":"collectionOfString"},{"name":"stringCollectionSameEndAndBegining"}],"methods":[{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\t\"Return a collection of integer with more than one element\"\r\t\r\t^withoutEqualElements"},{"name":"elementsCopyNonIdenticalWithoutEqualElements","linesOfCode":3,"sourceCode":"elementsCopyNonIdenticalWithoutEqualElements\r\t\"Return a collection that does niot incllude equal elements ( classic equality )\"\r\t\r\t^ collectionOfString"},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\"Return a collection including atLeast 3 elements.\"\r\t\r\t^ accessCollection "},{"name":"testSortBlock","linesOfCode":17,"sourceCode":"testSortBlock\r\t\t\r\t|aSortedCollection|\r\taSortedCollection := SortedCollection new.\r\taSortedCollection sortBlock: [:a :b | a < b].\r\taSortedCollection \r\t\tadd: 'truite'; \r\t\tadd: 'brochet'; \r\t\tadd: 'tortue'.\r\tself assert: aSortedCollection first equals: 'brochet'.\r\t\r\taSortedCollection := SortedCollection new.\r\taSortedCollection sortBlock: [:a :b | a >b].\r\taSortedCollection \r\t\tadd: 'truite'; \r\t\tadd: 'brochet';\r\t\tadd: 'tortue'.\r\tself assert: aSortedCollection first equals: 'truite'.\r\t\r\t\r\t"},{"name":"testCopy","linesOfCode":14,"sourceCode":"testCopy\r\t\t\r\t|aSortedCollection copySorted|\r\taSortedCollection := SortedCollection new.\r\taSortedCollection sortBlock: [:a :b | a < b].\r\taSortedCollection \r\t\tadd: 'truite'; \r\t\tadd: 'brochet'.\r\tself assert: aSortedCollection first equals: 'brochet'.\r\t\r\tcopySorted := aSortedCollection copy.\r\t\r\tself assert: (copySorted  hasEqualElements: aSortedCollection).\r\tself assert: copySorted species equals: aSortedCollection species.\r\tself assert: copySorted sortBlock equals: aSortedCollection sortBlock.\r\tself assert: copySorted first equals: 'brochet'"},{"name":"testIdentityIndexOfIAbsent","linesOfCode":10,"sourceCode":"testIdentityIndexOfIAbsent\r\r\t| collection element |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection \r\t\t\tidentityIndexOf: element\r\t\t\tifAbsent: [ 0 ]) equals: 1.\r\tself assert: (collection \r\t\t\tidentityIndexOf: self elementNotInForIndexAccessing\r\t\t\tifAbsent: [ 55 ]) equals: 55"},{"name":"testCreation","linesOfCode":5,"sourceCode":"testCreation\r\t\t\r\t| collection |\r\tcollection := #(10 9 3 6 1 8 7 5 4 2) asSortedCollection.\r\tself assert: collection equals: (1 to: 10) asSortedCollection\r\t"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":3,"sourceCode":"integerCollectionWithoutEqualElements\r\t\"Return a collection of integer without equal elements.\"\r\t\r\t^ withoutEqualElements "},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\"Return a collection of float including equal elements (classic equality).\"\r\t\r\t^ collectionOfFloatWithDuplicate"},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\t\"Return an element included exactly two time in # collectionWithEqualElements.\"\r\t\r\t^ duplicateFloat "},{"name":"subCollectionNotIn","linesOfCode":3,"sourceCode":"subCollectionNotIn\r\t\"Return a collection for which at least one element is not included in 'accessCollection'.\"\r\t\r\t^ SortedCollection new add: elementNoteIn ; add: elementNoteIn ; yourself."},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\"Return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t\r\t^ collectionOfString"},{"name":"collectionWithElementsToRemove","linesOfCode":3,"sourceCode":"collectionWithElementsToRemove\r\t\"Return a collection of elements included in 'nonEmpty'.\"\r\r\t^ collectionIncluded "},{"name":"testIndexOfIfAbsent","linesOfCode":9,"sourceCode":"testIndexOfIfAbsent\r\t\r\t| collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\tself assert: (collection \r\t\t\tindexOf: collection first\r\t\t\tifAbsent: [ 33 ]) equals: 1.\r\tself assert: (collection \r\t\t\tindexOf: self elementNotInForIndexAccessing\r\t\t\tifAbsent: [ 33 ]) equals: 33"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\t\"Return a collection elements that can be sorted ( understanding message ' < '  or ' > ')\"\r\t\r\t^ collectionOfString "},{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\t\"Return a collection without equal elements.\"\r\t\r\t^ withoutEqualElements "},{"name":"testCollect","linesOfCode":12,"sourceCode":"testCollect\r\t\r\t|result aSortedCollection|\r\taSortedCollection := SortedCollection new.\r\tresult := OrderedCollection new.\r\tresult \r\t\tadd: true; \r\t\tadd: true; \r\t\tadd: true;\r\t\tadd: false; \r\t\tadd: false.\r\t\r\taSortedCollection := (1 to: 5) asSortedCollection.\r\tself assert: result equals: (aSortedCollection collect: [:each | each < 4])\r\t"},{"name":"testEquals","linesOfCode":8,"sourceCode":"testEquals\r\t\t\r\t|aSortedCollection|\r\taSortedCollection := SortedCollection new.\r\taSortedCollection \r\t\tadd: 'truite'; \r\t\tadd: 'brochet'.\r\tself assert: aSortedCollection copy equals: aSortedCollection"},{"name":"testIndexOf","linesOfCode":9,"sourceCode":"testIndexOf\r\t\r\t| tmp index collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\ttmp := collection size.\r\tcollection reverseDo: \r\t\t[ :each | \r\t\teach = self elementInForIndexAccessing ifTrue: [ index := tmp ].\r\t\ttmp := tmp - 1 ].\r\tself assert: (collection indexOf: self elementInForIndexAccessing) equals: index"},{"name":"testMedianForEvenSizeCollection","linesOfCode":4,"sourceCode":"testMedianForEvenSizeCollection\r\t\r\t|aSortedCollection|\r\taSortedCollection := {1 .2 . 3 . 4 . 5 . 6 } asSortedCollection.\r\tself assert: aSortedCollection median equals: 3.5\r\t\r\t"},{"name":"testMedianForOddSizeCollection","linesOfCode":10,"sourceCode":"testMedianForOddSizeCollection\r\t\r\t|aSortedCollection|\r\taSortedCollection := {1 .2 . 3 . 4 . 5 . 6 .7} asSortedCollection.\r\tself assert: aSortedCollection median equals: 4.\r\t\r\taSortedCollection := SortedCollection new.\r\taSortedCollection \r\t\tadd: 'truite'; \r\t\tadd: 'porcinet'; \r\t\tadd: 'carpe'.\r\r\tself assert: aSortedCollection median equals: 'porcinet'\r\t"},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\t\"Return an index between 'collectionWithoutEqualsElements' bounds.\"\r\t\r\t^ 2"},{"name":"testIntersection","linesOfCode":8,"sourceCode":"testIntersection\r\t| sortedCollection anotherCollection intersection |\r\tsortedCollection := { Number . Object . Collection } asSortedCollection: [ :a :b | a name > b name ].\r\tanotherCollection := { Number . Object }.\r\r\tintersection := sortedCollection intersection: anotherCollection.\r\t\r\tself assert: (intersection isKindOf: SortedCollection).\r\tself deny: intersection sortBlock isNil.\r\tself assert: intersection asArray equals: { Object . Number }."},{"name":"collectionWithEqualElements","linesOfCode":3,"sourceCode":"collectionWithEqualElements\r\t\"Return a collection including atLeast two elements equal.\"\r\r\t^ collectionOfFloatWithDuplicate "},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\"Return an element (or an association for Dictionary ) present  in 'collection' \"\r\r\t^ self collection anyOne"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\r\t^ 666"},{"name":"testAdd","linesOfCode":13,"sourceCode":"testAdd\r\t\t\r\t| collection |\r\tcollection := #(10 9 8 7 5 4 4 2) asSortedCollection.\r\tself assert: collection first equals: 2.\r\tself assert: collection last equals: 10.\r\tself assert: collection size equals: 8.\r\tcollection add:1.\r\tself assert: collection size equals: 9.\r\tcollection add: 6.\r\tself assert: (collection at: 5) equals: 5.\r\tself assert: collection size equals: 10.\r\tcollection add: 3\r\t"},{"name":"collectionWith5Elements","linesOfCode":3,"sourceCode":"collectionWith5Elements\r\t\"Return a collection of size 5 including 5 elements\"\r\t\r\t^ accessCollection "},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^ 2"},{"name":"testFlatCollect","linesOfCode":2,"sourceCode":"testFlatCollect\r\r\tself assert: (#(1 2) asSortedCollection flatCollect: [ :x | { x } ]) equals: #(1 2) asOrderedCollection"},{"name":"testIndexOfSubCollectionStartingAt","linesOfCode":13,"sourceCode":"testIndexOfSubCollectionStartingAt\r\t \r\t| subcollection index collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\tsubcollection := self collectionMoreThan1NoDuplicates.\r\tindex := collection \r\t\tindexOfSubCollection: subcollection\r\t\tstartingAt: 1.\r\tself assert: index equals: 1.\r\tindex := collection \r\t\tindexOfSubCollection: subcollection\r\t\tstartingAt: 2.\r\tself assert: index equals: 0"},{"name":"testIndexOfSubCollectionStartingAtIfAbsent","linesOfCode":17,"sourceCode":"testIndexOfSubCollectionStartingAtIfAbsent\r\t \r\t| absent subcollection collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\tsubcollection := self collectionMoreThan1NoDuplicates.\r\tabsent := false.\r\tcollection \r\t\tindexOfSubCollection: subcollection\r\t\tstartingAt: 1\r\t\tifAbsent: [ absent := true ].\r\tself assert: absent equals: false.\r\tabsent := false.\r\tcollection \r\t\tindexOfSubCollection: subcollection\r\t\tstartingAt: 2\r\t\tifAbsent: [ absent := true ].\r\tself assert: absent equals: true"},{"name":"accessCollection","linesOfCode":3,"sourceCode":"accessCollection\r\t\"Return a collection of size 5\"\r\t\r\t^accessCollection "},{"name":"collectionWith2TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith2TimeSubcollection\r\t\"Return a collection including 'oldSubCollection' two or many time.\"\r\t\r\t^ (SortedCollection  new add: elementNoteIn ; yourself) , self oldSubCollection , self oldSubCollection  "},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\t\"Return an element not included in 'nonEmpty' \"\r\r\t^ elementNoteIn "},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\t\"Return a collection of size 1 including one element.\"\r\t\r\t^ nonEmpty1Element "},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\t\"Return an element not included in 'accessCollection' \"\r\t\r\t^ elementNoteIn "},{"name":"otherCollection","linesOfCode":7,"sourceCode":"otherCollection\r\t\"Returns a collection that does not include what is returned by #element.\"\r\t\r\t ^ SortedCollection new \r\t\t\tadd: 7; \r\t\t\tadd: 5; \r\t\t\tadd: 2; \r\t\t\tyourself"},{"name":"result","linesOfCode":2,"sourceCode":"result\r\r\t ^ collectResult"},{"name":"test0FixtureTConvertAsSetForMultiplinessTest","linesOfCode":13,"sourceCode":"test0FixtureTConvertAsSetForMultiplinessTest\r\t\"A collection ofFloat with equal elements:\"\r\r\t| res |\r\tself withEqualElements.\r\tself withEqualElements do: [ :each | self assert: each isFloat ].\r\tres := true.\r\tself withEqualElements detect: [ :each | (self withEqualElements occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself assert: res.\t\"a collection of Float without equal elements:\"\r\tres := true.\r\tself elementsCopyNonIdenticalWithoutEqualElements\r\t\tdetect: [ :each | (self elementsCopyNonIdenticalWithoutEqualElements occurrencesOf: each) > 1 ]\r\t\tifNone: [ res := false ].\r\tself assert: res equals: false"},{"name":"elementInForIndexAccessing","linesOfCode":3,"sourceCode":"elementInForIndexAccessing\r\t\"Return an element included in 'accessCollection' \"\r\t\r\t^ self collectionMoreThan1NoDuplicates  anyOne"},{"name":"testIdentityIncludes","linesOfCode":8,"sourceCode":"testIdentityIncludes\r\t\"Test the comportement in presence of elements 'includes' but not 'identityIncludes'.\"\r\r\t\"Can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\r\t| collection element |\r\tself collectionWithCopyNonIdentical.\r\tcollection := self collectionWithCopyNonIdentical.\r\telement := collection anyOne copy.\t\"self assert: (collection includes: element).\"\r\tself deny: (collection identityIncludes: element)"},{"name":"testLastIndexOf","linesOfCode":6,"sourceCode":"testLastIndexOf\r\t\r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection lastIndexOf: element) equals: 1.\r\tself assert: (collection lastIndexOf: self elementNotInForIndexAccessing) equals: 0"},{"name":"testSort","linesOfCode":17,"sourceCode":"testSort\r\t| s |\r \ts := SortedCollection withAll: #(3 2 1).\r \tself assert: s asArray equals: #(1 2 3).\r \ts sort: [:a :b | a >=b]. \r \tself assert: s asArray equals: #(3 2 1).\r \ts add: 4.\r \tself assert: s asArray equals: #(4 3 2 1).\r \ts := SortedCollection new \r \t\tsortBlock: [:a :b | a >=b];\r \t\taddAll: #(1 2 3);\r \t\tyourself.\r \tself assert: s asArray equals: #(3 2 1).\r \ts sort.\r \tself assert: s asArray equals: #(1 2 3).\r \ts add: 0.\r \tself assert: s asArray equals: #(0 1 2 3)"},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\r\t^ collectionWith4Elements"},{"name":"elementNotInForIndexAccessing","linesOfCode":3,"sourceCode":"elementNotInForIndexAccessing\r\t\"Return an element not included in 'accessCollection' \"\r\t\r\t^ elementNoteIn  \t"},{"name":"testLastIndexOfStartingAt","linesOfCode":16,"sourceCode":"testLastIndexOfStartingAt\r\r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection last.\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tstartingAt: collection size\r\t\t\tifAbsent: [ 99 ]) equals: collection size.\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tstartingAt: collection size - 1\r\t\t\tifAbsent: [ 99 ]) equals: 99.\r\tself assert: (collection \r\t\t\tlastIndexOf: self elementNotInForIndexAccessing\r\t\t\tstartingAt: collection size\r\t\t\tifAbsent: [ 99 ]) equals: 99"},{"name":"testRemoveAll","linesOfCode":11,"sourceCode":"testRemoveAll\r\t\"Allows one to remove all elements of a collection\" \r\t\r\t| c1 c2 s2 |\r\tc1 := #(10 9 8 7 5 4 4 2) asSortedCollection: [:a :b | a >= b].\r\tc2 := c1 copy.\r\ts2 := c2 size.\r\t\r\tc1 removeAll.\r\t\r\tself assert: c1 size equals: 0.\r\tself assert: c2 size = s2 description: 'the copy has not been modified'.\r\t\r\tc1 add: 13; add: 14.\r\tself assert: (c1 first = 14 and: [c1 second = 13]) description: 'the sortBlock has been preserved'"},{"name":"elementInCollectionOfFloat","linesOfCode":3,"sourceCode":"elementInCollectionOfFloat\r\t\"Return an element included in 'collectionOfFloat'\"\r\t\r\t^ collectionOfFloat anyOne"},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^ SortedCollection"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r\t^ empty"},{"name":"testSpeciesLooseSortBlock","linesOfCode":16,"sourceCode":"testSpeciesLooseSortBlock\r\t\"This is a non regression test for http://bugs.squeak.org/view.php?id=6535\"\r\r\t| numbers reverseOrder firstThree |\r\tnumbers := #(1 2 3 4 5).\r\treverseOrder := SortedCollection sortBlock: [:x :y | x > y].\r\treverseOrder addAll: numbers.\r\r\t\"The elements are inverted\"\r\tself assert: reverseOrder asArray equals: #(5 4 3 2 1).\r\r\t\"Copy the first 3 elements\"\r\tfirstThree := reverseOrder copyFrom: 1 to: 3.\r\r\t\"It appears to work\"\r\tself assert: firstThree asArray equals: #(5 4 3).\r\r\t\"but we have lost the sort block\"\r\tfirstThree add: 1.\r\r\t\" firstThree is now #(1 5 4 3)! \"\r\tself assert: firstThree asArray equals: #(5 4 3 1) \"fails\""},{"name":"testSortUsing","linesOfCode":6,"sourceCode":"testSortUsing\r\t| aSortedCollection |\r\taSortedCollection := (SortedCollection sortUsing: #yourself ascending)\r\t\taddAll: #(2 6 3 8 4 3 7 6);\r\t\tyourself.\r\tself assert: aSortedCollection asArray equals: #(2 3 3 4 6 6 7 8)"},{"name":"integerCollection","linesOfCode":3,"sourceCode":"integerCollection\r\t\"Return a collection only including SmallInteger elements.\"\r\t\r\t^ accessCollection "},{"name":"testIndexOfStartingAt","linesOfCode":17,"sourceCode":"testIndexOfStartingAt\r\t \r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 2\r\t\t\tifAbsent: [ 99 ]) equals: 99.\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 1\r\t\t\tifAbsent: [ 99 ]) equals: 1.\r\tself assert: (collection \r\t\t\tindexOf: self elementNotInForIndexAccessing\r\t\t\tstartingAt: 1\r\t\t\tifAbsent: [ 99 ]) equals: 99"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\"Return an element (or an association for Dictionary )not present  in 'collection' \"\r\r\t^ elementNoteIn "},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\t\"Return a collection not including equal elements.\"\r\t\r\t^withoutEqualElements "},{"name":"element","linesOfCode":3,"sourceCode":"element\r\t\"Returns an object that can be added to the collection returned by #collection.\"\r\t\r\t^ 88"},{"name":"expectedSizeAfterReject","linesOfCode":2,"sourceCode":"expectedSizeAfterReject\r\r\t^ 1"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\t\"Returns a collection that already includes what is returned by #element.\"\r\t\r\t^ SortedCollection new add: self element ; add: 5 ; add: 2; yourself."},{"name":"sizeCollection","linesOfCode":2,"sourceCode":"sizeCollection\r\r\t^ collectionWith4Elements "},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\t\"Return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t\r\t^ collectionWithoutNil  "},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\t\"Return a collection including at least 5 elements\"\r\t\r\t^ nonEmpty5Elements "},{"name":"testAddAll2","linesOfCode":10,"sourceCode":"testAddAll2\r\t\r\t| sorted2 sorted|\r\tsorted2 := SortedCollection new.\r\tsorted2 add: 'brochet'; add:'truitelle'.\r\tsorted := SortedCollection new.\r\tsorted add: 'perche'.\r\tsorted addAll: sorted2.\r\tself assert: sorted size equals: (sorted2 size + 1).\r\tsorted2 do: [ :each | self assert: (sorted includes: each)]\r\t "},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r\t^ nonEmpty"},{"name":"replacementCollection","linesOfCode":4,"sourceCode":"replacementCollection\r\t\"Return a collection that will be used to replace 'oldSubcollection' in ' collectionWith1TimeSubcollection' \"\r\t \r\t^ collectionWith4Elements  "},{"name":"testAddAll","linesOfCode":10,"sourceCode":"testAddAll\r\r\t| sorted2 sorted|\r\tsorted2 := SortedCollection new.\r\tsorted2 \r\t\tadd: 'brochet'; \r\t\tadd: 'truitelle'.\r\tsorted := SortedCollection new.\r\tsorted addAll: sorted2.\r\tself assert: (sorted hasEqualElements: sorted2)\r\t "},{"name":"testComma","linesOfCode":8,"sourceCode":"testComma\r\t| sortBlock collOne collTwo combined |\r\tsortBlock := [ :a :b | a > b ].\r\tcollOne := (1 to: 5) asSortedCollection: sortBlock.\r\tcollTwo := (6 to: 10) asSortedCollection: sortBlock.\r\tcombined := collOne , collTwo.\r\tself assert: combined sortBlock equals: sortBlock.\r\tself assert: combined asArray equals: (1 to: 10) asArray reverse"},{"name":"collectionWith1TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith1TimeSubcollection\r\t\"Return a collection including 'oldSubCollection' only one time.\"\r\t\r\t^ (SortedCollection new add: elementNoteIn ; yourself) , self oldSubCollection "},{"name":"elementInForIncludesTest","linesOfCode":3,"sourceCode":"elementInForIncludesTest\r\t\"Return an element included in nonEmpty.\"\r\t\r\t^ nonEmpty anyOne "},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":3,"sourceCode":"collectionWithSameAtEndAndBegining\r\t\"Return a collection with elements at end and begining equals (others elements of the collection are not equal to those elements)\"\r\t\r\t^ stringCollectionSameEndAndBegining "},{"name":"testDo2","linesOfCode":5,"sourceCode":"testDo2\r\r\t| res |\r\tres := self speciesClass sortBlock: [:a :b | a name < b name]..  \r\tself collection do: [:each | res add: each class].\r\tself assert: res asArray equals: self result asArray\r"},{"name":"testIdentityIndexOf","linesOfCode":5,"sourceCode":"testIdentityIndexOf\r\t\r\t| collection element |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection identityIndexOf: element) equals: (collection indexOf: element)"},{"name":"testMedianWithNumbers","linesOfCode":4,"sourceCode":"testMedianWithNumbers\r\r\t| aSortedCollection |\r\taSortedCollection := (1 to: 10) asSortedCollection.\r \tself assert: aSortedCollection median equals: 5.5"},{"name":"elementToAdd","linesOfCode":3,"sourceCode":"elementToAdd\r\t\"Return an element of type 'nonEmpy' elements'type'\"\r\t\r\t^ 5"},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\t\"Return a collection including at leat 4 elements\"\r\t\r\t^ accessCollection "},{"name":"collectionWithNonIdentitySameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithNonIdentitySameAtEndAndBegining\r\t\"Return a collection with elements at end and begining equals only with classic equality (they are not the same object).\r(others elements of the collection are not equal to those elements)\"\r\r\t^ stringCollectionSameEndAndBegining "},{"name":"anotherElementNotIn","linesOfCode":3,"sourceCode":"anotherElementNotIn\r\t\"Return an element different of 'elementNotIn'  not included in 'nonEmpty' \"\r\t\r\t^666"},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\t\"Return an element inculded in 'accessCollection '\"\r\t\r\t^ self accessCollection anyOne"},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ SortedCollection"},{"name":"oldSubCollection","linesOfCode":4,"sourceCode":"oldSubCollection\r\t\"Return a subCollection included in collectionWith1TimeSubcollection.\r\t Example:   subCollection := #( 2 3 4) and collectionWith1TimeSubcollection := #(1 2 3 4 5)\"\r\r\t^ oldSubcollection "},{"name":"setUp","linesOfCode":32,"sourceCode":"setUp\r\r\tsuper setUp.\r\tnonEmpty := SortedCollection new.\r\telementExistsTwice := 12332312321.\r\tnonEmpty add: 2.\r\tnonEmpty add: elementExistsTwice.\r\tnonEmpty add: elementExistsTwice.\r\tcollectionIncluded := SortedCollection new add: 2; add: elementExistsTwice ;yourself.\r\tcollectionNotIncluded := SortedCollection new add: 312; add: 313 ;yourself.\r\tempty := SortedCollection  new. \r\tcollectionWith4Elements := SortedCollection new.\r\tcollectionWith4Elements add: 1.\r\tcollectionWith4Elements add: -2.\r\tcollectionWith4Elements add: 3.\r\tcollectionWith4Elements add: 1.\r\tcollectionWithoutNil := SortedCollection new add: 1;add: 2 ;add:4 ;add:5;yourself.\r\tcollectResult := OrderedCollection new. \"SortedCollection sortBlock: [:a :b | a name < b name].\"\r\tcollectResult add: SmallInteger.\r\tcollectResult add: SmallInteger.\r\tcollectResult add: SmallInteger.\r\tcollectResult add: SmallInteger.\r\tnonEmpty1Element := SortedCollection new add:5; yourself.\r\tcollectionOfFloat := SortedCollection new add:1.2 ; add: 5.6 ; add:4.4 ; add: 1.9 ; yourself.\r\tcollectionOfString := SortedCollection new add: 'a' ; add: 'b' ; add: 'c' ; add: 'd' ; yourself.\r\tduplicateFloat := 1.2.\r\tcollectionOfFloatWithDuplicate := SortedCollection new add: duplicateFloat  ; add: 5.6 ; add:4.4 ; add: duplicateFloat  ; yourself.\r\taccessCollection := SortedCollection new add:1 ; add: 5 ; add:4 ; add: 2 ; add:7 ; yourself.\r\telementNoteIn := 999.\r\toldSubcollection := SortedCollection new add: 2 ; add: 2 ; add: 2 ; yourself.\r\tstringCollectionSameEndAndBegining := SortedCollection new add: 'a' ; add: 'a' copy ; yourself.\r\twithoutEqualElements := SortedCollection new add: 1 ; add: 8 copy ; add: 4;yourself.\r\tnonEmpty5Elements := SortedCollection new add: 1 ; add: 8 copy ; add: 4; add: 4; add: 4;yourself."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ SortedCollection"},{"name":"collectionOfSize5","linesOfCode":3,"sourceCode":"collectionOfSize5\r\t\"Return a collection of size 5\"\r\t\r\t^ accessCollection "},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\"Return a collection of size 5 without equal elements\"\r\t\r\t^ withoutEqualElements "},{"name":"testGroupedBySortedCollection","linesOfCode":7,"sourceCode":"testGroupedBySortedCollection\r\t| collection grouped |\r\tcollection := Object methods asSortedCollection: #selector ascending.\r\t\r\tgrouped := collection groupedBy: #methodClass.\r\t\r\t\"do we retain the sortblock?\"\r\tself assert: grouped values first class equals: SortedCollection.\r\tself assert: collection sortBlock equals: grouped values first sortBlock.\r\t\r\t"},{"name":"collectionNotIncluded","linesOfCode":3,"sourceCode":"collectionNotIncluded\r\t\"Return a collection for wich each element is not included in 'nonEmpty' \"\r\t\r\t^ collectionNotIncluded "}],"meta":{"name":"SortedCollectionTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SharedQueueTest","instanceVariables":[],"methods":[{"name":"testContention1","linesOfCode":14,"sourceCode":"testContention1\r\r\t| q r1 r2 |\r\tq := SharedQueue new.\r\tq nextPut: 5.\r\tq nextPut: 10.\r\tself should: [ q nextOrNil = 5 ].\r\t[ r1 := q next ] fork.\r\t[ r2 := q next ] fork.\r\tProcessor yield.\t\"let the above two threads block\"\r\tq nextPut: 10.\r\tProcessor yield.\r\tself should: [ r1 = 10 ].\r\tself should: [ r2 = 10 ].\r\tself should: [ q nextOrNil isNil ]"},{"name":"testNextOrNilSuchThat","linesOfCode":9,"sourceCode":"testNextOrNilSuchThat\r\t| q item |\r\tq := SharedQueue new.\r\tq nextPut: 5.\r\tq nextPut: 6.\r\titem := q findFirst: [ :x | x even ].\r\tself should: [ item = 6 ].\r\tself should: [ q nextOrNil = 5 ].\r\tself should: [ q nextOrNil isNil ]"},{"name":"testBasics","linesOfCode":10,"sourceCode":"testBasics\r\t| q |\r\tq := SharedQueue new.\r\tself should: [ q nextOrNil isNil ].\r\tself assert: q atEnd.\r\tq nextPut: 5.\r\tself assertCollection: q contents hasSameElements: #(5).\r\tself should: [ q nextOrNil = 5 ].\r\tself should: [ q nextOrNil isNil ].\r\tself assert: q atEnd."}],"meta":{"name":"SharedQueueTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"LinkedListTest","instanceVariables":[{"name":"nextLink"},{"name":"n"},{"name":"list"},{"name":"link1"},{"name":"link2"},{"name":"link3"},{"name":"link4"},{"name":"nonEmpty"},{"name":"otherList"},{"name":"link"},{"name":"collectionWithoutNil"},{"name":"nonEmpty1Element"},{"name":"collectionWithoutEqualElements"},{"name":"elementNotIn"},{"name":"elementIn"},{"name":"collection5Elements"},{"name":"collectResult"},{"name":"unsortedCollection"},{"name":"sortedCollection"}],"methods":[{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\" return a collection that don't includes equl elements'\" \r\t^collectionWithoutNil "},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\t^ collectionWithoutEqualElements "},{"name":"test10removeFirst","linesOfCode":24,"sourceCode":"test10removeFirst\r\tlist add: link1.\r\tlist add: link2.\r\tlist add: link3.\r\tlist add: link4.\r\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link3.\r\tself assert: list fourth identicalTo: link4.\r\r\tlist removeFirst.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link2.\r\tself assert: list second identicalTo: link3.\r\tself assert: list third identicalTo: link4.\r\r\tlist removeFirst.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link3.\r\tself assert: list second identicalTo: link4.\r\r\tlist removeFirst.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link4.\r\r\tlist removeFirst.\r\tself assertEmpty: list"},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size 5 without equal elements\"\r\t^ collectionWithoutEqualElements"},{"name":"nextLink:","linesOfCode":2,"sourceCode":"nextLink: aLink\r\tnextLink := aLink"},{"name":"testAddAfterLast2","linesOfCode":15,"sourceCode":"testAddAfterLast2\r\t\"LinkedListTest new testAddAfterLast2\"\r\r\t| l first second third fourth |\r\tl := LinkedList new.\r\tfirst := self class new n: 1.\r\tsecond := self class new n: 2.\r\tthird := self class new n: 3.\r\tfourth := self class new n: 4.\r\tl addLast: first.\r\tl addLast: second.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2).\r\tl add: third after: second.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2 3).\r\tl addLast: fourth.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2 3 4)"},{"name":"testSwapAdjacentEnd","linesOfCode":7,"sourceCode":"testSwapAdjacentEnd\r\t|aList|\r\taList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.\r\t\r\taList swap: 4 with: 5.\r\tself assert: (aList at: 4) equals: 1.\r\tself assert: (aList at: 5) equals: 2.\r\tself assert: aList last equals: 2."},{"name":"tearDown","linesOfCode":10,"sourceCode":"tearDown\r\tlist := nil.\r\tlink1 := nil.\r\tlink2 := nil.\r\tlink3 := nil.\r\tlink4 := nil.\r\t\r\tlink := nil.\r\tnonEmpty := nil.\r\totherList := nil.\r\t\r\tsuper tearDown"},{"name":"test03addFirst","linesOfCode":20,"sourceCode":"test03addFirst\r\tself assertEmpty: list.\r\r\tlist addFirst: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first equals: link1.\r\r\tlist addFirst: link2.\r\tself assert: list size equals: 2.\r\tself assert: list first equals: link2.\r\tself assert: list second equals: link1.\r\r\tlist addFirst: link3.\r\tself assert: list size equals: 3.\r\tself assert: list first equals: link3.\r\tself assert: list second equals: link2.\r\tself assert: list third equals: link1.\r\r\tlist addFirst: link4.\r\tself assert: list size equals: 4.\r\tself assert: list first equals: link4.\r\tself assert: list second equals: link3.\r\tself assert: list third equals: link2.\r\tself assert: list fourth equals: link1"},{"name":"testAtPut","linesOfCode":6,"sourceCode":"testAtPut\r\t| ll |\r\tll := LinkedList new.\r\tll add: 1.\r\tll at: 1 put: 2.\r\tself assert: (ll at: 1) equals: 2"},{"name":"subCollectionNotIn","linesOfCode":3,"sourceCode":"subCollectionNotIn\r\" return a collection for which at least one element is not included in 'accessCollection' \"\r\t^ collectionWithoutNil "},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ collectionWithoutEqualElements"},{"name":"collectionWithElementsToRemove","linesOfCode":3,"sourceCode":"collectionWithElementsToRemove\r\" return a collection of elements included in 'nonEmpty'  \"\r\t^ self nonEmpty "},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\t\" return a collection only including elements that can be sorted (understanding '<' )\"\r\t^ collection5Elements "},{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\" return a collection without equal elements \"\r\t^ collectionWithoutEqualElements "},{"name":"testAtPutOutsideBounds","linesOfCode":4,"sourceCode":"testAtPutOutsideBounds\r\t| ll |\r\tll := LinkedList new.\r\tself should: [ ll at: 1 put: 1 ] raise: SubscriptOutOfBounds"},{"name":"test22addAll","linesOfCode":28,"sourceCode":"test22addAll\r\t| link5 link6 link7 link8 listToBeAdded |\r\tlink5 := Link new.\r\tlink6 := Link new.\r\tlink7 := Link new.\r\tlink8 := Link new.\r\t\r\tlist\r\t\tadd: link1;\r\t\tadd: link2;\r\t\tadd: link3;\r\t\tadd: link4.\r\t\t\r\tlistToBeAdded := LinkedList new.\r\tlistToBeAdded\r\t\tadd: link5;\r\t\tadd: link6;\r\t\tadd: link7;\r\t\tadd: link8.\r\t\t\r\tlist addAll: listToBeAdded.\r\t\r\tself should: [(list at: 1) == link1].\r\tself should: [(list at: 2) == link2].\r\tself should: [(list at: 3) == link3].\r\tself should: [(list at: 4) == link4].\r\tself should: [(list at: 5) == link5].\r\tself should: [(list at: 6) == link6].\r\tself should: [(list at: 7) == link7].\r\tself should: [(list at: 8) == link8]."},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\" return an index between 'collectionWithoutEqualsElements'  bounds\"\r\t^ 2"},{"name":"testTAdd","linesOfCode":5,"sourceCode":"testTAdd\r\t| added |\r\tadded := self otherCollection add: self element.\r\tself assert: added equals: self element.\t\"equality or identity ?\"\r\tself assert: (self otherCollection includes: self element)"},{"name":"testSwapAdjacentStart","linesOfCode":7,"sourceCode":"testSwapAdjacentStart\r\t|aList|\r\taList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.\r\t\r\taList swap: 1 with: 2.\r\tself assert: (aList at: 1) equals: 4.\r\tself assert: (aList at: 2) equals: 5.\r\tself assert: aList first equals: 4."},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection anyOne"},{"name":"elementNotInForOccurrences","linesOfCode":3,"sourceCode":"elementNotInForOccurrences\r\" return an element notIncluded in #collectionWithoutEqualElements\"\r\t^ elementNotIn "},{"name":"testSwapAdjacent","linesOfCode":6,"sourceCode":"testSwapAdjacent\r\t|aList|\r\taList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.\r\t\r\taList swap: 3 with: 4.\r\tself assert: (aList at: 3) equals: 2.\r\tself assert: (aList at: 4) equals: 3."},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^ self nonEmpty size"},{"name":"test01add","linesOfCode":20,"sourceCode":"test01add\r\tself assertEmpty: list.\r\tlist add: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first equals: link1.\r\r\tlist add: link2.\r\tself assert: list size equals: 2.\r\tself assert: list first equals: link1.\r\tself assert: list second equals: link2.\r\r\tlist add: link3.\r\tself assert: list size equals: 3.\r\tself assert: list first equals: link1.\r\tself assert: list second equals: link2.\r\tself assert: list third equals: link3.\r\r\tlist add: link4.\r\tself assert: list size equals: 4.\r\tself assert: list first equals: link1.\r\tself assert: list second equals: link2.\r\tself assert: list third equals: link3.\r\tself assert: list fourth equals: link4"},{"name":"accessCollection","linesOfCode":2,"sourceCode":"accessCollection\r\t^collectionWithoutEqualElements "},{"name":"n:","linesOfCode":2,"sourceCode":"n: number\r\tn := number.\r\t"},{"name":"elementNotIn","linesOfCode":2,"sourceCode":"elementNotIn\r\t^ Link new"},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^ nonEmpty1Element "},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\" return an element not included in 'accessCollection' \"\r\t^ elementNotIn "},{"name":"otherCollection","linesOfCode":2,"sourceCode":"otherCollection\r\t^ otherList ifNil: [otherList := LinkedList with: Link new with: Link new]"},{"name":"result","linesOfCode":3,"sourceCode":"result\r\t\"Returns a collection of the classes of elements in #collection\"\r\t ^ collectResult"},{"name":"test06addAfter","linesOfCode":20,"sourceCode":"test06addAfter\r\tself assertEmpty: list.\r\r\tlist add: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link1.\r\r\tlist add: link2 after: link1.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\r\tlist add: link3 after: link2.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link3.\r\r\tlist add: link4 after: link3.\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link3.\r\tself assert: list fourth identicalTo: link4"},{"name":"elementInForIndexAccessing","linesOfCode":3,"sourceCode":"elementInForIndexAccessing\r\" return an element included in 'accessCollection' \"\r\t^ elementIn "},{"name":"test08addAfter","linesOfCode":9,"sourceCode":"test08addAfter\r\r\t| l first |\r\tl := LinkedList new.\r\tfirst := self class new n: 1.\r\tl add: first.\r\tl add: (self class new n: 3).\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 3).\r\tl add: (self class new n: 2) after: first.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2 3)"},{"name":"testIdentityIncludes","linesOfCode":8,"sourceCode":"testIdentityIncludes\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\r\t| collection element |\r\tself collectionWithCopyNonIdentical.\r\tcollection := self collectionWithCopyNonIdentical.\r\telement := collection anyOne copy.\t\"self assert: (collection includes: element).\"\r\tself deny: (collection identityIncludes: element)"},{"name":"testSort","linesOfCode":5,"sourceCode":"testSort\r\t| aLinkedList |\r\taLinkedList := LinkedList with: 1 with: 2.\r\taLinkedList sort: [ :a :b | a > b ].\r\tself assert: aLinkedList equals: (LinkedList with: 2 with: 1)"},{"name":"testSwapStartAndEnd","linesOfCode":8,"sourceCode":"testSwapStartAndEnd\r\t|aList|\r\taList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.\r\t\r\taList swap: 1 with: 5.\r\tself assert: (aList at: 1) equals: 1.\r\tself assert: (aList at: 5) equals: 5.\r\tself assert: aList first equals: 1.\r\tself assert: aList last equals: 5."},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\t^ self nonEmpty"},{"name":"elementNotInForIndexAccessing","linesOfCode":3,"sourceCode":"elementNotInForIndexAccessing\r\" return an element not included in 'accessCollection' \"\r\t^ elementNotIn "},{"name":"testRemoveAll","linesOfCode":10,"sourceCode":"testRemoveAll\r\t| list2 |\r\tlist add: link1.\r\tlist add: link2.\r\tlist add: link3.\r\tlist add: link4.\r\tlist2 := list copy.\r\tlist removeAll.\r\r\tself assert: list size equals: 0.\r\tself assert: list2 size = 4 description: 'the copy has not been modified'"},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^LinkedList"},{"name":"test12remove","linesOfCode":24,"sourceCode":"test12remove\r\tlist add: link1.\r\tlist add: link2.\r\tlist add: link3.\r\tlist add: link4.\r\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link3.\r\tself assert: list fourth identicalTo: link4.\r\r\tlist remove: link3.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link4.\r\r\tlist remove: link2.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link4.\r\r\tlist remove: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link4.\r\r\tlist remove: link4.\r\tself assertEmpty: list"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ list"},{"name":"testAddAfter","linesOfCode":9,"sourceCode":"testAddAfter\r\r\t| l first |\r\tl := LinkedList new.\r\tfirst := self class new n: 1.\r\tl add: first.\r\tl add: (self class new n: 3).\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 3).\r\tl add: (self class new n: 2) after: first.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2 3)"},{"name":"nextLink","linesOfCode":2,"sourceCode":"nextLink\r\t^nextLink"},{"name":"test04addBefore","linesOfCode":20,"sourceCode":"test04addBefore\r\tself assertEmpty: list.\r\r\tlist add: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link1.\r\r\tlist add: link2 before: link1.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link2.\r\tself assert: list second identicalTo: link1.\r\r\tlist add: link3 before: link1.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link2.\r\tself assert: list second identicalTo: link3.\r\tself assert: list third identicalTo: link1.\r\r\tlist add: link4 before: link1.\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link2.\r\tself assert: list second identicalTo: link3.\r\tself assert: list third identicalTo: link4.\r\tself assert: list fourth identicalTo: link1"},{"name":"test11removeLast","linesOfCode":24,"sourceCode":"test11removeLast\r\tlist add: link1.\r\tlist add: link2.\r\tlist add: link3.\r\tlist add: link4.\r\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link3.\r\tself assert: list fourth identicalTo: link4.\r\r\tlist removeLast.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link3.\r\r\tlist removeLast.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\r\tlist removeLast.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link1.\r\r\tlist removeFirst.\r\tself assertEmpty: list"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ elementNotIn "},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\t\" return a collection not including equal elements \"\r\r\t^ collectionWithoutEqualElements"},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ link ifNil: [link := ValueLink value: 42. \"so that we can recognize this link\"]"},{"name":"test02addLast","linesOfCode":20,"sourceCode":"test02addLast\r\tself assertEmpty: list.\r\r\tlist addLast: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first equals: link1.\r\r\tlist addLast: link2.\r\tself assert: list size equals: 2.\r\tself assert: list first equals: link1.\r\tself assert: list second equals: link2.\r\r\tlist addLast: link3.\r\tself assert: list size equals: 3.\r\tself assert: list first equals: link1.\r\tself assert: list second equals: link2.\r\tself assert: list third equals: link3.\r\r\tlist addLast: link4.\r\tself assert: list size equals: 4.\r\tself assert: list first equals: link1.\r\tself assert: list second equals: link2.\r\tself assert: list third equals: link3.\r\tself assert: list fourth equals: link4"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\t\"Returns a collection that already includes what is returned by #element.\"\r\t^ self collection"},{"name":"test14removeIfAbsent","linesOfCode":11,"sourceCode":"test14removeIfAbsent\r\tlist add: link1.\r\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link1.\r\r\tlist remove: link1.\r\tself assertEmpty: list.\r\r\t[ list remove: link1 ]\r\t\ton: Error\r\t\tdo: [ ^ self ].\r\r\t\"The execution should not get here. If yes, something went wrong.\"\r\tself fail"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element \"\r\t^collectionWithoutNil "},{"name":"n","linesOfCode":1,"sourceCode":"n\r\t^n"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ nonEmpty ifNil: [nonEmpty := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1 with: self element]"},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\" return a collection that will be used to replace 'oldSubcollection' in ' collectionWith1TimeSubcollection'  \" \r\t^ collectionWithoutNil "},{"name":"collectionWith1TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith1TimeSubcollection\r\" return a collection including 'oldSubCollection'  only one time \"\r\t^ self oldSubCollection "},{"name":"testSwapBasic","linesOfCode":6,"sourceCode":"testSwapBasic\r\t|aList|\r\taList := LinkedList with: 5 with: 4 with: 3 with: 2 with: 1.\r\t\r\taList swap: 2 with: 4.\r\tself assert: (aList at: 2) equals: 2.\r\tself assert: (aList at: 4) equals: 4.\r"},{"name":"testCreateAs","linesOfCode":10,"sourceCode":"testCreateAs\r\t\"Test that a LinkedList can be created by sending message #as: to another collection.\r\tImplementation note: this method is generic for sequenceable collection and should be traitified.\"\r\t| anotherCollection aLinkedList |\r\tanotherCollection := 1 to: 10.\r\taLinkedList := anotherCollection as: LinkedList.\r\tself assert: (aLinkedList isMemberOf: LinkedList).\r\tself assert: aLinkedList size equals: anotherCollection size.\r\taLinkedList with: anotherCollection do: [:nextElementOfLinkedList :nextElementOfAnotherCollection |\r\t\tself assert: nextElementOfLinkedList equals: nextElementOfAnotherCollection]"},{"name":"test13remove","linesOfCode":24,"sourceCode":"test13remove\r\tlist add: link1.\r\tlist add: link2.\r\tlist add: link3.\r\tlist add: link4.\r\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link3.\r\tself assert: list fourth identicalTo: link4.\r\r\tlist remove: link1.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link2.\r\tself assert: list second identicalTo: link3.\r\tself assert: list third identicalTo: link4.\r\r\tlist remove: link4.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link2.\r\tself assert: list second identicalTo: link3.\r\r\tlist remove: link2.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link3.\r\r\tlist remove: link3.\r\tself assertEmpty: list"},{"name":"elementToAdd","linesOfCode":3,"sourceCode":"elementToAdd\r\" return an element of type 'nonEmpy' elements'type'\"\r\t^ ValueLink value: 77"},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\" return a collection including at leat 4 elements\"\r\t^ collectionWithoutEqualElements "},{"name":"test07addAfter","linesOfCode":20,"sourceCode":"test07addAfter\r\tself assertEmpty: list.\r\r\tlist add: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link1.\r\r\tlist add: link2 after: link1.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link2.\r\r\tlist add: link3 after: link1.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link3.\r\tself assert: list third identicalTo: link2.\r\r\tlist add: link4 after: link1.\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link1.\r\tself assert: list second identicalTo: link4.\r\tself assert: list third identicalTo: link3.\r\tself assert: list fourth identicalTo: link2"},{"name":"anotherElementNotIn","linesOfCode":3,"sourceCode":"anotherElementNotIn\r\" return an element included  in 'collection' \"\r\t^ elementNotIn "},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\" return an element inculded in 'accessCollection '\"\r\t^ elementIn "},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ LinkedList"},{"name":"oldSubCollection","linesOfCode":4,"sourceCode":"oldSubCollection\r\" return a subCollection included in collectionWith1TimeSubcollection .\rex :   subCollection := #( 2 3 4) and collectionWith1TimeSubcollection := #(1 2 3 4 5)\"\r\t^ self nonEmpty "},{"name":"setUp","linesOfCode":20,"sourceCode":"setUp\r\t\r\tsuper setUp.\r\tlist := LinkedList new.\r\tlink1 := 133.\r\tlink2 := 'test'.\r\tlink3 := $h.\r\tlink4 := Set new.\r\telementNotIn := Link new.\r\tcollectionWithoutNil := LinkedList new add: link1; add: link2 ; add: link3; yourself.\r\telementIn := 'thisElementIsIncluded'.\r\tcollectionWithoutEqualElements := LinkedList new add: elementIn ; add: 'pewpew' ; add: 'normal links'; add: 'are no fun!' ;add: $x ;yourself.\r\tcollection5Elements := collectionWithoutEqualElements .\r\tunsortedCollection := LinkedList new addAll: #(57 937 92 49 0 78 -87); yourself.\r\tsortedCollection := LinkedList new addAll: #(-87 0 49 57 78 92 937); yourself.\r\t\"sameAttendAndBegining := LinkedList new add: Link new; add: Link new ; add: Link new; yourself.\"\r\tlink := ValueLink value: 42.\r\tnonEmpty1Element :=  LinkedList new add: Link new; yourself.\r\t \"so that we can recognize this link\"\r\t\"nonEmpty := LinkedList with: link with: Link new.\"\r\t\"otherList := LinkedList with: Link new with: Link new.\"\r"},{"name":"sortedInAscendingOrderCollection","linesOfCode":3,"sourceCode":"sortedInAscendingOrderCollection\r\t\"Return a collection sorted in ascending order\"\r\t^ sortedCollection\r\t"},{"name":"unsortedCollection","linesOfCode":3,"sourceCode":"unsortedCollection\r\"Return a collection that is not yet sorted\"\r\t^ unsortedCollection"},{"name":"test05addBefore","linesOfCode":20,"sourceCode":"test05addBefore\r\tself assertEmpty: list.\r\r\tlist add: link1.\r\tself assert: list size equals: 1.\r\tself assert: list first identicalTo: link1.\r\r\tlist add: link2 before: link1.\r\tself assert: list size equals: 2.\r\tself assert: list first identicalTo: link2.\r\tself assert: list second identicalTo: link1.\r\r\tlist add: link3 before: link2.\r\tself assert: list size equals: 3.\r\tself assert: list first identicalTo: link3.\r\tself assert: list second identicalTo: link2.\r\tself assert: list third identicalTo: link1.\r\r\tlist add: link4 before: link3.\r\tself assert: list size equals: 4.\r\tself assert: list first identicalTo: link4.\r\tself assert: list second identicalTo: link3.\r\tself assert: list third identicalTo: link2.\r\tself assert: list fourth identicalTo: link1"},{"name":"testAddAfterLast","linesOfCode":9,"sourceCode":"testAddAfterLast\r\r\t| l last |\r\tl := LinkedList new.\r\tlast := self class new n: 2.\r\tl add: (self class new n: 1).\r\tl add: last.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2).\r\tl add: (self class new n: 3) after: last.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2 3)"},{"name":"test09addAfter","linesOfCode":9,"sourceCode":"test09addAfter\r\r\t| l last |\r\tl := LinkedList new.\r\tlast := self class new n: 2.\r\tl add: (self class new n: 1).\r\tl add: last.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2).\r\tl add: (self class new n: 3) after: last.\r\tself assert: (l collect: [ :e | e n ]) asArray equals: #(1 2 3)"},{"name":"test0FixtureIndexAccessTest","linesOfCode":11,"sourceCode":"test0FixtureIndexAccessTest\r\t| res |\r\tself collectionMoreThan1NoDuplicates.\r\tself assert: self collectionMoreThan1NoDuplicates size equals: 5.\r\tres := true.\r\tself collectionMoreThan1NoDuplicates detect: [ :each | (self collectionMoreThan1NoDuplicates occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself assert: res equals: false.\r\tself elementInForIndexAccessing.\r\tself assert: (self collectionMoreThan1NoDuplicates includes: self elementInForIndexAccessing).\r\tself elementNotInForIndexAccessing.\r\tself deny: (self collectionMoreThan1NoDuplicates includes: self elementNotInForIndexAccessing)"},{"name":"collectionNotIncluded","linesOfCode":3,"sourceCode":"collectionNotIncluded\r\" return a collection for wich each element is not included in 'nonEmpty' \"\r\t^ collectionWithoutNil "}],"meta":{"name":"LinkedListTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Array2DTest","instanceVariables":[{"name":"matrix1"},{"name":"matrix2"},{"name":"matrix23"}],"methods":[{"name":"testAtRow","linesOfCode":4,"sourceCode":"testAtRow\r\r\tself assert: (matrix23 atRow: 1) equals: #(11 21).\r\tself assert: (matrix23 atRow: 2) equals: #(12 22).\r\tself assert: (matrix23 atRow: 3) equals: #(13 23)."},{"name":"testIncludes","linesOfCode":4,"sourceCode":"testIncludes\r\tself assert:\r\t\t\t((1 to: 4)\r\t\t\t\tallSatisfy: [:i | matrix1 includes: i])\r"},{"name":"testDiagonal","linesOfCode":11,"sourceCode":"testDiagonal\r\r\t| m m2 | \r\r\tm := Array2D diagonal: #(1 2 3 4 5).\r\r\tself assert: m numberOfColumns equals: 5.\r\tself assert: m numberOfRows equals: 5.\r\tself assert: (m occurrencesOf: 0) equals: 20.\r\t1 to: 5 do: [ :i |\r\t\tself assert: (m at: i at: i) equals: i.].\r\r\tm2 := Array2D diagonal: Array new.\r\r\tself assert: m2 numberOfColumns equals: 0.\r\tself assert: m2 numberOfRows equals: 0.\r\t"},{"name":"testOnes","linesOfCode":10,"sourceCode":"testOnes\r\r\t| m m2 | \r\r\tm := Array2D ones: 10.\r\r\tself assert: m numberOfColumns equals: 10.\r\tself assert: m numberOfRows equals: 10.\r\tself assert: (m occurrencesOf: 1) equals: (10*10).\r\r\tm2 := Array2D ones: 0.\r\r\tself assert: m2 numberOfColumns equals: 0.\r\tself assert: m2 numberOfRows equals: 0.\r\tself assert: (m2 occurrencesOf: 1) equals: 0.\r\t"},{"name":"testCopy","linesOfCode":4,"sourceCode":"testCopy\r\t| copyMatrix |\r\tcopyMatrix := matrix1 copy.\r\tself assert: matrix1 equals: copyMatrix"},{"name":"testRowVector","linesOfCode":10,"sourceCode":"testRowVector\r\r\t| m m2 | \r\r\tm := Array2D rowVector: #(1 2 3 4 5).\r\r\tself assert: m numberOfColumns equals: 5.\r\tself assert: m numberOfRows equals: 1.\r\t1 to: 5 do: [ :i |\r\t\tself assert: (m at: 1 at: i) equals: i.].\r\r\tm2 := Array2D rowVector: Array new.\r\r\tself assert: m2 numberOfColumns equals: 0.\r\tself assert: m2 numberOfRows equals: 1.\r\t"},{"name":"testSwap","linesOfCode":8,"sourceCode":"testSwap\r\tmatrix1\r\t\tswap: 1\r\t\tat: 2\r\t\twith: 1\r\t\tat: 1.\r\tself assert: (matrix1 at: 1 at: 1) equals: 3.\r\tself assert: (matrix1 at: 1 at: 2) equals: 1"},{"name":"testTabulate","linesOfCode":9,"sourceCode":"testTabulate\r\t| m |\r\tm := Array2D rows: 3 columns: 2 tabulate: [ :row :column | column * 10 + row ].\r\tself assert: (m at: 1 at: 1) equals: 11.\r\tself assert: (m at: 1 at: 2) equals: 21.\r\tself assert: (m at: 2 at: 1) equals: 12.\r\tself assert: (m at: 2 at: 2) equals: 22.\r\tself assert: (m at: 3 at: 1) equals: 13.\r\tself assert: (m at: 3 at: 2) equals: 23."},{"name":"testMultiply","linesOfCode":8,"sourceCode":"testMultiply\r\t| result |\r\tself should: [ matrix1 preMultiplyByMatrix: (Array2D new: 3) ] raise: Error.\r\r\tresult := matrix2 preMultiplyByMatrix: matrix1.\r\tself assert: (result at: 1 at: 1) equals: 15.\r\tself assert: (result at: 1 at: 2) equals: 31.\r\tself assert: (result at: 2 at: 1) equals: 22.\r\tself assert: (result at: 2 at: 2) equals: 46"},{"name":"testIdentityOtherTest","linesOfCode":7,"sourceCode":"testIdentityOtherTest\r\r\t| m | \r\tm := Array2D identity: 3.\r\tself assert: (m at: 1 at:1) equals: 1.\r\tself assert: (m at: 2 at:2) equals: 1.\r\tself assert: (m at: 3 at:3) equals: 1.\r\tself assert: (m occurrencesOf: 1) equals: 3.\r"},{"name":"testCollectCreatesANewMatrix","linesOfCode":8,"sourceCode":"testCollectCreatesANewMatrix\r\r\t| m m2 | \r\tm := Array2D new: 3. \r\tm atAllPut: -1.\r\tself assert: (m occurrencesOf: -1) equals: 9.\r\tm2 := m collect: [ :each | each abs ].\r\tm2 do: [ :each | self assert: each equals: 1 ].\r\tself assert: (m2 occurrencesOf: 1) equals: 9"},{"name":"testContentsEncodings","linesOfCode":2,"sourceCode":"testContentsEncodings\r\r\tself assert: matrix23 privateContents equals: #(11 21 12 22 13 23)"},{"name":"testSquaredWithAllElement","linesOfCode":2,"sourceCode":"testSquaredWithAllElement\r\r\tself assert: ((Array2D new: 3 element: -1) occurrencesOf: -1) equals: 9.\r"},{"name":"testTabulateEquals","linesOfCode":4,"sourceCode":"testTabulateEquals\r\t| m |\r\tm := Array2D rows: 3 columns: 2 tabulate: [ :row :column | column * 10 + row ].\r\tself assert: m equals: matrix23"},{"name":"testTransposed","linesOfCode":7,"sourceCode":"testTransposed\r\t| transposedMatrix |\r\ttransposedMatrix := matrix1 transposed.\r\tself assert: (transposedMatrix at: 1 at: 1) equals: 1.\r\tself assert: (transposedMatrix at: 1 at: 2) equals: 2.\r\tself assert: (transposedMatrix at: 2 at: 1) equals: 3.\r\tself assert: (transposedMatrix at: 2 at: 2) equals: 4"},{"name":"testAtAt","linesOfCode":14,"sourceCode":"testAtAt\r\tself should:[matrix1 at: 2 at: 3] raise: Error.\r\tself should:[matrix1 at: 3 at: 2] raise: Error.\r\tself should:[matrix1 at: 3 at: 3] raise: Error.\r\tself should:[matrix1 at: 0 at: 1] raise: Error.\r\tself should:[matrix1 at: 1 at: 0] raise: Error.\r\tself should:[matrix1 at: 0 at: 0] raise: Error.\r\t\r\tself assert: (matrix1 at: 1 at: 1) equals: 1.\r\tself assert: (matrix23 at: 1 at: 1) equals: 11.\r\tself assert: (matrix23 at: 1 at: 2) equals: 21.\r\tself assert: (matrix23 at: 2 at: 1) equals: 12.\r\tself assert: (matrix23 at: 2 at: 2) equals: 22.\r\tself assert: (matrix23 at: 3 at: 1) equals: 13.\r\tself assert: (matrix23 at: 3 at: 2) equals: 23."},{"name":"testAtAllPut","linesOfCode":6,"sourceCode":"testAtAllPut\r\r\t| m | \r\tm := Array2D new: 3. \r\tm do: [ :each | self assert: each equals: nil ].\r\tm atAllPut: 1.\r\tm do: [ :each | self assert: each equals: 1 ]."},{"name":"setUp","linesOfCode":19,"sourceCode":"setUp\r\tsuper setUp.\r\tmatrix1 := Array2D new: 2.\r\tmatrix1 at:1 at:1 put: 1.\r\tmatrix1 at:1 at:2 put: 3.\r\tmatrix1 at:2 at:1 put: 2.\r\tmatrix1 at:2 at:2 put: 4.\r\t\r\tmatrix2 := Array2D new: 2.\r\tmatrix2 at:1 at:1 put: 3.\r\tmatrix2 at:1 at:2 put: 7.\r\tmatrix2 at:2 at:1 put: 4.\r\tmatrix2 at:2 at:2 put: 8.\r\t\r\tmatrix23 := Array2D rows: 3 columns: 2.\r\tmatrix23 at: 1 at: 1 put: 11.\r\tmatrix23 at: 1 at: 2 put: 21.\r\tmatrix23 at: 2 at: 1 put: 12.\r\tmatrix23 at: 2 at: 2 put: 22.\r\tmatrix23 at: 3 at: 1 put: 13.\r\tmatrix23 at: 3 at: 2 put: 23."},{"name":"testAtColumn","linesOfCode":3,"sourceCode":"testAtColumn\r\r\tself assert: (matrix23 atColumn: 1) equals: #(11 12 13).\r\tself assert: (matrix23 atColumn: 2) equals: #(21 22 23).\r\t"},{"name":"testColumnVector","linesOfCode":10,"sourceCode":"testColumnVector\r\r\t| m m2 | \r\r\tm := Array2D columnVector: #(1 2 3 4 5).\r\r\tself assert: m numberOfColumns equals: 1.\r\tself assert: m numberOfRows equals: 5.\r\t1 to: 5 do: [ :i |\r\t\tself assert: (m at: i at: 1) equals: i.].\r\r\tm2 := Array2D columnVector: Array new.\r\r\tself assert: m2 numberOfColumns equals: 1.\r\tself assert: m2 numberOfRows equals: 0.\r\t"},{"name":"testReplaceAll","linesOfCode":6,"sourceCode":"testReplaceAll\r\r\tmatrix1 replaceAll: 1 with: 10.\r\tself assert: (matrix1 at: 1 at: 1) equals: 10.\r\tself assert: (matrix1 at: 2 at: 1) equals: 2.\r\tself assert: (matrix1 at: 1 at: 2) equals: 3.\r\tself assert: (matrix1 at: 2 at: 2) equals: 4."},{"name":"testIdentity","linesOfCode":9,"sourceCode":"testIdentity\r\t| m m2 |\r\tm := Array2D new: 3 element: 0.\r\tm at: 1 at: 1 put: 1.\r\tm at: 2 at: 2 put: 1.\r\tm at: 3 at: 3 put: 1.\r\tself assert: (m occurrencesOf: 1) equals: 3.\r\tm2 := Array2D identity: 3.\r\tself assert: m2 equals: m"},{"name":"testNewTabulate","linesOfCode":14,"sourceCode":"testNewTabulate\r\r\t| m m2 | \r\r\tm := Array2D new: 5 tabulate: [ :a :b | a*b ].\r\r\tself assert: m numberOfColumns equals: 5.\r\tself assert: m numberOfRows equals: 5.\r\tself assert: (m occurrencesOf: 8) equals: 2.\r\t1 to: 5 do: [ :i |\r\t\tself assert: (m at: i at: 1) equals: i.\r\t\tself assert: (m at: 1 at: i) equals: i.\r\t\tself assert: (m at: i at: i) equals: i*i.].\r\r\tm2 := Array2D new: 0 tabulate: [ :a :b | a*b ].\r\t\r\tself assert: m2 numberOfColumns equals: 0.\r\tself assert: m2 numberOfRows equals: 0.\r\tself assert: (m2 occurrencesOf: 1) equals: 0.\r\t"}],"meta":{"name":"Array2DTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ArrayTest","instanceVariables":[{"name":"example1"},{"name":"literalArray"},{"name":"selfEvaluatingArray"},{"name":"nonSEArray1"},{"name":"nonSEarray2"},{"name":"example2"},{"name":"empty"},{"name":"collectResult"},{"name":"withoutEqualElements"},{"name":"withEqualElements"},{"name":"withCharacters"},{"name":"unsortedCollection"},{"name":"sortedInAscendingOrderCollection"},{"name":"collectionNotIncluded"},{"name":"removedCollection"},{"name":"elementInForCopy"},{"name":"elementNotInForCopy"},{"name":"firstIndex"},{"name":"secondIndex"},{"name":"replacementCollection"},{"name":"indexArray"},{"name":"valueArray"},{"name":"nonEmptyMoreThan1Element"},{"name":"subCollectionNotIn"},{"name":"replacementCollectionSameSize"},{"name":"oldSubCollection"},{"name":"nonEmpty1Element"},{"name":"collectionOfCollection"},{"name":"collectionOfFloatWithEqualElements"},{"name":"collectionWithoutNil"},{"name":"duplicateElement"},{"name":"collection5Elements"},{"name":"collectionWith4Elements"},{"name":"collectionOfCollectionsOfStrings"},{"name":"collectionOfCollectionsOfInts"},{"name":"simpleCollection"},{"name":"stringCollectionWithSameBeginingAnEnd"},{"name":"collectionOfFloat"}],"methods":[{"name":"collectionNotIncluded","linesOfCode":2,"sourceCode":"collectionNotIncluded\r\t^ collectionNotIncluded."},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\t^ example1 "},{"name":"testOccurrencesOfEmpty","linesOfCode":4,"sourceCode":"testOccurrencesOfEmpty\r\t| result |\r\tresult := self empty occurrencesOf: self elementInForOccurrences.\r\tself assert: result equals: 0"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":2,"sourceCode":"integerCollectionWithoutEqualElements\r\t^{1. 2. 6. 5.}"},{"name":"subCollectionNotIn","linesOfCode":2,"sourceCode":"subCollectionNotIn\r\r\t^subCollectionNotIn "},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ collectionOfCollection"},{"name":"collectionWithElementsToRemove","linesOfCode":2,"sourceCode":"collectionWithElementsToRemove\r\t^ removedCollection"},{"name":"collectionOfCollectionsOfStrings","linesOfCode":2,"sourceCode":"collectionOfCollectionsOfStrings\r\t^ collectionOfCollectionsOfStrings."},{"name":"testAnySatisfy","linesOfCode":3,"sourceCode":"testAnySatisfy\r\r\tself assert: ( self collection anySatisfy: [:each | each = -2]).\r\tself deny: (self collection anySatisfy: [:each | each isString])."},{"name":"selectorToAccessValuePutIn","linesOfCode":3,"sourceCode":"selectorToAccessValuePutIn\r\t\"return the selector of the method that should be invoked to access an element\"\r\t\r\t^ #second"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ elementNotInForCopy "},{"name":"testIsArray","linesOfCode":2,"sourceCode":"testIsArray\r\t\r\tself assert: example1 isArray"},{"name":"elementInForCopy","linesOfCode":2,"sourceCode":"elementInForCopy\r\t^ elementInForCopy "},{"name":"accessCollection","linesOfCode":2,"sourceCode":"accessCollection\r\r\t^ example1"},{"name":"collectionWith2TimeSubcollection","linesOfCode":2,"sourceCode":"collectionWith2TimeSubcollection\r\t^ (self oldSubCollection copyWithoutFirst),self oldSubCollection,(self oldSubCollection copyWithoutFirst),self oldSubCollection ."},{"name":"elementInForIndexAccess","linesOfCode":2,"sourceCode":"elementInForIndexAccess\r\t^ elementInForCopy "},{"name":"nonEmpty1Element","linesOfCode":2,"sourceCode":"nonEmpty1Element\r\r\t^ nonEmpty1Element  "},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\" return an element not included in 'accessCollection' \"\r\t^ elementNotInForCopy "},{"name":"result","linesOfCode":2,"sourceCode":"result\r\t\r\t^ collectResult"},{"name":"elementInForIndexAccessing","linesOfCode":2,"sourceCode":"elementInForIndexAccessing\r\r\t^ withoutEqualElements anyOne"},{"name":"collection","linesOfCode":2,"sourceCode":"collection \r\r\t^ collectionWith4Elements "},{"name":"collectionOfFloat","linesOfCode":2,"sourceCode":"collectionOfFloat\r\t^ collectionOfFloat"},{"name":"anotherValue","linesOfCode":2,"sourceCode":"anotherValue\r\r\t^ 66"},{"name":"elementNotInForIndexAccessing","linesOfCode":2,"sourceCode":"elementNotInForIndexAccessing\r\r\t^elementNotInForCopy "},{"name":"elementInCollectionOfFloat","linesOfCode":2,"sourceCode":"elementInCollectionOfFloat\r\t^ collectionOfFloat atRandom"},{"name":"aValue","linesOfCode":2,"sourceCode":"aValue\r\r\t^ 33"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ empty"},{"name":"secondCollection","linesOfCode":2,"sourceCode":"secondCollection\r\t^example2 "},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^ Array"},{"name":"anIndex","linesOfCode":2,"sourceCode":"anIndex\r\r\t^ 2"},{"name":"testDo","linesOfCode":5,"sourceCode":"testDo\r\t| res |\r\tres := OrderedCollection new.\r\tself collection do: [ :each | res add: each class ].\r\tself assert: res asArray equals: self result"},{"name":"firstCollection","linesOfCode":2,"sourceCode":"firstCollection\r\t^example1 "},{"name":"integerCollection","linesOfCode":2,"sourceCode":"integerCollection\r\t^example1 ."},{"name":"testComplexIsSelfEvaluating","linesOfCode":8,"sourceCode":"testComplexIsSelfEvaluating\r\t| complexArray restoredArray |\r\tcomplexArray := {1 . true . false . nil . #a . 'a' . $a . Float pi . Float halfPi . (4 / 5) . Float infinity negated . (1 @ 2) . (0 @ 0 extent: 1 @ 1).\r\t('hola' -> 0) . Object . Object class}.\r\tcomplexArray := complexArray copyWith: complexArray.\r\tself assert: complexArray isSelfEvaluating.\r\trestoredArray := self class evaluate: complexArray printString.\r\tself assert: restoredArray equals: complexArray"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ elementNotInForCopy "},{"name":"indexArray","linesOfCode":2,"sourceCode":"indexArray\r\t^ indexArray ."},{"name":"sizeCollection","linesOfCode":2,"sourceCode":"sizeCollection\r\r\t^ self collection"},{"name":"testCopyNonEmptyWithoutAllNotIncluded","linesOfCode":1,"sourceCode":"testCopyNonEmptyWithoutAllNotIncluded\r\t"},{"name":"testShuffleModifyTheReceiver","linesOfCode":5,"sourceCode":"testShuffleModifyTheReceiver\r\r\t| array shuffled |\r\tarray := #( 1 2 3 4 5) copy.\r\tshuffled := array shuffle.\r\tself assert: array == shuffled. \r\t"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^ collectionWithoutNil  "},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\" return a collection including at least 5 elements\"\r\t\r\t^ collection5Elements "},{"name":"elementNotInForCopy","linesOfCode":2,"sourceCode":"elementNotInForCopy\r\t^ elementNotInForCopy "},{"name":"secondIndex","linesOfCode":2,"sourceCode":"secondIndex\r\t^ secondIndex "},{"name":"firstOdd","linesOfCode":3,"sourceCode":"firstOdd\r\t\"Returns the first odd number of #collection\"\r\t^ 1"},{"name":"firstEven","linesOfCode":3,"sourceCode":"firstEven\r\t\"Returns the first even number of #collection\"\r\t^ -2"},{"name":"replacementCollection","linesOfCode":2,"sourceCode":"replacementCollection\r\t^replacementCollection ."},{"name":"valuePutIn","linesOfCode":3,"sourceCode":"valuePutIn\r\t\"the value that we will put in the non empty collection\"\r\t\r\t^ 2"},{"name":"collectionWith1TimeSubcollection","linesOfCode":2,"sourceCode":"collectionWith1TimeSubcollection\r\t^ (self oldSubCollection copyWithoutFirst),self oldSubCollection,(self oldSubCollection copyWithoutFirst). "},{"name":"elementInForIncludesTest","linesOfCode":2,"sourceCode":"elementInForIncludesTest\r\r\t^ elementInForCopy "},{"name":"test0FixtureIncludeTest","linesOfCode":21,"sourceCode":"test0FixtureIncludeTest\r\t| anElementIn |\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself elementNotIn.\r\tanElementIn := true.\r\tself nonEmpty detect: [ :each | each = self elementNotIn ] ifNone: [ anElementIn := false ].\r\tself assert: anElementIn equals: false.\r\tself anotherElementNotIn.\r\tanElementIn := true.\r\tself nonEmpty detect: [ :each | each = self anotherElementNotIn ] ifNone: [ anElementIn := false ].\r\tself deny: anElementIn.\r\tself collection.\r\tself empty.\r\tself assertEmpty: self empty.\r\tself collectionOfFloat.\r\tself collectionOfFloat do: [ :each | self assert: each isFloat ].\r\tself elementInForIncludesTest.\r\tanElementIn := true.\r\tself nonEmpty detect: [ :each | each = self elementInForIncludesTest ] ifNone: [ anElementIn := false ].\r\tself assert: anElementIn"},{"name":"testAsArrayKeepsIdentity","linesOfCode":5,"sourceCode":"testAsArrayKeepsIdentity\r\t| x y |\r\tx := #(1 2 3 4 5).\r\ty := x asArray.\r\tself assert: y identityHash equals: x identityHash"},{"name":"collectionInForIncluding","linesOfCode":2,"sourceCode":"collectionInForIncluding\r\t^ self nonEmpty copyWithoutFirst."},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\" return a collection with elements at end and begining equals .\r(others elements of the collection are not equal to those elements)\"\r\t^ stringCollectionWithSameBeginingAnEnd "},{"name":"testDo2","linesOfCode":5,"sourceCode":"testDo2\r\t| res |\r\tres := OrderedCollection new.\r\tself collection do: [ :each | res add: each class ].\r\tself assert: res asArray equals: self result"},{"name":"testIdentityIndexOf","linesOfCode":6,"sourceCode":"testIdentityIndexOf\r\t| collection element |\r\telement := self collectionWithCopyNonIdentical anyOne copy.\r\tself deny: self collectionWithCopyNonIdentical anyOne identicalTo: element.\r\tcollection := self collectionWithCopyNonIdentical copyWith: element.\r\tself assert: (collection identityIndexOf: element) equals: collection size"},{"name":"testAtWrap2","linesOfCode":9,"sourceCode":"testAtWrap2\r\t| tabTest |\r\ttabTest := #(5 6 8).\r\tself assert: (tabTest atWrap: 2) equals: 6.\r\tself assert: (tabTest atWrap: 7) equals: 5.\r\tself assert: (tabTest atWrap: 5) equals: 6.\r\tself assert: (tabTest atWrap: 0) equals: 8.\r\tself assert: (tabTest atWrap: 1) equals: 5.\r\tself assert: (tabTest atWrap: -2) equals: 5"},{"name":"elementToAdd","linesOfCode":2,"sourceCode":"elementToAdd\r\t^ 55"},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t^ elementNotInForCopy "},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\" return an element inculded in 'accessCollection '\"\r\t^ self accessCollection anyOne"},{"name":"collectionClass","linesOfCode":4,"sourceCode":"collectionClass \r\t\"Return the class to be used to create instances of the class tested\"\r\t\t\r\t^ Array"},{"name":"elementInForOccurrences","linesOfCode":2,"sourceCode":"elementInForOccurrences\r\t^ elementInForCopy "},{"name":"testIsSelfEvaluating","linesOfCode":5,"sourceCode":"testIsSelfEvaluating\r\r\tself assert: example1 isSelfEvaluating.\r\texample1 at: 1 put: Bag new.\r\tself deny: example1 isSelfEvaluating.\r\texample1 at: 1 put: 1."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ Array"},{"name":"firstIndex","linesOfCode":2,"sourceCode":"firstIndex\r\t^ firstIndex "},{"name":"sortedInAscendingOrderCollection","linesOfCode":2,"sourceCode":"sortedInAscendingOrderCollection\r\t^sortedInAscendingOrderCollection .\r\t"},{"name":"test0FixtureOccurrencesTest","linesOfCode":9,"sourceCode":"test0FixtureOccurrencesTest\r\tself empty.\r\tself assertEmpty: self empty.\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself elementInForOccurrences.\r\tself assert: (self nonEmpty includes: self elementInForOccurrences).\r\tself elementNotInForOccurrences.\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences)"},{"name":"unsortedCollection","linesOfCode":2,"sourceCode":"unsortedCollection\r\t^unsortedCollection ."},{"name":"collectionWithCharacters","linesOfCode":2,"sourceCode":"collectionWithCharacters\r\t^ withCharacters."},{"name":"elementInForReplacement","linesOfCode":2,"sourceCode":"elementInForReplacement\r\t^ elementInForCopy "},{"name":"elementsCopyNonIdenticalWithoutEqualElements","linesOfCode":3,"sourceCode":"elementsCopyNonIdenticalWithoutEqualElements\r\t\" return a collection that does niot include equal elements ( classic equality )\"\r\t^ collectionOfCollection"},{"name":"nonEmptyMoreThan1Element","linesOfCode":2,"sourceCode":"nonEmptyMoreThan1Element\r\t^nonEmptyMoreThan1Element ."},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\" return a collection of float including equal elements (classic equality)\"\r\t^ collectionOfFloatWithEqualElements"},{"name":"simpleCollection","linesOfCode":2,"sourceCode":"simpleCollection\r\t^simpleCollection."},{"name":"smallerIndex","linesOfCode":2,"sourceCode":"smallerIndex\r\t^ firstIndex -1"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ withoutEqualElements "},{"name":"newElement","linesOfCode":2,"sourceCode":"newElement\r\t^999"},{"name":"testPremultiply","linesOfCode":2,"sourceCode":"testPremultiply\r\tself assert: example1 +* #(2) equals: #(2 4 6 8 10)"},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":2,"sourceCode":"indexInForCollectionWithoutDuplicates\r\t^ 2."},{"name":"collectionWithEqualElements","linesOfCode":2,"sourceCode":"collectionWithEqualElements\r\t^ withEqualElements."},{"name":"testLiteralEqual","linesOfCode":2,"sourceCode":"testLiteralEqual\r\r\tself deny: (example1 literalEqual: example1 asIntegerArray)"},{"name":"collectionOfCollectionsOfInts","linesOfCode":2,"sourceCode":"collectionOfCollectionsOfInts\r\t^collectionOfCollectionsOfInts."},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection anyOne."},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\t\r\t^ 2 "},{"name":"assertSameContents:whenConvertedTo:","linesOfCode":6,"sourceCode":"assertSameContents: aCollection whenConvertedTo: aClass\r\t| result |\r\tresult := aCollection perform: ('as' , aClass name) asSymbol.\r\tself assert: (result class includesBehavior: aClass).\r\tresult do: [ :each | self assert: (aCollection occurrencesOf: each) equals: (result occurrencesOf: each) ].\r\tself assert: result size equals: aCollection size"},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\"return an element not included in 'nonEmpty' \"\r\r\t^ elementNotInForCopy "},{"name":"testIdentityIncludes","linesOfCode":8,"sourceCode":"testIdentityIncludes\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\r\t| collection element |\r\tself collectionWithCopyNonIdentical.\r\tcollection := self collectionWithCopyNonIdentical.\r\telement := collection anyOne copy.\t\"self assert: (collection includes: element).\"\r\tself deny: (collection identityIncludes: element)"},{"name":"testOccurrencesOf","linesOfCode":6,"sourceCode":"testOccurrencesOf\r\t| result expected |\r\tresult := self nonEmpty occurrencesOf: self elementInForOccurrences.\r\texpected := 0.\r\tself nonEmpty do: [ :each | self elementInForOccurrences = each ifTrue: [ expected := expected + 1 ] ].\r\tself assert: result equals: expected"},{"name":"test0FixtureTConvertAsSetForMultiplinessTest","linesOfCode":13,"sourceCode":"test0FixtureTConvertAsSetForMultiplinessTest\r\t\"a collection ofFloat with equal elements:\"\r\r\t| res |\r\tself withEqualElements.\r\tself withEqualElements do: [ :each | self assert: each isFloat ].\r\tres := true.\r\tself withEqualElements detect: [ :each | (self withEqualElements occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself assert: res.\t\"a collection of Float without equal elements:\"\r\tres := true.\r\tself elementsCopyNonIdenticalWithoutEqualElements\r\t\tdetect: [ :each | (self elementsCopyNonIdenticalWithoutEqualElements occurrencesOf: each) > 1 ]\r\t\tifNone: [ res := false ].\r\tself deny: res"},{"name":"testFindBinary","linesOfCode":5,"sourceCode":"testFindBinary\r\tself assert: (#(1 3 5 7 11 15 23) findBinary: [ :arg | 1 - arg ]) equals: 1.\r\tself assert: (#(1 3 5 7 11 15 23) findBinary: [ :arg | 23 - arg ]) equals: 23.\r\tself assert: (#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ]) equals: 11.\r\tself should: [ #(1 3 5 7 11 15 23) findBinary: [ :arg | 8 - arg ] ] raise: NotFound"},{"name":"testShuffleChangeOrder","linesOfCode":5,"sourceCode":"testShuffleChangeOrder\r\r\t| array shuffled |\r\tarray := #( 1 2 3 4 5).\r\tshuffled := array copy shuffle.\r\tarray do: [ :e | self assert: (shuffled includes: e) ]\r\t"},{"name":"testFindBinaryIfNone","linesOfCode":3,"sourceCode":"testFindBinaryIfNone\r\tself assert: (#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ] ifNone: [ #none ]) equals: 11.\r\tself should: (#(1 3 5 7 11 15 23) findBinary: [ :arg | 8 - arg ] ifNone: [ #none ]) = #none"},{"name":"testDifferencePreservesOrder","linesOfCode":7,"sourceCode":"testDifferencePreservesOrder\r\t| n even odd odd2 |\r\tn := #(5 3 4).\r\teven := #(4).\r\todd := n difference: even.\r\todd2 := n reject: [ :i | i even ].\r\tself assert: odd equals: odd2"},{"name":"expectedSizeAfterReject","linesOfCode":2,"sourceCode":"expectedSizeAfterReject\r\t^1"},{"name":"collectionWithoutEqualElements","linesOfCode":2,"sourceCode":"collectionWithoutEqualElements\r\t^ withoutEqualElements "},{"name":"testSumNumberItemsWithoutBlock","linesOfCode":3,"sourceCode":"testSumNumberItemsWithoutBlock\r\t\r\tself assert: #() sumNumbers equals: 0.\r\t\r\tself assert: #(1 2 3) sumNumbers equals: 6"},{"name":"testCombinations","linesOfCode":3,"sourceCode":"testCombinations\r\tself assert: #(1 2 3) combinations equals: #(#(1) #(2) #(3) #(1 2) #(1 3) #(2 3) #(1 2 3)).\r\tself assert: (1 to: 3) combinations equals: #(#(1) #(2) #(3) #(1 2) #(1 3) #(2 3) #(1 2 3))"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ example1"},{"name":"testPrinting","linesOfCode":6,"sourceCode":"testPrinting\r\tself assert: literalArray printString equals: '#(1 true 3 #four)'.\r\tself assert: literalArray equals: (self class compiler evaluate: literalArray printString).\r\tself assert: selfEvaluatingArray equals: (self class compiler evaluate: selfEvaluatingArray printString).\r\tself assert: nonSEArray1 printString equals: 'an Array(1 a Set(1))'.\r\tself assert: nonSEarray2 printString equals: '{#Array->Array}'"},{"name":"replacementCollectionSameSize","linesOfCode":2,"sourceCode":"replacementCollectionSameSize\r\t^replacementCollectionSameSize "},{"name":"testNewWithSize","linesOfCode":5,"sourceCode":"testNewWithSize\r\t| array |\r\tarray := Array new: 5.\r\tself assert: array size equals: 5.\r\t1 to: 5 do: [ :index | self assert: (array at: index) isNil ]"},{"name":"testShuffleBy","linesOfCode":6,"sourceCode":"testShuffleBy\r\r\t| base random shuffleByResult |\r\tbase := #(1 2 3 4 5) copy.\r\trandom := (Random seed: 42).\r\tshuffleByResult := #(2 5 4 3 1) copy.\r\t\r\tself assert: ((base shuffleBy: random) hasEqualElements: shuffleByResult).\r\t"},{"name":"testOccurrencesOfNotIn","linesOfCode":4,"sourceCode":"testOccurrencesOfNotIn\r\r\t| result |\r\tresult := self empty occurrencesOf: self elementNotInForOccurrences.\r\tself assert: result equals: 0"},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\" return a collection including at leat 4 elements\"\r\t^ example1 "},{"name":"collectionWithNonIdentitySameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithNonIdentitySameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals only with classic equality (they are not the same object).\r(others elements of the collection are not equal to those elements)\"\r\t^ stringCollectionWithSameBeginingAnEnd "},{"name":"testIsLiteral","linesOfCode":8,"sourceCode":"testIsLiteral\r\t\"We work with a copy of literalArray, to avoid corrupting the code.\"\r\t\r\t| aLiteralArray |\r\taLiteralArray := literalArray copy.\r\tself assert: aLiteralArray isLiteral.\r\taLiteralArray at: 1 put: self class.\r\tself deny: aLiteralArray isLiteral.\r\tself deny: (literalArray as: WeakArray) isLiteral description: 'instances of Array subclasses are not literal'."},{"name":"setUp","linesOfCode":40,"sourceCode":"setUp\r\r\tsuper setUp.\r\tliteralArray := #(1 true 3 #four).\r\tselfEvaluatingArray := { 1. true. (3/4). String loremIpsum. (2 to: 4) . 5 }.\r\tnonSEArray1 := { 1 . Set with: 1 }.\r\tnonSEarray2 := { testingEnvironment associationAt: #Array }.\r\texample1 := #(1 2 3 4 5) copy.\r\tindexArray:= {2. 3. 4.}.\r\tvalueArray:={0. 0. 0.}.\r\toldSubCollection:= {2. 3. 4.}.\r\tnonEmptyMoreThan1Element:= example1.\r\tsubCollectionNotIn:= {1. 8. 3.}.\r\tcollectionNotIncluded:= {7. 8. 9.}.\r\tremovedCollection:=  { 2. 4. }.\r\t\r\texample2 := {1. 2. 3/4. 4. 5}.\r\tcollectionWith4Elements := #(1 -2 3 1). \r\tcollectionWithoutNil := #( 1 2 3 4).\r\tsimpleCollection := #( 1 8 3).\r\tcollectionOfCollectionsOfInts := { 1. { 2. 3 }. { 4. { 5. 6} } }.\r\tcollectionOfCollectionsOfStrings:= {{{'foo'}. {'bar'}}. 'zorg'}.\r\tcollectResult := {SmallInteger. SmallInteger. SmallInteger. SmallInteger.}.\r\tempty := #().\r\tduplicateElement := 5.2.\r\twithEqualElements := {1.5. duplicateElement . 6.1. 2.0. duplicateElement .} .\r\twithoutEqualElements := {1.1. 4.4. 6.5. 2.4. 3.1.}.\r\twithCharacters := {$a. $x. $d. $c. $m.}.\r\tunsortedCollection := {1. 2.  8. 5. 6. 7.}.\r\tsortedInAscendingOrderCollection := {1. 2. 3. 4. 5. 6.}.\r\telementInForCopy:= 2.\r\telementNotInForCopy:= 9.\r\tfirstIndex:= 2.\r\tsecondIndex:= 4.\r\treplacementCollection:= {4. 3. 2. 1.}.\r\treplacementCollectionSameSize := {5. 4. 3.}.\t\r\tnonEmpty1Element:={ 5.}.\r\tcollectionOfCollection:={'a'. 'b'. 'c'.}.\r\tcollectionOfFloat:={1.5. 5.5. 6.5.}.\r\tcollectionOfFloatWithEqualElements:={1.5. 5.5. 6.5. 1.5}.\r\tstringCollectionWithSameBeginingAnEnd := {'c'. 's'. 'c' copy}.\r\tcollection5Elements := { 1. 2. 5. 3. 4.}."},{"name":"oldSubCollection","linesOfCode":2,"sourceCode":"oldSubCollection\r\t^oldSubCollection "},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size 5 without equal elements\"\r\t^ withoutEqualElements "},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\" return an element included exactly two time in # collectionWithEqualElements\"\r^ duplicateElement "}],"meta":{"name":"ArrayTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Atomic","classes":[{"name":"AtomicSharedQueue","instanceVariables":[{"name":"availSema"}],"methods":[{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tsuper initialize.\r\tavailSema := Semaphore new.\r\t"},{"name":"waitForNewItems","linesOfCode":2,"sourceCode":"waitForNewItems\r\tavailSema wait"},{"name":"next","linesOfCode":9,"sourceCode":"next\r\t\"Fetch the next item from queue. If queue is locked or empty, block the sender until operation can complete\"\r\t \r\t| result |\r\t\r\t[ | keepWaiting | \r\t\tkeepWaiting := false. \r\t\tresult := self nextIfNone: [ keepWaiting := true ]. \r\t\tkeepWaiting ] whileTrue: [ self waitForNewItems ].\r\r\t^ result"},{"name":"signalNoMoreItems","linesOfCode":3,"sourceCode":"signalNoMoreItems\r\t\"queue is empty, reset sema signals\"\r\tavailSema consumeAllSignals "},{"name":"signalAddedNewItem","linesOfCode":2,"sourceCode":"signalAddedNewItem\r\tavailSema signal"}],"meta":{"name":"AtomicSharedQueue class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ManifestCollectionsAtomic","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsAtomic class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'Collections-Streams')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#Kernel)"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Atomic'"}],"meta":null}},{"name":"AtomicCollection","instanceVariables":[],"methods":[{"name":"deepCopy","linesOfCode":2,"sourceCode":"deepCopy\r\t^ self errorDontCopy"},{"name":"waitForNewItems","linesOfCode":5,"sourceCode":"waitForNewItems\r\t\"Override in subclass. By default, yield current process.\r\tIf you run more than one process, which popping items from queue,\r\tthen there is no guarantee, that after wait, #next won't block the queue\"\r\t^ self yield"},{"name":"yield","linesOfCode":6,"sourceCode":"yield\r\t\"Yield the current process.\r\tUsed internally by spin loops, once detected that \r\tcurrent process can't make any progress\r\twithout some external event to happen\"\r\tProcessor yield"},{"name":"signalAddedNewItem","linesOfCode":3,"sourceCode":"signalAddedNewItem\r\t\"Optional, override in subclass(es) to signal that new item available in queue.\r\tDefault implementation does nothing\""},{"name":"copy","linesOfCode":2,"sourceCode":"copy\r\t^ self errorDontCopy"},{"name":"newItem","linesOfCode":3,"sourceCode":"newItem\r\t\"override in subclass, if you need to instantiate queue items of different class or initialize them in some specific way\"\r\t^ AtomicQueueItem new"},{"name":"interrupt","linesOfCode":3,"sourceCode":"interrupt\r\t\"simulate interrupt , for debugging purposes only\"\r\tProcessor yield"},{"name":"signalNoMoreItems","linesOfCode":3,"sourceCode":"signalNoMoreItems\r\t\"Optional, override in subclass(es) to signal that queue is currently empty.\r\tDefault implementation does nothing\""},{"name":"errorDontCopy","linesOfCode":3,"sourceCode":"errorDontCopy\r\t\"copying a structure, involved in concurrent operations is a bad idea\"\r\t^ self error: 'Copying not available'"}],"meta":{"name":"AtomicCollection class","instanceVariables":[],"methods":[],"meta":null}},{"name":"AtomicQueueItem","instanceVariables":[{"name":"next"},{"name":"object"}],"methods":[{"name":"object","linesOfCode":3,"sourceCode":"object\r\t\"Answer the value of object\"\r\r\t^ object"},{"name":"isCircular","linesOfCode":2,"sourceCode":"isCircular\r\t^ next == self"},{"name":"makeCircular","linesOfCode":9,"sourceCode":"makeCircular\r\t\"Make a receiver circular, i.e. point to itself,\r\tanswer the old value of next variable. \r\tNote, this operation should be atomic\"\r\t\r\t| temp |\r\r\t\" atomic swap here\"\r\ttemp := next.\r\tnext := self.\r\r\t^ temp"},{"name":"isZombie","linesOfCode":4,"sourceCode":"isZombie\r\t\"Answer a boolean indicating that the receiver doesn't have a real object.\r\tThis should really check that the object is the queue's dummy, but since the item doesn't know which queue it is part of, use the object class instead.\"\r\r\t^object class = self class"},{"name":"printOn:","linesOfCode":11,"sourceCode":"printOn: aStream\r\r\tsuper printOn: aStream.\r\taStream << '('.\r\tself isZombie ifTrue: \r\t\t[ aStream << '<zombie>' ]\r\tifFalse:\r\t\t[ object printOn: aStream ].\r\tself isCircular ifTrue: \r\t\t[ aStream << ', Circular' ].\r\taStream\r\t\t<< ')'"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\t\"make circular\"\r\tsuper initialize.\r\tnext := self."},{"name":"next:","linesOfCode":3,"sourceCode":"next: anObject\r\t\"Set the value of next\"\r\r\tnext := anObject"},{"name":"object:","linesOfCode":3,"sourceCode":"object: anObject\r\t\"Set the value of object\"\r\r\tobject := anObject"},{"name":"next","linesOfCode":3,"sourceCode":"next\r\t\"Answer the value of next\"\r\r\t^ next"}],"meta":{"name":"AtomicQueueItem class","instanceVariables":[],"methods":[],"meta":null}},{"name":"LIFOQueue","instanceVariables":[{"name":"head"}],"methods":[{"name":"nextPut:","linesOfCode":10,"sourceCode":"nextPut: anObject\r\t\r\t| newItem oldHead |\r\r\tnewItem := self newItem.\r\tnewItem object: anObject.\r\r\t\"this is atomic\"\r\toldHead := head.\r\thead := newItem.\r\t\r\tnewItem next: oldHead.\r\t\r\tself signalAddedNewItem.\r\t^ anObject"},{"name":"fastPeek","linesOfCode":10,"sourceCode":"fastPeek\r\t\"Answer a top-most value without removing it from queue.\r\tAnswer nil, if queue is empty or currently blocked by other process,\r\twhich reading from queue\"\r\t\r\t| item result |\r\titem := head.\r\t\r\t[ (result := item object) == item ] whileTrue: [ \r\t\titem isCircular ifTrue: [ ^ nil ].\r\t\t(item := item next) ifNil: [ ^ nil ] ].\r\t\r\t^ result"},{"name":"pop","linesOfCode":2,"sourceCode":"pop\r\r\t^ self nextIfNone: [ self errorEmptyStack ]"},{"name":"nextIfNone:","linesOfCode":15,"sourceCode":"nextIfNone: aBlock\r\t| dummy tail |\r\r\tdummy := self newItem.\r\tdummy object: dummy.\r\r\ttail := head.\r\thead := dummy.\r\r\t\"skip over dummies\"\r\t[ tail object == tail ] whileTrue: [ \r\t\t[ tail isCircular ] whileTrue: [ self yield ].\r\t\t(tail := tail next) ifNil: [ \r\t\t\tdummy next: nil. \r\t\t\tdummy == head ifTrue: [ self signalNoMoreItems].\r\t\t\t^ aBlock value ] ].\r\r\tdummy next: tail next.\r\r\t^ tail object\r\t"},{"name":"nextOrNil","linesOfCode":2,"sourceCode":"nextOrNil\r\t^ self nextIfNone: [ nil ]"},{"name":"initialize","linesOfCode":5,"sourceCode":"initialize\r\t| dummy |\r\tdummy := self newItem.\r\tdummy next: nil; object: dummy.\r\thead := dummy."},{"name":"push:","linesOfCode":2,"sourceCode":"push: anObject\r\t^ self nextPut: anObject"},{"name":"errorEmptyStack","linesOfCode":2,"sourceCode":"errorEmptyStack\r\tself error: 'this stack is empty'"},{"name":"next","linesOfCode":19,"sourceCode":"next\r\t| dummy tail |\r\r\tdummy := self newItem.\r\tdummy object: dummy.\r\r\t\"this is atomic\"\r\ttail := head.\r\thead := dummy.\r\r\t\"skip over dummies\"\r\t[ tail object == tail ] whileTrue: [ \r\t\t[ tail isCircular ] whileTrue: [ self yield ].\r\t\t(tail := tail next) ifNil: [  | result |\r\t\t\t\"queue is empty. block until new items appear\"\r\t\t\thead == dummy ifTrue: [ self signalNoMoreItems ].\r\t\t\t[ head == dummy ] whileTrue: [ self waitForNewItems ].\r\t\t\tdummy next: nil. \r\t\t\tresult := self next.\r\t\t\t^ result ] ].\r\r\tdummy next: tail next.\r\r\t^ tail object\r\t"},{"name":"peek","linesOfCode":9,"sourceCode":"peek\r\t\"answer a top-most value without removing it,  or nil, if queue is empty.\r\tMay block if there's another process reading from queue\"\r\t\r\t| item result |\r\titem := head.\r\t\r\t[ (result := item object) == item ] whileTrue: [ \r\t\t[ item isCircular ] whileTrue: [ self yield ].\r\t\t(item := item next) ifNil: [ ^ nil ] ].\r\t\r\t^ result"}],"meta":{"name":"LIFOQueue class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WaitfreeQueue","instanceVariables":[{"name":"tail"},{"name":"dummy"}],"methods":[{"name":"removeAll","linesOfCode":6,"sourceCode":"removeAll\r\t\"\r\tThis message makes no sense in concurrent environment. There is no way to guarantee that when this method returns to sender, the queue will remain empty,\r\tbecause at any moment other process may interrupt current process and put new item(s) to queue.\r\r\tTherefore we just flush the queue and hope for the best\"\r\t\r\tself flush"},{"name":"isEmpty","linesOfCode":15,"sourceCode":"isEmpty\r\t\"Answer true if queue contains at least one element.\r\tNote, that answer is non-deterministic, because sender could be interrupted at any moment,\r\tmeans that even if message answers true, there is no any guarantees that consequent #nextXX messages could \r\tretrieve item(s) from queue.\r\t\r\tTherefore use of this method is discouraged. \r\tThis test will work only if sender is the only process, which fetching items from queue. If there are two or more processes which \r\tfetching items from queue, using this method makes no sense \"\r\t\r\t| item |\r\r\titem := dummy next.\r\r\t[  item object == dummy ] whileTrue: [\r\t\titem isCircular ifTrue: [ ^ true ].\r\t\titem := item next.\r\t].\r\t\r\t^ false"},{"name":"nextIfNone:","linesOfCode":16,"sourceCode":"nextIfNone: aBlock\r\t\"Attempt to fetch the next item from queue. Evaluate a block if attempt is failed i.e. there is no items available or queue is locked by another process\"\r\t\r\t| item result |\r\r\t(item := dummy makeCircular) == dummy ifTrue: [\r\t\t\"queue is either empty or currently locked by other feeder,\r\t\tjust give a quick answer that item not found\"\r\t\t ^ aBlock value  ].\r\r\t[ (result := item object) == dummy ] whileTrue: [\r\t\titem isCircular ifTrue: [ \r\t\t\tself signalNoMoreItems. \r\t\t\tdummy next: item. ^ aBlock value ].\r\t\titem := item next.\r\t].\r\t\r\titem object: dummy.\r\r\tdummy next: item next.\r\t^ result\r"},{"name":"dummy","linesOfCode":4,"sourceCode":"dummy\r\t\"Answer the dummy entry of the receiver.\r\tThis is internal state and is only for automated unit testing\"\r\r\t^dummy"},{"name":"printOn:","linesOfCode":6,"sourceCode":"printOn: aStream\r\r\taStream \r\t\tnextPutAll: self class name;\r\t\tnextPutAll: ' with ';\r\t\tprint: self size;\r\t \tnextPutAll: ' items' ."},{"name":"flush:","linesOfCode":24,"sourceCode":"flush: aFlushBlock\r\t\"Process all currently available items, passing each item to a flush block.\r\tIf there is another process, which currently fetching items from queue, or queue is empty,\r\treturn immediately\"\r\t\r\t| item |\r\r\titem := dummy makeCircular. \r\titem == dummy ifTrue: [ ^ self  ].\r\r\t[ | object |\r\t\tobject := item object.\r\t\tobject == dummy ifFalse: [\r\t\t\t[ aFlushBlock value: object ] ifCurtailed: [ \r\t\t\t\titem object: dummy.\r\t\t\t\tdummy next: item next ].\r\t\t].\r\t\titem object: dummy.\r\t\t\r\t\titem isCircular ifTrue: [\r\t\t\t\"this was the last one\"\r\t\t\tdummy next: item.\r\t\t\tself signalNoMoreItems.\r\t\t\t^ self\r\t\t\t].\r\t\titem := item next.\r\t] repeat.\r\r\t"},{"name":"nextPut:","linesOfCode":12,"sourceCode":"nextPut: value\r\t\" Add new item to queue \"\r\t| item oldTail |\r\t\r\titem := self newItem.\r\titem object: value.\r\r\t\" atomic swap here\"\r\toldTail := tail.\r\ttail := item.\r\t\r\t\"self interrupt\"\r\t\r\toldTail next: item.\r\r\tself signalAddedNewItem.\r\r\t^ value"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\tdummy := AtomicQueueItem new.\r\tdummy object: dummy.\r\ttail := dummy.\r"},{"name":"flush","linesOfCode":2,"sourceCode":"flush\r\tself flush: [:ea | ]"},{"name":"itemCount","linesOfCode":14,"sourceCode":"itemCount\r\t\"Answer the number of items in the queue including zombies. \r\tIf queue is currently in the middle of extraction by other process, give a (very) approximate answer.\r\t\r\tThis method has a non-deterministic result due to the design of the concurrent shared queue. \r\t\"\r\t\r\t| item count |\r\r\titem := dummy.\r\r\tcount := 0.\r\t[ item := item next. item == dummy ifFalse: [ count := count + 1 ]. item isCircular ] whileFalse.\r\r\tcount = 0 ifTrue: [\r\t\t\"if queue is locked by other process, check the tail and give a (very) approximate answer.\"\r\t\t^ tail object == dummy ifTrue: [ 0 ] ifFalse: [ 1 ]\r\t\t].\t\r\r\t^ count"},{"name":"flushAllSuchThat:","linesOfCode":19,"sourceCode":"flushAllSuchThat: aBlock\r\t\"Remove from the queue all objects that satisfy aBlock.\r\tNote, the operation is no-op, if queue is currently in the middle of extraction by other process\"\r\t\r\t| item first |\r\r\t(item := dummy makeCircular) == dummy ifTrue: [ ^ self ]. \r\tfirst := item.\r\t\r\t[ | object |\r\t\tobject := item object.\r\t\tobject == dummy ifFalse: [\r\t\t\t( [ aBlock value: object ] ifCurtailed: [ dummy next: first ] ) ifTrue: [\r\t\t\t\titem object: dummy.\r\t\t\t] ].\r\t\r\t\titem isCircular ifTrue: [\r\t\t\t\"this was the last one\"\r\t\t\tdummy next: first.\r\t\t\t^ self\r\t\t\t].\r\t\titem := item next.\r\t] repeat."},{"name":"size","linesOfCode":14,"sourceCode":"size\r\t\"Answer the size of queue. \r\tIf queue is currently in the middle of extraction by other process, give a (very) approximate answer.\r\t\r\tThis method having a non-deterministic results, because of nature of concurrent shared queue. \r\t\"\r\t\r\t| item count |\r\r\titem := dummy.\r\r\tcount := 0.\r\t[ item := item next. item object == dummy ifFalse: [ count := count + 1]. item isCircular ] whileFalse.\r\r\tcount = 0 ifTrue: [\r\t\t\"if queue is locked by other process, check the tail and give a (very) approximate answer.\"\r\t\t^ tail object == dummy ifTrue: [ 0 ] ifFalse: [ 1]\r\t\t].\t\r\r\t^ count"},{"name":"tail","linesOfCode":4,"sourceCode":"tail\r\t\"Answer the tail entry of the receiver.\r\tThis is internal state and is only for automated unit testing\"\r\r\t^tail"},{"name":"nextOrNilSuchThat:","linesOfCode":43,"sourceCode":"nextOrNilSuchThat: aBlock\r\t\"Fetch an object from queue that satisfies aBlock, skipping (but not removing) any intermediate objects.\r\tIf no object has been found, answer <nil> and leave me intact.\r\t\r\tNOTA BENE:  aBlock can contain a non-local return (^).\r\tFound item is removed from queue.\r\r\tIf queue currently in the middle of extraction by other process, don't wait and return <nil> immediately\"\r\t\r\t| item first previous object |\r\r\t(first := dummy makeCircular) == dummy  ifTrue: [ ^ nil ]. \r\r\t\"Remove any zombie objects from the start of the list\"\r\t[ (object := first object) == dummy ] whileTrue: [\r\t\tfirst isCircular ifTrue: [ \r\t\t\tself signalNoMoreItems. \r\t\t\tdummy next: first. ^ nil ].\r\t\tfirst := first next.\r\t].\r\r\tprevious := nil.\r\titem := first.\r\t\"Iterate over the list searching for the requested entry and removing zombies\"\r\t[\r\t\tobject := item object.\r\t\tobject == dummy ifTrue: [ \r\t\t\t\"Remove the object unless it is the last.\r\t\t\tThis can't happen on the first iteration, so no need to check previous\"\r\t\t\titem isCircular ifFalse: [ \r\t\t\t\tprevious next: item next ] ]\r\t\tifFalse: [\r\t\t\t( [ aBlock value: object ] ifCurtailed: [ dummy next: first ] ) ifTrue: [\r\t\t\t\titem object: dummy.\r\t\t\t\tprevious ifNotNil: [ \r\t\t\t\t\tprevious next: item next.\r\t\t\t\t\tdummy next: first ]\r\t\t\t\tifNil: \r\t\t\t\t\t[ dummy next: item next ].\r\t\t\t\t^ object ]\r\t\t\tifFalse:\r\t\t\t\t[ previous := item ] ].\r\t\r\t\titem isCircular ifTrue: [\r\t\t\t\"this was the last one\"\r\t\t\tdummy next: first.\r\t\t\t^ nil\r\t\t\t].\r\r\t\titem := item next.\r\t] repeat.\r"},{"name":"initializeWithAll:","linesOfCode":7,"sourceCode":"initializeWithAll: aCollection\r\t\"Initialise the receiver with the supplied items (AtomicQueueItem).\r\tThis method is not thread safe and should only be used for initialising the queue prior to normal operation (and is normally used only for testing).\"\r\r\tdummy next: aCollection first.\r\t1 to: aCollection size - 1 do: [ :i |\r\t\t(aCollection at: i) next: (aCollection at: i+1) ].\r\ttail := aCollection last."},{"name":"nextOrNil","linesOfCode":4,"sourceCode":"nextOrNil\r\t\"Fetch next item from queue, or nil if queue is either empty or in the middle of extraction by other process.\r\tIf queue can contain a nil as element, use #nextIfNone: instead \"\r\t^ self nextIfNone: nil"},{"name":"findFirst:","linesOfCode":4,"sourceCode":"findFirst: aBlock\r\t\"Note, this method only for backward compatibility. It duplicating the semantics of #nextOrNilSuchThat: completely.\r\tUse #nextOrNilSuchThat: instead \"\r\r\t\r\t^ self nextOrNilSuchThat: aBlock\r\t"},{"name":"peek","linesOfCode":17,"sourceCode":"peek\r\t\"Answer the object that was sent through the receiver first and has not \r\tyet been received by anyone but do not remove it from the receiver. \r\tIf queue is empty or there are other process currently fetching object from queue, answer nil.\r\t\r\tNote: do not assume that if #peek answers non-nil object, the next message sent to queue,\r\tlike #next or #nextOrNil will answer the same item.\r\tThe use of this method is discouraged , it is provided only for backward compatibility.\r\t\"\r\r\t| item result |\r\r\titem := dummy next. \r\r\t[ (result := item object) == dummy ] whileTrue: [\r\t\titem isCircular ifTrue: [ \r\t\t\tself signalNoMoreItems. \r\t\t\t^ nil ].\r\t\titem := item next.\r\t].\r\t\r\t^ result\r"}],"meta":{"name":"WaitfreeQueue class","instanceVariables":[],"methods":[{"name":"withAll:","linesOfCode":3,"sourceCode":"withAll: aCollection\r\t\"Answer an instance of the receiver initialised with the supplied collection of items\"\r\r\t^self new initializeWithAll: aCollection"},{"name":"new:","linesOfCode":3,"sourceCode":"new: anInteger \r\t\"Just to match SharedQueue protocol\"\r\t^self new"}],"meta":null}}]},{"name":"Collections-Native","classes":[{"name":"IntegerArray","instanceVariables":[],"methods":[{"name":"at:","linesOfCode":9,"sourceCode":"at: index\r\t| word |\r\t<primitive: 165>\r\tword := self basicAt: index.\r\tword < 16r3FFFFFFF ifTrue:[^word]. \"Avoid LargeInteger computations\"\r\t^word >= 16r80000000\t\"Negative?!\"\r\t\tifTrue:[\"word - 16r100000000\"\r\t\t\t\t(word bitInvert32 + 1) negated]\r\t\tifFalse:[word]"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"asIntegerArray","linesOfCode":2,"sourceCode":"asIntegerArray\r\t^self"},{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"primFill:","linesOfCode":4,"sourceCode":"primFill: aPositiveInteger\r\t\"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays.\"\r\r\t<primitive: 145>\r\tself errorImproperStore."},{"name":"at:put:","linesOfCode":9,"sourceCode":"at: index put: anInteger\r\t| word |\r\t<primitive: 166>\r\tanInteger < 0\r\t\tifTrue:[\"word := 16r100000000 + anInteger\"\r\t\t\t\tword := (anInteger + 1) negated bitInvert32]\r\t\tifFalse:[word := anInteger].\r\tself  basicAt: index put: word.\r\t^anInteger"},{"name":"atAllPut:","linesOfCode":7,"sourceCode":"atAllPut: anInteger\r\t| word |\r\tanInteger < 0\r\t\tifTrue:[\"word := 16r100000000 + anInteger\"\r\t\t\t\tword := (anInteger + 1) negated bitInvert32]\r\t\tifFalse:[word := anInteger].\r\tself primFill: word."}],"meta":{"name":"IntegerArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ManifestCollectionsNative","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsNative class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'Collections-Streams')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Abstract' #Kernel #'Collections-Strings')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Native'"}],"meta":null}},{"name":"WordArray","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 4"},{"name":"primDivScalar:and:into:","linesOfCode":7,"sourceCode":"primDivScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveDivScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveDivScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) / other.\r\t].\r\t^ result.\r"},{"name":"primSubArray:and:into:","linesOfCode":7,"sourceCode":"primSubArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveSubArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveSubArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) - (other at: i)\r\t].\r\t^ result.\r"},{"name":"asWordArray","linesOfCode":2,"sourceCode":"asWordArray\r\t^self"},{"name":"+","linesOfCode":14,"sourceCode":"+ other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primAddScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primAddArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primAddArray: self and: other into: result ].\r\t^ super + other"},{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":3,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t<primitive: 105>\r\t^super replaceFrom: start to: stop with: replacement startingAt: repStart "},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"primSubScalar:and:into:","linesOfCode":7,"sourceCode":"primSubScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveSubScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveSubScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) - other.\r\t].\r\t^ result.\r"},{"name":"*","linesOfCode":14,"sourceCode":"* other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primMulScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primMulArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primMulArray: self and: other into: result ].\r\t^ super * other"},{"name":"primAddArray:and:into:","linesOfCode":7,"sourceCode":"primAddArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveAddArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveAddArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) + (other at: i)\r\t].\r\t^ result.\r"},{"name":"primAddScalar:and:into:","linesOfCode":7,"sourceCode":"primAddScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveAddScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveAddScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) + other.\r\t].\r\t^ result.\r"},{"name":"-","linesOfCode":14,"sourceCode":"- other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primSubScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primSubArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primSubArray: self and: other into: result ].\r\t^ super - other"},{"name":"primMulArray:and:into:","linesOfCode":7,"sourceCode":"primMulArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveMulArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveMulArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) * (other at: i)\r\t].\r\t^ result.\r"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"/","linesOfCode":14,"sourceCode":"/ other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primDivScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primDivArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primDivArray: self and: other into: result ].\r\t^ super / other"},{"name":"primDivArray:and:into:","linesOfCode":7,"sourceCode":"primDivArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveDivArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveDivArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) / (other at: i)\r\t].\r\t^ result.\r"},{"name":"primMulScalar:and:into:","linesOfCode":7,"sourceCode":"primMulScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveMulScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveMulScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) * other.\r\t].\r\t^ result.\r"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"}],"meta":{"name":"WordArray class","instanceVariables":[],"methods":[{"name":"newFromStream:","linesOfCode":10,"sourceCode":"newFromStream: s\r\t\"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk.\"\r\t| len |\r\r\ts next = 16r80 ifTrue:\r\t\t[\"A compressed format.  Could copy what BitMap does, or use a \r\t\tspecial sound compression format.  Callers normally compress their own way.\"\r\t\t^ self error: 'not implemented'].\r\ts skip: -1.\r\tlen := s nextInt32.\r\t^ s nextWordsInto: (self basicNew: len)"}],"meta":null}},{"name":"DoubleWordArray","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 8"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"bytesPerElement","linesOfCode":3,"sourceCode":"bytesPerElement\r\t\"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored.\"\r\t^ 8"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"}],"meta":{"name":"DoubleWordArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FloatArray","instanceVariables":[],"methods":[{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0.0"},{"name":"primSubScalar:","linesOfCode":3,"sourceCode":"primSubScalar: scalarValue\r\r\t<primitive: 'primitiveSubScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue]."},{"name":"asFloatArray","linesOfCode":2,"sourceCode":"asFloatArray\r\t^self"},{"name":"*","linesOfCode":2,"sourceCode":"* anObject\r\t^self copy *= anObject"},{"name":"/=","linesOfCode":4,"sourceCode":"/= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primDivScalar: anObject asFloat]\r\t\tifFalse:[self primDivArray: anObject]"},{"name":"=","linesOfCode":9,"sourceCode":"= aFloatArray \r\t| length |\r\t<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>\r\taFloatArray class = self class ifFalse: [^ false].\r\tlength := self size.\r\tlength = aFloatArray size ifFalse: [^ false].\r\t1 to: self size do: [:i | (self at: i)\r\t\t\t= (aFloatArray at: i) ifFalse: [^ false]].\r\t^ true"},{"name":"primAddScalar:","linesOfCode":3,"sourceCode":"primAddScalar: scalarValue\r\r\t<primitive: 'primitiveAddScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue]."},{"name":"-","linesOfCode":2,"sourceCode":"- anObject\r\t^self shallowCopy -= anObject"},{"name":"primMulArray:","linesOfCode":3,"sourceCode":"primMulArray: floatArray\r\r\t<primitive: 'primitiveMulFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)]."},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"/","linesOfCode":2,"sourceCode":"/ anObject\r\t^self copy /= anObject"},{"name":"hash","linesOfCode":6,"sourceCode":"hash\r\t| result |\r\t<primitive:'primitiveHashArray' module: 'FloatArrayPlugin'>\r\tresult := 0.\r\t1 to: self size do:[:i| result := result + (self basicAt: i) ].\r\t^result bitAnd: 16r1FFFFFFF"},{"name":"+=","linesOfCode":2,"sourceCode":"+= anObject\r\t^ anObject addAssignToFloatArray: self"},{"name":"primDivArray:","linesOfCode":3,"sourceCode":"primDivArray: floatArray\r\r\t<primitive: 'primitiveDivFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)]."},{"name":"primMulScalar:","linesOfCode":3,"sourceCode":"primMulScalar: scalarValue\r\r\t<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue]."},{"name":"primDivScalar:","linesOfCode":3,"sourceCode":"primDivScalar: scalarValue\r\r\t<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue]."},{"name":"primSubArray:","linesOfCode":3,"sourceCode":"primSubArray: floatArray\r\r\t<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)]."},{"name":"sum","linesOfCode":3,"sourceCode":"sum\r\r\t<primitive: 'primitiveSum' module: 'FloatArrayPlugin'>\r\t^ super sum"},{"name":"\\\\=","linesOfCode":10,"sourceCode":"\\\\= other\r\r\tother isNumber ifTrue: [\r\t\t1 to: self size do: [:i |\r\t\t\tself at: i put: (self at: i) \\\\ other\r\t\t].\r\t\t^ self.\r\t].\r\t1 to: (self size min: other size) do: [:i |\r\t\tself at: i put: (self at: i) \\\\ (other at: i).\r\t].\r\r"},{"name":"adaptToNumber:andSend:","linesOfCode":14,"sourceCode":"adaptToNumber: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a Number. If possible,\r\tconvert it to a float and perform the (more efficient) primitive operation.\"\r\tselector == #+ ifTrue:[^self + rcvr].\r\tselector == #* ifTrue:[^self * rcvr].\r\tselector == #- ifTrue:[^self negated += rcvr].\r\tselector == #/ ifTrue:[\r\t\t\"DO NOT USE TRIVIAL CODE\r\t\t\t^self reciprocal * rcvr\r\t\tBECAUSE OF GRADUAL UNDERFLOW\r\t\tself should: (1.0e-39 / (FloatArray with: 1.0e-39)) first < 2.\"\r\t\t\t^(self class new: self size withAll: rcvr) / self\r\t\t].\r\t^super adaptToNumber: rcvr andSend: selector"},{"name":"+","linesOfCode":2,"sourceCode":"+ anObject\r\t^self copy += anObject"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"primAddArray:","linesOfCode":3,"sourceCode":"primAddArray: floatArray\r\r\t<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)]."},{"name":"addAssignToFloatArray:","linesOfCode":2,"sourceCode":"addAssignToFloatArray: aFloatArray\r\t^ self primAddArray: aFloatArray"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index\r\t<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>\r\t^Float fromIEEE32Bit: (self basicAt: index)"},{"name":"dot:","linesOfCode":10,"sourceCode":"dot: aFloatVector\r\t\"Primitive. Return the dot product of the receiver and the argument.\r\tFail if the argument is not of the same size as the receiver.\"\r       | result |\r\t<primitive: 'primitiveDotProduct' module: 'FloatArrayPlugin'>\r\tself size = aFloatVector size ifFalse:[^self error:'Must be equal size'].\r\tresult := 0.0.\r\t1 to: self size do:[:i|\r\t\tresult := result + ((self at: i) * (aFloatVector at: i))].\r\t^result"},{"name":"negated","linesOfCode":2,"sourceCode":"negated\r\t^self copy *= -1"},{"name":"*=","linesOfCode":4,"sourceCode":"*= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primMulScalar: anObject asFloat]\r\t\tifFalse:[self primMulArray: anObject]"},{"name":"-=","linesOfCode":4,"sourceCode":"-= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primSubScalar: anObject asFloat]\r\t\tifFalse:[self primSubArray: anObject]"},{"name":"at:put:","linesOfCode":6,"sourceCode":"at: index put: value\r\t<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>\r\tvalue isFloat \r\t\tifTrue:[self basicAt: index put: value asIEEE32BitWord]\r\t\tifFalse:[self at: index put: value asFloat].\r\t^value"}],"meta":{"name":"FloatArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"DoubleByteArray","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 2"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"bytesPerElement","linesOfCode":3,"sourceCode":"bytesPerElement\r\t\"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored.\"\r\t^ 2"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"}],"meta":{"name":"DoubleByteArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ByteArray","instanceVariables":[],"methods":[{"name":"signedShortAt:put:","linesOfCode":2,"sourceCode":"signedShortAt: byteIndex put: value\r\t^ self int16AtOffset: byteIndex - 1 put: value"},{"name":"packAsDoubleToArity:","linesOfCode":4,"sourceCode":"packAsDoubleToArity: arity\r\t\"In case I sending a buffer to get the contents I need to understand this message. \r\t See AthensCairoCanvas>>getCurrentPoint as an example.\"\r\t^ self packToArity: arity "},{"name":"pointerAtOffset:put:","linesOfCode":9,"sourceCode":"pointerAtOffset: zeroBasedOffset put: value\r\t<primitive: 624>\r\t\"Store a pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\tself unsignedByteAt: zeroBasedOffset+i put: (value basicAt: i)].\r\t^value"},{"name":"isNull","linesOfCode":3,"sourceCode":"isNull\r\t\"Answer false since only external addresses can be null\"\r\t^false"},{"name":"longPointerAt:","linesOfCode":8,"sourceCode":"longPointerAt: byteIndex\r\t\"Answer an 8-byte pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress basicNew: 8.\r\t1 to: 8 do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: byteIndex+i-1)].\r\t^addr"},{"name":"float32AtOffset:put:","linesOfCode":3,"sourceCode":"float32AtOffset: zeroBasedOffset put: value\r\t<primitive: 628>\r\t\r\t^ FFIBackend current on: self float32At: zeroBasedOffset + 1 put: value\r"},{"name":"float64AtOffset:","linesOfCode":3,"sourceCode":"float64AtOffset: zeroBasedOffset\r\t<primitive: 614>\r\t\r\t^ FFIBackend current on: self float64At: zeroBasedOffset + 1\r"},{"name":"int32AtOffset:","linesOfCode":3,"sourceCode":"int32AtOffset: zeroBasedOffset\r\t<primitive: 606>\r\t^ self integerAt: zeroBasedOffset + 1 size: 4 signed: true"},{"name":"uint16AtOffset:put:","linesOfCode":3,"sourceCode":"uint16AtOffset: zeroBasedOffset put: value\r\t<primitive: 618>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 2 signed: false"},{"name":"lastIndexOfPKSignature:","linesOfCode":15,"sourceCode":"lastIndexOfPKSignature: aSignature\r\t\"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found\"\r\t| a b c d |\r\ta := aSignature first.\r\tb := aSignature second.\r\tc := aSignature third.\r\td := aSignature fourth.\r\t(self size - 3) to: 1 by: -1 do: [ :i |\r\t\t(((self at: i) = a)\r\t\t\tand: [ ((self at: i + 1) = b)\r\t\t\t\tand: [ ((self at: i + 2) = c)\r\t\t\t\t\tand: [ ((self at: i + 3) = d) ]]])\r\t\t\t\t\t\tifTrue: [ ^i ]\r\t].\r\t^0"},{"name":"stonOn:","linesOfCode":3,"sourceCode":"stonOn: stonWriter\r\t\"Use a hex representation\"\r\t\r\tstonWriter writeObject: self listSingleton: self hex"},{"name":"oldIntegerAt:put:size:signed:","linesOfCode":7,"sourceCode":"oldIntegerAt: byteOffset put: value size: nBytes signed: aBoolean\r\t\"Primitive. Store the given value as integer of nBytes size\r\tin the receiver. Fail if the value is out of range.\r\tNote: This primitive will access memory in the outer space if\r\tinvoked from ExternalAddress.\"\r\t<primitive: 'primitiveFFIIntegerAtPut' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"platformSizeTAt:put:","linesOfCode":6,"sourceCode":"platformSizeTAt: byteOffset put: value\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture sizeTTypeSize\r\t\tsigned: false"},{"name":"platformUnsignedLongAt:put:","linesOfCode":6,"sourceCode":"platformUnsignedLongAt: byteOffset put: value\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize \r\t\tsigned: false"},{"name":"bgraColorAt:","linesOfCode":7,"sourceCode":"bgraColorAt: index\r\t| b g r a |\r\tb := (self unsignedByteAt: index) asFloatFromNormalizedUByte.\r\tg := (self unsignedByteAt: index + 1) asFloatFromNormalizedUByte.\r\tr := (self unsignedByteAt: index + 2) asFloatFromNormalizedUByte.\r\ta := (self unsignedByteAt: index + 3) asFloatFromNormalizedUByte.\r\t^ Float32x4 x: r y: g z: b w: a"},{"name":"floatAt:put:","linesOfCode":2,"sourceCode":"floatAt: byteIndex put: value\r\t^ self float32AtOffset: byteIndex - 1 put: value"},{"name":"nbInt16AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt16AtOffset: zeroBasedOffset put: value\r\t\"Store signed 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedShortAt: zeroBasedOffset + 1 put: value"},{"name":"indexOf:startingAt:","linesOfCode":3,"sourceCode":"indexOf: anInteger startingAt: start\r\r\t(anInteger isInteger and: [ anInteger between: 0 and: 255 ]) ifFalse: [ ^0 ].\r\t^ByteString indexOfAscii: anInteger inString: self startingAt: start"},{"name":"unsignedLongAt:put:bigEndian:","linesOfCode":19,"sourceCode":"unsignedLongAt: index put: value bigEndian: aBool\r\t\"Store a 32bit unsigned integer quantity starting from the given byte index\"\r\t| b0 b1 b2 b3 |\r\tb0 := value bitShift: -24.\r\tb1 := (value bitShift: -16) bitAnd: 255.\r\tb2 := (value bitShift: -8) bitAnd: 255.\r\tb3 := value bitAnd: 255.\r\taBool ifTrue:[\r\t\tself at: index put: b0.\r\t\tself at: index+1 put: b1.\r\t\tself at: index+2 put: b2.\r\t\tself at: index+3 put: b3.\r\t] ifFalse:[\r\t\tself at: index put: b3.\r\t\tself at: index+1 put: b2.\r\t\tself at: index+2 put: b1.\r\t\tself at: index+3 put: b0.\r\t].\r\t^value"},{"name":"boolean8AtOffset:","linesOfCode":3,"sourceCode":"boolean8AtOffset: zeroBasedOffset\r\t<primitive: 600>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 1 signed: false) ~= 0"},{"name":"nbInt8AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt8AtOffset: zeroBasedOffset put: value\r\t\"Store signed 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self signedByteAt: zeroBasedOffset + 1 put: value"},{"name":"zipped","linesOfCode":7,"sourceCode":"zipped\r\t\"Return a ByteArray containing a GZIP compressed version of the receiver\"\r\t\r\t\"#[ 1 2 3 ] zipped >>> #[31 139 8 0 0 0 0 0 0 0 99 100 98 6 0 29 128 188 85 3 0 0 0]\"\r\r\t^ ByteArray streamContents: [ :out | \r\t\t(GZipWriteStream on: out)\r\t\t\tnextPutAll: self;\r\t\t\tclose ]"},{"name":"pointerAt:","linesOfCode":2,"sourceCode":"pointerAt: byteIndex\r\t^ self pointerAtOffset: byteIndex - 1"},{"name":"nbUInt16AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt16AtOffset: zeroBasedOffset put: value\r\t\"Store unsigned 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self unsignedShortAt: zeroBasedOffset + 1 put: value"},{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size"},{"name":"int16AtOffset:put:","linesOfCode":3,"sourceCode":"int16AtOffset: zeroBasedOffset put: value\r\t<primitive: 619>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 2 signed: true"},{"name":"int8AtOffset:put:","linesOfCode":3,"sourceCode":"int8AtOffset: zeroBasedOffset put: value\r\t<primitive: 617>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 1 signed: true"},{"name":"putOn:","linesOfCode":6,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream by iterating over its elements.\r\tIn general we assume aStream accepts the receiver's elements as element type.\r\tThis is an optimisation.\r\tReturn self.\"\r\r\taStream nextPutAll: self"},{"name":"uint32AtOffset:","linesOfCode":3,"sourceCode":"uint32AtOffset: zeroBasedOffset\r\t<primitive: 605>\r\t^ self integerAt: zeroBasedOffset + 1 size: 4 signed: false"},{"name":"printOn:","linesOfCode":6,"sourceCode":"printOn: aStream\r\r\taStream nextPutAll: '#['.\r\tself\r\t\tdo: [ :each | each printOn: aStream ]\r\t\tseparatedBy: [ aStream nextPut: $ ].\r\taStream nextPut: $]"},{"name":"unzipped","linesOfCode":5,"sourceCode":"unzipped\r\t\"Assuming the receiver contains GZIP compressed data, \r\treturn a ByteArray with the decompressed data.\"\r\t\r\t\"#[31 139 8 0 0 0 0 0 0 0 99 100 98 6 0 29 128 188 85 3 0 0 0] unzipped >>> #[1 2 3]\"\r\r\t^ (GZipReadStream on: self) upToEnd"},{"name":"int64AtOffset:put:","linesOfCode":3,"sourceCode":"int64AtOffset: zeroBasedOffset put: value\r\t<primitive: 623>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 8 signed: true"},{"name":"gtInspectorHexDumpIn:","linesOfCode":16,"sourceCode":"gtInspectorHexDumpIn: composite\r\t<gtInspectorPresentationOrder: 40>\r\tcomposite text\r\t\t\ttitle: 'Hex Dump';\r\t\t\tformat: #asText;\r\t\t\twhen: [ self isCompiledMethod not ];\r\t\t\tdisplay: [ | maxBytes displayStream displayString |\r\t\t\t\tmaxBytes := 10000.\r\t\t\t\tdisplayStream := (String new: maxBytes * 5) writeStream.\r\t\t\t\tself hexDumpOn: displayStream max: maxBytes.\r\t\t\t\tdisplayString := displayStream contents asText.\r\t\t\t\tdisplayString addAttribute: (TextFontReference\r\t\t\t\t\t\ttoFont: (LogicalFont \r\t\t\t\t\t\t\tfamilyName: 'Source Code Pro' \r\t\t\t\t\t\t\tpointSize: StandardFonts defaultFont pointSize)).\r\t\t\t\tdisplayString asText ]"},{"name":"isLiteral","linesOfCode":4,"sourceCode":"isLiteral\r\t\"so that #(1 #[1 2 3] 5) prints itself\"\r\t\"\"\r\t^ self class == ByteArray"},{"name":"asByteArrayOfSize:","linesOfCode":14,"sourceCode":"asByteArrayOfSize: size\r\t\"\r\t\t'34523' asByteArray asByteArrayOfSize: 100.\r\r\t\u0010(((\r\t\t| repeats bytes | \r\t\trepeats := 1000000.\r\t\tbytes := '123456789123456789123456789123456789123456789123456789' asByteArray.\r\t\t [repeats timesRepeat: (bytes asByteArrayOfSize: 1024) ] timeToRun.\r\t)))\"\r\r\t| bytes |\r\tsize < self size\r\t\tifTrue: [^ self error: 'bytearray bigger than ', size asString].\r\tbytes := self asByteArray.\r\t^ (ByteArray new: (size - bytes size)), bytes\r"},{"name":"nbUInt8AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt8AtOffset: zeroBasedOffset put: value\r\t\"Store unsigned 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedByteAt: zeroBasedOffset + 1 put: value"},{"name":"longPointerAt:put:","linesOfCode":8,"sourceCode":"longPointerAt: byteIndex put: value\r\t\"Store an 8-byte pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: 8 do:\r\t\t[:i|\r\t\tself unsignedByteAt: byteIndex+i-1 put: (value basicAt: i)].\r\t^value"},{"name":"shortPointerAt:put:","linesOfCode":8,"sourceCode":"shortPointerAt: byteIndex put: value\r\t\"Store a 4-byte pointer object at the given byte address\"\r\tvalue isExternalAddress ifFalse:\r\t\t[^self error:'Only external addresses can be stored'].\r\t1 to: 4 do:\r\t\t[:i|\r\t\tself unsignedByteAt: byteIndex+i-1 put: (value basicAt: i)].\r\t^value"},{"name":"shortAt:put:bigEndian:","linesOfCode":4,"sourceCode":"shortAt: index put: value bigEndian: aBool\r\t\"Store a 16 bit integer quantity starting from the given byte index\"\r\tself unsignedShortAt: index put: (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000) bigEndian: aBool.\r\t^value"},{"name":"oldFFIPrimFloat64At:","linesOfCode":3,"sourceCode":"oldFFIPrimFloat64At: byteOffset\r\t<primitive:'primitiveFFIDoubleAt' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"nbFloat32AtOffset:","linesOfCode":3,"sourceCode":"nbFloat32AtOffset: zeroBasedOffset\r\t\"Read 32-bit float at ZERO-based index.\"\r\t^ self floatAt: zeroBasedOffset + 1"},{"name":"unsignedLongAt:put:","linesOfCode":2,"sourceCode":"unsignedLongAt: byteIndex put: value\r\t^ self uint32AtOffset: byteIndex - 1 put: value"},{"name":"decodeWith:","linesOfCode":5,"sourceCode":"decodeWith: encoding\r\t\"Produce a String that decodes the receiver, using a specified encoding.\r\tEncoding is either a ZnCharacterEncoder instance or an identifier for one.\"\r\t\r\t\"#[76 101 115 32 195 169 108 195 168 118 101 115 32 102 114 97 110 195 167 97 105 115] decodeWith: #utf8\"\r\t\r\t^ encoding asZnCharacterEncoder decodeBytes: self"},{"name":"uint16AtOffset:","linesOfCode":3,"sourceCode":"uint16AtOffset: zeroBasedOffset\r\t<primitive: 603>\r\t^ self integerAt: zeroBasedOffset + 1 size: 2 signed: false"},{"name":"pointerAt:put:","linesOfCode":2,"sourceCode":"pointerAt: byteIndex put: value\r\t^ self pointerAtOffset: byteIndex - 1 put: value"},{"name":"byteAt:put:","linesOfCode":3,"sourceCode":"byteAt: index put: value\r\t<primitive: 61>\r\t^self at: index put: value"},{"name":"platformBitAt:put:","linesOfCode":6,"sourceCode":"platformBitAt: byteOffset put: value\r\t\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize\r\t\tsigned: true"},{"name":"signedLongLongAt:put:","linesOfCode":2,"sourceCode":"signedLongLongAt: byteIndex put: value\r\t^ self int64AtOffset: byteIndex - 1 put: value"},{"name":"shortPointerAt:","linesOfCode":8,"sourceCode":"shortPointerAt: byteIndex\r\t\"Answer a 4-byte pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress basicNew: 4.\r\t1 to: 4 do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: byteIndex+i-1)].\r\t^addr"},{"name":"nbInt8AtOffset:","linesOfCode":3,"sourceCode":"nbInt8AtOffset: zeroBasedOffset\r\t\"Reads signed 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedByteAt: zeroBasedOffset + 1"},{"name":"nbFloat64AtOffset:put:","linesOfCode":3,"sourceCode":"nbFloat64AtOffset: zeroBasedOffset put: value\r\t\"Store 64-bit float at ZERO-based index.\"\r\t^ self doubleAt: zeroBasedOffset + 1 put: value"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createObjectBytes: self class: objectModel byteArrayClass"},{"name":"bitXor:","linesOfCode":11,"sourceCode":"bitXor: aByteArray \r\t| answer |\r\tanswer := self copy.\r\t1 \r\t\tto: (self size min: aByteArray size)\r\t\tdo: \r\t\t\t[ :each | \r\t\t\tanswer \r\t\t\t\tat: each\r\t\t\t\tput: ((self at: each) bitXor: (aByteArray at: each)) ].\r\t^ answer"},{"name":"asSocketAddress","linesOfCode":2,"sourceCode":"asSocketAddress\r\t^SocketAddress fromOldByteAddress: self"},{"name":"sBGR_A_colorAt:","linesOfCode":7,"sourceCode":"sBGR_A_colorAt: index\r\t| b g r a |\r\tb := (self unsignedByteAt: index) asFloatFromNormalizedUByte decodeSRGBComponent.\r\tg := (self unsignedByteAt: index + 1) asFloatFromNormalizedUByte decodeSRGBComponent.\r\tr := (self unsignedByteAt: index + 2) asFloatFromNormalizedUByte decodeSRGBComponent.\r\ta := (self unsignedByteAt: index + 3) asFloatFromNormalizedUByte.\r\t^ Float32x4 x: r y: g z: b w: a"},{"name":"char16AtOffset:","linesOfCode":3,"sourceCode":"char16AtOffset: zeroBasedOffset\r\t<primitive: 611>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 2 signed: false) asCharacter"},{"name":"unsignedLongLongAt:","linesOfCode":2,"sourceCode":"unsignedLongLongAt: byteIndex\r\t^ self uint64AtOffset: byteIndex - 1"},{"name":"signedCharAt:","linesOfCode":2,"sourceCode":"signedCharAt: byteOffset\r\t^ self char8AtOffset: byteOffset - 1"},{"name":"signedShortAt:","linesOfCode":2,"sourceCode":"signedShortAt: byteIndex\r\t^ self int16AtOffset: byteIndex - 1"},{"name":"platformSizeTAt:","linesOfCode":5,"sourceCode":"platformSizeTAt: byteOffset\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture sizeTTypeSize\r\t\tsigned: false"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"signedLongLongAt:","linesOfCode":2,"sourceCode":"signedLongLongAt: byteIndex\r\t^ self int64AtOffset: byteIndex - 1"},{"name":"uint32AtOffset:put:","linesOfCode":3,"sourceCode":"uint32AtOffset: zeroBasedOffset put: value\r\t<primitive: 620>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 4 signed: false"},{"name":"pointerAtOffset:","linesOfCode":9,"sourceCode":"pointerAtOffset: zeroBasedOffset\r\t<primitive: 609>\r\t\"Answer a pointer object stored at the given byte address\"\r\t| addr |\r\taddr := ExternalAddress new.\r\t1 to: ExternalAddress wordSize do:\r\t\t[:i|\r\t\taddr basicAt: i put: (self unsignedByteAt: zeroBasedOffset+i)].\r\t^addr"},{"name":"hex","linesOfCode":7,"sourceCode":"hex\r\t\"Answer a lowercase hexadecimal String representation of the receiver\"\r\t\t\r\t^ String\r\t\tnew: self size * 2\r\t\tstreamContents: [ :out |\r\t\t\tself do: [ :each | each printLowercaseHexByteOn: out ] ]"},{"name":"signedCharAt:put:","linesOfCode":2,"sourceCode":"signedCharAt: byteIndex put: aCharacter\r\t^ self char8AtOffset: byteIndex - 1 put: aCharacter"},{"name":"nbInt32AtOffset:","linesOfCode":3,"sourceCode":"nbInt32AtOffset: zeroBasedOffset\r\t\"Reads signed 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1"},{"name":"uint64AtOffset:","linesOfCode":3,"sourceCode":"uint64AtOffset: zeroBasedOffset\r\t<primitive: 607>\r\t^ self integerAt: zeroBasedOffset + 1 size: 8 signed: false"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"},{"name":"unsignedByteAt:put:","linesOfCode":2,"sourceCode":"unsignedByteAt: byteIndex put: value\r\t^ self uint8AtOffset: byteIndex - 1 put: value"},{"name":"signedByteAt:","linesOfCode":3,"sourceCode":"signedByteAt: byteOffset\r    \"Return a 8bit signed integer starting at the given byte offset\"\r    ^self integerAt: byteOffset size: 1 signed: true"},{"name":"byteAt:","linesOfCode":3,"sourceCode":"byteAt: index\r\t<primitive: 60>\r\t^self at: index"},{"name":"unpackHandleFromArity:","linesOfCode":4,"sourceCode":"unpackHandleFromArity: arity\r\t\"This will 'unpack' a long (handle) from a certain arity. See #packToArity: for a better explanation.\"\r\r\tarity > 1 ifTrue: [ ^ self error: 'Use ExternalAddress instead!' ].\r\t^ self unsignedLongAt: 1\r"},{"name":"doubleAt:bigEndian:","linesOfCode":12,"sourceCode":"doubleAt: index bigEndian: bool \r\t\"Return a 64 bit float starting from the given byte index\"\r\t| w1 w2 dbl |\r\tw1 := self unsignedLongAt: index bigEndian: bool.\r\tw2 := self unsignedLongAt: index + 4 bigEndian: bool.\r\tdbl := Float new: 2. \r\tbool\r\t\tifTrue: [dbl basicAt: 1 put: w1.\r\t\t\tdbl basicAt: 2 put: w2]\r\t\tifFalse: [dbl basicAt: 1 put: w2.\r\t\t\tdbl basicAt: 2 put: w1].\r\t^ dbl"},{"name":"readHexFrom:","linesOfCode":4,"sourceCode":"readHexFrom: characterReadStream\r\t\"Initialize the receiver from a hexadecimal representation.\"\r\t\r\t1 to: self size do: [ :offset |\r\t\tself at: offset put: (Integer readHexByteFrom: characterReadStream) ]"},{"name":"nbUInt8AtOffset:","linesOfCode":3,"sourceCode":"nbUInt8AtOffset: zeroBasedOffset\r\t\"Reads unsigned 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedByteAt: zeroBasedOffset + 1"},{"name":"bgraColorAt:put:","linesOfCode":11,"sourceCode":"bgraColorAt: index put: aColor\r\t| r g b a |\r\tr := aColor r asNormalizedUByte.\r\tg := aColor g asNormalizedUByte.\r\tb := aColor b asNormalizedUByte.\r\ta := aColor a asNormalizedUByte.\r\tself\r\t\tat: index put: b;\r\t\tat: index + 1 put: g;\r\t\tat: index + 2 put: r;\r\t\tat: index + 3 put: a"},{"name":"int64AtOffset:","linesOfCode":3,"sourceCode":"int64AtOffset: zeroBasedOffset\r\t<primitive: 608>\r\t^ self integerAt: zeroBasedOffset + 1 size: 8 signed: true"},{"name":"base64Encoded","linesOfCode":8,"sourceCode":"base64Encoded\r\t\"Encode the receiver using Base64, returning a String.\r\tBase64 encoding is a technique to represent binary data as ASCII text.\r\tThe inverse operation is String>>#base64Decoded\"\r\t\r\t\"(0 to: 255) asByteArray base64Encoded\"\r\t\"(Integer primesUpTo: 255) asByteArray base64Encoded\"\r\t\"'Hello World!' utf8Encoded base64Encoded\"\r\t\r\t^ ZnBase64Encoder new encode: self"},{"name":"unsignedLongAt:","linesOfCode":2,"sourceCode":"unsignedLongAt: byteIndex\r\t^ self uint32AtOffset: byteIndex - 1"},{"name":"nbUlongAt:put:","linesOfCode":3,"sourceCode":"nbUlongAt: index put: value\r\t\"Store unsigned long at one-based index.\"\r\t^ self unsignedLongAt: index put: value\t"},{"name":"char32AtOffset:","linesOfCode":3,"sourceCode":"char32AtOffset: zeroBasedOffset\r\t<primitive: 612>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 4 signed: false) asCharacter"},{"name":"integerAt:size:signed:","linesOfCode":6,"sourceCode":"integerAt: byteOffset size: nBytes signed: aBoolean\r\r\t^ FFIBackend current\r\t\t  integerOfObject: self\r\t\t  at: byteOffset\r\t\t  size: nBytes\r\t\t  signed: aBoolean"},{"name":"unsignedCharAt:put:","linesOfCode":2,"sourceCode":"unsignedCharAt: byteIndex put: aCharacter\r\t^ self char8AtOffset: byteIndex - 1 put: aCharacter"},{"name":"nbFloat32AtOffset:put:","linesOfCode":3,"sourceCode":"nbFloat32AtOffset: zeroBasedOffset put: value\r\t\"Store 32-bit float at ZERO-based index.\"\r\t^ self floatAt: zeroBasedOffset + 1 put: value"},{"name":"nbUInt16AtOffset:","linesOfCode":3,"sourceCode":"nbUInt16AtOffset: zeroBasedOffset\r\t\"Reads unsigned 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self unsignedShortAt: zeroBasedOffset + 1"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitBytesObject: self"},{"name":"storeOn:","linesOfCode":6,"sourceCode":"storeOn: aStream\r\taStream nextPutAll: '#['.\r\tself\r\t\tdo: [ :each | each storeOn: aStream ]\r\t\tseparatedBy: [ aStream nextPut: $ ].\r\taStream nextPut: $]"},{"name":"unsignedShortAt:put:","linesOfCode":2,"sourceCode":"unsignedShortAt: byteIndex put: value\r\t^ self uint16AtOffset: byteIndex - 1 put: value"},{"name":"floatAt:","linesOfCode":2,"sourceCode":"floatAt: byteIndex\r\t^ self float32AtOffset: byteIndex - 1"},{"name":"signedByteAt:put:","linesOfCode":3,"sourceCode":"signedByteAt: byteOffset put: value\r\t\"Store a 8bit signed integer starting at the given byte offset\"\r\t^self integerAt: byteOffset put: value size: 1 signed: true"},{"name":"gtInspectorBytesIn:","linesOfCode":24,"sourceCode":"gtInspectorBytesIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\t^ composite table\r\t\ttitle: 'Bytes';\r\t\tdisplay: [ \r\t\t\t(self size < 2048 or: [ self confirm: 'Looking at more than 2048 bytes might be slow. Continue ?' ])\r\t\t\t\tifTrue: [ {\r\t\t\t\t\t'hex string' -> (String streamContents: [ :out | \r\t\t\t\t\t\tself printHexOn: out ]).\r\t\t\t\t\t'hex lines' -> (String streamContents: [ :out |\r\t\t\t\t\t\tself withIndexDo: [ :each :index |\r\t\t\t\t\t\t\tindex = 1 ifFalse: [ \r\t\t\t\t\t\t\t\tindex - 1 \\\\ 8 = 0 ifTrue: [ out cr ] ifFalse: [ out space ] ].\r\t\t\t\t\t\t\t\teach printHexByteOn: out ] ]).\r\t\t\t\t\t'latin1' -> ([ ZnCharacterEncoder latin1 decodeBytes: self ]\r\t\t\t\t\t\t\t\t\t\t\ton: ZnCharacterEncodingError do: [ :exception | exception ]).\r\t\t\t\t\t'utf8' -> ([ ZnUTF8Encoder new decodeBytes: self ] \r\t\t\t\t\t\t\t\t\t\t\ton: ZnCharacterEncodingError do: [ :exception | exception ]).\r\t\t\t\t\t'integer' -> self asInteger.\r\t\t\t\t\t'integer reversed' -> self reversed asInteger } ]\r\t\t\t\tifFalse: [ #() ] ];\r\t\tcolumn: 'Key' evaluated: #key;\r\t\tcolumn: 'Value' evaluated: #value;\r\t\tsend: #value"},{"name":"nbInt64AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt64AtOffset: zeroBasedOffset put: value\r\t\"Store signed 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1 put: value"},{"name":"int32AtOffset:put:","linesOfCode":3,"sourceCode":"int32AtOffset: zeroBasedOffset put: value\r\t<primitive: 621>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 4 signed: true"},{"name":"unsignedShortAt:put:bigEndian:","linesOfCode":10,"sourceCode":"unsignedShortAt: index put: value bigEndian: aBool\r\t\"Store a 16 bit unsigned integer quantity starting from the given byte index\"\r\taBool ifTrue:[\r\t\tself at: index put: (value bitShift: -8).\r\t\tself at: index+1 put: (value bitAnd: 255).\r\t] ifFalse:[\r\t\tself at: index+1 put: (value bitShift: -8).\r\t\tself at: index put: (value bitAnd: 255).\r\t].\r\t^value"},{"name":"unsignedShortAt:bigEndian:","linesOfCode":5,"sourceCode":"unsignedShortAt: index bigEndian: aBool\r\t\"Return a 16 bit unsigned integer quantity starting from the given byte index\"\r\t^aBool \r\t\tifTrue:[((self at: index) bitShift: 8) + (self at: index+1)]\r\t\tifFalse:[((self at: index+1) bitShift: 8) + (self at: index)]."},{"name":"utf8Decoded","linesOfCode":5,"sourceCode":"utf8Decoded\r\t\"Produce a String decoding the receiver using UTF-8,\r\tthe recommended encoding for Strings, unless you know what you are doing.\"\r\r\t\"#[76 101 115 32 195 169 108 195 168 118 101 115 32 102 114 97 110 195 167 97 105 115] utf8Decoded\"\r\t\r\t^ self decodeWith: ZnCharacterEncoder utf8"},{"name":"uint8AtOffset:put:","linesOfCode":3,"sourceCode":"uint8AtOffset: zeroBasedOffset put: value\r\t<primitive: 616>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 1 signed: false"},{"name":"nbUlongAt:","linesOfCode":3,"sourceCode":"nbUlongAt: index\r\t\"Read unsigned long at one-based index.\"\r\t^ self unsignedLongAt: index"},{"name":"oldFFIPrimFloat32At:","linesOfCode":3,"sourceCode":"oldFFIPrimFloat32At: byteOffset\r\t<primitive:'primitiveFFIFloatAt' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"nbUInt32AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt32AtOffset: zeroBasedOffset  put: value\r\t\"Store unsigned 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedLongAt: zeroBasedOffset + 1 put: value"},{"name":"nbInt64AtOffset:","linesOfCode":3,"sourceCode":"nbInt64AtOffset: zeroBasedOffset\r\t\"Reads signed 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1"},{"name":"destroy","linesOfCode":4,"sourceCode":"destroy\r\t1 to: self size do: \r\t\t[ : x |\r\t\tself at: x put: 0 ]"},{"name":"utf8ToIso","linesOfCode":35,"sourceCode":"utf8ToIso\r\t| s i v1 v2 v3 v4 |\r\ts := WriteStream on: (String new: self size).\r\ti := 1.\r\t[i <= self size] whileTrue:\r\t\t[v1 := self at: i.\r\t\t i := i + 1.\r\t\t v1 < 128\r\t\t\tifTrue: [ s nextPut: v1 asCharacter ]\r\t\t\tifFalse:\r\t\t\t\t[(i > self size) ifTrue:\r\t\t\t\t\t[self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].\r\t\t\t\t v2 := self at: i.\r\t\t\t\t i := i + 1.\r\t\t\t\t v1 < 224\r\t\t\t\t\tifTrue:\r\t\t\t\t\t\t[s nextPut: ((v2 bitAnd: 63) bitOr: ((v1 bitAnd: 31) bitShift: 6)) asCharacter]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[(i > self size) ifTrue:\r\t\t\t\t\t\t\t[self error: 'illegal end-of-string, expected 3rd byte of UTF-8'].\r\t\t\t\t\t\t v3 := self at: i.\r\t\t\t\t\t\t i := i + 1.\r\t\t\t\t\t\t v1 < 240\r\t\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t\t[s nextPut: ((v3 bitAnd: 63) bitOr: (((v2 bitAnd: 63) bitShift: 6) bitOr: ((v1 bitAnd: 31) bitShift: 12))) asCharacter]\r\t\t\t\t\t\t\tifFalse:\r\t\t\t\t\t\t\t\t[(i > self size) ifTrue:\r\t\t\t\t\t\t\t[self error: 'illegal end-of-string, expected 4th byte of UTF-8'].\r\t\t\t\t\t\t\t v4 := self at: i.\r\t\t\t\t\t\t\t i := i + 1.\r\t\t\t\t\t\t\t v1 < 248\r\t\t\t\t\t\t\t\t\tifTrue: [s nextPut: ((v4 bitAnd: 63) bitOr: (((v3 bitAnd: 63) bitShift: 6) bitOr: (((v2 bitAnd: 63) bitShift: 12) bitOr: ((v1 bitAnd: 15) bitShift: 18)))) asCharacter]\r\t\t\t\t\t\t\t\t\tifFalse:\r\t\t\t\t\t\t\t\t\t\t[self error: 'illegal UTF-8 character']]]]].\r\t^s contents"},{"name":"defaultElement","linesOfCode":2,"sourceCode":"defaultElement\r\r\t^0"},{"name":"shortAt:bigEndian:","linesOfCode":5,"sourceCode":"shortAt: index bigEndian: aBool\r\t\"Return a 16 bit integer quantity starting from the given byte index\"\r\t| uShort |\r\tuShort := self unsignedShortAt: index bigEndian: aBool.\r\t^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)"},{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size values: self"},{"name":"asInteger","linesOfCode":7,"sourceCode":"asInteger\r\t\"Convert me to an Integer, network byte order, most significant byte first, big endian\"\r\t\r\t| integer |\r\tinteger := 0.\r\tself withIndexDo: [ :each :index | \r\t\tinteger := integer + (each bitShift: (self size - index) * 8) ].\r\t^ integer"},{"name":"doubleAt:put:bigEndian:","linesOfCode":11,"sourceCode":"doubleAt: index put: value bigEndian: bool \r\t\"Store a 64 bit float starting from the given byte index\"\r\t| w1 w2 |\r\tbool\r\t\tifTrue: [w1 := value basicAt: 1.\r\t\t\tw2 := value basicAt: 2]\r\t\tifFalse: [w1 := value basicAt: 2.\r\t\t\tw2 := value basicAt: 1]. \r\tself unsignedLongAt: index put: w1 bigEndian: bool.\r\tself unsignedLongAt: index + 4 put: w2 bigEndian: bool.\r\t^ value"},{"name":"asByteArrayPointer","linesOfCode":3,"sourceCode":"asByteArrayPointer\r\t\"Return a ByteArray describing a pointer to the contents of the receiver.\"\r\t^self shouldNotImplement"},{"name":"nbLongAt:","linesOfCode":3,"sourceCode":"nbLongAt: index\r\t\"Read signed long at one-based index\"\r\t^ self signedLongAt: index"},{"name":"sBGR_A_colorAt:put:","linesOfCode":11,"sourceCode":"sBGR_A_colorAt: index put: aColor\r\t| r g b a |\r\tr := aColor r encodeSRGBComponent asNormalizedUByte.\r\tg := aColor g encodeSRGBComponent asNormalizedUByte.\r\tb := aColor b encodeSRGBComponent asNormalizedUByte.\r\ta := aColor a asNormalizedUByte.\r\tself\r\t\tat: index put: b;\r\t\tat: index + 1 put: g;\r\t\tat: index + 2 put: r;\r\t\tat: index + 3 put: a"},{"name":"oldFFIPrimFloat64At:put:","linesOfCode":5,"sourceCode":"oldFFIPrimFloat64At: byteOffset put: value\r\t<primitive:'primitiveFFIDoubleAtPut' module:'SqueakFFIPrims'>\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #oldFFIPrimFloat64At:put: index: byteOffset value: value ].\r\t^self primitiveFailed"},{"name":"stonContainSubObjects","linesOfCode":2,"sourceCode":"stonContainSubObjects \r\t^ false"},{"name":"platformLongAt:","linesOfCode":5,"sourceCode":"platformLongAt: byteOffset\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize \r\t\tsigned: true"},{"name":"platformUnsignedLongAt:","linesOfCode":5,"sourceCode":"platformUnsignedLongAt: byteOffset\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize\r\t\tsigned: false"},{"name":"structAt:length:","linesOfCode":7,"sourceCode":"structAt: byteOffset length: length\r\t\"Return a structure of the given length starting at the indicated byte offset.\"\r\t| value |\r\tvalue := ByteArray new: length.\r\t1 to: length do:[:i|\r\t\tvalue unsignedByteAt: i put: (self unsignedByteAt: byteOffset+i-1)].\r\t^value"},{"name":"isExternalAddress","linesOfCode":3,"sourceCode":"isExternalAddress\r\t\"Return true if the receiver describes the address of an object in the outside world\"\r\t^false"},{"name":"nbLongAt:put:","linesOfCode":3,"sourceCode":"nbLongAt: index put: value\r\t\"Store signed long at one-based index\"\r\t^ self signedLongAt: index put: value"},{"name":"booleanAt:","linesOfCode":5,"sourceCode":"booleanAt: byteIndex\r\t\"Returns the boolean the byte at index byteOffset of this ByteArray represents in the C convention ( A byte representing the 0 integer corresponds to false, while all other integers corresponds to true).\"\r\t\r\t\"(#[1 2 0 4] booleanAt: 2) >>> true.\"\r\t\"(#[1 2 0 4] booleanAt: 3) >>> false.\"\r\t\r\t^ self boolean8AtOffset: byteIndex - 1"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":13,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\treplacement isString\r\t\tifFalse:\r\t\t\t[super replaceFrom: start to: stop with: replacement startingAt: repStart]\r\t\tifTrue:\r\t\t\t[ \"use String>>byteAt: to mimic prim 105\"\r\t\t\t| index repOff |\r\t\t\trepOff := repStart - start.\r\t\t\tindex := start - 1.\r\t\t\t[(index := index + 1) <= stop]\r\t\t\t\twhileTrue: [self at: index put: (replacement byteAt: repOff + index)]]\r"},{"name":"unsignedLongAt:bigEndian:","linesOfCode":19,"sourceCode":"unsignedLongAt: index bigEndian: aBool\r\t\"Return a 32bit unsigned integer quantity starting from the given byte index\"\r\t| b0 b1 b2 w |\r\taBool ifTrue:[\r\t\tb0 := self at: index.\r\t\tb1 := self at: index+1.\r\t\tb2 := self at: index+2.\r\t\tw := self at: index+3.\r\t] ifFalse:[\r\t\tw := self at: index.\r\t\tb2 := self at: index+1.\r\t\tb1 := self at: index+2.\r\t\tb0 := self at: index+3.\r\t].\r\t\"Minimize LargeInteger arithmetic\"\r\tb2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].\r\tb1 = 0 ifFalse:[w := (b1 bitShift: 16) + w].\r\tb0 = 0 ifFalse:[w := (b0 bitShift: 24) + w].\r\t^w"},{"name":"signedLongAt:","linesOfCode":2,"sourceCode":"signedLongAt: byteIndex\r\t^ self int32AtOffset: byteIndex - 1"},{"name":"voidAt:","linesOfCode":3,"sourceCode":"voidAt: byteOffset\r\t\"no accessors for void\"\r\t^self shouldNotImplement"},{"name":"referenceStructAt:length:","linesOfCode":4,"sourceCode":"referenceStructAt: byteOffset length: length\r\t^ FFIExternalStructureReferenceHandle \r\t\thandle: self \r\t\toffset: byteOffset"},{"name":"nbFloat64AtOffset:","linesOfCode":3,"sourceCode":"nbFloat64AtOffset: zeroBasedOffset\r\t\"Read 64-bit float at ZERO-based index.\"\r\t^ self doubleAt: zeroBasedOffset + 1"},{"name":"integerAt:put:size:signed:","linesOfCode":7,"sourceCode":"integerAt: byteOffset put: value size: nBytes signed: aBoolean\r\r\t^ FFIBackend current\r\t\t  integerOfObject: self\r\t\t  at: byteOffset\r\t\t  put: value\r\t\t  size: nBytes\r\t\t  signed: aBoolean"},{"name":"writeString:","linesOfCode":2,"sourceCode":"writeString: aString\r\tLibC memCopy: aString to: self size: aString size"},{"name":"unsignedLongLongAt:put:","linesOfCode":2,"sourceCode":"unsignedLongLongAt: byteIndex put: value\r\t^ self uint64AtOffset: byteIndex - 1 put: value"},{"name":"packAsFloatToArity:","linesOfCode":4,"sourceCode":"packAsFloatToArity: arity\r\t\"In case I sending a buffer to get the contents I need to understand this message. \r\t See AthensCairoCanvas>>getCurrentPoint as an example.\"\r\t^ self packToArity: arity "},{"name":"llvmPrintEscapedStringOn:addNull:","linesOfCode":13,"sourceCode":"llvmPrintEscapedStringOn: aStream addNull: addNull\r\t| element |\r\taStream nextPut: $\".\r\tself do: [ :byte |\r\t\telement := byte asCharacter.\r\t\t(Character space <= element and: [ element <= $~ and: [('\\\"' includes: element) not]]) ifTrue: [ \r\t\t\taStream nextPut: element\r\t\t] ifFalse: [\r\t\t\taStream nextPut: $\\; nextPutAll: (byte printStringBase: 16 length: 2 padded: true)\r\t\t]\r\t].\r\t\r\taddNull ifTrue: [ aStream nextPutAll: '\\00' ].\r\taStream nextPut: $\".\r"},{"name":"signedLongAt:put:","linesOfCode":2,"sourceCode":"signedLongAt: byteIndex put: value\r\t^ self int32AtOffset: byteIndex - 1 put: value"},{"name":"char8AtOffset:","linesOfCode":3,"sourceCode":"char8AtOffset: zeroBasedOffset\r\t<primitive: 610>\r\t^ (self integerAt: zeroBasedOffset + 1 size: 1 signed: false) asCharacter"},{"name":"oldFFIPrimFloat32At:put:","linesOfCode":5,"sourceCode":"oldFFIPrimFloat32At: byteOffset put: value\r\t<primitive:'primitiveFFIFloatAtPut' module:'SqueakFFIPrims'>\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #oldFFIPrimFloat32At:put: index: byteOffset value: value ].\r\t^self primitiveFailed"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString\r\r\t^ WideString fromByteArray: self.\r"},{"name":"longAt:bigEndian:","linesOfCode":19,"sourceCode":"longAt: index bigEndian: aBool\r\t\"Return a 32bit integer quantity starting from the given byte index\"\r\t| b0 b1 b2 w h |\r\taBool ifTrue:[\r\t\tb0 := self at: index.\r\t\tb1 := self at: index+1.\r\t\tb2 := self at: index+2.\r\t\tw := self at: index+3.\r\t] ifFalse:[\r\t\tw := self at: index.\r\t\tb2 := self at: index+1.\r\t\tb1 := self at: index+2.\r\t\tb0 := self at: index+3.\r\t].\r\t\"Minimize LargeInteger arithmetic\"\r\th := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.\r\tb2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].\r\th = 0 ifFalse:[w := (h bitShift: 16) + w].\r\t^w"},{"name":"unsignedShortAt:","linesOfCode":2,"sourceCode":"unsignedShortAt: byteIndex\r\t^ self uint16AtOffset: byteIndex - 1"},{"name":"nbInt16AtOffset:","linesOfCode":3,"sourceCode":"nbInt16AtOffset: zeroBasedOffset\r\t\"Reads signed 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedShortAt: zeroBasedOffset + 1"},{"name":"oldIntegerAt:size:signed:","linesOfCode":6,"sourceCode":"oldIntegerAt: byteOffset size: nBytes signed: aBoolean\r\t\"Primitive. Return an integer of nBytes size from the receiver.\r\tNote: This primitive will access memory in the outer space if\r\tinvoked from ExternalAddress.\"\r\t<primitive: 'primitiveFFIIntegerAt' module:'SqueakFFIPrims'>\r\t^self primitiveFailed"},{"name":"doubleAt:put:","linesOfCode":2,"sourceCode":"doubleAt: byteIndex put: value\r\t^ self float64AtOffset: byteIndex - 1 put: value"},{"name":"asByteArray","linesOfCode":2,"sourceCode":"asByteArray\r\t^ self"},{"name":"char32AtOffset:put:","linesOfCode":3,"sourceCode":"char32AtOffset: zeroBasedOffset put: value\r\t<primitive: 627>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 4 signed: false"},{"name":"unsignedByteAt:","linesOfCode":2,"sourceCode":"unsignedByteAt: byteIndex\r\t^ self uint8AtOffset: byteIndex - 1"},{"name":"platformUnsignedBitAt:put:","linesOfCode":6,"sourceCode":"platformUnsignedBitAt: byteOffset put: value\r\t\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize\r\t\tsigned: false"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ self"},{"name":"printHexOn:","linesOfCode":4,"sourceCode":"printHexOn: characterWriteStream\r\t\"Print a hexadecimal representation of the receiver on characterWriteStream\r\tusing exactly 2 characters for each byte\"\r\r\tself do: [ :each | each printHexByteOn: characterWriteStream ]"},{"name":"packToArity:","linesOfCode":26,"sourceCode":"packToArity: arity\r\t\"This is complicated... I assuming this ways of calling a function: \r\t \r   arity == 1: \r\t-----------\r\tByteArray works as pointer buffer of single pointer to something: \r\tex 1)\r\t\tbuffer := ByteArray new: 4.\r\t\tself ffiCall: #( void function (int *buffer) ).\r\tex 2)\r\t\tbuffer := 'Hello, World' asByteArray.\r\t\tself ffiCall: #( void function (char *buffer) ).\r\t\r\tarity > 1: \r\t----------\r\tByteArray works as pointer to allocate results:\r\tex 1)\r\t\tpointer := ByteArray new: (FFIExternalType pointerSize).\r\t\tself ffiCall: #( void function ( char **answer )).\r\t   \r\tIn this case this will not work fine because content of ByteArray needs to be a \r\tpointer too, and then it needs to be allocated in the heap... while this could be \r\tmanaged, I'm puting for the moment just an error and a recommendation of using an \r\tExternalAddress.\r\t\"\r\tarity = 1 ifTrue: [ ^ self ].\r\tself error: 'Use ExternalAddress instead!'"},{"name":"platformBitAt:","linesOfCode":5,"sourceCode":"platformBitAt: byteOffset\r\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize \r\t\tsigned: true"},{"name":"float32AtOffset:","linesOfCode":3,"sourceCode":"float32AtOffset: zeroBasedOffset\r\t<primitive: 613>\r\r\t^ FFIBackend current on: self float32At: zeroBasedOffset + 1"},{"name":"nbInt32AtOffset:put:","linesOfCode":3,"sourceCode":"nbInt32AtOffset: zeroBasedOffset put: value\r\t\"Store signed 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self signedLongAt: zeroBasedOffset + 1 put: value"},{"name":"float64AtOffset:put:","linesOfCode":6,"sourceCode":"float64AtOffset: zeroBasedOffset put: value\r\r\t<primitive: 629>\r\t^ FFIBackend current\r\t\t  on: self\r\t\t  float64At: zeroBasedOffset + 1\r\t\t  put: value"},{"name":"uint64AtOffset:put:","linesOfCode":3,"sourceCode":"uint64AtOffset: zeroBasedOffset put: value\r\t<primitive: 622>\r\t^ self integerAt: zeroBasedOffset + 1 put: value size: 8 signed: false"},{"name":"char16AtOffset:put:","linesOfCode":3,"sourceCode":"char16AtOffset: zeroBasedOffset put: value\r\t<primitive: 626>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 2 signed: false"},{"name":"nbUInt64AtOffset:","linesOfCode":3,"sourceCode":"nbUInt64AtOffset: zeroBasedOffset\r\t\"Reads unsigned 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedLongLongAt: zeroBasedOffset + 1"},{"name":"readStringUTF8","linesOfCode":2,"sourceCode":"readStringUTF8\r\t^ (ExternalData fromHandle: self type: ExternalType string) readStringUTF8."},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t\"#hash is implemented, because #= is implemented\"\r\r\t^self class\r\t\thashBytes: self\r\t\tstartingWith: self species hash"},{"name":"voidAt:put:","linesOfCode":3,"sourceCode":"voidAt: byteOffset put: value\r\t\"no accessors for void\"\r\t^self shouldNotImplement"},{"name":"platformLongAt:put:","linesOfCode":6,"sourceCode":"platformLongAt: byteOffset put: value\r\tself \r\t\tintegerAt: byteOffset\r\t\tput: value\r\t\tsize: FFIArchitecture forCurrentArchitecture longTypeSize\r\t\tsigned: true"},{"name":"int16AtOffset:","linesOfCode":3,"sourceCode":"int16AtOffset: zeroBasedOffset\r\t<primitive: 604>\r\t^ self integerAt: zeroBasedOffset + 1 size: 2 signed: true"},{"name":"readString","linesOfCode":2,"sourceCode":"readString\r\t^ (ExternalData fromHandle: self type: ExternalType string) readString"},{"name":"nbUInt32AtOffset:","linesOfCode":3,"sourceCode":"nbUInt32AtOffset: zeroBasedOffset\r\t\"Reads unsigned 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.\"\r\t^ self unsignedLongAt: zeroBasedOffset + 1"},{"name":"hexDumpOn:max:","linesOfCode":39,"sourceCode":"hexDumpOn: aStream max: maxBytes\r\t\"Print a hex dump of the receiver on the supplied stream, up to maxBytes long\"\r\r\t| ch i string remainder |\r\r\ti := 0.\r\tself readStreamDo: [ :stream |\r\t\tch := stream next.\r\t\t[ch notNil and: [ i < maxBytes ]] whileTrue: [ \r\t\t\tremainder := i \\\\ 16.\r\t\t\tremainder = 0 ifTrue: [ \r\t\t\t\ti = 0 ifFalse: [ aStream cr ].\r\t\t\t\taStream \r\t\t\t\t\t<< (i printPaddedWith: $0 to: 8 base: 16);\r\t\t\t\t\t<< '  '.\r\t\t\t\tstring := String new writeStream ].\r\t\t\tch printHexByteOn: aStream.\r\t\t\taStream space.\r\t\t\t(ch between: 32 and: 126) ifTrue: \r\t\t\t\t[ string nextPut: (Character value: ch) ]\r\t\t\tifFalse:\r\t\t\t\t[ string nextPut: $. ].\r\t\t\tremainder = 15 ifTrue: [ \r\t\t\t\taStream\r\t\t\t\t\t<< '  |';\r\t\t\t\t\t<< string contents;\r\t\t\t\t\t<< '|' ].\r\t\t\tch := stream next.\r\t\t\ti := i + 1 ].\r\t\tremainder := i \\\\ 16.\r\t\t(ch isNil and: [remainder between: 1 and: 15]) ifTrue: [ \r\t\t\t(16 - remainder) timesRepeat: [ aStream nextPutAll: '   ' ].\r\t\t\taStream\r\t\t\t\t<< '  |';\r\t\t\t\t<< string contents.\r\t\t\t(16 - remainder timesRepeat: [ aStream nextPut: Character space ]).\r\t\t\taStream\r\t\t\t\t<< '|' ].\r\t\taStream cr.\r\t\tself size > maxBytes ifTrue: \r\t\t\t[ aStream nextPutAll: '  ... truncated ...'; cr ] ].\r"},{"name":"nbUInt64AtOffset:put:","linesOfCode":3,"sourceCode":"nbUInt64AtOffset: zeroBasedOffset put: value\r\t\"Store unsigned 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order\"\r\t^ self unsignedLongLongAt: zeroBasedOffset + 1 put: value"},{"name":"doubleAt:","linesOfCode":2,"sourceCode":"doubleAt: byteIndex\r\t^ self float64AtOffset: byteIndex - 1"},{"name":"asExternalPointer","linesOfCode":3,"sourceCode":"asExternalPointer\r\t\"Convert the receiver assuming that it describes a pointer to an object.\"\r\t^ self pointerAt: 1"},{"name":"uint8AtOffset:","linesOfCode":3,"sourceCode":"uint8AtOffset: zeroBasedOffset\r\t<primitive: 601>\r\t^ self integerAt: zeroBasedOffset + 1 size: 1 signed: false"},{"name":"structAt:put:length:","linesOfCode":5,"sourceCode":"structAt: byteOffset put: value length: length\r\t\"Store a structure of the given length starting at the indicated byte offset.\"\r\t1 to: length do:[:i|\r\t\tself unsignedByteAt: byteOffset+i-1 put: (value unsignedByteAt: i)].\r\t^value"},{"name":"floatAt:bigEndian:","linesOfCode":3,"sourceCode":"floatAt: index bigEndian: boolean \r\t^ Float\r\t\tfromIEEE32Bit: (self unsignedLongAt: index bigEndian: boolean)"},{"name":"asString","linesOfCode":4,"sourceCode":"asString\r\t\"Convert to a String with Characters for each byte.\r\tFast code uses primitive that avoids character conversion\"\r\r\t^ (String new: self size) replaceFrom: 1 to: self size with: self"},{"name":"booleanAt:put:","linesOfCode":2,"sourceCode":"booleanAt: byteIndex put: value\r\t^ self boolean8AtOffset: byteIndex - 1 put: value"},{"name":"longAt:put:bigEndian:","linesOfCode":21,"sourceCode":"longAt: index put: value bigEndian: aBool\r\t\"Return a 32bit integer quantity starting from the given byte index\"\r\t| b0 b1 b2 b3 |\r\tb0 := value bitShift: -24.\r\tb0 := (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).\r\tb0 < 0 ifTrue:[b0 := 256 + b0].\r\tb1 := (value bitShift: -16) bitAnd: 255.\r\tb2 := (value bitShift: -8) bitAnd: 255.\r\tb3 := value bitAnd: 255.\r\taBool ifTrue:[\r\t\tself at: index put: b0.\r\t\tself at: index+1 put: b1.\r\t\tself at: index+2 put: b2.\r\t\tself at: index+3 put: b3.\r\t] ifFalse:[\r\t\tself at: index put: b3.\r\t\tself at: index+1 put: b2.\r\t\tself at: index+2 put: b1.\r\t\tself at: index+3 put: b0.\r\t].\r\t^value"},{"name":"unsignedCharAt:","linesOfCode":2,"sourceCode":"unsignedCharAt: byteIndex\r\t^ self char8AtOffset: byteIndex - 1"},{"name":"int8AtOffset:","linesOfCode":3,"sourceCode":"int8AtOffset: zeroBasedOffset\r\t<primitive: 602>\r\t^ self integerAt: zeroBasedOffset + 1 size: 1 signed: true"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeByteArray: self"},{"name":"boolean8AtOffset:put:","linesOfCode":3,"sourceCode":"boolean8AtOffset: zeroBasedOffset put: value\r\t<primitive: 615>\r\t^ self integerAt: zeroBasedOffset + 1 put: (value ifTrue:[1] ifFalse:[0]) size: 1 signed: false"},{"name":"closureDescriptionForCaching","linesOfCode":6,"sourceCode":"closureDescriptionForCaching\r\t^ 'ba ' , (self size < 32 ifTrue: [\r\t\t self hex\r\t] ifFalse: [\r\t\t(SHA256 hashMessage: self) hex\r\t])"},{"name":"platformUnsignedBitAt:","linesOfCode":5,"sourceCode":"platformUnsignedBitAt: byteOffset\r\r\t^ self \r\t\tintegerAt: byteOffset \r\t\tsize: FFIArchitecture forCurrentArchitecture bitTypeSize \r\t\tsigned: false"},{"name":"char8AtOffset:put:","linesOfCode":3,"sourceCode":"char8AtOffset: zeroBasedOffset put: value\r\t<primitive: 625>\r\t^ self integerAt: zeroBasedOffset + 1 put: value asInteger size: 1 signed: false"}],"meta":{"name":"ByteArray class","instanceVariables":[],"methods":[{"name":"hashBytes:startingWith:","linesOfCode":19,"sourceCode":"hashBytes: aByteArray startingWith: speciesHash\r\t\"Answer the hash of a byte-indexed collection,\r\tusing speciesHash as the initial value.\r\tSee SmallInteger>>hashMultiply.\r\r\tThe primitive should be renamed at a\r\tsuitable point in the future\"\r\r\t| byteArraySize hash low |\r\t<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>\r\r\t<var: #aHash declareC: 'int speciesHash'>\r\t<var: #aByteArray declareC: 'unsigned char *aByteArray'>\r\r\tbyteArraySize := aByteArray size.\r\thash := speciesHash bitAnd: 16rFFFFFFF.\r\t1 to: byteArraySize do: [:pos |\r\t\thash := hash + (aByteArray basicAt: pos).\r\t\t\"Begin hashMultiply\"\r\t\tlow := hash bitAnd: 16383.\r\t\thash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.\r\t].\r\t^ hash"},{"name":"readHexFrom:","linesOfCode":3,"sourceCode":"readHexFrom: aString\r\t\"Create a byte array from a hexadecimal representation\"\r\t^(self new: aString size // 2) readHexFrom: aString readStream"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeByteArrayInspector"},{"name":"fromSton:","linesOfCode":3,"sourceCode":"fromSton: stonReader\r\t\"Use a hex representation\"\r\t\r\t^ self readHexFrom: stonReader parseListSingleton"}],"meta":null}}]},{"name":"Collections-Atomic-Tests","classes":[{"name":"WaitfreeQueueTest","instanceVariables":[],"methods":[{"name":"testZombieFirst","linesOfCode":21,"sourceCode":"testZombieFirst\r\t\"Check that a zombie item at the start of the queue is correctly removed\"\r\r\t| items queue real |\r\r\titems := self newItems: 2.\r\tqueue := WaitfreeQueue withAll: items.\r\titems first object: queue dummy.\r\titems last object: #real.\r\r\treal := queue nextOrNil.\r\tself assert: real equals: #real.\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r\tself assert: items last isZombie.\r\r\r\titems := self newItems: 2.\r\tqueue := WaitfreeQueue withAll: items.\r\titems first object: queue dummy.\r\titems last object: #real.\r\r\treal := queue nextOrNilSuchThat: [ :v | v = #real ].\r\tself assert: real equals: #real.\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r\tself assert: items last isZombie.\r"},{"name":"testNextOrNilSuchThat","linesOfCode":30,"sourceCode":"testNextOrNilSuchThat\r\r\t| queue |\r\r\tqueue := WaitfreeQueue new.\r\t1 to: 10 do: [ :i |\r\t\tqueue nextPut: i ].\r\r\t\"Remove the first element\"\r\tself assert: (queue nextOrNilSuchThat: [ :o | o = 1 ]) equals: 1.\r\r\t\"Remove the last element\"\r\tself assert: (queue nextOrNilSuchThat: [ :o | o = 10 ]) equals: 10.\r\r\t\"Remove the middle elements\"\r\t4 to: 6 do: [ :i |\r\t\tself assert: (queue nextOrNilSuchThat: [ :o | o = i ]) equals: i ].\r\r\t\"There should be 5 elements left with 1 zombie (the last element)\"\r\tself assert: queue size equals: 5.\r\t\"But... all items removed with #nextOrNilSuchThat: leave zombie behind\"\r\tself assert: queue itemCount equals: 6.\r\tself assert: queue tail isZombie.\r\r\t11 to: 13 do: [ :i |\r\t\tqueue nextPut: i ].\r\r\t#(2 3 7 8 9 11 12 13) do: [ :i |\r\t\tself assert: queue nextOrNil equals: i ].\r\r\t\"There should be 0 elements left with one zombie\"\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r\r\tqueue nextPut: 11.\r\tself assert: queue nextOrNil equals: 11.\r\tself assert: queue nextOrNil equals: nil.\r\r\t\"There should be 0 elements left with one zombie\"\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r"},{"name":"testZombieMiddle","linesOfCode":31,"sourceCode":"testZombieMiddle\r\t\"Check that a zombie item at the start of the queue is correctly removed\"\r\r\t| items queue real |\r\r\titems := self newItems: 3.\r\tqueue := WaitfreeQueue withAll: items.\r\titems first object: #real1.\r\titems second object: queue dummy.\r\titems last object: #real2.\r\r\treal := queue nextOrNil.\r\tself assert: real equals: #real1.\r\tself assert: queue size equals: 1.\r\tself assert: queue itemCount equals: 2.\r\treal := queue nextOrNil.\r\tself assert: real equals: #real2.\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r\tself assert: items last isZombie.\r\r\r\titems := self newItems: 3.\r\tqueue := WaitfreeQueue withAll: items.\r\titems first object: #real1.\r\titems second object: queue dummy.\r\titems last object: #real2.\r\r\treal := queue nextOrNilSuchThat: [ :v | v = #real1 ].\r\tself assert: real equals: #real1.\r\tself assert: queue size equals: 1.\r\tself assert: queue itemCount equals: 2.\r\treal := queue nextOrNilSuchThat: [ :v | v = #real2 ].\r\tself assert: real equals: #real2.\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r\tself assert: items last isZombie.\r"},{"name":"testNextOrNil","linesOfCode":22,"sourceCode":"testNextOrNil\r\r\t| queue |\r\r\tqueue := WaitfreeQueue new.\r\t1 to: 3 do: [ :i |\r\t\tqueue \tnextPut: i ].\r\r\t\"Remove the entries\"\r\t1 to: 3 do: [ :i |\r\t\tself assert: queue nextOrNil equals: i ].\r\r\t\"There should be 0 entries left with no zombies\"\r\tself assert: queue size equals: 0.\r\t\"But a zombie is always left behind\"\r\tself assert: queue itemCount equals: 1.\r\r\t\"Repeat to check that the number of zombies doesn't grow\"\r\t1 to: 3 do: [ :i |\r\t\tqueue \tnextPut: i ].\r\r\t\"Remove the entries\"\r\t1 to: 3 do: [ :i |\r\t\tself assert: queue nextOrNil equals: i ].\r\r\t\"There should be 0 entries left with no zombies\"\r\tself assert: queue size equals: 0.\r\t\"But a zombie is always left behind\"\r\tself assert: queue itemCount equals: 1.\r"},{"name":"newItems:","linesOfCode":6,"sourceCode":"newItems: count\r\t\"Answer a collection with the requested number of items\"\r\r\t| collection |\r\r\tcollection := OrderedCollection new.\r\tcount timesRepeat: [ collection add: AtomicQueueItem new ].\r\t^collection"},{"name":"testZombieLast","linesOfCode":26,"sourceCode":"testZombieLast\r\t\"Check that a zombie item at the end of the queue is correctly left\"\r\r\t| items queue real |\r\r\titems := self newItems: 2.\r\tqueue := WaitfreeQueue withAll: items.\r\titems first object: #real.\r\titems last object: queue dummy.\r\r\treal := queue nextOrNil.\r\tself assert: real equals: #real.\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r\tself assert: items last isZombie.\r\tself assert: queue nextOrNil isNil.\r\r\titems := self newItems: 2.\r\tqueue := WaitfreeQueue withAll: items.\r\titems first object: #real.\r\titems last object: queue dummy.\r\r\treal := queue nextOrNilSuchThat: [ :v | v = #real ].\r\tself assert: real equals: #real.\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r\tself assert: items last isZombie.\r\treal := queue nextOrNilSuchThat: [ :v | v = #real ].\r\tself assert: real isNil.\r\tself assert: queue size equals: 0.\r\tself assert: queue itemCount equals: 1.\r"}],"meta":{"name":"WaitfreeQueueTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FIFOQueueTest","instanceVariables":[{"name":"count"}],"methods":[{"name":"testFlush","linesOfCode":10,"sourceCode":"testFlush\r\t| q v sema |\r\tq := self newQueue.\r\tsema := Semaphore new.\r\t\r\t[ #( 1 2 3 4 5 6 7 8 9 10 ) do: [:each |\r\t\tq nextPut: each ]. sema signal ] fork.\r\t\r\tv := 0.\r\t\r\tsema wait. \r\tq flush: [:each | self assert: v < each. v := each ].\r\r\tself assert: v equals: 10\t"},{"name":"testSize","linesOfCode":6,"sourceCode":"testSize\r\t| q |\r\tq := self newQueue.\r\t\r\t#( 1 2 3 4 5 6 7 8 9 10 ) do: [:each |\r\t\tq nextPut: each ].\r\r\tself assert: q size equals: 10"},{"name":"testContention1","linesOfCode":14,"sourceCode":"testContention1\r\t| q r1 r2 |\r\tq := AtomicSharedQueue new.\r\tq nextPut: 5.\r\tq nextPut: 10.\r\r\tself assert: q nextOrNil equals: 5.\r\r\t[ r1 := q next ] fork.\r\t[ r2 := q next ] fork.\r\tProcessor  yield.   \"let the above two threads block\"\r\t\r\tq nextPut: 10.\r\tProcessor yield.\r\r\tself assert: r1 equals: 10.\r\tself assert: r2 equals: 10.\r\tself assert: q nextOrNil isNil"},{"name":"runValidationTest","linesOfCode":30,"sourceCode":"runValidationTest\r\t| q sema prio pusher feeder feeders r crit done |\r\tr := Random new.\r\tq := AtomicSharedQueue new.\r\tfeeders := OrderedCollection new.\r\tcount := 0.\r\tsema := Semaphore new.\r\tcrit := Semaphore forMutualExclusion.\r\tdone := Semaphore new.\r\r\tprio := Processor activePriority.\r\tpusher := [ sema wait.\r\t1 to: 100 do: [ :i | q nextPut: i ] ].\r\tfeeder := [ sema wait.\r\t[ q next.\r\tcrit critical: [ count := count + 1 ].\r\tcount < 1000 ] whileTrue.\r\tdone signal ].\r\r\t10\r\t\ttimesRepeat: [ | proc |\r\t\t\tproc := pusher newProcess priority: prio + (r next * 10) asInteger - 5.\r\t\t\tproc resume.\r\t\t\tproc := feeder newProcess priority: prio + (r next * 10) asInteger - 10.\r\t\t\tfeeders add: proc.\r\t\t\tproc resume ].\r\r\t\" let them run \"\r\t20 timesRepeat: [ sema signal ].\r\tProcessor yield.\r\r\tdone waitTimeoutSeconds: 10.\r\r\tfeeders do: [ :ea | ea terminate ].\r\tself assert: count equals: 1000"},{"name":"testFlushAllSuchThat","linesOfCode":7,"sourceCode":"testFlushAllSuchThat\r\t| q |\r\tq := self newQueue.\r\t\r\t#( 1 2 3 4 5 6 7 8 9 10 ) do: [:each | q nextPut: each ]. \r\t\r\tq flushAllSuchThat: [:each | each odd ].\r\t\r\tq flush: [:each | self assert: each even ].\r\t\r\tself assert: q nextOrNil isNil"},{"name":"testNextOrNilSuchThat","linesOfCode":9,"sourceCode":"testNextOrNilSuchThat\r\t| q item |\r\tq := self newQueue.\r\tq nextPut: 5.\r\tq nextPut: 6.\r\r\titem := q nextOrNilSuchThat: [ :x | x even ].\r\tself assert: item equals: 6.\r\r\tself assert: q nextOrNil equals: 5.\r\tself should: q nextOrNil isNil\r"},{"name":"newQueue","linesOfCode":2,"sourceCode":"newQueue\r\r\t^ WaitfreeQueue new"},{"name":"testHeavyContention","linesOfCode":34,"sourceCode":"testHeavyContention\r\t\"run 10 threads, pushing new values to queue,\r\tand 10 threads pullung values from queue,\r\tat random priorities\"\r\t\r\t| q sema prio pusher feeder\r\t\tfeeders r crit done |\r\r\tr := Random new.\r\tq := AtomicSharedQueue new.\r\tfeeders := OrderedCollection new.\r\tcount := 0.\r\tsema := Semaphore new.\r\tcrit := Semaphore forMutualExclusion.\r\tdone := Semaphore new.\r\t\r\tprio := Processor activePriority.\r\tpusher := [ sema wait. 1 to: 100 do: [:i | q nextPut: i ]. ].\r\tfeeder := [ sema wait. \r\t\t[ q next.  crit critical: [count := count + 1 ]. count < 1000 ] whileTrue. done signal ].\r\t\r\t10 timesRepeat: [\r\t\t| proc |\r\t\tproc := pusher newProcess priority: prio + (r next * 10) asInteger.\r\t\tproc resume.\r\t\t\r\t\tproc := feeder newProcess priority: prio + (r next * 10) asInteger.\r\t\tfeeders add: proc. \r\t\tproc resume.\t\t\r\t].\r\r\t\" let them run \"\r\t20 timesRepeat: [ sema signal ].\r\tProcessor yield.\r\t\r\tdone waitTimeoutSeconds: 10.\r\t \r\tfeeders do: [:ea | ea terminate ].\r\tself assert: count equals: 1000.\r\tself assert: q nextOrNil isNil"},{"name":"testSuchThat","linesOfCode":10,"sourceCode":"testSuchThat\r\t| q |\r\tq := self newQueue.\r\t\r\t#( 1 2 3 4 5 6 7 8 9 10 ) do: [:each |\r\t\tq nextPut: each ].\r\r\tself assert: (q nextOrNilSuchThat: [:e | e = 100 ]) isNil.\t\r\r\tself assert: (q nextOrNilSuchThat: [:e | e = 5 ]) equals: 5.\t\r\r\t9 timesRepeat: [ \r\t\tself assert: (q nextOrNil notNil) ].\r\t\r\tself assert: q nextOrNil isNil"},{"name":"runValidationTest2","linesOfCode":25,"sourceCode":"runValidationTest2\r\t| q sema prio pusher r cnt |\r\r\tr := Random new.\r\tq := AtomicSharedQueue new.\r\tcnt := 0.\r\tsema := Semaphore new.\r\t\r\tprio := Processor activePriority.\r\tpusher := [ sema wait. 1 to: 100 do: [:i | q nextPut: i ]. Processor yield ].\r\t\r\t10 timesRepeat: [\r\t\t| proc |\r\t\tproc := pusher newProcess priority: prio + (r next * 10) asInteger  - 5.\r\t\tproc resume.\r\t].\r\r\t\" let them run \"\r\t10 timesRepeat: [ sema signal ].\r\tProcessor yield.\r\t\r\t[ q next. cnt := cnt + 1. cnt < 1000 ] whileTrue.\r\"\r\tstarted := Time now asSeconds. \r\t[\r\t[ count < (1000) ] whileTrue: [\r\t\tTime now asSeconds - started > 20 ifTrue: [ self error: 'deadlock' ].\r\t Processor yield ].\r\t] ensure: [ \r\t\tfeeders do: [:ea | ea terminate ]\r\t]\r\""},{"name":"testBasics","linesOfCode":12,"sourceCode":"testBasics\r\t| q |\r\tq := self newQueue.\r\t\r\tq nextPut: 5.\r\t\r\tself assert: q peek equals: 5.\r\tself assert: q nextOrNil equals: 5.\r\t\r\tq nextPut: 10.\r\tq nextPut: 15.\r\t\r\tself assert: q nextOrNil equals: 10.\r\tself assert: q peek equals: 15.\r\tself assert: q nextOrNil equals: 15.\r\t\r\tself assert: q nextOrNil isNil"},{"name":"testHeavyContention2","linesOfCode":33,"sourceCode":"testHeavyContention2\r\t\"run 10 threads, pushing new values to queue,\r\tand 10 threads pullung values from queue,\r\tat random priorities\"\r\t\r\t| q sema prio pusher feeder\r\t\tfeeders r crit done |\r\r\tr := Random new.\r\tq := AtomicSharedQueue new.\r\tfeeders := OrderedCollection new.\r\tcount := 0.\r\tsema := Semaphore new.\r\tcrit := Semaphore forMutualExclusion.\r\tdone := Semaphore new.\r\t\r\tprio := Processor activePriority.\r\tpusher := [ sema wait. 1 to: 100 do: [:i | q nextPut: i ]. ].\r\tfeeder := [ sema wait. \r\t\t[ q waitForNewItems. q next. crit critical: [count := count + 1 ]. count < 1000 ] whileTrue. done signal ].\r\t\r\t10 timesRepeat: [\r\t\t| proc |\r\t\tproc := pusher newProcess priority: prio + (r next * 10) asInteger - 5.\r\t\tproc resume.\r\t\tproc := feeder newProcess priority: prio + (r next * 10) asInteger - 5.\r\t\tfeeders add: proc. \r\t\tproc resume.\t\t\r\t].\r\r\t\" let them run \"\r\t20 timesRepeat: [ sema signal ].\r\tProcessor yield.\r\t\r\tdone waitTimeoutSeconds: 10.\r\t \r\tfeeders do: [:ea | ea terminate ].\r\tself assert: count equals: 1000.\r\tself assert: q nextOrNil isNil"}],"meta":{"name":"FIFOQueueTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"LIFOQueueTest","instanceVariables":[],"methods":[{"name":"newQueue","linesOfCode":2,"sourceCode":"newQueue\r\r\t^ LIFOQueue new"},{"name":"testHeavyContention","linesOfCode":35,"sourceCode":"testHeavyContention\r\t\"run 10 threads, pushing new values to queue,\r\tand 10 threads pullung values from queue,\r\tat random priorities\"\r\t\r\t| q sema prio pusher feeder\r\t\tfeeders r crit done count |\r\r\tr := Random new.\r\tq := self newQueue.\r\tfeeders := OrderedCollection new.\r\tcount := 0.\r\tsema := Semaphore new.\r\tcrit := Semaphore forMutualExclusion.\r\tdone := Semaphore new.\r\t\r\tprio := Processor activePriority.\r\tpusher := [ sema wait. 1 to: 100 do: [:i | q nextPut: i ]. ].\r\tfeeder := [ sema wait. \r\t\t[ q nextOrNil ifNotNil: [ crit critical: [count := count + 1 ]]. Processor yield. count < 1000 ] whileTrue. done signal ].\r\t\r\t10 timesRepeat: [\r\t\t| proc |\r\t\tproc := pusher newProcess priority: prio + (r next * 10) asInteger.\r\t\tproc resume.\r\t\t\"run feeders at lower priority, otherwise they won't give a chance pushers to complete,\r\t\tbecause queue doesn't blocks the process\"\r\t\tproc := feeder newProcess priority: prio + (r next * 10) asInteger  - 10.\r\t\tfeeders add: proc. \r\t\tproc resume.\t\t\r\t].\r\r\t\" let them run \"\r\t20 timesRepeat: [ sema signal ].\r\tProcessor yield.\r\t\r\tdone waitTimeoutSeconds: 10.\r\t \r\tfeeders do: [:ea | ea terminate ].\r\tself assert: count equals: 1000.\r\tself assert: q nextOrNil isNil"},{"name":"testContention1","linesOfCode":14,"sourceCode":"testContention1\r\r\t| q r1 r2 |\r\tq := self newQueue.\r\tq nextPut: 10.\r\tq nextPut: 5.\r\r\tself assert: q nextOrNil equals: 5.\r\r\t[ r1 := q next ] fork.\r\t[ r2 := q next ] fork.\r\tProcessor  yield.   \"let the above two threads block\"\r\t\r\tq nextPut: 10.\r\tProcessor yield.\r\r\tself assert: r1 equals: 10.\r\tself assert: r2 equals: 10.\r\tself assert: q nextOrNil isNil"},{"name":"testBasics","linesOfCode":8,"sourceCode":"testBasics\r\t| q |\r\tq := self newQueue.\r\t\r\tq nextPut: 5.\r\t\r\tself assert: q next equals: 5.\r\t\r\tq nextPut: 10.\r\t\r\tself assert: q nextOrNil equals: 10.\r\t\r\tself assert: q nextOrNil isNil"}],"meta":{"name":"LIFOQueueTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Arithmetic","classes":[{"name":"FloatArray","instanceVariables":[],"methods":[{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0.0"},{"name":"primSubScalar:","linesOfCode":3,"sourceCode":"primSubScalar: scalarValue\r\r\t<primitive: 'primitiveSubScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue]."},{"name":"asFloatArray","linesOfCode":2,"sourceCode":"asFloatArray\r\t^self"},{"name":"*","linesOfCode":2,"sourceCode":"* anObject\r\t^self copy *= anObject"},{"name":"/=","linesOfCode":4,"sourceCode":"/= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primDivScalar: anObject asFloat]\r\t\tifFalse:[self primDivArray: anObject]"},{"name":"=","linesOfCode":9,"sourceCode":"= aFloatArray \r\t| length |\r\t<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>\r\taFloatArray class = self class ifFalse: [^ false].\r\tlength := self size.\r\tlength = aFloatArray size ifFalse: [^ false].\r\t1 to: self size do: [:i | (self at: i)\r\t\t\t= (aFloatArray at: i) ifFalse: [^ false]].\r\t^ true"},{"name":"primAddScalar:","linesOfCode":3,"sourceCode":"primAddScalar: scalarValue\r\r\t<primitive: 'primitiveAddScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue]."},{"name":"-","linesOfCode":2,"sourceCode":"- anObject\r\t^self shallowCopy -= anObject"},{"name":"primMulArray:","linesOfCode":3,"sourceCode":"primMulArray: floatArray\r\r\t<primitive: 'primitiveMulFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)]."},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"/","linesOfCode":2,"sourceCode":"/ anObject\r\t^self copy /= anObject"},{"name":"hash","linesOfCode":6,"sourceCode":"hash\r\t| result |\r\t<primitive:'primitiveHashArray' module: 'FloatArrayPlugin'>\r\tresult := 0.\r\t1 to: self size do:[:i| result := result + (self basicAt: i) ].\r\t^result bitAnd: 16r1FFFFFFF"},{"name":"+=","linesOfCode":2,"sourceCode":"+= anObject\r\t^ anObject addAssignToFloatArray: self"},{"name":"primDivArray:","linesOfCode":3,"sourceCode":"primDivArray: floatArray\r\r\t<primitive: 'primitiveDivFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)]."},{"name":"primMulScalar:","linesOfCode":3,"sourceCode":"primMulScalar: scalarValue\r\r\t<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue]."},{"name":"primDivScalar:","linesOfCode":3,"sourceCode":"primDivScalar: scalarValue\r\r\t<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue]."},{"name":"primSubArray:","linesOfCode":3,"sourceCode":"primSubArray: floatArray\r\r\t<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)]."},{"name":"sum","linesOfCode":3,"sourceCode":"sum\r\r\t<primitive: 'primitiveSum' module: 'FloatArrayPlugin'>\r\t^ super sum"},{"name":"\\\\=","linesOfCode":10,"sourceCode":"\\\\= other\r\r\tother isNumber ifTrue: [\r\t\t1 to: self size do: [:i |\r\t\t\tself at: i put: (self at: i) \\\\ other\r\t\t].\r\t\t^ self.\r\t].\r\t1 to: (self size min: other size) do: [:i |\r\t\tself at: i put: (self at: i) \\\\ (other at: i).\r\t].\r\r"},{"name":"adaptToNumber:andSend:","linesOfCode":14,"sourceCode":"adaptToNumber: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a Number. If possible,\r\tconvert it to a float and perform the (more efficient) primitive operation.\"\r\tselector == #+ ifTrue:[^self + rcvr].\r\tselector == #* ifTrue:[^self * rcvr].\r\tselector == #- ifTrue:[^self negated += rcvr].\r\tselector == #/ ifTrue:[\r\t\t\"DO NOT USE TRIVIAL CODE\r\t\t\t^self reciprocal * rcvr\r\t\tBECAUSE OF GRADUAL UNDERFLOW\r\t\tself should: (1.0e-39 / (FloatArray with: 1.0e-39)) first < 2.\"\r\t\t\t^(self class new: self size withAll: rcvr) / self\r\t\t].\r\t^super adaptToNumber: rcvr andSend: selector"},{"name":"+","linesOfCode":2,"sourceCode":"+ anObject\r\t^self copy += anObject"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"primAddArray:","linesOfCode":3,"sourceCode":"primAddArray: floatArray\r\r\t<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>\r\t1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)]."},{"name":"addAssignToFloatArray:","linesOfCode":2,"sourceCode":"addAssignToFloatArray: aFloatArray\r\t^ self primAddArray: aFloatArray"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index\r\t<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>\r\t^Float fromIEEE32Bit: (self basicAt: index)"},{"name":"dot:","linesOfCode":10,"sourceCode":"dot: aFloatVector\r\t\"Primitive. Return the dot product of the receiver and the argument.\r\tFail if the argument is not of the same size as the receiver.\"\r       | result |\r\t<primitive: 'primitiveDotProduct' module: 'FloatArrayPlugin'>\r\tself size = aFloatVector size ifFalse:[^self error:'Must be equal size'].\r\tresult := 0.0.\r\t1 to: self size do:[:i|\r\t\tresult := result + ((self at: i) * (aFloatVector at: i))].\r\t^result"},{"name":"negated","linesOfCode":2,"sourceCode":"negated\r\t^self copy *= -1"},{"name":"*=","linesOfCode":4,"sourceCode":"*= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primMulScalar: anObject asFloat]\r\t\tifFalse:[self primMulArray: anObject]"},{"name":"-=","linesOfCode":4,"sourceCode":"-= anObject\r\t^anObject isNumber\r\t\tifTrue:[self primSubScalar: anObject asFloat]\r\t\tifFalse:[self primSubArray: anObject]"},{"name":"at:put:","linesOfCode":6,"sourceCode":"at: index put: value\r\t<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>\r\tvalue isFloat \r\t\tifTrue:[self basicAt: index put: value asIEEE32BitWord]\r\t\tifFalse:[self at: index put: value asFloat].\r\t^value"}],"meta":{"name":"FloatArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WordArray","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size * 4"},{"name":"primDivScalar:and:into:","linesOfCode":7,"sourceCode":"primDivScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveDivScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveDivScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) / other.\r\t].\r\t^ result.\r"},{"name":"primSubArray:and:into:","linesOfCode":7,"sourceCode":"primSubArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveSubArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveSubArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) - (other at: i)\r\t].\r\t^ result.\r"},{"name":"asWordArray","linesOfCode":2,"sourceCode":"asWordArray\r\t^self"},{"name":"+","linesOfCode":14,"sourceCode":"+ other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primAddScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primAddArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primAddArray: self and: other into: result ].\r\t^ super + other"},{"name":"pushAsGPUConstantsWithCommandList:at:","linesOfCode":2,"sourceCode":"pushAsGPUConstantsWithCommandList: computationCommandList at: offset\r\tcomputationCommandList pushConstants: offset size: self size * 4 values: self"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":3,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t<primitive: 105>\r\t^super replaceFrom: start to: stop with: replacement startingAt: repStart "},{"name":"defaultElement","linesOfCode":3,"sourceCode":"defaultElement\r\t\"Return the default element of the receiver\"\r\t^0"},{"name":"primSubScalar:and:into:","linesOfCode":7,"sourceCode":"primSubScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveSubScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveSubScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) - other.\r\t].\r\t^ result.\r"},{"name":"*","linesOfCode":14,"sourceCode":"* other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primMulScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primMulArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primMulArray: self and: other into: result ].\r\t^ super * other"},{"name":"primAddArray:and:into:","linesOfCode":7,"sourceCode":"primAddArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveAddArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveAddArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) + (other at: i)\r\t].\r\t^ result.\r"},{"name":"primAddScalar:and:into:","linesOfCode":7,"sourceCode":"primAddScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveAddScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveAddScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) + other.\r\t].\r\t^ result.\r"},{"name":"-","linesOfCode":14,"sourceCode":"- other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primSubScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primSubArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primSubArray: self and: other into: result ].\r\t^ super - other"},{"name":"primMulArray:and:into:","linesOfCode":7,"sourceCode":"primMulArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveMulArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveMulArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) * (other at: i)\r\t].\r\t^ result.\r"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"/","linesOfCode":14,"sourceCode":"/ other\r\t| result |\r\tother isNumber\r\t\tifTrue: [ result := (other isFloat\r\t\t\t\tifTrue: [ FloatArray ]\r\t\t\t\tifFalse: [ WordArray ]) new: self size.\r\t\t\t^ self primDivScalar: self and: other into: result ].\r\t(other isMemberOf: WordArray)\r\t\tifTrue: [ result := WordArray new: self size.\r\t\t\t^ self primDivArray: self and: other into: result ].\r\t(other isMemberOf: FloatArray)\r\t\tifTrue: [ result := FloatArray new: self size.\r\t\t\t^ self primDivArray: self and: other into: result ].\r\t^ super / other"},{"name":"primDivArray:and:into:","linesOfCode":7,"sourceCode":"primDivArray: rcvr and: other into: result\r\r\t<primitive: 'primitiveDivArrays' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveDivArrays.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) / (other at: i)\r\t].\r\t^ result.\r"},{"name":"primMulScalar:and:into:","linesOfCode":7,"sourceCode":"primMulScalar: rcvr and: other into: result\r\r\t<primitive: 'primitiveMulScalar' module:'KedamaPlugin'>\r\t\"^ KedamaPlugin doPrimitive: #primitiveMulScalar.\"\r\r\t1 to: rcvr size do: [:i |\r\t\tresult at: i put: (rcvr at: i) * other.\r\t].\r\t^ result.\r"},{"name":"atAllPut:","linesOfCode":4,"sourceCode":"atAllPut: value\r\t\"Fill the receiver with the given value\"\r\r\t<primitive: 145>\r\tsuper atAllPut: value"}],"meta":{"name":"WordArray class","instanceVariables":[],"methods":[{"name":"newFromStream:","linesOfCode":10,"sourceCode":"newFromStream: s\r\t\"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk.\"\r\t| len |\r\r\ts next = 16r80 ifTrue:\r\t\t[\"A compressed format.  Could copy what BitMap does, or use a \r\t\tspecial sound compression format.  Callers normally compress their own way.\"\r\t\t^ self error: 'not implemented'].\r\ts skip: -1.\r\tlen := s nextInt32.\r\t^ s nextWordsInto: (self basicNew: len)"}],"meta":null}},{"name":"Array","instanceVariables":[],"methods":[{"name":"asTraitComposition","linesOfCode":4,"sourceCode":"asTraitComposition\r\t^ self isEmpty\r\t\tifTrue: [ TaEmptyComposition new ]\r\t\tifFalse: [ TaSequence withAll: (self collect: [:each | each asTraitComposition]) ]"},{"name":"atWrap:","linesOfCode":12,"sourceCode":"atWrap: index \r\r    \"Answer the index'th element of the receiver.  If index is out of bounds,\r    let it wrap around from the end to the beginning until it is in bounds.\"\r    \r    \"Optimized to go through the primitive if possible\"\r    \r    \"(#(11 22 33) atWrap: 3) >>> 33\"\r    \"(#(11 22 33) atWrap: 2) >>> 22\"\r    \"(#(11 22 33) atWrap: 4) >>> 11\"\r    \r    <primitive: 60>\r    ^ self at: index - 1 \\\\ self size + 1 "},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ (self allSatisfy: [:each | each isSelfEvaluating]) and: [self class == Array]"},{"name":"literalEqual:","linesOfCode":6,"sourceCode":"literalEqual: other\r\r\tself class == other class ifFalse: [^ false].\r\tself size = other size ifFalse: [^ false].\r\tself with: other do: [:e1 :e2 |\r\t\t(e1 literalEqual: e2) ifFalse: [^ false]].\r\t^ true"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ { #array . self collect: [ :each | each slvmEncodeAsSExpression ]  }"},{"name":"preMultiplyByArray:","linesOfCode":5,"sourceCode":"preMultiplyByArray: a\r\t\"Answer a+*self where a is an Array.  Arrays are always understood as column vectors,\r\t so an n element Array is an n*1 Array.  This multiplication is legal iff self size = 1.\"\r\r\tself size = 1 ifFalse: [self error: 'dimensions do not conform'].\r\t^a * self first"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createArray: self class: objectModel arrayClass"},{"name":"elementsForwardIdentityTo:","linesOfCode":8,"sourceCode":"elementsForwardIdentityTo: otherArray\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t The identityHashes remain with the pointers rather than with the objects so that\r\t the objects in this array should still be properly indexed in any existing hashed\r\t structures after the mutation.\"\r\t<primitive: 72 error: ec>\r\tself primitiveFailed"},{"name":"asMapArgument","linesOfCode":2,"sourceCode":"asMapArgument\r\t^ self"},{"name":"asArray","linesOfCode":3,"sourceCode":"asArray\r\t\"Answer with the receiver itself.\"\r\r\t^ self"},{"name":"gtDisplayString","linesOfCode":2,"sourceCode":"gtDisplayString\r\r\t^ super gtDisplayString contractTo: 200"},{"name":"preMultiplyByMatrix:","linesOfCode":8,"sourceCode":"preMultiplyByMatrix: m\r\t\"Answer m+*self where m is a Matrix.\"\r\r\tm numberOfColumns = self size ifFalse: [self error: 'dimensions do not conform'].\r\t^ (1 to: m numberOfRows) collect: [ :row | \r\t\t\t| s |\r\t\t\ts := 0.\r\t\t\t1 to: self size do: [:k | s := (m at: row at: k) * (self at: k) + s].\r\t\ts ]"},{"name":"isArray","linesOfCode":2,"sourceCode":"isArray\r\t^true"},{"name":"hasLiteral:","linesOfCode":10,"sourceCode":"hasLiteral: literal\r\t\"Answer true if literal is identical to any literal in this array, even \r\tif imbedded in further array structure. This method is only intended \r\tfor private use by CompiledMethod hasLiteralSymbol:\"\r\r\t| lit |\r\t1 to: self size do: \r\t\t[:index | \r\t\t((lit := self at: index) literalEqual: literal) ifTrue: [^true].\r\t\t(Array == lit class and: [lit hasLiteral: literal]) ifTrue: [^true]].\r\t^false"},{"name":"settingStoreOn:","linesOfCode":11,"sourceCode":"settingStoreOn: aStream \r\t\"Use the literal form if possible.\"\r\r\tself isLiteral\r\t\tifTrue: \r\t\t\t[aStream nextPut: $#; nextPut: $(.\r\t\t\tself do: \r\t\t\t\t[:element | \r\t\t\t\telement settingStoreOn: aStream.\r\t\t\t\taStream space].\r\t\t\taStream nextPut: $)]\r\t\tifFalse: [super settingStoreOn: aStream]"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #Array earlyFields: self size fields: [self collect: [:each | each encodeGraphForMessagePackWith: graphEncoder]]"},{"name":"atWrap:put:","linesOfCode":4,"sourceCode":"atWrap: index put: anObject\r\t\"Optimized to go through the primitive if possible\"\r\t<primitive: 61>\r\t^ self at: index - 1 \\\\ self size + 1 put: anObject"},{"name":"hasLiteralSuchThat:","linesOfCode":7,"sourceCode":"hasLiteralSuchThat: testBlock\r\t\"Answer true if testBlock returns true for any literal in this array, even if imbedded in \tfurther Arrays or CompiledMethods.  This method is only intended for private use by \tCompiledMethod \thasLiteralSuchThat:\"\r\t| lit |\r\t1 to: self size do: [:index |\r\t\t(testBlock value: (lit := self at: index)) ifTrue: [^ true].\r\t\t(lit hasLiteralSuchThat: testBlock) ifTrue: [^ true]].\r\t^ false"},{"name":"printAsLiteralFormOn:","linesOfCode":3,"sourceCode":"printAsLiteralFormOn: aStream\r\taStream nextPut: $#.\r\tself printElementsOn: aStream\r"},{"name":"elementsForwardIdentityTo:copyHash:","linesOfCode":10,"sourceCode":"elementsForwardIdentityTo: otherArray copyHash: copyHash\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t If copyHash is true, the identityHashes remain with the pointers rather than with the\r\t objects so that the objects in the receiver should still be properly indexed in any\r\t existing hashed structures after the mutation.  If copyHash is false, then the hashes\r\t of the objects in otherArray remain unchanged.  If you know what you're doing this\r\t may indeed be what you want.\"\r\t<primitive: 249 error: ec>\r\tself primitiveFailed"},{"name":"generateSpec","linesOfCode":9,"sourceCode":"generateSpec\r\t| str spec |\r\tstr := self readStream.\t\r\t\r\tspec :=  OrderedCollection with: #SpecLayoutFrame.\r\t\t\r\t#( leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset: ) do: [:sel |\r\t\tspec add: sel.\r\t\tstr next ifNil: [ spec add: 0 ] ifNotNil: [:value | spec add: value ]].\r\t^ spec asArray"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\tself shouldBePrintedAsLiteral ifTrue: [self printAsLiteralFormOn: aStream. ^ self].\r\tself isSelfEvaluating ifTrue: [self printAsSelfEvaluatingFormOn: aStream. ^ self].\r\r\tsuper printOn: aStream"},{"name":"asTestMatrix","linesOfCode":5,"sourceCode":"asTestMatrix\r\r\t| matrix |\r\tmatrix := ParametrizedTestMatrix new.\r\tself do: [ :e | matrix addCase: e ].\r\t^ matrix"},{"name":"asLayoutFrame","linesOfCode":2,"sourceCode":"asLayoutFrame\r\t ^ LayoutFrame new fromArray: self"},{"name":"isLiteral","linesOfCode":2,"sourceCode":"isLiteral\r\t^self class == Array and: [self allSatisfy: [:each | each isLiteral]]"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"shouldBePrintedAsLiteral","linesOfCode":2,"sourceCode":"shouldBePrintedAsLiteral\r\r\t^self class == Array and: [ self allSatisfy: [ :each | each shouldBePrintedAsLiteral ] ]"},{"name":"+*","linesOfCode":4,"sourceCode":"+* aCollection\r\t\"Premultiply aCollection by self.  aCollection should be an Array or Matrix.\r\t The name of this method is APL's +.x squished into Smalltalk syntax.\"\r\r\t^aCollection preMultiplyByArray: self\r"},{"name":"refersToLiteral:","linesOfCode":3,"sourceCode":"refersToLiteral: literal\r\t^ (self literalEqual: literal) \r\t\tor: [ self hasLiteral: literal ]"},{"name":"fuelReplacement","linesOfCode":4,"sourceCode":"fuelReplacement\r\t^ self == Smalltalk specialObjectsArray\r\t\tifTrue: [ nil ]\r\t\tifFalse: [ self ]"},{"name":"copyWithDependent:","linesOfCode":3,"sourceCode":"copyWithDependent: newElement\r\tself size = 0 ifTrue:[^DependentsArray with: newElement].\r\t^self copyWith: newElement"},{"name":"printAsSelfEvaluatingFormOn:","linesOfCode":4,"sourceCode":"printAsSelfEvaluatingFormOn: aStream\r\r\taStream nextPut: ${.\r\tself do: [:el | el printOn: aStream] separatedBy: [ aStream nextPutAll: '. '].\r\taStream nextPut: $}"},{"name":"gtInspectorFastPrintOn:","linesOfCode":9,"sourceCode":"gtInspectorFastPrintOn: aStream\r\t\"Only scan through a limited number of elements to determine how to print the Array.\"\r\t((1 to: (self size min: self gtCollectionSizeThreshold)) allSatisfy: [ :anIndex | \r\t\t\t(self at: anIndex) shouldBePrintedAsLiteral ]) ifTrue: [\r\t\tself printAsLiteralFormOn: aStream.  ^ self].\r\t((1 to: (self size min: self gtCollectionSizeThreshold)) allSatisfy: [ :anIndex | \r\t\t\t(self at: anIndex) isSelfEvaluating ])  ifTrue: [\r\t\tself printAsSelfEvaluatingFormOn: aStream. ^ self].\r\r\tsuper printOn: aStream"},{"name":"fuelAccept:","linesOfCode":6,"sourceCode":"fuelAccept: aGeneralMapper\r\t\r\t\"This IF is because there are subclasses of Array that are weak. If we do not put this IF, all subclasses fuel be using the #visitVariableObject:, loosing the capability of the weak\r\tHowever, this method is just to optimize the method lookup of the message #fuelAccept:. If this method is removed, the default behavior of Object shuld work as well. If the performance is not that different, then we can remove this method which has an ugly if.\"\r\t^ self class isWeak\r\t\tifTrue: [ aGeneralMapper visitWeakObject: self ]\r\t\tifFalse: [ aGeneralMapper visitVariableObject: self ]\r\t\r\t"},{"name":"storeOn:","linesOfCode":11,"sourceCode":"storeOn: aStream \r\t\"Use the literal form if possible.\"\r\r\tself shouldBePrintedAsLiteral\r\t\tifTrue: \r\t\t\t[aStream nextPut: $#; nextPut: $(.\r\t\t\tself do: \r\t\t\t\t[:element | \r\t\t\t\telement storeOn: aStream.\r\t\t\t\taStream space].\r\t\t\taStream nextPut: $)]\r\t\tifFalse: [super storeOn: aStream]"},{"name":"closureDescriptionForCaching","linesOfCode":11,"sourceCode":"closureDescriptionForCaching\r\t^ ByteString streamContents: [ :out |\r\t\tout << ${.\r\t\tself doWithIndex: [ :element :index |\r\t\t\tindex > 1 ifTrue: [ \r\t\t\t\tout nextPut: $|\r\t\t\t].\r\t\t\tout nextPutAll: element closureDescriptionForCaching\r\t\t].\r\t\tout << $}.\r\t]"},{"name":"elementsExchangeIdentityWith:","linesOfCode":33,"sourceCode":"elementsExchangeIdentityWith: otherArray\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t At the same time, all pointers to the elements of otherArray are replaced by\r\t pointers to the corresponding elements of this array.  The identityHashes remain\r\t with the pointers rather than with the objects so that objects in hashed structures\r\t should still be properly indexed after the mutation.\"\r\r\t<primitive: 128 error: ec>\r\t| minimalRequiredSize |\r\tec == #'bad receiver' ifTrue:\r\t\t[^self error: 'receiver must be of class Array'].\r\tec == #'bad argument' ifTrue:\r\t\t[^self error: (otherArray class == Array\r\t\t\t\t\t\tifTrue: ['arg must be of class Array']\r\t\t\t\t\t\tifFalse: ['receiver and argument must have the same size'])].\r\tec == #'inappropriate operation' ifTrue:\r\t\t[^self error: 'can''t become immediates such as SmallIntegers or Characters'].\r\tec == #'no modification' ifTrue:\r\t\t[^self error: 'can''t become immutable objects'].\r\tec == #'object is pinned' ifTrue:\r\t\t[^self error: 'can''t become pinned objects'].\r\tec == #'insufficient object memory' ifTrue:\r\t\t[\r\t\t\tminimalRequiredSize := \r\t\t\t\t(self sumNumbers: [ :anElement | anElement sizeInMemory ]) \r\t\t\t\t+ (otherArray sumNumbers: [ :anElement | anElement sizeInMemory ]).\r\t\t\t\r\t\t\tSmalltalk garbageCollect < minimalRequiredSize ifTrue:\r\t\t\t\t[ (Smalltalk growMemoryByAtLeast: minimalRequiredSize) < minimalRequiredSize ifTrue:[\r\t\t\t\t\tself error: 'Could not allocate enought memory for two way become']].\r\t\t\r\t\t ^self elementsExchangeIdentityWith: otherArray].\r\tself primitiveFailed"}],"meta":{"name":"Array class","instanceVariables":[],"methods":[{"name":"braceWith:","linesOfCode":7,"sourceCode":"braceWith: a\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 1.\r\tarray at: 1 put: a.\r\t^ array"},{"name":"braceWith:with:with:with:","linesOfCode":10,"sourceCode":"braceWith: a with: b with: c with: d\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 4.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\tarray at: 3 put: c.\r\tarray at: 4 put: d.\r\t^ array"},{"name":"new:","linesOfCode":6,"sourceCode":"new: sizeRequested \r\t\"Answer an instance of this class with the number of indexable\r\tvariables specified by the argument, sizeRequested.\r\t\r\tThis is a shortcut (direct call of primitive, no #initialize, for performance\"\r\r\t<primitive: 71>  \"This method runs primitively if successful\"\r\t^ self basicNew: sizeRequested  \"Exceptional conditions will be handled in basicNew:\"\r"},{"name":"braceWith:with:","linesOfCode":8,"sourceCode":"braceWith: a with: b \r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 2.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\t^ array"},{"name":"braceWithNone","linesOfCode":4,"sourceCode":"braceWithNone\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t^ self new: 0"},{"name":"braceStream:","linesOfCode":4,"sourceCode":"braceStream: nElements\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t^ WriteStream basicNew braceArray: (self new: nElements)\r"},{"name":"braceWith:with:with:","linesOfCode":9,"sourceCode":"braceWith: a with: b with: c \r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 3.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\tarray at: 3 put: c.\r\t^ array"},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #Array ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext doWithIndex: [ :eachValue :index |\r\t\t\tresult at: index put: eachValue\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"},{"name":"empty","linesOfCode":3,"sourceCode":"empty\r\t\"A canonicalized empty Array instance.\"\r\t^ #()"}],"meta":null}},{"name":"SequenceableCollection","instanceVariables":[],"methods":[{"name":"copyWith:","linesOfCode":12,"sourceCode":"copyWith: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver and has \r\tnewElement at the last element.\"\r\r\t| newIC |\r\tnewIC := self species new: self size + 1.\r\tnewIC \r\t\treplaceFrom: 1\r\t\tto: self size\r\t\twith: self\r\t\tstartingAt: 1.\r\tnewIC at: newIC size put: newElement.\r\t^newIC"},{"name":"at:incrementBy:","linesOfCode":4,"sourceCode":"at: index incrementBy: value\r\t\"(#(1 2 3 4) at: 3 incrementBy: 2) >>> 5\"\r\t\"(#(1 2 3 4) at: 2 incrementBy: 2) >>> 4\"\r\t\r\t^self at: index put: (self at: index) + value"},{"name":"copyReplaceFrom:to:with:","linesOfCode":29,"sourceCode":"copyReplaceFrom: start to: stop with: replacementCollection \r\t\"Answer a copy of the receiver satisfying the following conditions: If \r\tstop is less than start, then this is an insertion; stop should be exactly \r\tstart-1, start = 1 means insert before the first character, start = size+1 \r\tmeans append after last character. Otherwise, this is a replacement; start \r\tand stop have to be within the receiver's bounds.\"\r\r\t| newSequenceableCollection newSize endReplacement |\r\tnewSize := self size - (stop - start + 1) + replacementCollection size.\r\tendReplacement := start - 1 + replacementCollection size.\r\tnewSequenceableCollection := self species new: newSize.\r\tstart > 1 ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: 1\r\t\t\tto: start - 1\r\t\t\twith: self\r\t\t\tstartingAt: 1].\r\tstart <= endReplacement ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: start\r\t\t\tto: endReplacement\r\t\t\twith: replacementCollection\r\t\t\tstartingAt: 1].\r\tendReplacement < newSize ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: endReplacement + 1\r\t\t\tto: newSize\r\t\t\twith: self\r\t\t\tstartingAt: stop + 1].\r\t^newSequenceableCollection"},{"name":"reject:thenCollect:","linesOfCode":8,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Optimized version of Collection>>#reject:thenCollect:\"\r\t\r\t\"(#(1 2 3 4) reject: [:each | each = 3 ] thenCollect: [:each | each + 10 ]) >>> #(11 12 14)\"\r\t\r\t| each |\r\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(rejectBlock value: (each := self at: index))\r\t\t\t\tifFalse: [ stream nextPut: (collectBlock value: each) ]]]"},{"name":"seventh","linesOfCode":5,"sourceCode":"seventh\r\t\"Answer the seventh element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) seventh >>> #g\"\r\r\t^ self at: 7"},{"name":"stonOn:","linesOfCode":6,"sourceCode":"stonOn: stonWriter\r\t\"Instances of STON listClass will be encoded directly, without a class tag.\r\tOther (sub)classes will be encoded with a class tag and will use a list representation. \"\r\r\tself class == STON listClass\r\t\tifTrue: [ stonWriter writeList: self ]\r\t\tifFalse: [ super stonOn: stonWriter ]"},{"name":"asFloatArray","linesOfCode":7,"sourceCode":"asFloatArray\r\t\"Answer a FloatArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| floatArray |\r\tfloatArray := FloatArray new: self size.\r\t1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].\r\t^floatArray"},{"name":"flatCollect:","linesOfCode":12,"sourceCode":"flatCollect: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. optimized version for Sequencable Collection and subclasses\r\timplementing #writeStream\"\r\r\t\"(#( (2 -3) (4 -5) #(-6)) flatCollect: [ :e | e abs  ]) >>> #(2 3 4 5 6)\"\r\r\t\"(#( (2 -3) #((4 -5)) #(-6)) flatCollect: [ :e | e abs  ]) >>> #(2 3 #(4 5) 6)\"\r\r\tself isEmpty\r\t\tifTrue: [ ^ self copy ].\r\t^self species \r\t\tnew: 0\r\t\tstreamContents: [ :stream | self do: [ :each | stream nextPutAll: (aBlock value: each) ] ]"},{"name":"splitOn:do:","linesOfCode":4,"sourceCode":"splitOn: splitter do: aBlock\r\t\"Perform an action specified as aBlock to each of the elements of the receiver that have been split using the splitter argument. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\t\"(String streamContents: [:s | 'Pharo is cool' splitOn: Character space do: [:each | s << each ]])>>>'Pharoiscool'\"\r\t\r\t^ splitter split: self do: aBlock"},{"name":"replaceAll:with:","linesOfCode":15,"sourceCode":"replaceAll: oldObject with: newObject \r\t\"Replace all occurrences of oldObject with newObject\"\r\t\"(#(a b a d a) replaceAll: #a with: #e) >>> #(e b e d e)\"\r\t\r\t| index |\r\tindex := self\r\t\t\t\tindexOf: oldObject\r\t\t\t\tstartingAt: 1\r\t\t\t\tifAbsent: [0].\r\t[index = 0]\r\t\twhileFalse: \r\t\t\t[self at: index put: newObject.\r\t\t\tindex := self\r\t\t\t\t\t\tindexOf: oldObject\r\t\t\t\t\t\tstartingAt: index + 1\r\t\t\t\t\t\tifAbsent: [0]]"},{"name":"asGPUFloat32x2Array","linesOfCode":2,"sourceCode":"asGPUFloat32x2Array\r\t^ self asGPUArrayOfType: #Float32x2"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock \r\t\"Refer to the comment in Collection|do:.\"\r\t1 to: self size do:\r\t\t[:index | aBlock value: (self at: index)]"},{"name":"before:","linesOfCode":7,"sourceCode":"before: target\r\t\"Answer the receiver's element immediately before target. Raise an\r\terror if target is not an element of the receiver, or if there are no \r\telements before it (i.e. it is the first element).\"\r\t\"(#(11 22 33) before: 22) >>> 11\"\r\t\"(#(11 22 33) before: 33) >>> 22\"\r\r\t^ self before: target ifAbsent: [self errorNotFound: target]"},{"name":"allPairsDo:","linesOfCode":5,"sourceCode":"allPairsDo: aBinaryBlock\r\t\"Iterate over all the pairs of the receiver and apply the binaryBlock\r\tto each pair. \"\r\r\t\"(Array streamContents: [ :stream | #(0 1 2 3) allPairsDo: [ :first :second | stream nextPut: { first . second } ] ]) >>> #(#(0 0) #(0 1) #(0 2) #(0 3) #(1 0) #(1 1) #(1 2) #(1 3) #(2 0) #(2 1) #(2 2) #(2 3) #(3 0) #(3 1) #(3 2) #(3 3))\"\r\r\tself do: [ :first | self do: [ :second | aBinaryBlock value: first value: second ] ]"},{"name":"combinations:atATimeDo:","linesOfCode":10,"sourceCode":"combinations: kk atATimeDo: aBlock\r\t\"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations.\"\r\r\t\"(Array streamContents: [:stream | 'abcde' combinations: 3 atATimeDo: [:each | stream nextPut: each copy]]) >>> #(#($a $b $c) #($a $b $d) #($a $b $e) #($a $c $d) #($a $c $e) #($a $d $e) #($b $c $d) #($b $c $e) #($b $d $e) #($c $d $e))\"\r\r\t| aCollection |\r\taCollection := Array new: kk.\r\tself\r\t\tcombinationsAt: 1\r\t\tin: aCollection\r\t\tafter: 0\r\t\tdo: aBlock"},{"name":"putOn:","linesOfCode":5,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream by iterating over its elements.\r\tIn general we assume aStream accepts the receiver's elements as element type.\r\tReturn self.\"\r\r\tself do: [ :each | each putOn: aStream ]"},{"name":"allButFirst","linesOfCode":5,"sourceCode":"allButFirst\r\t\"Answer a copy of the receiver containing all but the first\r\telement. Raise an error if there are not enough elements.\"\t\r\t\"#(a b c) allButFirst >>> #(b c)\"\r\r\t^ self allButFirst: 1"},{"name":"split:indicesDo:","linesOfCode":15,"sourceCode":"split: aSequenceableCollection indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of aSequenceableCollection that have been identified by taking the receiver as a splitter.\"\r\t\"('||' split: 'foo||bar||2')>>>#('foo' 'bar' '2') asOrderedCollection\"\r\t\"(String streamContents: [:s | '||' split: 'foo||bar||2' indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:3 s:6 e:8 s:11 e:11 '\"\r\t\r\t| position oldPosition |\r\tposition := 1.\r\toldPosition := position.\r\tposition := aSequenceableCollection indexOfSubCollection: self startingAt: position.\r\t\r\t[ position > 0 ] whileTrue: [\r\t\taBlock value: oldPosition value: position - 1.\r\t\tposition := position + self size.\r\t\toldPosition := position.\r\t\tposition := aSequenceableCollection indexOfSubCollection: self startingAt: position.\r\t].\r\r\taBlock value: oldPosition value: aSequenceableCollection size.\r\r"},{"name":"reverseDo:","linesOfCode":7,"sourceCode":"reverseDo: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument, \r\tstarting with the last element and taking each in sequence up to the \r\tfirst. For SequenceableCollections, this is the reverse of the enumeration \r\tfor do:.\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) reverseDo: [:each | stream nextPut: each + 10]]) >>> #(13 12 11)\"\r\r\tself size to: 1 by: -1 do: [:index | aBlock value: (self at: index)]"},{"name":"asGroup","linesOfCode":2,"sourceCode":"asGroup\r\t^ (RSGroup new: self size) addAll: self; yourself"},{"name":"bind:","linesOfCode":5,"sourceCode":"bind: aBlock \r\r\t\"Extract items from the receiver and use them as arguments of aBlock. Signal an error\r\t(ArgumentsCountMismatch) when the arguments count of aBlock does not match the receiver size.\" \r\t\r\t\"(#(1 2 3) bind: [ :first :second :third | first + second + third ]) >>> 6\"\r\r\t^ aBlock valueWithArguments: self"},{"name":"joinUsing:last:","linesOfCode":8,"sourceCode":"joinUsing: joiner last: last \r\t\"Append the elements of the receiver separating them with the joiner argument and handle the last elment separation using the last argument.\"\r\t\r\t\"(#(1 2 3 4) joinUsing: ', ' last: ' and ') >>> '1, 2, 3 and 4'\"\r\t\r\t(self size = 0) ifTrue: [  ^ '' ].\r\t(self size = 1) ifTrue: [  ^ self first asString ].\r\t^ last join: (Array\r\t\t\t\twith: (joiner join: self allButLast)\r\t\t\t\twith: self last)"},{"name":"asPetitStream","linesOfCode":2,"sourceCode":"asPetitStream\r\t^ PPStream on: self"},{"name":"isSortedBy:","linesOfCode":15,"sourceCode":"isSortedBy: aBlock\r\t\"Return true if the receiver is sorted by the given criterion.\"\r\t\"(#(1 2 3) isSortedBy: [:a :b | a <= b ]) >>> true\"\r\t\"(#(1 2 3) isSortedBy: [:a :b | a >= b ]) >>> false\"\r\t\"(#(xa xc xz xb xy) isSortedBy: #last ascending) >>> false\"\r\t\"(#(xa xb xc xy xz) isSortedBy: #last ascending) >>> true\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\t(aBlock value: lastElm value: elm) ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"isSorted","linesOfCode":14,"sourceCode":"isSorted\r\t\"Return true if the receiver is sorted by the given criterion.\r\tOptimization for isSortedBy: [:a :b | a <= b].\"\r\t\"#(1 2 3) isSorted >>> true\"\r\t\"#(1 2 3 0) isSorted >>> false\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\tlastElm <= elm ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"asDastrelCollectionWithContext","linesOfCode":2,"sourceCode":"asDastrelCollectionWithContext\r\t^ DASLCollectionWithContext new collection: self"},{"name":"do:separatedBy:","linesOfCode":8,"sourceCode":"do: elementBlock separatedBy: separatorBlock\r\t\"Evaluate the elementBlock for all elements in the receiver,\r\tand evaluate the separatorBlock between.\"\r\t\r\t\"(Array streamContents: ([:stream | #(1 2 3) do: [:each | stream nextPut: (each + 10)] separatedBy: [ stream nextPut: 0 ]])) >>> #(11 0 12 0 13)\"\r\r\t1 to: self size do:\r\t\t[:index |\r\t\tindex = 1 ifFalse: [separatorBlock value].\r\t\telementBlock value: (self at: index)]"},{"name":"reject:thenDo:","linesOfCode":7,"sourceCode":"reject: rejectBlock thenDo: aBlock\r\t\"Refer to the comment in Collection>>#reject:thenDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) reject: [:each | each = 3 ] thenDo: [:each | stream nextPut: each + 10]]) >>> #(11 12 14)\"\r\t\r\t|  each |\r\t\r\t1 to: self size do: [ :index |\r\t\t(rejectBlock value: (each := self at: index))\r\t\t\tifFalse: [ aBlock value: each ]]."},{"name":"collect:thenSelect:","linesOfCode":9,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Optimized version of Collection>>#collect:thenSelect:\"\r\t\r\t\"(#(1 2 3) collect: [:each | each + 10 ] thenSelect: [:each | each even]) >>> #(12)\"\r\t\r\t| each |\r\t\r\t^  self class new: self size streamContents: [ :stream |\r\t\t1 to: self size do: [:index |\r\t\t\teach := collectBlock value: (self at: index).\r\t\t\t(selectBlock value: each)\r\t\t\t\tifTrue: [ stream nextPut: each ]]]"},{"name":"paddedWith:do:","linesOfCode":10,"sourceCode":"paddedWith: otherCollection do: twoArgBlock \r\t\"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection.\r\tMissing elements from either will be passed as nil.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) paddedWith: #(40 50 60) do: [:first :second | stream nextPut: (first + second)]]) >>> #(50 70 90) \"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) paddedWith: #(40 50) do: [:a :b | stream nextPut: {a. b} ]]) >>> #(#(10 40) #(20 50) #(30 nil)) \"\r\r\t\"(Array streamContents: [:stream | #(10 20) paddedWith: #(40 50 60) do: [:a :b | stream nextPut: {a. b} ]]) >>> #(#(10 40) #(20 50) #(nil 60))\"\r\t\t\r\t1 to: (self size max: otherCollection size) do:\r\t\t[:index | twoArgBlock value: (self at: index ifAbsent: [])\r\t\t\t\tvalue: (otherCollection at: index ifAbsent: [])]"},{"name":"collectWithIndex:","linesOfCode":3,"sourceCode":"collectWithIndex: elementAndIndexBlock\r\t\"Use the new version with consistent naming\"\r\t^ self withIndexCollect: elementAndIndexBlock"},{"name":"swap:with:","linesOfCode":7,"sourceCode":"swap: oneIndex with: anotherIndex \r\t\"Move the element at oneIndex to anotherIndex, and vice-versa.\"\r\t\"(#(a b c d e) swap: 5 with: 1) >>> #(e b c d a)\"\r\r\t| element |\r\telement := self at: oneIndex.\r\tself at: oneIndex put: (self at: anotherIndex).\r\tself at: anotherIndex put: element"},{"name":"difference:","linesOfCode":3,"sourceCode":"difference: aCollection\r\t\"Answer the difference of two sequences preserving order and collection type.\"\r\t^ self reject: [:each | aCollection includes: each]"},{"name":"runningMax:","linesOfCode":4,"sourceCode":"runningMax: aSubsetSize\r\t\"Running max. See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningMax: 3) >>> {2 . 2 . 3 . 3}\"\r\r\t^ self running: [ :subset | subset max ] of: aSubsetSize"},{"name":"beginsWith:","linesOfCode":9,"sourceCode":"beginsWith: aSequenceableCollection\r\t\"Answer true if the receiver starts with the argument collection\"\r\t\r\t\"#(1 2 3 4 5) beginsWith: #() >>> false\"\r\t\"#(1 2 3) beginsWith: #(1 2 3 4 5) >>> false\"\r\t\"#(1 2 3 4 5) beginsWith: #(0 1 2) >>> false\"\r\t\"#(1 2 3 4 5) beginsWith: #(1 2 3) >>> true\"\r\t\r\t(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].\r\taSequenceableCollection withIndexDo: [:each :index | (self at: index) ~= each ifTrue: [^false]].\r\t^true"},{"name":"findBinary:","linesOfCode":9,"sourceCode":"findBinary: aBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, raise an error.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ]) >>> 11 \"\r\r\t^ self findBinary: aBlock do: [ :found | found ] ifNone: [ self errorNotFound: aBlock ]"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\t\"SequencableCollections cannot implement removing.\"\r\r\tself shouldNotImplement"},{"name":"indexOfAnyOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"indexOfAnyOf: aCollection startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of any element included in aCollection after start within the receiver.\r\tIf the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.\r\tNote: it is user responsibility to provide aCollection that behaves relatevily fast when asked for includes: (like a Set)\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 2 ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 4 ifAbsent: 7) >>> 7\"\r\r\tstart to: self size do:\r\t\t[:index |\r\t\t(aCollection includes: (self at: index)) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"asGPUFloat32x3Array","linesOfCode":2,"sourceCode":"asGPUFloat32x3Array\r\t^ self asGPUArrayOfType: #Float32x3"},{"name":"asGPUArrayOfType:","linesOfCode":2,"sourceCode":"asGPUArrayOfType: type\r\t^ SGPUCompilationEnvironment current constructArrayOfType: type with: self"},{"name":"groupsOf:atATimeDo:","linesOfCode":17,"sourceCode":"groupsOf: n atATimeDo: aBlock \r\t\"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.\r\tAllows use of a flattened \r\tarray for things that naturally group into groups of n.\r\tIf aBlock has a single argument, pass it an array of n items,\r\totherwise, pass the items as separate arguments.\r\tSee also pairsDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40 50) groupsOf: 2 atATimeDo:  [:first :second | stream nextPut: (first + second)]]) >>> #(30 70)\"\r\t\r\t| passArray |\r\tpassArray := (aBlock numArgs = 1).\r\tn\r\t\tto: self size\r\t\tby: n\r\t\tdo: [:index | | args | \r\t\t\targs := (self copyFrom: index - n + 1 to: index) asArray.\r\t\t\tpassArray ifTrue: [ aBlock value: args ]\r\t\t\t\tifFalse: [ aBlock valueWithArguments: args ]]."},{"name":"overlappingPairsWithIndexDo:","linesOfCode":5,"sourceCode":"overlappingPairsWithIndexDo: aBlock \r\t\"Emit overlapping pairs of my elements into aBlock, along with an index.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40) overlappingPairsWithIndexDo: [:first :second :index| stream nextPut: (first + second + index)]]) >>> #(31 52 73)\"\r\r\t1 to: self size - 1\r\t\tdo: [:i | aBlock value: (self at: i) value: (self at: i + 1) value: i ]"},{"name":"atPin:","linesOfCode":9,"sourceCode":"atPin: index \r\t\"Return the index'th element of me if possible.\r\tReturn the first or last element if index is out of bounds.\"\r\t\"(#(w x y z) atPin: 2) >>> #x\"\r\t\"(#(w x y z) atPin: 4) >>> #z\"\r\t\"(#(w x y z) atPin: 8) >>> #z\"\r\r\tindex < 1 ifTrue: [^ self first].\r\tindex > self size ifTrue: [^ self last].\r\t^ self at: index"},{"name":"max:","linesOfCode":11,"sourceCode":"max: aBlock\r\t| max |\r\tself ifEmpty: [ ^ nil ].\r\tmax := aBlock value: self first.\r\tself\r\t\tallButFirstDo:\r\t\t\t[ :each | \r\t\t\t| value |\r\t\t\tvalue := aBlock value: each.\r\t\t\tmax := max max: value ].\r\t^ max"},{"name":"asGPUFloat64x4Array","linesOfCode":2,"sourceCode":"asGPUFloat64x4Array\r\t^ self asGPUArrayOfType: #Float64x4"},{"name":"indexOfAnyOf:startingAt:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection startingAt: start\r\t\"Answer the index of the first occurrence of any element included in aCollection after start within the receiver.\r\tIf the receiver does not contain anElement, answer zero, which is an invalid index.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 2) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 4) >>> 0\"\r\r\t^self indexOfAnyOf: aCollection startingAt: start ifAbsent: [0]"},{"name":"first:","linesOfCode":5,"sourceCode":"first: n\r\t\"Answer the first n elements of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"(#(a b c d e f g h ) first: 3) >>> #(a b c)\"\r\r\t^ self copyFrom: 1 to: n"},{"name":"copyReplaceAll:with:","linesOfCode":15,"sourceCode":"copyReplaceAll: oldSubCollection with: newCollection\r\t\"Answer a copy of the receiver in which all occurrences of\r\toldSubCollection have been replaced by newCollection \"\r\r\t| aString startSearch currentIndex endIndex |\r\t\r\taString := self.\r\tstartSearch := 1.\r\t[(currentIndex := aString indexOfSubCollection: oldSubCollection startingAt: startSearch) > 0]\r\t\twhileTrue: [\r\t\t\tendIndex := currentIndex + oldSubCollection size - 1.\r\t\t\taString := aString\r\t\t\t\t\tcopyReplaceFrom: currentIndex\r\t\t\t\t\tto: endIndex\r\t\t\t\t\twith: newCollection.\r\t\t\t\tstartSearch := currentIndex + newCollection size].\r\r\t^ aString"},{"name":"endsWith:","linesOfCode":7,"sourceCode":"endsWith: aSequenceableCollection\r\t\"Answer true if the receiver ends with the argument collection\"\r\t\r\t| start |\r\t(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].\r\tstart := self size - aSequenceableCollection size.\r\taSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].\r\t^true"},{"name":"permutationsStartingAt:do:","linesOfCode":9,"sourceCode":"permutationsStartingAt: anInteger do: aBlock\r\tanInteger > self size\r\t\tifTrue: [ ^ self ].\r\tanInteger = self size\r\t\tifTrue: [ ^ aBlock value: self ].\r\tanInteger to: self size do: [ :i | \r\t\tself swap: anInteger with: i.\r\t\tself permutationsStartingAt: anInteger + 1 do: aBlock.\r\t\tself swap: anInteger with: i ]"},{"name":"asPointArray","linesOfCode":7,"sourceCode":"asPointArray\r\t\"Answer an PointArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| pointArray |\r\tpointArray := PointArray new: self size.\r\t1 to: self size do:[:i| pointArray at: i put: (self at: i)].\r\t^pointArray"},{"name":"mergeSortFrom:to:src:dst:by:","linesOfCode":9,"sourceCode":"mergeSortFrom: first to: last src: src dst: dst by: aBlock\r\t\"Private. Split the range to be sorted in half, sort each half, and \r\tmerge the two half-ranges into dst.\"\r\r\t| middle |\r\tfirst = last ifTrue: [^ self].\r\tmiddle := (first + last) // 2.\r\tself mergeSortFrom: first to: middle src: dst dst: src by: aBlock.\r\tself mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.\r\tsrc mergeFirst: first middle: middle last: last into: dst by: aBlock"},{"name":"asDigitsToPower:do:","linesOfCode":8,"sourceCode":"asDigitsToPower: anInteger do: aBlock\r\t\"Repeatedly value aBlock with a single Array.  Adjust the collection\r\tso that aBlock is presented all (self size raisedTo: anInteger) possible \r\tcombinations of the receiver's elements taken as digits of an anInteger long number.\"\r\r\t\"(Array streamContents: [:stream | (0 to: 1) asDigitsToPower: 4 do: [:each | stream nextPut: each copy]]) >>> #((0 0 0 0) (0 0 0 1) (0 0 1 0) (0 0 1 1) (0 1 0 0) (0 1 0 1) (0 1 1 0) (0 1 1 1) (1 0 0 0) (1 0 0 1) (1 0 1 0) (1 0 1 1) (1 1 1 0) (1 1 1 1))\"\r\r\t| aCollection |\r\taCollection := Array new: anInteger.\r\tself asDigitsAt: 1 in: aCollection do: aBlock"},{"name":"select:","linesOfCode":8,"sourceCode":"select: aBlock \r\t\"Optimized version of Collection>>#select:\"\r\t\r\t\"(#(1 2 3 4) select: [:each | each > 2 ]) >>> #(3 4)\"\r\t\r\t| each |\r\t^ self species new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(aBlock value: (each := self at: index))\r\t\t\t\tifTrue: [ stream nextPut: each ]]]"},{"name":"do:without:","linesOfCode":7,"sourceCode":"do: aBlock without: anItem\r\t\"Enumerate all elements in the receiver.\r\tExecute aBlock for those elements that are not equal to the given item\"\r\t\"Refer to the comment in Collection|do:.\"\r\t\r\t\"(Array streamContents: ([:stream | #(1 2 3) do: [:each | stream nextPut: (each + 10)] without: 2])) >>> #(11 13)\"\r\t\r\t1 to: self size do:\r\t\t[:index | anItem = (self at: index) ifFalse:[aBlock value: (self at: index)]]"},{"name":"allButLast","linesOfCode":5,"sourceCode":"allButLast\r\t\"Answer a copy of the receiver containing all but the last\r\telement. Raise an error if there are not enough elements.\"\r\t\"#(a b c d) allButLast >>> #(a b c)\"\r\r\t^ self allButLast: 1"},{"name":"after:","linesOfCode":5,"sourceCode":"after: target\r\t\"Answer the element after target.  Raise an error if target is not\r\tin the receiver, or if there are no elements after it.\"\r\t\"(#(a b c d) after: #b) >>> #c\"\r\r\t^ self after: target ifAbsent: [self errorNotFound: target]"},{"name":"reduceRight:","linesOfCode":17,"sourceCode":"reduceRight: aBlock\r\t\"Fold the result of the receiver from right to left into aBlock. The argument aBlock must take two or more arguments.\"\r\r\t\"(#(1 2 3) reduceRight: [ :a :b | a - b ]) >>> (1 - (2 - 3))\"\r\t\"(#(1 2 3) reduceRight: [ :a :b | a - b ]) >>> 2\"\r\t\"(#(1 + 3 - 5) reduceRight: [ :a :op :b | a perform: op with: b ]) >>> (1 + (3 - 5))\"\r\t\"(#(1 + 3 - 5) reduceRight: [ :a :op :b | a perform: op with: b ]) >>> -1\"\r\r\t| arguments |\r\tself emptyCheck.\r\targuments := Array new: aBlock argumentCount.\r\t(arguments size = 0 or: [ (self size + 1) \\\\ (arguments size - 1) > 0 ])\r\t\tifTrue: [ self error: 'Collection size and block argument count do not match.' ].\r\targuments at: arguments size put: self last.\r\tself size - arguments size + 1 to: 1 by: 1 - arguments size do: [ :index |\r\t\targuments\r\t\t\treplaceFrom: 1 to: aBlock argumentCount - 1 with: self startingAt: index;\r\t\t\tat: arguments size put: (aBlock valueWithArguments: arguments) ].\r\t^ arguments last"},{"name":"lastIndexOf:ifAbsent:","linesOfCode":7,"sourceCode":"lastIndexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOf: #a ifAbsent: 7) >>> 5\"\r\t\"(#(a b a d e) lastIndexOf: #c ifAbsent: 7) >>> 7\"\r\t\r\t^self lastIndexOf: anElement startingAt: self size ifAbsent: exceptionBlock"},{"name":"=","linesOfCode":8,"sourceCode":"= otherCollection \r\t\"Answer true if the receiver is equivalent to the otherCollection.\r\tFirst test for identity, then rule out different species and sizes of\r\tcollections. As a last resort, examine each element of the receiver\r\tand the otherCollection.\"\r\r\tself == otherCollection ifTrue: [^ true].\r\tself species == otherCollection species ifFalse: [^ false].\r\t^ self hasEqualElements: otherCollection"},{"name":"allButLastDo:","linesOfCode":5,"sourceCode":"allButLastDo: block\r\r\t\"Executes aBlock on each of the receiver's elements except for the last one\"\r\r\t\"(Array streamContents: [:stream | #(1 2 3) allButLastDo: [:each | stream nextPut: (each + 10)]]) >>> #(11 12)\"\r\r\t1 to: self size - 1 do:\r\t\t[:index | block value: (self at: index)]"},{"name":"atAll:","linesOfCode":10,"sourceCode":"atAll: indexArray\r\t\"Answer a new collection like the receiver which contains all elements\r\tof the receiver at the indices of indexArray.\"\r\t\"(#('one' 'two' 'three' 'four') atAll: #(3 2 4)) >>> #('three' 'two' 'four')\"\r\r\t| newCollection |\r\tnewCollection := self species ofSize: indexArray size.\r\t1 to: indexArray size do:\r\t\t[:index |\r\t\tnewCollection at: index put: (self at: (indexArray at: index))].\r\t^ newCollection"},{"name":"from:to:do:","linesOfCode":4,"sourceCode":"from: start to: stop do: aBlock\r\t\"Evaluate aBlock for all elements between start and stop (inclusive).\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40) from: 2 to: 3 do: [:each | stream nextPut: each]]) >>> #(20 30)\"\r\r\tstart to: stop do: [:index | aBlock value: (self at: index)]"},{"name":"runningMin:","linesOfCode":4,"sourceCode":"runningMin: aSubsetSize\r\t\"Running min. See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningMin: 3) >>> {1 . 1 . 2 . 2}\"\r\r\t^ self running: [ :subset | subset min ] of: aSubsetSize"},{"name":"beginsWithAnyOf:","linesOfCode":3,"sourceCode":"beginsWithAnyOf: aCollection\r\t\"Return true if the receiver starts with any of the elements in aCollection.\"\r\t^aCollection anySatisfy:[:prefix| self beginsWith: prefix]"},{"name":"asStringWithCr","linesOfCode":12,"sourceCode":"asStringWithCr\r\t\"Convert to a string with returns between items.  Elements are\rusually strings.\r\t Useful for labels for PopUpMenus.\"\r\t| labelStream |\r\tlabelStream := (String new: 200) writeStream.\r\tself do: [:each |\r\t\teach isString\r\t\t\tifTrue: [labelStream nextPutAll: each; cr]\r\t\t\tifFalse: [each printOn: labelStream. labelStream cr]].\r\tself size > 0 ifTrue: [labelStream skip: -1].\r\t^ labelStream contents"},{"name":"copyEmpty","linesOfCode":2,"sourceCode":"copyEmpty\r\t^ self species new: 0"},{"name":"readStreamDo:","linesOfCode":4,"sourceCode":"readStreamDo: aBlock\r\t\"Evaluates the argument with the read stream of the collection. Answers the result.\"\r\t\r\t\"#(3 4 5) readStreamDo: [ :stream | stream contents ] >>> #(3 4 5)\"\r\r\t^ aBlock value: self readStream"},{"name":"with:collect:","linesOfCode":12,"sourceCode":"with: otherCollection collect: twoArgBlock \r\t\"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection.\"\r\t\r\t\"(#(1 2 3) with: #(4 5 6) collect: [:a :b | a + b]) >>> #(5 7 9)\"\r\t\r\t| result |\r\totherCollection size = self size ifFalse: [self errorSizeMismatch].\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result at: index put:\r\t\t(twoArgBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: (otherCollection at: index))].\r\t^ result"},{"name":"groupsOf:","linesOfCode":12,"sourceCode":"groupsOf: n\r\t| groups pos |\r\r\tpos := 0.\r\tgroups := OrderedCollection new.\r\t(n to: self size by: n) do: [ :index | \r\t\t\t| args |\r\t\t\targs := self copyFrom: index - n + 1 to: index.\r\t\t\tgroups add: args.\r\t\t\tpos := pos + n ].\r\tpos < self size ifTrue: [ \r\t\tgroups add: (self copyFrom: pos + 1 to: self size) ].\r\t^ groups"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"#(a b c d e) size >>> 5\"\r\t\"#(x y z) size >>> 3\"\r\t\r\t^ self subclassResponsibility"},{"name":"collect:from:to:","linesOfCode":9,"sourceCode":"collect: aBlock from: firstIndex to: lastIndex\r\t\"Refer to the comment in Collection|collect:.\"\r\t\r\t\"(#(1 2 3 4) collect: [:each | each  + 10] from: 2 to: 3) >>> #(12 13) \"\r\r\t| size result j |\r\tsize := lastIndex - firstIndex + 1.\r\tresult := self species new: size.\r\tj := firstIndex.\r\t1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j := j + 1].\r\t^ result"},{"name":"indexOfAnyOf:ifAbsent:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of any element included in aCollection within the receiver.\r\tIf the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y z) ifAbsent: 7) >>> 7\"\r\r\t^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: exceptionBlock"},{"name":"overlappingPairsCollect:","linesOfCode":8,"sourceCode":"overlappingPairsCollect: aBlock \r\r\t\"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements.\"\r\t\r\t\"(#(1 2 3 4) overlappingPairsCollect: [:first :second| first + second]) >>> #(3 5 7)\"\r\t\r\t| retval |\r\tretval := self species ofSize: self size - 1.\r\t1 to: self size - 1\r\t\tdo: [:i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].\r\t^retval"},{"name":"asIntegerArray","linesOfCode":7,"sourceCode":"asIntegerArray\r\t\"Answer an IntegerArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| intArray |\r\tintArray := IntegerArray new: self size.\r\t1 to: self size do:[:i| intArray at: i put: (self at: i)].\r\t^intArray"},{"name":"first","linesOfCode":4,"sourceCode":"first\r\t\"Answer the first element of the receiver\"\r\t\"#(a b c d e f g h ) first >>> #a\"\r\r\t^ self at: 1"},{"name":"mergeFirst:middle:last:into:by:","linesOfCode":21,"sourceCode":"mergeFirst: first middle: middle last: last into: dst by: aBlock\r\t\"Private. Merge the sorted ranges [first..middle] and [middle+1..last] \r\tof the receiver into the range [first..last] of dst.\"\r\r\t| i1 i2 val1 val2 out |\r\ti1 := first.\r\ti2 := middle + 1.\r\tval1 := self at: i1.\r\tval2 := self at: i2.\r\tout := first - 1.  \"will be pre-incremented\"\r\r\t\"select 'lower' half of the elements based on comparator\"\r\t[(i1 <= middle) and: [i2 <= last]] whileTrue:\r\t\t[(aBlock value: val1 value: val2)\r\t\t\tifTrue: [dst at: (out := out + 1) put: val1.\r\t\t\t\t\tval1 := self at: (i1 := i1 + 1)]\r\t\t\tifFalse: [dst at: (out := out + 1) put: val2.\r\t\t\t\t\ti2 := i2 + 1.\r\t\t\t\t\ti2 <= last ifTrue: [val2 := self at: i2]]].\r\r\t\"copy the remaining elements\"\r\ti1 <= middle\r\t\tifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]\r\t\tifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]"},{"name":"permutationsDo:","linesOfCode":5,"sourceCode":"permutationsDo: aBlock\r\t\"Repeatly value aBlock with a single copy of the receiver. Reorder the copy\r\tso that aBlock is presented all (self size factorial) possible permutations.\"\r\r\t\"(Array streamContents: [:stream | (1 to: 3) permutationsDo: [:each | stream nextPut: each copy]]) >>> #(#(1 2 3) #(1 3 2) #(2 1 3) #(2 3 1) #(3 2 1) #(3 1 2))\"\r\r\tself shallowCopy permutationsStartingAt: 1 do: aBlock"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":10,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"This destructively replaces elements from start to stop in the receiver \r\tstarting at index, repStart, in the sequenceable collection, \r\treplacementCollection. Answer the receiver. No range checks are \r\tperformed.\"\r\r\t| index repOff |\r\trepOff := repStart - start.\r\tindex := start - 1.\r\t[(index := index + 1) <= stop]\r\t\twhileTrue: [self at: index put: (replacement at: repOff + index)]"},{"name":"reduce:","linesOfCode":7,"sourceCode":"reduce: aBlock\r\t\"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified.\"\r\r\t\"(#(1 2 3) reduce: [ :a :b | a + b ]) >>> 6\" \"1 + 2 + 3\"\r\t\"(#(1 2 3) reduce: [ :a :b | a + b ]) >>> (1 + 2 + 3)\"\r\r\t\"(#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]) >>> 15\"\r\t\"(#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]) >>> (1 + 2 + 3 + 4 + 5)\"\r\r\t^ self reduceLeft: aBlock"},{"name":"atLast:","linesOfCode":6,"sourceCode":"atLast: indexFromEnd\r\t\"Return element at indexFromEnd from the last position.\r\t atLast: 1, returns the last element\"\r\t\"(#(x y z) atLast: 1) >>> #z\"\r\t\"(#(x y z) atLast: 2) >>> #y\"\r\r\t^ self atLast: indexFromEnd ifAbsent: [self error: 'index out of range']"},{"name":"rsSwapElement:withElement:","linesOfCode":6,"sourceCode":"rsSwapElement: u withElement: v\r\t| index1 index2 |\r\tindex1 := self indexOf: u.\r\tindex2 := self indexOf: v.\r\tself at: index2 put: u.\r\tself at: index1 put: v."},{"name":"gtInspectorItemsIn:","linesOfCode":21,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self ];\r\t\tbeMultiple;\r\t\tenableElementIndex;\r\t\twantsAutomaticRefresh: true;\r\t\tcolumn: 'Index' evaluated: [ :value :idex | idex asString ] width: 50;\r\t\tcolumn: 'Item' evaluated: [ :value | GTObjectPrinter asTruncatedTextFrom: value ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult ifNotNil: [ \r\t\t\t\tresult isCollection ifTrue: [ \r\t\t\t\t\tresult size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] \r\t\t\t\t] ifFalse: [ result ]\r\t\t\t]\r\t\t]"},{"name":"fasterDifferencePreservingOrder:","linesOfCode":8,"sourceCode":"fasterDifferencePreservingOrder: aCollection\r\t\" this implementation does not preserve the original species of self ! it serves ONE specific use case only \"\r\t| newCollection |\r\tnewCollection := OrderedCollection new: self size.\r\tself do: [ :each | \r\t\t(aCollection includes: each) \r\t\t\tifFalse: [ newCollection add: each ] ].\r\t^ newCollection"},{"name":"detectIndex:","linesOfCode":5,"sourceCode":"detectIndex: aBlock\r\r\t\"Return index of first element that satisfies aBlock.\r\tIf no matching element is found, raise an error.\"\r\t\r\t\"(#(1 5 10) detectIndex: [ :each | each > 3 ]) >>> 2\"\r\r\t^ self detectIndex: aBlock ifNone: [ self errorNotFound: aBlock ] "},{"name":"piecesCutWhere:do:","linesOfCode":17,"sourceCode":"piecesCutWhere: binaryBlock do: pieceBlock\r\t\"Evaluate pieceBlock with substrings of the receiver derived from cutting the receiver at points where binaryBlock answers true for adjacent elements.\"\r\t\r\t\"(Array streamContents: [:stream |  #(1 2 3 1 6 1 2 3 4) piecesCutWhere: [ :a :b | a = 1 and: [ b = 2]] do: [:each | stream nextPut: each size]]) >>> #(1 5 3)\"\r\r\t| size lastCut this next |\r\t(size := self size) <= 1 ifTrue:\r\t\t [size = 1 ifTrue: [pieceBlock value: self].\r\t\t^self].\r\tlastCut := 1.\r\tthis := self at: 1.\r\t2 to: size do:\r\t\t[:i|\r\t\tnext := self at: i.\r\t\t(binaryBlock value: this value: next) ifTrue:\r\t\t\t[pieceBlock value: (self copyFrom: lastCut to: i - 1).\r\t\t\tlastCut := i].\r\t\tthis := next].\r\tpieceBlock value: (self copyFrom: lastCut to: size)"},{"name":"sorted","linesOfCode":6,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted in ascending order using the #'<=' operator.\"\r\t\"#(8 5 3 9) sorted >>> #(3 5 8 9)\"\r\t\"#(a b z d) sorted >>> #(a b d z)\"\r\t\r\t^self sorted: [ :a :b| a <= b ]"},{"name":"lastIndexOfAnyOf:startingAt:ifAbsent:","linesOfCode":9,"sourceCode":"lastIndexOfAnyOf: aCollection startingAt: lastIndex ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOfAnyOf: #(a b) startingAt: 1 ifAbsent: 7) >>> 1\"\r\r\tlastIndex to: 1 by: -1 do:\r\t\t[:index |\r\t\t(aCollection includes: (self at: index)) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"reverse","linesOfCode":3,"sourceCode":"reverse\r\t\"Answer a copy of the receiver with element order reversed, as expected by ANSI.\"\r\r\t^ self reversed"},{"name":"sort","linesOfCode":5,"sourceCode":"sort\r\t\"Sort this collection into ascending order using the '<=' operator.\"\r\t\"#(8 5 3 9) sort >>> #(3 5 8 9)\"\r\t\"#(a b z d) sort >>> #(a b d z)\"\r\t\r\tself sort: [:a :b | a <= b]"},{"name":"atWrap:","linesOfCode":8,"sourceCode":"atWrap: index\r\r    \"Answer the index'th element of the receiver.  If index is out of bounds,\r    let it wrap around from the end to the beginning until it is in bounds.\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 2) >>> 22\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 4) >>> 11\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 5) >>> 22\"\r    \r    ^ self at: index - 1 \\\\ self size + 1"},{"name":"findBinary:do:ifNone:","linesOfCode":24,"sourceCode":"findBinary: aBlock do: actionBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf found, evaluate actionBlock with the found element as argument\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements or nil as arguments.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 11\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 12 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(11 15)'\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 0.5 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(nil 1)'\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 25 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(23 nil)'\"\r\r\t^ self\r\t\tfindBinaryIndex: aBlock\r\t\tdo: [ :foundIndex | actionBlock value: (self at: foundIndex) ]\r\t\tifNone: [ :prevIndex :nextIndex | \r\t\t\texceptionBlock\r\t\t\t\tcull:\r\t\t\t\t\t(prevIndex > 0\r\t\t\t\t\t\tifTrue: [ self at: prevIndex ])\r\t\t\t\tcull:\r\t\t\t\t\t(nextIndex <= self size\r\t\t\t\t\t\tifTrue: [ self at: nextIndex ]) ]"},{"name":"joinUsing:","linesOfCode":3,"sourceCode":"joinUsing: joiner\r\t\"Append the elements of the receiver separating them with the joiner - character, string or sequenceable collection. Return collection of the same collection class as 'joiner', or a String\"\r\t^ joiner join: self"},{"name":"piecesCutWhere:","linesOfCode":10,"sourceCode":"piecesCutWhere: binaryBlock\r\t\"Answer substrings of the receiver derived from cutting the receiver at points where binaryBlock answers true for adjacent elements.\"\r\t\"( #(1 2 3 1 6 1 2 3 4) piecesCutWhere: [ :a :b | a = 1 and: [ b = 2]]) asArray >>> #(#(1) #(2 3 1 6 1) #(2 3 4))\"\r\t| pieces |\r\tpieces := OrderedCollection new.\r\tself \r\t\tpiecesCutWhere: binaryBlock\r\t\tdo: [ :piece | pieces add: piece ].\r\t^pieces\r\r   \"'Now is the time for all good people to come to the aid of the cause of world peace.  It is just fine, even desirable, to love your country, if that means wanting it to play a beneficial role in the course of world events and be the best possible example of a good society.  But if it means wanting dominion over the rest of the world, it is not love but defensiveness or self-glorification, and will lead only to oblivion.'  piecesCutWhere: [:a :b| a = $. and: [b isSeparator]]\""},{"name":"anyOne","linesOfCode":7,"sourceCode":"anyOne\r\t\"Answer a representative sample of the receiver. It raises an error when the collection is empty. This method can be helpful when needing to preinfer the nature of the contents of semi-homogeneous collections.\"\r\t\"#(1 2 3) anyOne >>> 1\"\r\t\"\r\t([#() anyOne] on: SubscriptOutOfBounds do: [ :ex | 'whatever' ]) >>> 'whatever'\r\t\"\r\t^ self first"},{"name":",","linesOfCode":7,"sourceCode":", otherCollection \r\t\"Concatenate two Strings or Collections.\"\r\t\"#(2 4 6 8) , #(who do we appreciate) >>> #(2 4 6 8 who do we appreciate)\"\r\t\"((2989 storeStringBase: 16) copyFrom: 4 to: 6) , ' boy!' >>> 'BAD boys!'\"\r\t\r\t^ self copyReplaceFrom: self size + 1\r\t\t  to: self size\r\t\t  with: otherCollection\r"},{"name":"copyUpTo:","linesOfCode":4,"sourceCode":"copyUpTo: anElement \r\t\"Answer all elements up to but not including anObject. If there\r\tis no such object, answer a copy of the receiver.\"\r\r\t^ self first: (self indexOf: anElement ifAbsent: [^ self copy]) - 1"},{"name":"asPetit2Stream","linesOfCode":3,"sourceCode":"asPetit2Stream\r\t^ PP2Stream on: self\r\t\"^ PP2BufferStream on: (ReadStream on: self)\""},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"atWrap:put:","linesOfCode":8,"sourceCode":"atWrap: index put: value\r\t\"Store value into the index'th element of the receiver.  If index is out\r\tof bounds, let it wrap around from the end to the beginning until it \r\tis in bounds. Answer value.\"\r\t\"(#(11 22 33) asOrderedCollection atWrap: 2 put: 0; yourself) >>> #(11 0 33)\"\r   \"(#(11 22 33) asOrderedCollection atWrap: 4 put: 0; yourself) >>> #(0 22 33)\"\r   \"(#(11 22 33) asOrderedCollection atWrap: 6 put: 0; yourself) >>> #(11 22 0)\"\r\r\t^ self at: index  - 1 \\\\ self size + 1 put: value"},{"name":"asGPUFloat32x4Array","linesOfCode":2,"sourceCode":"asGPUFloat32x4Array\r\t^ self asGPUArrayOfType: #Float32x4"},{"name":"replace:","linesOfCode":6,"sourceCode":"replace: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into self.\"\r\t\r\t\"(#(1 2 3 4) replace: [:each | each + 1 ]) >>> #(2 3 4 5)\"\r\r\t1 to: self size do: [ :index |\r\t\tself at: index put: (aBlock value: (self at: index)) ]"},{"name":"sortedAs:","linesOfCode":20,"sourceCode":"sortedAs: aSortBlockOrSymbol\r\t\"Answer a SortedCollection whose elements are the elements of the \r\treceiver. The sort order is defined by the argument, aSortBlock.\"\r\r\t| aSortedCollection aSortBlock |\r\taSortedCollection := SortedCollection new: self size.\r\taSortBlock := \r\t\taSortBlockOrSymbol isSymbol \r\t\t\tifTrue: [ [:a :b | |t1 t2|\r\t\t\t\t\t\t\tt1 := (a perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\tt2 := (b perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\t((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])\r\t\t\t\t\t\t\t\tifTrue: [ t1 ]\r\t\t\t\t\t\t\t\tifFalse: [ t1 < t2 ] ] ]\r\t\t\tifFalse: [ \r\t\t\t\t(aSortBlockOrSymbol numArgs = 1)\r\t\t\t\t\tifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) < (aSortBlockOrSymbol value: v2) ] ]\r\t\t\t\t\tifFalse: [ aSortBlockOrSymbol ] ].\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"asWordArray","linesOfCode":7,"sourceCode":"asWordArray\r\t\"Answer a WordArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| wordArray |\r\twordArray := WordArray new: self size.\r\t1 to: self size do:[:i| wordArray at: i put: (self at: i)].\r\t^wordArray"},{"name":"lastIndexOf:","linesOfCode":6,"sourceCode":"lastIndexOf: anElement\r\t\"Answer the index of the last occurrence of anElement within the \r\treceiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b a d a) lastIndexOf: #a) >>> 5\"\r\t\"(#(a b a d e) lastIndexOf: #a) >>> 3\"\r\r\t^ self lastIndexOf: anElement startingAt: self size ifAbsent: [0]"},{"name":"asDigitsAt:in:do:","linesOfCode":7,"sourceCode":"asDigitsAt: anInteger in: aCollection do: aBlock\r\tself\r\t\tdo: [ :each | \r\t\t\taCollection at: anInteger put: each.\r\t\t\tanInteger = aCollection size\r\t\t\t\tifTrue: [ aBlock value: aCollection ]\r\t\t\t\tifFalse: [ self asDigitsAt: anInteger + 1 in: aCollection do: aBlock ] ]"},{"name":"readStream","linesOfCode":2,"sourceCode":"readStream\r\t^ ReadStream on: self"},{"name":"allButFirstDo:","linesOfCode":5,"sourceCode":"allButFirstDo: aBlock\r\r\t\"Executes aBlock on each of the receiver's elements except for the first one\"\r\r\t\"(Array streamContents: [:stream | #(1 2 3) allButFirstDo: [:each | stream nextPut: (each + 10)]]) >>> #(12 13)\"\r\r\t2 to: self size do:\r\t\t[:index | aBlock value: (self at: index)]"},{"name":"lastIndexOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOf: #a startingAt: 1 ifAbsent: 7) >>> 1\"\r\t\"(#(e b a d e) lastIndexOf: #a startingAt: 4 ifAbsent: 7) >>> 3\"\r\r\tlastIndex to: 1 by: -1 do:\r\t\t[:index |\r\t\t(self at: index) = anElement ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"overlappingPairsDo:","linesOfCode":5,"sourceCode":"overlappingPairsDo: aBlock \r\r\t\"Emit overlapping pairs of my elements into aBlock\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) overlappingPairsDo: [:first :second| stream nextPut: (first + second)]]) >>> #(3 5 7)\"\r\r\t1 to: self size - 1\r\t\tdo: [:i | aBlock value: (self at: i) value: (self at: i + 1)]"},{"name":"second","linesOfCode":5,"sourceCode":"second\r\t\"Answer the second element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) second >>> #b\"\r\r\t^ self at: 2"},{"name":"ninth","linesOfCode":5,"sourceCode":"ninth\r\t\"Answer the ninth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) ninth >>> #i\"\r\r\t^ self at: 9"},{"name":"@","linesOfCode":2,"sourceCode":"@ aCollection \r\t^ self with: aCollection collect: [:a :b | a @ b]"},{"name":"writeStreamDo:","linesOfCode":4,"sourceCode":"writeStreamDo: aBlock\r\t\"Evaluates the argument with the write stream of the collection. Answers the result.\"\r\t\r\t\"(#() writeStreamDo: [ :stream | stream nextPut: '4'; space; nextPutAll: '34'. stream contents ]) >>> {'4'. Character space. $3. $4}\"\r\r\t^ aBlock value: self writeStream"},{"name":"copyWithoutFirst","linesOfCode":4,"sourceCode":"copyWithoutFirst\r\t\"Deprecatd. Return a copy of the receiver which doesn't include\r\tthe first element.\"\r\r\t^ self allButFirst"},{"name":"findBinaryIndex:do:ifNone:","linesOfCode":27,"sourceCode":"findBinaryIndex: aBlock do: actionBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf found, evaluate actionBlock with the index as argument\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the indexes of the 'bounding' elements as arguments.\r\tWarning: Might give invalid indexes, see examples below\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 5\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 12 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(5 6)'\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 0.5 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(0 1)'\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(7 8)' \"\r\t\t\t\r\t| index low high test |\r\tlow := 1.\r\thigh := self size.\r\t[ index := high + low // 2.\r\t  low > high ] whileFalse: [\r\t\ttest := aBlock value: (self at: index).\r\t\ttest = 0 \r\t\t\tifTrue: [ ^ actionBlock value: index ]\r\t\t\tifFalse: [ test > 0\r\t\t\t\tifTrue: [ low := index + 1 ]\r\t\t\t\tifFalse: [ high := index - 1 ] ] ].\r\t^ exceptionBlock cull: high cull: low"},{"name":"combinations","linesOfCode":7,"sourceCode":"combinations\r\t\"Return all the combinations of elements of the receiver. Note that combinations does not include the empty element contrary to the mathematical definition of combinations.\"\r\r\t\"#(1 2 3 4) combinations >>> #(#(1) #(2) #(3) #(4) #(1 2) #(1 3) #(1 4) #(2 3) #(2 4) #(3 4) #(1 2 3) #(1 2 4) #(1 3 4) #(2 3 4) #(1 2 3 4))\"\r\r\t^ Array\r\t\tstreamContents: [ :stream | \r\t\t\t1 to: self size do:\r\t\t\t\t[ :take | self combinations: take atATimeDo: [ :combination | stream nextPut: combination copy ] ] ]"},{"name":"with:do:","linesOfCode":8,"sourceCode":"with: otherCollection do: twoArgBlock \r\t\"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection.\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) with: #(4 5 6) do: [:a :b | stream nextPut: (a + b)]]) >>> #(5 7 9)\"\r\t\r\totherCollection size = self size ifFalse: [self errorSizeMismatch].\r\t1 to: self size do:\r\t\t[:index |\r\t\ttwoArgBlock value: (self at: index)\r\t\t\t\tvalue: (otherCollection at: index)]"},{"name":"shuffle","linesOfCode":4,"sourceCode":"shuffle\r\t\"Modify the receiver but with its elements in random positions.\r\tThis method use Random class as random generator\"\r\t\r\t^ self shuffleBy: Random new"},{"name":"findBinaryIndex:","linesOfCode":12,"sourceCode":"findBinaryIndex: aBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, raise an error.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ]) >>> 5\"\r\r\t^ self\r\t\tfindBinaryIndex: aBlock\r\t\tdo: [ :found | found ]\r\t\tifNone: [ self errorNotFound: aBlock ]"},{"name":"findBinary:ifNone:","linesOfCode":15,"sourceCode":"findBinary: aBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements as optional arguments.\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 24 - arg ] ifNone: ['Not found']) >>> 'Not found'\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 24 - arg ] ifNone: [:a :b | 'over ', a printString]) >>> 'over 23'\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 25 - arg ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(23 nil)'\"\r\t\r\t^ self \r\t\tfindBinary: aBlock \r\t\tdo: [ :found | found ] \r\t\tifNone: exceptionBlock"},{"name":"reject:","linesOfCode":8,"sourceCode":"reject: rejectBlock \r\t\"Optimized version of Collection>>#reject:\"\r\t\r\t\"#(1 2 3 4) reject: [:each | each = 3 ] >>> #(1 2 4)\"\r\t\r\t| each |\r\t\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(rejectBlock value: (each := self at: index))\r\t\t\t\tifFalse: [ stream nextPut: each ]]]"},{"name":"indexOf:startingAt:","linesOfCode":5,"sourceCode":"indexOf: anElement startingAt: start\r       \"Answer the index of the first occurrence of anElement after start within the receiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b c d e) indexOf: #c startingAt: 2) >>> 3\" \r\t\"(#(a b c d e) indexOf: #c startingAt: 4) >>> 0\"\r\r\t^self indexOf: anElement startingAt: start ifAbsent: 0"},{"name":"withIndexCollect:","linesOfCode":11,"sourceCode":"withIndexCollect: elementAndIndexBlock \r\t\"Just like with:collect: except that the iteration index supplies the second argument to the block.\"\r\t\r\t\"(#(10 20 30) withIndexCollect: [:each :index | each + (index * 2)]) >>> #(12 24 36)\"\r\t\r\t| result |\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result at: index put:\r\t\t(elementAndIndexBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: index)].\r\t^ result"},{"name":"nextToLast","linesOfCode":3,"sourceCode":"nextToLast\r\t\"(#(1 2 3 4) nextToLast) >>> 3\"\r\t^self at: self size - 1"},{"name":"withIndexSelect:","linesOfCode":10,"sourceCode":"withIndexSelect: elementAndIndexBlock\r\t\"select elements from the receiver that the block evaluates true with the element and its index.\"\r\r\t\"(#('We' 'love' 'pharo!') withIndexSelect: [:value :index | value size - 1 <= index]) >>> #('We')\"\r\r\t^ self class\r\t\tnew: self size\r\t\tstreamContents: [ :stream | \r\t\t\t1 to: self size do: [ :index | \r\t\t\t\t| each |\r\t\t\t\t(elementAndIndexBlock value: (each := self at: index) value: index)\r\t\t\t\t\tifTrue: [ stream nextPut: each ] ] ]"},{"name":"writeStream","linesOfCode":2,"sourceCode":"writeStream\r\t^ WriteStream on: self"},{"name":"endsWithAnyOf:","linesOfCode":3,"sourceCode":"endsWithAnyOf: aCollection\r\t\"Return true if the receiver ends with any of the elements in aCollection.\"\r\t^aCollection anySatisfy:[:suffix| self endsWith: suffix]"},{"name":"findFirst:","linesOfCode":10,"sourceCode":"findFirst: aBlock\r\t\"Return the index of my first element for which aBlock evaluates as true.\r\tIf no matching element is found, return 0\"\r\t\r\t\"(#(1 5 10) findFirst: [ :each | each > 3 ]) >>> 2\"\r\t\"(#(1 5 10) findFirst: [ :each | each > 15 ]) >>> 0\"\r\r\t| index |\r\tindex := 0.\r\t[(index := index + 1) <= self size] whileTrue:\r\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\r\t^ 0"},{"name":"reversed","linesOfCode":9,"sourceCode":"reversed\r\t\"Answer a copy of the receiver with element order reversed.\"\r\t\"Example: 'frog' reversed\"\r\r\t| n result src |\r\tn := self size.\r\tresult := self species new: n.\r\tsrc := n + 1.\r\t1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].\r\t^ result\r"},{"name":"indexOfSubCollection:startingAt:","linesOfCode":11,"sourceCode":"indexOfSubCollection: aSubCollection startingAt: anIndex \r\t\"Answer the index of the receiver's first element, such that that element \r\tequals the first element of aSubCollection, and the next elements equal \r\tthe rest of the elements of aSubCollection. Begin the search at element \r\tanIndex of the receiver. If no such match is found, answer 0.\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 2) >>> 3\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 4) >>> 0\"\r\r\t^self\r\t\tindexOfSubCollection: aSubCollection\r\t\tstartingAt: anIndex\r\t\tifAbsent: [0]"},{"name":"copyAfter:","linesOfCode":5,"sourceCode":"copyAfter: anElement\r\t\"Answer a copy of the receiver from after the first occurrence\r\tof anElement up to the end. If no such element exists, answer \r\tan empty copy.\"\r\r\t^ self allButFirst: (self indexOf: anElement ifAbsent: [^ self copyEmpty])"},{"name":"combinationsAt:in:after:do:","linesOfCode":12,"sourceCode":"combinationsAt: jj in: aCollection after: nn do: aBlock\r\t\"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1.\"\r\r\tnn + 1 to: self size do: [ :index | \r\t\taCollection at: jj put: (self at: index).\r\t\tjj = aCollection size\r\t\t\tifTrue: [ aBlock value: aCollection ]\r\t\t\tifFalse: [ \r\t\t\t\tself\r\t\t\t\t\tcombinationsAt: jj + 1\r\t\t\t\t\tin: aCollection\r\t\t\t\t\tafter: index\r\t\t\t\t\tdo: aBlock ] ]"},{"name":"reverseSortedAs:","linesOfCode":20,"sourceCode":"reverseSortedAs: aSortBlockOrSymbol\r\t\"Answer a SortedCollection whose elements are the elements of the \r\treceiver. The sort order is defined by the argument, aSortBlock.\"\r\r\t| aSortedCollection aSortBlock |\r\taSortedCollection := SortedCollection new: self size.\r\taSortBlock := \r\t\taSortBlockOrSymbol isSymbol \r\t\t\tifTrue: [ [:a :b | |t1 t2|\r\t\t\t\t\t\t\tt1 := (a perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\tt2 := (b perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\t((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])\r\t\t\t\t\t\t\t\tifTrue: [ t1 ]\r\t\t\t\t\t\t\t\tifFalse: [ t1 > t2 ] ] ]\r\t\t\tifFalse: [ \r\t\t\t\t(aSortBlockOrSymbol numArgs = 1)\r\t\t\t\t\tifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) > (aSortBlockOrSymbol value: v2) ] ]\r\t\t\t\t\tifFalse: [ aSortBlockOrSymbol ] ].\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"from:to:put:","linesOfCode":20,"sourceCode":"from: startIndex to: endIndex put: anObject\r\t\"Put anObject in all indexes between startIndex \r\tand endIndex. Very fast. Faster than to:do: for\r\tmore than 26 positions. Answer anObject\"\r\t\"(#(a b c d e) from: 3 to: 4 put: #x; yourself) >>> #(a b x x e)\"\r\r\t| written toWrite thisWrite |\r\r\tstartIndex > endIndex ifTrue: [^self].\r\tself at: startIndex put: anObject.\r\twritten := 1.\r\ttoWrite := endIndex - startIndex + 1.\r\t[written < toWrite] whileTrue:\r\t\t[\r\t\t\tthisWrite := written min: toWrite - written.\r\t\t\tself \r\t\t\t\treplaceFrom: startIndex + written\r\t\t\t\tto: startIndex + written + thisWrite - 1\r\t\t\t\twith: self startingAt: startIndex.\r\t\t\twritten := written + thisWrite\r\t\t].\r\t^anObject"},{"name":"reduceLeft:","linesOfCode":17,"sourceCode":"reduceLeft: aBlock\r\t\"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments.\"\r\r\t\"(#(1 2 3) reduceLeft: [ :a :b | a - b ])>>> ((1 - 2) - 3)\"\r\t\"(#(1 2 3) reduceLeft: [ :a :b | a - b ]) >>> -4\"\r\t\"(#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ]) >>> ((1 + 3) - 5)\"\r\t\"(#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ]) >>> -1\"\r\r\t| arguments |\r\tself emptyCheck.\r\targuments := Array new: aBlock argumentCount.\r\t(arguments size = 0 or: [ (self size + 1) \\\\ (arguments size - 1) > 0 ])\r\t\tifTrue: [ self error: 'Collection size and block argument count do not match.' ].\r\targuments at: 1 put: self first.\r\t2 to: self size by: arguments size - 1 do: [ :index |\r\t\targuments\r\t\t\treplaceFrom: 2 to: arguments size with: self startingAt: index;\r\t\t\tat: 1 put: (aBlock valueWithArguments: arguments) ].\r\t^ arguments first"},{"name":"at:ifAbsent:","linesOfCode":7,"sourceCode":"at: index ifAbsent: exceptionBlock \r\t\"Answer the element at my position index. If I do not contain an element \r\tat index, answer the result of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d) at: 3 ifAbsent: #z) >>> #c\"\r\t\"(#(a b c d) at: 5 ifAbsent: #z) >>> #z\"\r\r\t(index between: 1 and: self size) ifTrue: [^ self at: index].\r\t^ exceptionBlock value"},{"name":"detectIndex:ifNone:","linesOfCode":7,"sourceCode":"detectIndex: aBlock ifNone: exceptionBlock\r\r\t\"Return index of first element that satisfies aBlock.\r\tIf no matching element is found, evaluate exceptionBlock.\"\r\t\r\t\"(#(1 5 10) detectIndex: [ :each | each > 3 ] ifNone: ['Not found']) >>> 2\"\r\t\"(#(1 5 10) detectIndex: [ :each | each > 15 ] ifNone: ['Not found']) >>> 'Not found'\"\r\t\r\tself doWithIndex: [:each :index | (aBlock value: each) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"select:thenCollect:","linesOfCode":8,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Optimized version of Collection>>#select:thenCollect:\"\r\t\r\t\"(#(1 2 3 4)  select: [:each | each > 2 ] thenCollect: [:each | each + 10 ]) >>> #(13 14)\"\r\t\r\t| each |\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(selectBlock value: (each := self at: index))\r\t\t\t\tifTrue: [ stream nextPut: (collectBlock value: each) ]]]"},{"name":"asColorArray","linesOfCode":2,"sourceCode":"asColorArray\r\t^ColorArray withAll: self"},{"name":"copyWithoutIndex:","linesOfCode":7,"sourceCode":"copyWithoutIndex: index\r\t\"Return a copy containing all elements except the index-th.\"\r\r\t| copy |\r\tcopy := self species ofSize: self size - 1.\r\tcopy replaceFrom: 1 to: index-1 with: self startingAt: 1.\r\tcopy replaceFrom: index to: copy size with: self startingAt: index+1.\r\t^ copy"},{"name":"asValueHolder","linesOfCode":2,"sourceCode":"asValueHolder\r\r\t^ CollectionValueHolder value: self"},{"name":"middle","linesOfCode":5,"sourceCode":"middle\r\t\"Answer the middle element of the receiver.\"\r\t\"#(a b c d e) middle >>> #c\"\r\t\"#(a b c d) middle >>> #c\"\r\t\r\t^ self at: self size // 2 + 1"},{"name":"keysAndValuesDo:","linesOfCode":4,"sourceCode":"keysAndValuesDo: aBlock \r\t\"Enumerate the receiver with all the keys (aka indices) and values.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) keysAndValuesDo:  [:key :value | stream nextPut: (key * 2 + value)]]) >>> #(12 24 36)\"\r\r\t1 to: self size do: [:index | aBlock value: index value: (self at: index)]"},{"name":"pairsCollect:","linesOfCode":5,"sourceCode":"pairsCollect: aBlock\r\t\"Evaluate aBlock with my elements taken two at a time, and return an Array with the results\"\r\r\t\"(#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect: [:a :b | b, ' is number ', a printString]) >>> #('fred is number 1' 'charlie is number 2' 'elmer is number 3')\"\r\r\t^ (1 to: self size // 2)\r\t\tcollect: [ :index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]"},{"name":"fourth","linesOfCode":5,"sourceCode":"fourth\r\t\"Answer the fourth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) fourth >>> #d\"\r\r\t^ self at: 4"},{"name":"splitOn:indicesDo:","linesOfCode":4,"sourceCode":"splitOn: splitter indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of the receiver element that have been identified by splitting the receiver using the splitter argument. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\t\"(String streamContents: [:s | 'Pharo is cool' splitOn: Character space indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:5 s:7 e:8 s:10 e:13 '\"\r\t\r\t\r\t^ splitter split: self indicesDo: aBlock"},{"name":"asGPUFloat32Array","linesOfCode":2,"sourceCode":"asGPUFloat32Array\r\t^ self asGPUArrayOfType: #Float32"},{"name":"atAllPut:","linesOfCode":7,"sourceCode":"atAllPut: anObject \r\t\"Put anObject at every one of the receiver's indices.\"\r\t\"(#(x y z) atAllPut: #a) >>> #(a a a)\"\r\r\t| size |\r\t(size := self size) > 26 \"first method faster from 27 accesses and on\"\r\t\tifTrue: [self from: 1 to: size put: anObject]\r\t\tifFalse: [1 to: size do: [:index | self at: index put: anObject]]"},{"name":"after:ifAbsent:","linesOfCode":11,"sourceCode":"after: target ifAbsent: exceptionBlock\r\t\"Answer the element after target.  Answer the result of evaluation\r\tthe exceptionBlock if target is not in the receiver, or if there are \r\tno elements after it.\"\r\t\"(#(a b c d) after: #b ifAbsent: #z) >>> #c\"\r\t\"(#(a b c d) after: #x ifAbsent: #z) >>> #z\"\r\r\t| index |\r\tindex := self indexOf: target.\r\t^ (index = 0 or: [index = self size])\r\t\tifTrue: [exceptionBlock value]\r\t\tifFalse: [self at: index + 1]"},{"name":"identityIndexOf:ifAbsent:","linesOfCode":9,"sourceCode":"identityIndexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of anElement within the receiver. If the receiver does \r\tnot contain anElement, answer the result of evaluating the argument, \r\texceptionBlock.\"\r\t\"(#(a b c d e) identityIndexOf: #c ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) identityIndexOf: #x ifAbsent: 7) >>> 7\"\r\t\r\t1 to: self size do:\r\t\t[:i | (self at: i) == anElement ifTrue: [^ i]].\r\t^ exceptionBlock value"},{"name":"replaceFrom:to:with:","linesOfCode":8,"sourceCode":"replaceFrom: start to: stop with: replacement \r\t\"This destructively replaces elements from start to stop in the receiver. \r\tAnswer the receiver itself. Use copyReplaceFrom:to:with: for \r\tinsertion/deletion which may alter the size of the result.\"\r\t\"(#(a b c d e) replaceFrom: 3 to: 4 with: #(x y)) >>> #(a b x y e)\"\r\r\treplacement size = (stop - start + 1)\r\t\tifFalse: [self error: 'Size of replacement doesnt match'].\r\t^self replaceFrom: start to: stop with: replacement startingAt: 1"},{"name":"shuffled","linesOfCode":2,"sourceCode":"shuffled\r\t^ self copy shuffle"},{"name":"mergeSortFrom:to:by:","linesOfCode":21,"sourceCode":"mergeSortFrom: startIndex to: stopIndex by: aBlock\r\t\"Sort the given range of indices using the mergesort algorithm.\r\tMergesort is a worst-case O(N log N) sorting algorithm that usually\r\tdoes only half as many comparisons as heapsort or quicksort.\"\r\r\t\"Details: recursively split the range to be sorted into two halves,\r\tmergesort each half, then merge the two halves together. An extra \r\tcopy of the data is used as temporary storage and successive merge \r\tphases copy data back and forth between the receiver and this copy.\r\tThe recursion is set up so that the final merge is performed into the\r\treceiver, resulting in the receiver being completely sorted.\"\r\t\"(#(a b z d i l) mergeSortFrom: 3 to: 5 by: [ :a :b | a<=b ]) >>> #(a b d i z l)\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tstartIndex = stopIndex ifTrue: [^ self].\r\t[startIndex >= 1 and: [startIndex < stopIndex]] assert. \"bad start index\"\r\t[stopIndex <= self size] assert. \"bad stop index\"\r\tself\r\t\tmergeSortFrom: startIndex\r\t\tto: stopIndex \r\t\tsrc: self copy \r\t\tdst: self \r\t\tby: aBlock"},{"name":"sort:","linesOfCode":10,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\t\"(#(3 9 1) sort: [:a :b | a <= b ]) >>> #(1 3 9)\"\r\t\"(#(3 9 1) sort: [:a :b | a >= b ]) >>> #(9 3 1)\"\r\t\"(#(xa xc xz xb xy) sort: #last ascending) >>> #(xa xb xc xy xz)\"\r\r\tself\r\t\tmergeSortFrom: 1\r\t\tto: self size\r\t\tby: aSortBlock"},{"name":"indexOf:","linesOfCode":6,"sourceCode":"indexOf: anElement\r\t\"Answer the index of the first occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b c d e) indexOf: #c) >>> 3\"\r\t\"(#(a b c d e) indexOf: #x) >>> 0\"\r\r\t^ self indexOf: anElement ifAbsent: 0"},{"name":"groupsOf:atATimeCollect:","linesOfCode":16,"sourceCode":"groupsOf: n atATimeCollect: aBlock\r\t\"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end. \r\tAllows use of a flattened array for things that naturally group into groups of n. \r\tIf aBlock has a single argument, pass it an array of n items, otherwise, pass the items as separate arguments. See also pairsDo:\"\r\r\t\"(#(16 17 17 16 18 17 18   19 19 19 18 19 19 20   19 20 19 20 20 20 19   20) groupsOf: 7 atATimeCollect: [ :x | x ]) >>> #(#(16 17 17 16 18 17 18) #(19 19 19 18 19 19 20) #(19 20 19 20 20 20 19))\"\r\r\t\"(#(1 1 1 10 10 10 100  100 100) groupsOf: 3 atATimeCollect: [ :x :y :z | x + y + z]) >>> #(3 30 300)\"\r\r\t\"(#(1 1 1 10 10 10 100  100 100) groupsOf: 3 atATimeCollect: [ :x | x ]) >>> #(#(1 1 1) #(10 10 10) #(100 100 100))\"\r\r\t| passArray |\r\tpassArray := aBlock numArgs <= 1.\r\t^ (n to: self size by: n)\r\t\tcollect: [ :index | \r\t\t\t| args |\r\t\t\targs := (self copyFrom: index - n + 1 to: index) asArray.\r\t\t\tpassArray\r\t\t\t\tifTrue: [ aBlock value: args ]\r\t\t\t\tifFalse: [ aBlock valueWithArguments: args ] ]"},{"name":"collect:thenReject:","linesOfCode":9,"sourceCode":"collect: collectBlock thenReject: rejectBlock\r\t\"Optimized version of Collection>>#thenReject:\"\r\t\r\t\"(#(1 2 3) collect: [:each | each + 10 ] thenReject: [:each | each even]) >>> #(11 13)\"\r\t\r\t| each |\r\t\r\t^  self class new: self size streamContents: [ :stream |\r\t\t1 to: self size do: [:index |\r\t\t\teach := collectBlock value: (self at: index).\r\t\t\t(rejectBlock value: each)\r\t\t\t\tifFalse: [ stream nextPut: each ]]]"},{"name":"copyFrom:to:","linesOfCode":10,"sourceCode":"copyFrom: start to: stop \r\t\"Answer a copy of a subset of the receiver, starting from element at \r\tindex start until element at index stop.\"\r\r\t| newSize |\r\tnewSize := stop - start + 1.\r\t^(self species new: newSize)\r\t\treplaceFrom: 1\r\t\tto: newSize\r\t\twith: self\r\t\tstartingAt: start"},{"name":"copyWithFirst:","linesOfCode":11,"sourceCode":"copyWithFirst: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element.\"\r\r\t| newIC |\r\tnewIC := self species ofSize: self size + 1.\r\tnewIC \r\t\treplaceFrom: 2\r\t\tto: self size + 1\r\t\twith: self\r\t\tstartingAt: 1.\r\tnewIC at: 1 put: newElement.\r\t^ newIC"},{"name":"copyUpThrough:","linesOfCode":4,"sourceCode":"copyUpThrough: anElement\r    \"Answer all elements up to and including anObject. If there\r     is no such object, answer a copy of the receiver.\"\r\r\t^self first: (self indexOf: anElement ifAbsent: [^ self copy])"},{"name":"asPetit2Context","linesOfCode":2,"sourceCode":"asPetit2Context\r\t^ PP2InMemoryContext on: self position: 0"},{"name":"sixth","linesOfCode":5,"sourceCode":"sixth\r\t\"Answer the sixth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) sixth >>> #f\"\r\r\t^ self at: 6"},{"name":"atLast:ifAbsent:","linesOfCode":6,"sourceCode":"atLast: indexFromEnd ifAbsent: block\r\t\"Return element at indexFromEnd from the last position.\r\t atLast: 1 ifAbsent: [] returns the last element\"\r\t\"(#(x y z) atLast: 1 ifAbsent: #a) >>> #z\"\r\t\"(#(x y z) atLast: 4 ifAbsent: #a) >>> #a\"\r\r\t^ self at: self size + 1 - indexFromEnd ifAbsent: block"},{"name":"grownBy:","linesOfCode":7,"sourceCode":"grownBy: length\r\t\"Answer a copy of receiver collection with size grown by length\"\r\r\t| newCollection size |\r\tsize := self size.\r\tnewCollection := self species ofSize: size + length.\r\tnewCollection replaceFrom: 1 to: size with: self startingAt: 1.\r\t^ newCollection"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"indexOf: anElement startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement after start\r\twithin the receiver. If the receiver does not contain anElement, \r\tanswer the \tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOf: #c startingAt: 2 ifAbsent: 7) >>> 3\" \r\t\"(#(a b c d e) indexOf: #c startingAt: 4 ifAbsent: 7) >>> 7\"\r\r\tstart to: self size do:\r\t\t[:index |\r\t\t(self at: index) = anElement ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject\r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t^ (self indexOf: anObject) ~= 0"},{"name":"asGPUFloat64Array","linesOfCode":2,"sourceCode":"asGPUFloat64Array\r\t^ self asGPUArrayOfType: #Float64"},{"name":"collect:","linesOfCode":11,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\t\r\t\"#(1 2 3) collect: [:each | each  + 10] >>> #(11 12 13) \"\r\r\t| newCollection |\r\tnewCollection := self species new: self size.\r\t1 to: self size do:\r\t\t[:index |\r\t\tnewCollection at: index put: (aBlock value: (self at: index))].\r\t^ newCollection"},{"name":"last","linesOfCode":4,"sourceCode":"last\r\t\"Answer the last element of the receiver\"\r\t\"#(a b c d e) last >>> #e\"\r\r\t^ self at: self size"},{"name":"copyUpToLast:","linesOfCode":4,"sourceCode":"copyUpToLast: anElement\r\t\"Answer a copy of the receiver from index 1 to the last occurrence of \r\tanElement, not including anElement.\"\r\r\t^ self first: (self lastIndexOf: anElement ifAbsent: [^ self copy]) - 1"},{"name":"last:","linesOfCode":8,"sourceCode":"last: n\r\t\"Answer the last n elements of the receiver.  \r\tRaise an error if there are not enough elements.\"\r\t\"(#(a b c d e) last: 2) >>> #(d e)\"\r\t\"(#(a b c d e) last: 3) >>> #(c d e)\"\r\r\t| size |\r\tsize := self size.\r\t^ self copyFrom: size - n + 1 to: size"},{"name":"asArray","linesOfCode":3,"sourceCode":"asArray\r\t\"Answer an Array whose elements are the elements of the receiver.\"\r\r\t^ Array withAll: self"},{"name":"findLast:","linesOfCode":10,"sourceCode":"findLast: aBlock\r\t\"Return the index of my last element for which aBlock evaluates as true.\r\tIf no matching element is found, return 0\"\r\t\r\t\"(#(10 20 30 40 50) findLast: [ :each | each > 10 ]) >>> 5\"\r\t\"(#(10 20 30 40 50) findLast: [ :each | each > 60 ]) >>> 0\"\r\t\r\t| index |\r\tindex := self size + 1.\r\t[(index := index - 1) >= 1] whileTrue:\r\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\r\t^ 0"},{"name":"reverseWith:do:","linesOfCode":10,"sourceCode":"reverseWith: aSequenceableCollection do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements, in reverse order, \r\talong with the  corresponding element, also in reverse order, from \r\taSequencableCollection. \"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) reverseWith: #(4 5 6) do: [:a :b | stream nextPut: (a + b)]]) >>> #(9 7 5)\"\r\r\tself size ~= aSequenceableCollection size ifTrue: [^ self errorSizeMismatch].\r\tself size to: 1 by: -1 do: [:index | \r\t\t\taBlock \r\t\t\t\tvalue: (self at: index)\r\t\t\t\tvalue: (aSequenceableCollection at: index)]"},{"name":"select:thenDo:","linesOfCode":7,"sourceCode":"select: selectBock thenDo: aBlock\r\t\"Refer to the comment in Collection>>#select:thenDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) select: [:each | each > 2 ] thenDo: [:each | stream nextPut: each + 10]]) >>> #(13 14)\"\r\t\r\t| each |\r\t1 to: self size do: [ :index |\r\t\t(selectBock value: (each := self at: index))\r\t\t\tifTrue: [ aBlock value: each ]]."},{"name":"before:ifAbsent:","linesOfCode":11,"sourceCode":"before: target ifAbsent: exceptionBlock\r\t\"Answer the receiver's element immediately before target. Answer\r\tthe result of evaluating the exceptionBlock if target is not an element\r\tof the receiver, or if there are no elements before it.\"\r\t\"(#(11 22 33) before: 22 ifAbsent: 55) >>> 11\"\r\t\"(#(11 22 33) before: 44 ifAbsent: 55) >>> 55\"\r\r\t| index |\r\tindex := self indexOf: target.\r\t^ (index = 0 or: [index = 1])\r\t\tifTrue: [exceptionBlock value]\r\t\tifFalse: [self at: index - 1]"},{"name":"asMoebiusBandCollectionWithContext","linesOfCode":2,"sourceCode":"asMoebiusBandCollectionWithContext\r\t^ MbndCollectionWithContext new collection: self"},{"name":"atRandom:","linesOfCode":7,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver.  Uses aGenerator which\r\tshould be kept by the user in a variable and used every time. Use\r\tthis instead of #atRandom for better uniformity of random numbers \r\tbecause only you use the generator.  Causes an error if self has no \r\telements.\"\r\r\t^ self at: (aGenerator nextInteger: self size)"},{"name":"findBinaryIndex:ifNone:","linesOfCode":14,"sourceCode":"findBinaryIndex: aBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements as optional arguments.\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(7 8)' \"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] ifNone: [ :a :b | 'over index: ', a printString ]) >>> 'over index: 7' \"\r\r\t^ self \r\t\tfindBinaryIndex: aBlock \r\t\tdo: [ :found | found ] \r\t\tifNone: exceptionBlock"},{"name":"copyAfterLast:","linesOfCode":5,"sourceCode":"copyAfterLast: anElement\r\t\"Answer a copy of the receiver from after the last occurrence\r\tof anElement up to the end. If no such element exists, answer \r\tan empty copy.\"\r\r\t^ self allButFirst: (self lastIndexOf: anElement ifAbsent: [^ self copyEmpty])"},{"name":"takeFirst:","linesOfCode":2,"sourceCode":"takeFirst: anInteger\r\t^ self first: (self size min: anInteger)"},{"name":"withIndexDo:","linesOfCode":4,"sourceCode":"withIndexDo: elementAndIndexBlock\r\t\"Just like do: except that the iteration index supplies the second argument to the block\"\r\r\t\"(Array streamContents: [:stream| #(11 22 13) withIndexDo: [ :each :i | stream nextPut: (each * each + i)]]) >>> #(122 486 172)\"\r\r\t1 to: self size do: [ :index | elementAndIndexBlock value: (self at: index) value: index ]"},{"name":"groupByRuns:","linesOfCode":21,"sourceCode":"groupByRuns: aBlock\r\t\"Answer a new collection of the same species as the receiver with elements being collections (of the receiver species) containing those elements of the receiver for which the given block consecutively evaluates to the same object.\"\r\r\t\"(#(1 2 3 4 4 1 2 3 5 6 ) groupByRuns: [ :each | each = 4]) >>> #(#(1 2 3) #(4 4) #(1 2 3 5 6))\"\r\r\t\"(#(1 2 3 4 1 2 3 4 5 6 ) groupByRuns: [ :each | each = 4]) >>> #(#(1 2 3) #(4) #(1 2 3) #(4) #(5 6))\"\r\r\t\"((1 to: 12) groupByRuns: [ :each | (each \\\\ 3) = 0]) >>> #(#(1 2) #(3) #(4 5) #(6) #(7 8) #(9) #(10 11) #(12))\"\r\r\t| str eStr r |\r\tstr := Array new writeStream.\r\tr := nil.\r\teStr := Array new writeStream.\r\tself\r\t\tdo: [ :e | \r\t\t\t| t |\r\t\t\t(t := aBlock value: e) = r\r\t\t\t\tifFalse: [ r := t.\r\t\t\t\t\teStr isEmpty\r\t\t\t\t\t\tifFalse: [ str nextPut: (eStr contents as: self species).\r\t\t\t\t\t\t\teStr reset ] ].\r\t\t\teStr nextPut: e ].\r\teStr isEmpty\r\t\tifFalse: [ str nextPut: (eStr contents as: self species) ].\r\t^ str contents as: self species"},{"name":"running:of:","linesOfCode":14,"sourceCode":"running: aBlock of: aSubsetSize\r\t\"This is a generalization of a running average (a.k.a. moving average, rolling average) which allows you to apply any given block to the shifting subsets of a given size.\r\t\r\tFor example, given a collection #(1 2 3 4 5) and a window size 2, we collect subsets of this collection by starting with first 2 elements and shifting the window 1 element to the right: #((1 2)(2 3)(3 4)(4 5)), then we apply aBlock to each subset and collect the results. For example, if aBlock is [ :subset | subset average ], this will give us #(1.5 2.5 3.5 4.5)\"\r\t| result |\r\t\r\taSubsetSize > self size ifTrue: [\r\t\tSubscriptOutOfBounds\r\t\t\tsignal: 'The subset size can not exceed the size of a collection' ].\r\t\t\r\taSubsetSize < 0 ifTrue: [\r\t\tSubscriptOutOfBounds\r\t\t\tsignal: 'The subset size must be positive' ].\r\t\r\tresult := (1 to: self size - aSubsetSize + 1) collect: [ :i |\r\t\taBlock value: (self copyFrom: i to: i + aSubsetSize - 1) ].\r\t\r\t^ self species withAll: result"},{"name":"indexOfAnyOf:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection\r\t\"Answer the index of the first occurrence of any element included in aCollection within the receiver.\r\tIf the receiver does not contain anElement, answer zero, which is an invalid index.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c)) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y z)) >>> 0\"\r\r\t^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: [0]"},{"name":"join:","linesOfCode":8,"sourceCode":"join: aCollection\r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\r\t\"({Character space. Character space} join: #('Pharo' 'is' 'cool')) >>>  {$P. $h. $a. $r. $o. Character space. Character space. $i. $s. Character space. Character space. $c. $o. $o. $l}\"\r\r\t\"NB: this implementation only works for Array, since WriteStreams only work for Arrays and Strings. (!) Overridden in OrderedCollection and SortedCollection.\"\r\t\r\t^ self class\r\t\tstreamContents: [:stream | aCollection\r\t\t\t\tdo: [:each | each joinTo: stream]\r\t\t\t\tseparatedBy: [stream nextPutAll: self]]"},{"name":"indexOfSubCollection:startingAt:ifAbsent:","linesOfCode":20,"sourceCode":"indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the receiver's first element, such that that element \r\tequals the first element of sub, and the next elements equal \r\tthe rest of the elements of sub. Begin the search at element \r\tstart of the receiver. If no such match is found, answer the result of \r\tevaluating argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 2 ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 4 ifAbsent: 7) >>> 7\"\r\t\r\t| first index |\r\tsub isEmpty ifTrue: [^ exceptionBlock value].\r\tfirst := sub first.\r\tstart to: self size - sub size + 1 do:\r\t\t[:startIndex |\r\t\t(self at: startIndex) = first ifTrue:\r\t\t\t[index := 1.\r\t\t\t[(self at: startIndex+index-1) = (sub at: index)]\r\t\t\t\twhileTrue:\r\t\t\t\t[index = sub size ifTrue: [^startIndex].\r\t\t\t\tindex := index+1]]].\r\t^ exceptionBlock value"},{"name":"eighth","linesOfCode":5,"sourceCode":"eighth\r\t\"Answer the eighth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) eighth  >>> #h\"\r\r\t^ self at: 8"},{"name":"asByteArray","linesOfCode":3,"sourceCode":"asByteArray\r\t\"Answer a ByteArray whose elements are the elements of the receiver.\"\r\r\t^ ByteArray withAll: self"},{"name":"atAll:put:","linesOfCode":5,"sourceCode":"atAll: aCollection put: anObject \r\t\"Put anObject at every index specified by the elements of aCollection.\"\r\t\"(#(x y z) atAll: #(1 3) put: #e; yourself) >>> #(e y e)\"\r\r\taCollection do: [:index | self at: index put: anObject].\r\t^ anObject"},{"name":"indexOf:ifAbsent:","linesOfCode":7,"sourceCode":"indexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the \r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOf: #c ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOf: #x ifAbsent: 7) >>> 7\"\r\r\t^ self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock"},{"name":"fifth","linesOfCode":5,"sourceCode":"fifth\r\t\"Answer the fifth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) fifth >>> #e\"\r\r\t^ self at: 5"},{"name":"errorOutOfBounds","linesOfCode":2,"sourceCode":"errorOutOfBounds\r\r\tSubscriptOutOfBounds signal"},{"name":"allButFirst:","linesOfCode":6,"sourceCode":"allButFirst: n\r\t\"Answer a copy of the receiver containing all but the first n\r\telements. Raise an error if there are not enough elements.\"\r\t\"(#(a b c d) allButFirst: 2) >>> #(c d)\"\r\t\"(#(a b c d) allButFirst: 3) >>> #(d)\"\r\t\r\t^ self copyFrom: n + 1 to: self size"},{"name":"atLast:put:","linesOfCode":5,"sourceCode":"atLast: indexFromEnd put: obj\r\t\"Set the element at indexFromEnd from the last position.\r\t atLast: 1 put: obj, sets the last element\"\r\t\"(#(x y z) atLast: 2 put: #e; yourself) >>> #(x e z)\"\r\r\t^ self at: self size + 1 - indexFromEnd put: obj"},{"name":"reverseWithIndexDo:","linesOfCode":7,"sourceCode":"reverseWithIndexDo: elementAndIndexBlock \r\t\"Just like reverseWith:do: except that the iteration index supplies the second argument to the block.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) reverseWithIndexDo: [:each :index | stream nextPut: each + index]]) >>> #(33 22 11)\"\r\t\r\tself size to: 1 by: -1 do: [:index |\r\t\telementAndIndexBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: index]"},{"name":"forceTo:paddingStartWith:","linesOfCode":17,"sourceCode":"forceTo: length paddingStartWith: elem \r\t\"Force the length of the collection to length, padding  \r\tthe beginning of the result if necessary with elem.  \r\tNote that this makes a copy.\"\r\t| newCollection padLen |\r\tnewCollection := self species ofSize: length.\r\tpadLen := length - self size max: 0.\r\tnewCollection\r\t\tfrom: 1\r\t\tto: padLen\r\t\tput: elem.\r\tnewCollection\r\t\treplaceFrom: padLen + 1\r\t\tto: ((padLen + self size) min: length)\r\t\twith: self\r\t\tstartingAt:  1.\r\t^ newCollection"},{"name":"appendTo:","linesOfCode":3,"sourceCode":"appendTo: aCollection\r\t\"double dispatch for join:\"\r\t^ aCollection addAllLast: self"},{"name":"shuffleBy:","linesOfCode":5,"sourceCode":"shuffleBy: aRandom\r\t\"Durstenfeld's version of the Fisher-Yates shuffle\"\r\t\"#(1 2 3 4 5) shuffleBy: (Random seed: 42) >>> #(2 5 4 3 1)\"\r\r\tself size to: 2 by: -1 do: [ :i | \r\t\tself swap: i with: (aRandom nextInteger: i) ]"},{"name":"pairsDo:","linesOfCode":4,"sourceCode":"pairsDo: aBlock\r\t\"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:\"\r\r\t\"(#(1 'fred' 2 'charlie' 3 'elmer') pairsDo: [:a :b | Transcript cr; show: b, ' is number ', a printString]) >>> #(1 'fred' 2 'charlie' 3 'elmer')\"\r\r\t1 to: self size // 2 do: [ :index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]"},{"name":"hasEqualElements:","linesOfCode":12,"sourceCode":"hasEqualElements: otherCollection\r\t\"Answer whether the receiver's size is the same as otherCollection's\r\tsize, and each of the receiver's elements equal the corresponding \r\telement of otherCollection.\r\tThis should probably replace the current definition of #= .\"\r\r\t| size |\r\t(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].\r\t(size := self size) = otherCollection size ifFalse: [^ false].\r\t1 to: size do:\r\t\t[:index |\r\t\t(self at: index) = (otherCollection at: index) ifFalse: [^ false]].\r\t^ true"},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t| hash |\r\r\thash := self species hash.\r\t1 to: self size do: [:i | hash := (hash + (self at: i) hash) hashMultiply].\r\t^hash"},{"name":"joinTo:","linesOfCode":3,"sourceCode":"joinTo: stream\r\t\"double dispatch for join:\"\r\t^ stream nextPutAll: self"},{"name":"atAll:putAll:","linesOfCode":6,"sourceCode":"atAll: indexArray putAll: valueArray\r\t\"Store the elements of valueArray into the slots\r\tof this collection selected by indexArray.\"\r\t\"(#(x y z) atAll: #(1 3) putAll: #(a e); yourself) >>> #(a y e)\"\r\r\tindexArray with: valueArray do: [:index :value | self at: index put: value].\r\t^ valueArray"},{"name":"sorted:","linesOfCode":9,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\"(#(3 9 1) sorted: [:a :b | a <= b ]) >>> #(1 3 9)\"\r\t\"(#(3 9 1) sorted: [:a :b | a >= b ]) >>> #(9 3 1)\"\r\t\"(#(xa xc xz xb xy) sorted: #last ascending) >>> #(xa xb xc xy xz)\"\r\t\r\t^self copy sort: aSortBlockOrNil"},{"name":"third","linesOfCode":5,"sourceCode":"third\r\t\"Answer the third element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) third >>> #c\"\r\r\t^ self at: 3"},{"name":"isSequenceable","linesOfCode":2,"sourceCode":"isSequenceable\r\t^ true"},{"name":"forceTo:paddingWith:","linesOfCode":7,"sourceCode":"forceTo: length paddingWith: elem\r\t\"Force the length of the collection to length, padding\r\tif necessary with elem.  Note that this makes a copy.\"\r\r\t| newCollection |\r\tnewCollection := self species new: length withAll: elem.\r\tnewCollection replaceFrom: 1 to: (self size min: length) with: self startingAt: 1.\r\t^ newCollection"},{"name":"asGPUFloat64x3Array","linesOfCode":2,"sourceCode":"asGPUFloat64x3Array\r\t^ self asGPUArrayOfType: #Float64x3"},{"name":"allButLast:","linesOfCode":6,"sourceCode":"allButLast: n\r\t\"Answer a copy of the receiver containing all but the last n\r\telements. Raise an error if there are not enough elements.\"\r\t\"(#(a b c d) allButLast: 2) >>> #(a b)\"\r\t\"(#(a b c d) allButLast: 3) >>> #(a)\"\r\r\t^ self copyFrom: 1 to: self size - n"},{"name":"splitOn:","linesOfCode":6,"sourceCode":"splitOn: splitter\r\t\"Split a collection of objects based on a splitter. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\r\t\"(#(1 2 3 3 4 1 2 3 5 4 6) splitOn: 4) >>> #(#(1 2 3 3) #(1 2 3 5) #(6))asOrderedCollection\"\r\t\"(#(1 2 3 3 4 1 2 3 3 5 6) splitOn: #(3 3)) >>> #(#(1 2) #(4 1 2) #(5 6)) asOrderedCollection\"\r\t\"(#(2 2 3 3 4 1 2 3 3 5) splitOn: [:each | each > 3])>>> #(#(2 2 3 3) #(1 2 3 3) #()) asOrderedCollection\"\r\r\t^ splitter split: self"},{"name":"identityIndexOf:","linesOfCode":6,"sourceCode":"identityIndexOf: anElement \r\t\"Answer the index of anElement within the receiver. If the receiver does \r\tnot contain anElement, answer 0.\"\r\t\"(#(a b c d e) identityIndexOf: #c) >>> 3\"\r\t\"(#(a b c d e) identityIndexOf: #x) >>> 0\"\r\r\t^self identityIndexOf: anElement ifAbsent: [0]"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeArray: self"},{"name":"asGPUFloat64x2Array","linesOfCode":2,"sourceCode":"asGPUFloat64x2Array\r\t^ self asGPUArrayOfType: #Float64x2"},{"name":"runningAverage:","linesOfCode":4,"sourceCode":"runningAverage: aSubsetSize\r\t\"Running average (a.k.a. moving average, rolling average). See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningAverage: 2) >>> {1 . (3/2) . 2 . (5/2) . 3}\"\r\r\t^ self running: [ :subset | subset average ] of: aSubsetSize"},{"name":"polynomialEval:","linesOfCode":11,"sourceCode":"polynomialEval: thisX\r\t\"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power.\r\t#(1 2 3) polynomialEval: 2  is 3*X^2 + 2*X + 1 with X = 2\"\r\r\t\"(#(1 2 3) polynomialEval: 2) >>> 17\"\r\r\t| sum valToPower |\r\tsum := self first.\r\tvalToPower := thisX.\r\t2 to: self size do: [ :ind | \r\t\tsum := sum + ((self at: ind) * valToPower).\r\t\tvalToPower := valToPower * thisX ].\r\t^ sum"}],"meta":{"name":"SequenceableCollection class","instanceVariables":[],"methods":[{"name":"streamContents:limitedTo:","linesOfCode":10,"sourceCode":"streamContents: blockWithArg limitedTo: sizeLimit\r\t\"A variant of #streamContents: with a strict size limit\"\r\r\t\"(String streamContents: [:s | 10 timesRepeat: [s nextPutAll: 'foo']] limitedTo: 9) >>> 'foofoofoo'\"\r\r\t| stream |\r\tstream := LimitedWriteStream\r\t\ton: (self streamSpecies new: (100 min: sizeLimit))\r\t\tlimit: sizeLimit\r\t\tlimitBlock: [ ^ stream contents ].\r\tblockWithArg value: stream.\r\t^ stream contents"},{"name":"new:streamContents:","linesOfCode":11,"sourceCode":"new: newSize streamContents: blockWithArg\r\t\"A variant of #streamContents: where the initial or even final size is given to optimize memory consumption\"\r\t\r\t\"(Array new: 3 streamContents: [ :out | 3 timesRepeat: [ out nextPut: 42 ] ]) >>> #(42 42 42)\"\r\t\r\t| stream |\r\tstream := WriteStream on: (self streamSpecies new: newSize).\r\tblockWithArg value: stream.\r\t\"If the write position of stream is at the end of the internal buffer of stream (originalContents),\r\twe can return it directly instead of making a copy as contents would do\"\r\t^ stream position = stream originalContents size\r\t\tifTrue: [ stream originalContents ]\r\t\tifFalse: [ stream contents ]"},{"name":"streamSpecies","linesOfCode":3,"sourceCode":"streamSpecies\r\t\"I return the class that is used for streaming. If override consider overriding #new:streamContents:\"\r\t^ self"},{"name":"ofSize:","linesOfCode":5,"sourceCode":"ofSize: n\r\t\"Create a new collection of size n with nil as its elements.\r\tThis method exists because OrderedCollection new: n creates an\r\tempty collection,  not one of size n.\"\r\t^ self new: n"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeCollectionInspector"},{"name":"fromSton:","linesOfCode":5,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to use #streamContents: and #nextPut:\"\r\t\r\t^ self streamContents: [ :stream |\r\t\tstonReader parseListDo: [ :each |\r\t\t\tstream nextPut: each ] ]"},{"name":"<<","linesOfCode":4,"sourceCode":"<< blockWithArg\r\t\"An alias to #streamContents:\"\r\t\r\t\"Array << [ :stream | 0 to: 100 by: 25 do: [ :each | stream nextPut: each ] ] >>> #(0 25 50 75 100)\"\r\t\r\t^ self streamContents: blockWithArg"},{"name":"streamContents:","linesOfCode":8,"sourceCode":"streamContents: blockWithArg\r\t\"Build an instance of the receiver by writing elements to a stream.\r\tMore specifically: blockWithArg will be given a WriteStream on an instance of the receiver.\r\tInside blockWithArg you write elements to the stream to build up the collection.\r\tAt the end, the contents of the stream up to that point will be returned.\r\tNote that the underlying collection grows as needed.\"\r\t\r\t\"(Array streamContents: [ :out | out nextPut: 1; nextPutAll: #(2 3 4); nextPut: 5 ]) >>> #(1 2 3 4 5)\"\r\r\t^ self new: 100 streamContents: blockWithArg"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #SequenceableCollection"}],"meta":null}},{"name":"Collection","instanceVariables":[],"methods":[{"name":"copyWith:","linesOfCode":6,"sourceCode":"copyWith: newElement\r\t\"Answer a new collection with newElement added (as last\r\telement if sequenceable).\"\r\r\t^ self copy\r\t\tadd: newElement;\r\t\tyourself"},{"name":"reject:thenCollect:","linesOfCode":3,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self reject: rejectBlock) collect: collectBlock"},{"name":"stonOn:","linesOfCode":6,"sourceCode":"stonOn: stonWriter\r\t\"For collections we chose to write a list of elements as delivered by #do:\r\tThis is not the best or most correct solution for all subclasses though,\r\tso some will revert to standard object behavior or chose another solution\"\r\t\r\tstonWriter writeObject: self do: [\r\t\tstonWriter encodeList: self ]\r"},{"name":"collect:thenDo:","linesOfCode":4,"sourceCode":"collect: collectBlock thenDo: doBlock \r\t\"Utility method to improve readability.\"\r\t\r\t^ self do: [ :each|\r\t\tdoBlock value: (collectBlock value: each)]"},{"name":"flatCollect:","linesOfCode":7,"sourceCode":"flatCollect: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t\"( #((3 4) (1 2)) flatCollect: [:each | each ] )>>> #(3 4 1 2)\"\r\t\"( #(3 4 1 2) flatCollect: [:each | { each } ] ) >>> #(3 4 1 2)\"\r\t\r\t^ self flatCollect: aBlock as: self species"},{"name":"cos","linesOfCode":2,"sourceCode":"cos\r\t^self collect: [:each | each cos]"},{"name":"removeFromMetacelloRepositories:","linesOfCode":2,"sourceCode":"removeFromMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each removeFromMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"asCharacterSet","linesOfCode":4,"sourceCode":"asCharacterSet\r\t\"Answer a CharacterSet whose elements are the unique elements of the receiver.\r\tThe reciever should only contain characters.\"\r\r\t^ CharacterSet newFrom: self"},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: aCollection \r\t\"Include all the elements of aCollection as the receiver's elements. Answer \r\taCollection. Actually, any object responding to #do: can be used as argument.\"\r\r\taCollection do: [:each | self add: each].\r\t^ aCollection"},{"name":"removeAllFoundIn:","linesOfCode":6,"sourceCode":"removeAllFoundIn: aCollection \r\t\"Remove each element of aCollection which is present in the receiver \r\tfrom the receiver. Answer aCollection. No error is raised if an element\r\tisn't found. ArrayedCollections cannot respond to this message.\"\r\r\taCollection do: [:each | self remove: each ifAbsent: []].\r\t^ aCollection"},{"name":"-","linesOfCode":2,"sourceCode":"- arg\r\r\t^ arg adaptToCollection: self andSend: #-"},{"name":"asDraggableMorph","linesOfCode":5,"sourceCode":"asDraggableMorph\r\t^ (String streamContents: [ :s| \r\t\tself \r\t\t\tdo: [ :each | s print: each ]\r\t\t\tseparatedBy: [ s space ]]) asStringMorph"},{"name":"gtDebuggerSUnitPrint","linesOfCode":3,"sourceCode":"gtDebuggerSUnitPrint\r\r\t^ String streamContents: [ :s | \r\t\t  self asStringOn: s delimiter: String cr ]"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\r\tself subclassResponsibility"},{"name":"raisedTo:","linesOfCode":2,"sourceCode":"raisedTo: arg\r\r\t^ arg adaptToCollection: self andSend: #raisedTo:"},{"name":"asOrderedCollection","linesOfCode":7,"sourceCode":"asOrderedCollection\r\t\"Answer an OrderedCollection whose elements are the elements of the\r\treceiver. The order in which elements are added depends on the order\r\tin which the receiver enumerates its elements. In the case of unordered\r\tcollections, the ordering is not necessarily the same for multiple \r\trequests for the conversion.\"\r\r\t^ self as: OrderedCollection"},{"name":"sum","linesOfCode":11,"sourceCode":"sum\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t| sum sample |\r\t\r\tself emptyCheck.\r\tsample := self anyOne.\r\tsum := self inject: sample into: [:accum :each | accum + each].\r\t^ sum - sample"},{"name":"gtInspectorInterestingObject","linesOfCode":4,"sourceCode":"gtInspectorInterestingObject\r\t^ self size = 1\r\t\tifTrue: [ self anyOne ]\r\t\tifFalse: [ self ]"},{"name":"copyWithoutDuplicates","linesOfCode":6,"sourceCode":"copyWithoutDuplicates\r\t\"Answer a copy of the receiver without any duplicated elements\"\r\t\"(#(2 3 4 4  5 6) copyWithoutDuplicates)  >>> #(2 3 4 5 6)\"\r\t\"(#('do' 'la' 'si' 'do' 'la') copyWithoutDuplicates) >>> #('la' 'do' 'si')\"\r\t\"(#(#do #la #si #do #la) copyWithoutDuplicates) >>> #(#la #do #si)\"\r\t^ self asSet asArray"},{"name":"//","linesOfCode":2,"sourceCode":"// arg\r\r\t^ arg adaptToCollection: self andSend: #//"},{"name":"copyWithout:","linesOfCode":6,"sourceCode":"copyWithout: oldElement \r\t\"Answer a copy of the receiver that does not contain any\r\telements equal to oldElement.\"\r\t\"('fred the bear' copyWithout: $e) >>> 'frd th bar'\"\r\t\"(#(2 3 4 5 5 6) copyWithout: 5) >>> #(2 3 4 6)\"\r\t\r\t\r\t^ self reject: [:each | each = oldElement]"},{"name":"floor","linesOfCode":2,"sourceCode":"floor\r\t^ self collect: [:a | a floor]"},{"name":"negated","linesOfCode":4,"sourceCode":"negated\r\t\"Negated value of all elements in the collection\"\r\t\"#(1 2 3) negated >>> #(-1 -2 -3)\"\r\t^ self collect: [:a | a negated]"},{"name":"do:separatedBy:","linesOfCode":12,"sourceCode":"do: elementBlock separatedBy: separatorBlock\r\t\"Evaluate the elementBlock for all elements in the receiver,\r\tand evaluate the separatorBlock between.\"\r\t\"(String streamContents: [:s | #(1 2 3) do: [:each | s << each asString] separatedBy: [s << ', ']]) >>> '1, 2, 3'\"\r\r\t| beforeFirst | \r\tbeforeFirst := true.\r\tself do:\r\t\t[:each |\r\t\tbeforeFirst\r\t\t\tifTrue: [beforeFirst := false]\r\t\t\tifFalse: [separatorBlock value].\r\t\telementBlock value: each]"},{"name":"reject:thenDo:","linesOfCode":6,"sourceCode":"reject: rejectBlock thenDo: doBlock \r\t\"Utility method to improve readability.\r\tDo not create the intermediate collection.\"\r\t\r\tself do: [ :each |\r\t\t(rejectBlock value: each)\r\t\t\tifFalse: [ doBlock value: each ] ]."},{"name":"collect:thenSelect:","linesOfCode":3,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self collect: collectBlock) select: selectBlock"},{"name":"asStringOn:delimiter:","linesOfCode":6,"sourceCode":"asStringOn: aStream delimiter: delimString\r\t\"Print elements on a stream separated\r\twith a delimiter String like: 'a, b, c'\r\tUses #asString instead of #print:.\"\r\r\tself do: [:elem | aStream nextPutAll: elem asString]\r\t\tseparatedBy: [aStream nextPutAll: delimString]"},{"name":"errorSizeMismatch","linesOfCode":3,"sourceCode":"errorSizeMismatch\r\t\"Signal a SizeMismatch exception\"\r\r\tSizeMismatch signal"},{"name":"asStringOn:delimiter:last:","linesOfCode":14,"sourceCode":"asStringOn: aStream delimiter: delimString last: lastDelimString\r\t\"Print elements on a stream separated\r\twith a delimiter between all the elements and with\r\ta special one before the last like: 'a, b and c'.\r\tUses #asString instead of #print:\r\r\tNote: Feel free to improve the code to detect the last element.\"\r\r\t| n sz |\r\tn := 1.\r\tsz := self size.\r\tself do: [:elem |\r\t\tn := n + 1.\r\t\taStream nextPutAll: elem asString]\r\tseparatedBy: [\r\t\taStream nextPutAll: (n = sz ifTrue: [lastDelimString] ifFalse: [delimString])]"},{"name":"addIfNotPresent:ifPresentDo:","linesOfCode":7,"sourceCode":"addIfNotPresent: anObject ifPresentDo: aBlock\r\t\"Include anObject as one of the receiver's elements and then value aBlock, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t(self includes: anObject) \r\t\tifFalse: [ self add: anObject ]\r\t\tifTrue: [ aBlock value ].\r\t^ anObject"},{"name":"averageIfEmpty:","linesOfCode":5,"sourceCode":"averageIfEmpty: aBlock \r\t\"This method return the average of the collection if it is not empty. In the other case,\r\tit return the value of the block. It means the user the user of this method decide of the return value. #() averageIfEmpty: [ 0 ]\"\r\tself ifEmpty: [ ^ aBlock value ].\r\t^ self average"},{"name":"difference:","linesOfCode":9,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. Pay attention that the difference is not commutative, hence the order is important.\"\r\r\t\"(#(a b c d e f) difference:  #(a b z k))>>> #(#f #d #e #c)\"\r\r\t\"(#(a b z k) difference: #(a b c d e f)) >>> #(#k #z)\"\r\r\t| set |\r\tset := self asSet\r\t\tremoveAllFoundIn: aCollection;\r\t\tyourself.\r\t^ self species withAll: set asArray"},{"name":"adaptToCollection:andSend:","linesOfCode":7,"sourceCode":"adaptToCollection: rcvr andSend: selector\r\t\"If I am involved in arithmetic with another Collection, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t(rcvr isSequenceable and: [ self isSequenceable ]) ifFalse:\r\t\t[self error: 'Only sequenceable collections may be combined arithmetically'].\r\t^ rcvr with: self collect:\r\t\t[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]"},{"name":"includesAny:","linesOfCode":4,"sourceCode":"includesAny: aCollection \r\t\"Answer whether any element of aCollection is one of the receiver's elements.\"\r\taCollection do: [:elem | (self includes: elem) ifTrue: [^ true]].\r\t^ false"},{"name":"inspectionItems:","linesOfCode":15,"sourceCode":"inspectionItems: aBuilder\r\t<inspectorPresentationOrder: 0 title: 'Items'> \r\t\r\t^ aBuilder newTable\t\t\r\t\taddColumn: (SpIndexTableColumn new \r\t\t\ttitle: 'Index';\r\t\t\tsortFunction: #yourself ascending;\r\t\t\tbeNotExpandable;\r\t\t\tyourself);\r\t\taddColumn: (SpStringTableColumn new  \r\t\t\ttitle: 'Value'; \r\t\t\tevaluated: [ :each | StObjectPrinter asTruncatedTextFrom: each ];\r\t\t\tsortFunction: #printString ascending;\r\t\t\tyourself);\r\t\titems: self asOrderedCollection;\r\t\tyourself"},{"name":"flattened","linesOfCode":5,"sourceCode":"flattened\r\t\"Flattens a collection of collections (no matter how many levels of collections exist). Strings are considered atoms and, as such, won't be flattened\"\r\t\"( #(1 #(2 3) #(4 #(5))) flattened ) >>> #(1 2 3 4 5)\" \r\t\"( #('string1' #('string2' 'string3')) flattened ) >>> #('string1' 'string2' 'string3')\"\r\t\r\t^ Array streamContents: [ :stream | self flattenOn: stream]."},{"name":"max","linesOfCode":6,"sourceCode":"max\r\t\"Return the maximum value of the collection\r\t\r\tExample of use:\r\t#(1 5 10 -4) max >>> 10\r\t\"\r\t^ self inject: self anyOne into: [:max :each | max max: each]"},{"name":"detect:ifNone:","linesOfCode":5,"sourceCode":"detect: aBlock ifNone: exceptionBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tAnswer the first element for which aBlock evaluates to true. If none  \r\tevaluate to true, then evaluate the argument, exceptionBlock.\"\r\r\t^ self detect: aBlock ifFound: [ :element | element ] ifNone: exceptionBlock"},{"name":"asCommaString","linesOfCode":5,"sourceCode":"asCommaString\r    \"Return collection printed as 'a, b, c' \"\r    \"#( 'a' 'b' 'c') asCommaString >>> 'a, b, c'\"\r    \r    ^String streamContents: [:s | self asStringOn: s delimiter: ', ']"},{"name":"remove:ifAbsent:","linesOfCode":7,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\t\"Remove oldObject from the receiver's elements. If several of the \r\telements are equal to oldObject, only one is removed. If no element is \r\tequal to oldObject, answer the result of evaluating anExceptionBlock. \r\tOtherwise, answer the argument, oldObject. ArrayedCollections cannot \r\trespond to this message.\"\r\r\tself subclassResponsibility"},{"name":"errorEmptyCollection","linesOfCode":3,"sourceCode":"errorEmptyCollection\r\t\"Signal a CollectionIsEmpty exception\"\r\r\tCollectionIsEmpty signalWith: self"},{"name":"removeFromMetacelloPackages:","linesOfCode":2,"sourceCode":"removeFromMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each removeFromMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"min","linesOfCode":2,"sourceCode":"min\r\t^ self inject: self anyOne into: [:min :each | min min: each]"},{"name":"asGCoordinates","linesOfCode":2,"sourceCode":"asGCoordinates\r\t^ GCoordinates withCollection: self"},{"name":"tan","linesOfCode":2,"sourceCode":"tan\r\t^self collect: [:each | each tan]"},{"name":"gtCollectionSizeThreshold","linesOfCode":4,"sourceCode":"gtCollectionSizeThreshold\r\t\"Return the maximum collection size that GT supports while showing all elements.\r\tWhen this threshold is reached, we no longer show certain views that would take too much resources.\"\r\r\t^ 16rFFFF \"65535\""},{"name":"gather:","linesOfCode":3,"sourceCode":"gather: aBlock\r\t\"This method is kept for compatibility reasons, use flatCollect: instead.\"\r\t\r\t^ self flatCollect: aBlock."},{"name":"sign","linesOfCode":5,"sourceCode":"sign\r\t\"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.\"\r\t\"5 sign >>> 1\"\r\t\"-3 sign >>> -1\"\r\t^self collect: [:each | each sign]"},{"name":"printOn:delimiter:","linesOfCode":5,"sourceCode":"printOn: aStream delimiter: delimString\r\t\"Print elements on a stream separated\r\twith a delimiter String like: 'a, b, c' \"\r\r\tself do: [:elem | aStream print: elem] separatedBy: [aStream nextPutAll: delimString]\r\t\t"},{"name":"isCollection","linesOfCode":3,"sourceCode":"isCollection\r\t\"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:\"\r\t^true"},{"name":"storeOn:","linesOfCode":16,"sourceCode":"storeOn: aStream \r\t\"Refer to the comment in Object|storeOn:.\"\r\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new)'.\r\tnoneYet := true.\r\tself do: \r\t\t[:each | \r\t\tnoneYet\r\t\t\tifTrue: [noneYet := false]\r\t\t\tifFalse: [aStream nextPut: $;].\r\t\taStream nextPutAll: ' add: '.\r\t\taStream store: each].\r\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"execute:against:","linesOfCode":2,"sourceCode":"execute: projectSpecBlock against: aScriptExecutor\r    aScriptExecutor executeCollection: self do: projectSpecBlock"},{"name":"select:","linesOfCode":9,"sourceCode":"select: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. Collect into a new collection like the receiver, only those elements for which aBlock evaluates to true. Answer the new collection.\"\r\t\"(#(1 2 3 4 5) select: #even) >>> #(2 4)\"\r\t\r\t| newCollection |\r\tnewCollection := self copyEmpty.\r\tself do: [ :each | \r\t\t(aBlock value: each) \r\t\t\tifTrue: [ newCollection add: each ]].\r\t^newCollection"},{"name":"do:without:","linesOfCode":4,"sourceCode":"do: aBlock without: anItem \r\t\"Enumerate all elements in the receiver. \r\tExecute aBlock for those elements that are not equal to the given item\"\r\r\t^ self do: [:each | anItem = each ifFalse: [aBlock value: each]]"},{"name":"arcTan","linesOfCode":2,"sourceCode":"arcTan\r\t^self collect: [:each | each arcTan]"},{"name":"detectSum:","linesOfCode":9,"sourceCode":"detectSum: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tReturn the sum of the answers.\"\r\t| sum |\r\tself deprecated: 'Use #sum: instead'.\r\tsum := 0.\r\tself do: [:each | \r\t\tsum := (aBlock value: each) + sum].  \r\t^ sum"},{"name":"sqrt","linesOfCode":2,"sourceCode":"sqrt\r\t^ self collect: [:each | each sqrt]"},{"name":"printElementsOn:","linesOfCode":6,"sourceCode":"printElementsOn: aStream\r\t\"The original code used #skip:, but some streams do not support that,\r\t and we don't really need it.\"\r\r\taStream nextPut: $(.\r\tself do: [:element | aStream print: element] separatedBy: [aStream space].\r\taStream nextPut: $)"},{"name":"printOn:delimiter:last:","linesOfCode":15,"sourceCode":"printOn: aStream delimiter: delimString last: lastDelimString\r\t\"Print elements on a stream separated\r\twith a delimiter between all the elements and with\r\ta special one before the last like: 'a, b and c'\r\r\tNote: Feel free to improve the code to detect the last element.\"\r\r\t| n sz |\r\tn := 1.\r\tsz := self size.\r\tself do: [:elem |\r\t\tn := n + 1.\r\t\taStream print: elem]\r\tseparatedBy: [\r\t\tn = sz\r\t\t\tifTrue: [aStream print: lastDelimString]\r\t\t\tifFalse: [aStream print: delimString]]"},{"name":"flatCollectAsSet:","linesOfCode":5,"sourceCode":"flatCollectAsSet: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t^ self flatCollect: aBlock as: Set"},{"name":"flattenOn:","linesOfCode":2,"sourceCode":"flattenOn: aStream\r\r\tself do: [ :each | each flattenOn: aStream ]"},{"name":"includesAllOf:","linesOfCode":5,"sourceCode":"includesAllOf: aCollection \r\r\tself\r\t\tdeprecated: 'Please use #includesAll: instead'\r\t\ttransformWith: '`@receiver includesAllOf: `@statements' -> '`@receiver includesAll: `@statements'.\r\t\r\t^ self includesAll: aCollection"},{"name":"asSet","linesOfCode":3,"sourceCode":"asSet\r\t\"Answer a Set whose elements are the unique elements of the receiver.\"\r\r\t^ Set withAll: self"},{"name":"addToMetacelloRepositories:","linesOfCode":2,"sourceCode":"addToMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each addToMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"resolvePackageSpecsNamedForMetacelloMCVersion:visited:ifAbsent:","linesOfCode":4,"sourceCode":"resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock\r    ^ aMetacelloMCVersion\r        allPackagesForSpecs: (self collect: [ :ea | aMetacelloMCVersion packageNamed: ea ifAbsent: aBlock ])\r        visited: visited"},{"name":"copyEmpty","linesOfCode":2,"sourceCode":"copyEmpty\r\t^ self species new"},{"name":"sumNumbers","linesOfCode":9,"sourceCode":"sumNumbers\r\t\"This is implemented using a variant of the normal inject:into: pattern\r\tthat is specific to handling numbers. The receiver should include only numbers.\r\t\r\tDifferent from the sum implementation, the default value is zero. While sum is \r\tmore general, sumNumbers is meant to support the most often encountered use case of\r\tdealing with numbers.\"\r\r\t^ self \r\t\tinject: 0 \r\t\tinto: [ :sum :each |  sum + each ]"},{"name":"ifNotEmpty:ifEmpty:","linesOfCode":6,"sourceCode":"ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock\r\t\"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise\r\t If the notEmptyBlock has an argument, eval with the receiver as its argument\"\r\r\t^ self isEmpty\r\t\tifTrue: [ emptyBlock value ]\r\t\tifFalse: [ notEmptyBlock cull: self ]"},{"name":"size","linesOfCode":6,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | tally := tally + 1].\r\t^ tally"},{"name":"addedToZnUrl:","linesOfCode":2,"sourceCode":"addedToZnUrl: url \r\t^ url withPathSegments: self"},{"name":"ln","linesOfCode":2,"sourceCode":"ln\r\t^self collect: [:each | each ln]"},{"name":"asOrderedDictionary","linesOfCode":2,"sourceCode":"asOrderedDictionary\r\r\t^ self as: OrderedDictionary"},{"name":"inject:into:","linesOfCode":7,"sourceCode":"inject: thisValue into: binaryBlock \r\t\"Accumulate a running value associated with evaluating the argument, binaryBlock, with the current value of the argument, thisValue, and the receiver as block arguments.\"\r\t\r\t\"( #(1 2 3) inject: 0 into: [ :sum :each | sum + each ] ) >>> 6\"\r\r\t| nextValue |\r\tnextValue := thisValue.\r\tself do: [:each | nextValue := binaryBlock value: nextValue value: each].\r\t^nextValue"},{"name":"capacity","linesOfCode":3,"sourceCode":"capacity\r\t\"Answer the current capacity of the receiver.\"\r\r\t^ self size"},{"name":"squared","linesOfCode":2,"sourceCode":"squared\r\t^ self collect: [:each | each * each]"},{"name":"reduce:","linesOfCode":6,"sourceCode":"reduce: aBlock\r\t\"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified.\"\r\t\"( #(1 2 3) asSet reduce: [ :a :b | a + b ] ) >>> 1 + 2 + 3\"\r\t\"( #(1 2 3 4 5) asSet reduce: [ :a :b :c | a + b + c ] ) >>> 1 + 2 + 3 + 4 + 5\"\r\t\t\r\t^self asOrderedCollection reduce: aBlock"},{"name":"removeAll:","linesOfCode":7,"sourceCode":"removeAll: aCollection \r\t\"Remove each element of aCollection from the receiver. If successful for \r\teach, answer aCollection. Otherwise create an error notification.\r\tArrayedCollections cannot respond to this message.\"\r\r\taCollection == self ifTrue: [^self removeAll].\r\taCollection do: [:each | self remove: each].\r\t^ aCollection"},{"name":"gtInspectorItemsIn:","linesOfCode":18,"sourceCode":"gtInspectorItemsIn: composite\r\t<gtInspectorPresentationOrder: 0>\r\t^ composite fastList\r\t\ttitle: 'Items';\r\t\tdisplay: [ \"The FastTable renderer needs to access elements by index so we transform\r\t\t\tthe collection to an OrderedCollection. Subclasses can override the #display\r\t\t\tblock to provide a different behaviour. The previous renderer had this behaviour\r\t\t\timplemented in the renderer.\" self asOrderedCollection ];\r\t\tbeMultiple;\r\t\tformat: [ :each | GTObjectPrinter asTruncatedTextFrom: each ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\t\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult\r\t\t\t\tifNotNil: [ result size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] ] ]"},{"name":"doWithIndex:","linesOfCode":6,"sourceCode":"doWithIndex: elementAndIndexBlock\r\t\"Use the new version with consistent naming\r\t\r\tExample of use:\r\t(#('hello' 'world' 'bonjour') doWithIndex: [ :element :index |  ])\r\t\"\r\r\t^ self withIndexDo: elementAndIndexBlock"},{"name":"collectAll:","linesOfCode":8,"sourceCode":"collectAll: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect all the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself do: [:each | newCollection addAll: (aBlock value: each)].\r\t^ newCollection"},{"name":"atRandom","linesOfCode":11,"sourceCode":"atRandom\r\t\"Answer a random element of the receiver.  Uses a shared random \r\tnumber generator owned by class Collection.  If you use this a lot, \r\tdefine your own instance of Random and use #atRandom:.  Causes \r\tan error if self has no elements.\"\r\r\t^ self atRandom: SharedRandom globalGenerator.\r\r\"Examples:\r\t#('one' 'or' 'the' 'other') atRandom\r\t(1 to: 10) atRandom\r\t'Just pick one of these letters at random' atRandom\r\t#(3 7 4 9 21) asSet atRandom\t\t(just to show it also works for Sets)\r\""},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted\"\r\t\r\t^self asArray sorted"},{"name":"detect:ifFound:","linesOfCode":14,"sourceCode":"detect: aBlock ifFound: foundBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tIf some element evaluates aBlock to true, then cull this element into \r\tfoundBlock. \r\tIf no element matches the criteria then do nothing.\r\tAlways returns self to avoid misuse and a potential isNil check on the sender.\"\r\t\"(#(1 2) detect: [ :each | each even ] ifFound: [ ^'yay!' ]) >>> 'yay'\"\r\t\"(#(1 3) detect: [ :each | each even ] ifFound: [ ^'yay!' ]) >>> #(1 3)\"\r\r\tself\r\t\tdetect: aBlock\r\t\tifFound: foundBlock\r\t\tifNone: [ \r\t\t\t\"Do nothing on purpose\"\r\t\t\t ]"},{"name":"rounded","linesOfCode":2,"sourceCode":"rounded\r\t^ self collect: [:a | a rounded]"},{"name":"anyOne","linesOfCode":8,"sourceCode":"anyOne\r\t\"Answer a representative sample of the receiver. It raises an error when the collection is empty. This method can be helpful when needing to preinfer the nature of the contents of semi-homogeneous collections.\"\r\t\"#(1 2 3) anyOne >>> 1\"\r\t\"\r\t([#() anyOne] on: SubscriptOutOfBounds do: [ :ex | 'whatever' ]) >>> 'whatever'\r\t\"\r\t\r\tself emptyCheck.\r\tself do: [:each | ^ each]"},{"name":"add:","linesOfCode":4,"sourceCode":"add: newObject \r\t\"Include newObject as one of the receiver's elements. Answer newObject. \r\tArrayedCollections cannot respond to this message.\"\r\r\tself subclassResponsibility"},{"name":",","linesOfCode":4,"sourceCode":", aCollection\r\t\"Concatenate the receiver with the argument.\"\r\t\"#(1 2 3) , #(4 5 6) >>> #(1 2 3 4 5 6)\"\r\t\r\t^self copy addAll: aCollection; yourself"},{"name":"stdev","linesOfCode":9,"sourceCode":"stdev\r\t| avg sample sum |\r\t\"In statistics, the standard deviation is a measure that is used to quantify the amount of variation or dispersion of a set of data values.\r\tFor details about implementation see comment in self sum.\"\r\tavg := self average.\r\tsample := self anyOne.\r\tsum := self inject: sample into: [ :accum :each | accum + (each - avg) squared ].\r\tsum := sum - sample.\r\t^ (sum / (self size - 1)) sqrt"},{"name":"asSortedCollection:","linesOfCode":7,"sourceCode":"asSortedCollection: aSortBlock \r\t\"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is defined by the argument, aSortBlock. Note that it is better to use #sorted: if you don't really need a SortedCollection, but a sorted collection!!\"\r\r\t| aSortedCollection |\r\taSortedCollection := SortedCollection new: self size.\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"detect:ifFound:ifNone:","linesOfCode":10,"sourceCode":"detect: aBlock ifFound: foundBlock ifNone: exceptionBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tIf some element evaluates aBlock to true, then cull this element into \r\tfoundBlock and answer the result of this evaluation. \r\tIf none evaluate to true, then evaluate exceptionBlock.\"\r\r\tself\r\t\tdo: [ :each | \r\t\t\t(aBlock value: each)\r\t\t\t\tifTrue: [ ^ foundBlock cull: each ] ].\r\t^ exceptionBlock value\t"},{"name":"recordRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"recordRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doRecordRequiredFromArray: self."},{"name":"sin","linesOfCode":2,"sourceCode":"sin\r\t^self collect: [:each | each sin]"},{"name":"notEmpty","linesOfCode":4,"sourceCode":"notEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\t\"use isNotEmpty for consistency with isEmpty\"\r\r\t^ self isEmpty not"},{"name":"mergeIntoMetacelloPackages:","linesOfCode":2,"sourceCode":"mergeIntoMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each mergeIntoMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"loadRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"loadRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doLoadRequiredFromArray: self."},{"name":"allSatisfy:","linesOfCode":8,"sourceCode":"allSatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver.\r\tIf aBlock returns false for any element return false.\r\tOtherwise return true.\"\r\t\"#(1 2) allSatisfy: [ :each | each even ] >>> false\"\r\t\"#(2 4) allSatisfy: [ :each | each even ] >>> true\"\r\r\tself do: [:each | (aBlock value: each) ifFalse: [^ false]].\r\t^ true"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self asArray"},{"name":"removeAll","linesOfCode":7,"sourceCode":"removeAll\r\t\"Remove each element from the receiver and leave it empty.\r\tArrayedCollections cannot respond to this message.\r\tThere are two good reasons why a subclass should override this message:\r\t1) the subclass does not support being modified while being iterated\r\t2) the subclass provides a much faster way than iterating through each element\"\r\r\tself do: [:each | self remove: each]."},{"name":"setRequiresInMetacelloPackage:","linesOfCode":2,"sourceCode":"setRequiresInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setRequires: self asArray."},{"name":"sumNumbers:","linesOfCode":10,"sourceCode":"sumNumbers: aBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern\r\tthat is specific to handling numbers. aBlock is expected to return a number\r\tfor every element in the collection.\r\t\r\tDifferent from the sum: implementation, the default value is zero. While sum: is \r\tmore general, sumNumbers: is meant to support the most often encountered use case of\r\tdealing with numbers.\"\r\r\t^ self \r\t\tinject: 0 \r\t\tinto: [ :sum :each |  sum + (aBlock value: each) ]"},{"name":"do:displayingProgress:every:","linesOfCode":33,"sourceCode":"do: aBlock displayingProgress: aStringOrBlock every: msecs\r\t\"Enumerate aBlock displaying progress information.\r \t If the argument is a string, use a static label for the process.\r\t If the argument is a block, evaluate it with the element to retrieve the label.\r \t The msecs argument ensures that updates happen at most every msecs.\r       Example:\r               Smalltalk allClasses\r                       do:[:aClass| (Delay forMilliseconds: 1) wait]\r                       displayingProgress:[:aClass| 'Processing ', aClass name]\r                       every: 0.\"\r\r\t| size labelBlock count oldLabel lastUpdate |\r\tself isEmpty ifTrue: [ ^ self ].\r\toldLabel := nil.\r\tcount := lastUpdate := 0.\r\tsize := self size.\r\t'' displayProgressFrom: 0 to: size during: [:bar |\r\t\tlabelBlock := aStringOrBlock isString\r\t\t\tifTrue: [\r\t\t\t\tbar label: aStringOrBlock.\r\t\t\t\t[ :dummyItem | aStringOrBlock] ]\r\t\t\tifFalse: [ aStringOrBlock ].\r\r\t\tself do: [ :each | | newLabel |\r\t\t\t\"Special handling for first and last element\"\r\t\t\t(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) \r\t\t\t\tifTrue: [ \r\t\t\t\t\tbar current: count.\r\t\t\t\t\toldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) \r\t\t\t\t\t\tifFalse: [\r\t\t\t\t\t\t\tbar label: newLabel.\r\t\t\t\t\t\t\toldLabel := newLabel ].\r\t\t\t\tlastUpdate := Time millisecondClockValue ].\r\t\t\taBlock value: each.\r\t\t\tcount := count + 1 ] ]"},{"name":"contents","linesOfCode":2,"sourceCode":"contents\r\t^ self"},{"name":"addIfNotPresent:","linesOfCode":5,"sourceCode":"addIfNotPresent: anObject\r\t\"Include anObject as one of the receiver's elements, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t(self includes: anObject) ifFalse: [self add: anObject].\r\t^ anObject"},{"name":"asSequenceParser","linesOfCode":2,"sourceCode":"asSequenceParser\r\t^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])"},{"name":"fold:","linesOfCode":4,"sourceCode":"fold: binaryBlock\r\t\"Evaluate the block with the first two elements of the receiver, then with the result of the first evaluation and the next element, and so on.  Answer the result of the final evaluation. If the receiver is empty, raise an error. If the receiver has a single element, answer that element.\"\r\t\"( #('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b] ) >>> 'if it is to be it is up to me'\"\r\r\t^self reduce: binaryBlock"},{"name":"roundTo:","linesOfCode":2,"sourceCode":"roundTo: quantum\r\t^self collect: [ :ea | ea roundTo: quantum ]"},{"name":"asChoiceParser","linesOfCode":2,"sourceCode":"asChoiceParser\r\t^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])"},{"name":"anySatisfy:","linesOfCode":8,"sourceCode":"anySatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver.\r\tIf aBlock returns true for any element return true.\r\tOtherwise return false.\"\r\t\"#(1 3) anySatisfy: [ :each | each even ] >>> false\"\r\t\"#(1 2) anySatisfy: [ :each | each even ] >>> true\"\r\r\tself do: [:each | (aBlock value: each) ifTrue: [^ true]].\r\t^ false"},{"name":"selectEveryFirst","linesOfCode":5,"sourceCode":"selectEveryFirst\r\t\"#(1 2 3 4) selectEveryFirst asArray \r\t>>> #(1 3)\r\t\"\r\t^ self selectEvery: [ :i | (i+1 \\\\ 2) = 0 ]"},{"name":"findFirstInByteString:startingAt:","linesOfCode":8,"sourceCode":"findFirstInByteString: aByteString startingAt: start\r\t\"Find the index of first character starting at start in aByteString that is included in the receiver.\r\tDefault is to use a naive algorithm.\r\tSubclasses might want to implement a more efficient scheme\"\r\r\tstart to: aByteString size do:\r\t\t[:index |\r\t\t(self includes: (aByteString at: index)) ifTrue: [^ index]].\r\t^ 0"},{"name":"isEmpty","linesOfCode":3,"sourceCode":"isEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\r\t^self size = 0"},{"name":"asParser","linesOfCode":12,"sourceCode":"asParser    \r\t\"Create a range of characters between start and stop.\"\r\r\t(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ \r\t\t| charSet |\r\t\tcharSet := PPCharSetPredicate on: [ :char | self includes: char ] .\r     \t^ PPPredicateObjectParser on: charSet message: 'One of these charactes expected: ', self printString.\r\t].\r\r\r\t^ super asParser\r\t\"\r\t\t($a to:$f) asParser parse:'a'\r\t\t($a to:$f) asParser parse:'g'\r\t\"\r"},{"name":"arcSin","linesOfCode":2,"sourceCode":"arcSin\r\t^self collect: [:each | each arcSin]"},{"name":"emptyCheck","linesOfCode":2,"sourceCode":"emptyCheck\r\r\tself isEmpty ifTrue: [self errorEmptyCollection]"},{"name":"occurrencesOf:","linesOfCode":6,"sourceCode":"occurrencesOf: anObject \r\t\"Answer how many of the receiver's elements are equal to anObject.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | anObject = each ifTrue: [tally := tally + 1]].\r\t^tally"},{"name":"union:","linesOfCode":6,"sourceCode":"union: aCollection\r\t\"Answer the set theoretic union of two collections.\"\r\t\"(#(1 2 3) union: #(4 5 6 2)) >>> #(1 2 3 4 5 6)\"\r\t\r\t| set |\r\tset := self asSet addAll: aCollection; yourself.\r\t^ self species withAll: set asArray"},{"name":"unzip","linesOfCode":18,"sourceCode":"unzip\r\t\"Given a collection returns in one pass two collections containing each odd and even elements in respective subcollections\"\r\t\"\r\t#(1 2 3 4) unzip first asArray \r\t>>> #(1 3)\r\t#(1 2 3 4) unzip second asArray \r\t>>> #(2 4)\r\t\"\r\t\r\t| odd even s |\r\ts := self size // 2.\r\todd := OrderedCollection new: s.\r\teven := OrderedCollection new: s.\r\t1 \r\t\tto: self size \r\t\tdo: [ :i | (i \\\\ 2) = 0\t\r\t\t\t\t\t\tifTrue: [ even add: (self at: i) ]\r\t\t\t\t\t\tifFalse: [ odd add: (self at: i) ] ].\r\t^ { odd . even }"},{"name":"fetchRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doFetchRequiredFromArray: self."},{"name":"collect:as:","linesOfCode":4,"sourceCode":"collect: aBlock as: aClass\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into an instance of aClass. Answer the resulting collection.\"\r\r\t^(aClass new: self size) fillFrom: self with: aBlock"},{"name":"asMetacelloAttributePath","linesOfCode":2,"sourceCode":"asMetacelloAttributePath\r    ^ MetacelloMethodSectionPath withAll: self"},{"name":"reject:","linesOfCode":4,"sourceCode":"reject: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. Collect into a new collection like the receiver only those elements for which aBlock evaluates to false. Answer the new collection.\"\r\t\"#(1 2 3 4 5) reject: #even >>>  #(1 3 5)\"\r\r\t^ self select: [ :element | (aBlock value: element) == false ]"},{"name":"|","linesOfCode":4,"sourceCode":"| aCollection\r\t\"Return all the elements that appear in self or in aCollection\"\r\t\"'abc' | 'cbe' >>> 'bcea'\"\r\t\r\t^ self union: aCollection"},{"name":"degreeCos","linesOfCode":2,"sourceCode":"degreeCos\r\t^self collect: [:each | each degreeCos]"},{"name":"noneSatisfy:","linesOfCode":4,"sourceCode":"noneSatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver. If aBlock returns false for all elements return true. Otherwise return false\"\r\r\tself do: [:item | (aBlock value: item) ifTrue: [^ false]].\r\t^ true"},{"name":"addToMetacelloPackages:","linesOfCode":2,"sourceCode":"addToMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each addToMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"asDictionary","linesOfCode":2,"sourceCode":"asDictionary\r\r\t^ self as: Dictionary"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream \r\t\"Append a sequence of characters that identify the receiver to aStream.\"\r\r\tself printNameOn: aStream.\r\tself printElementsOn: aStream"},{"name":"nodesDo:","linesOfCode":2,"sourceCode":"nodesDo: aBlock\r\tself do: aBlock"},{"name":"fillFrom:with:","linesOfCode":5,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollections's elements as the argument.  \r\tCollect the resulting values into self. Answer self.\"\r\r\taCollection do: [ :each |\r\t\tself add: (aBlock value: each) ]"},{"name":"isNotEmpty","linesOfCode":7,"sourceCode":"isNotEmpty\r\t\"Answer whether the receiver contains any elements.\r\t\r\tExample of use:\r\t\r\t#() isNotEmpty >>> false\r\t#(1 2 3) isNotEmpty >>> true\r\t\"\r\r\t^ self isEmpty not"},{"name":"setIncludesInMetacelloPackage:","linesOfCode":2,"sourceCode":"setIncludesInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setIncludes: self asArray."},{"name":"asGVector","linesOfCode":2,"sourceCode":"asGVector\r\t^ GVector withCollection: self"},{"name":"asCommaStringAnd","linesOfCode":4,"sourceCode":"asCommaStringAnd\r\t\"Return collection printed as 'a, b and c' \"\r\t\"#( 'a' 'b' 'c') asCommaStringAnd >>> 'a, b and c'\"\r\r\t^String streamContents: [:s | self asStringOn: s delimiter: ', ' last: ' and ']"},{"name":"printNameOn:","linesOfCode":2,"sourceCode":"printNameOn: aStream\r\tsuper printOn: aStream"},{"name":"includesAll:","linesOfCode":4,"sourceCode":"includesAll: aCollection \r\t\"Answer whether all the elements of aCollection are in the receiver.\"\r\taCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].\r\t^ true"},{"name":"arcCos","linesOfCode":2,"sourceCode":"arcCos\r\t^self collect: [:each | each arcCos]"},{"name":"select:thenCollect:","linesOfCode":3,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self select: selectBlock) collect: collectBlock"},{"name":"&","linesOfCode":3,"sourceCode":"& aCollection\r\t\"#(1 2 3 4) & #(1 2 4 6 7) >>> #(1 2 4)\"\r\t\r\t^ self intersection: aCollection"},{"name":"detectMin:","linesOfCode":21,"sourceCode":"detectMin: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the element for which aBlock evaluates to the lowest number.\r\tIf collection empty, return nil.\r\t\r\tExample of use:\r\t({ 2@3 . -4@6 . 10@ -3 } detectMin: [ :p | p x ]) >>> (-4@6)\r\t({ 2@3 . -4@6 . 10@ -3 } detectMin: [ :p | p y ]) >>> (10@ -3)\r\t\"\r\r\t| minElement minValue |\r\tself do: [:each | | val | \r\t\tminValue == nil\r\t\t\tifFalse: [\r\t\t\t\t(val := aBlock value: each) < minValue ifTrue: [\r\t\t\t\t\tminElement := each.\r\t\t\t\t\tminValue := val]]\r\t\t\tifTrue: [\"first element\"\r\t\t\t\tminElement := each.\r\t\t\t\tminValue := aBlock value: each].\r\t\t\t\t\"Note that there is no way to get the first element that works \r\t\t\t\tfor all kinds of Collections.  Must test every one.\"].\r\t^ minElement"},{"name":"selectEvery:","linesOfCode":7,"sourceCode":"selectEvery: aBlock\r\t\"Select elements of the receiver whose index satisfy the argument. Look at selectEveryFirst and selectEverySecond for examples.\"\r\t\r\t| res |\r\tres := OrderedCollection new.\r\t1 to: self size do: [ :i | (aBlock value: i) \r\t\t\t\t\t\t\t\t\t\t\tifTrue: [res add: (self at: i) ]].\r\t^ res"},{"name":"sum:ifEmpty:","linesOfCode":14,"sourceCode":"sum: aBlock ifEmpty: anEmptySumBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t| sum sample |\r\t\r\t^ self\r\t\tifNotEmpty: [ \r\t\t\tsample := aBlock value: self anyOne.\r\t\t\tsum := self inject: sample into: [ :previousValue :each |\r\t\t\t\tpreviousValue + (aBlock value: each) ].\r\t\t\tsum - sample ]\r\t\tifEmpty: anEmptySumBlock."},{"name":"range","linesOfCode":4,"sourceCode":"range\r\t\"returns the difference between the max and min element, their positions notwithstanding\"\r\t\"#( 1 51 10 ) range >>> 50\"\r\t^ self max - self min"},{"name":"associationsDo:","linesOfCode":5,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).  If any non-association is within, the error is not caught now,\r\tbut later, when a key or value message is sent to it.\"\r\r\tself do: aBlock"},{"name":"gtInspectorHash","linesOfCode":2,"sourceCode":"gtInspectorHash\r\r\t^ super gtInspectorHash bitXor: self size hash"},{"name":"flatCollect:as:","linesOfCode":8,"sourceCode":"flatCollect: aBlock as: aCollectionClass\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\r\t| col |\r\tcol := OrderedCollection new: self size.\r\tself do: [ :each | col addAll: (aBlock value: each) ].\r\t^ aCollectionClass withAll: col "},{"name":"remove:","linesOfCode":5,"sourceCode":"remove: oldObject \r\t\"Remove oldObject from the receiver's elements. Answer oldObject \r\tunless no element is equal to oldObject, in which case, raise an error.\r\tArrayedCollections cannot respond to this message.\"\r\r\t^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]"},{"name":"asBag","linesOfCode":3,"sourceCode":"asBag\r\t\"Answer a Bag whose elements are the elements of the receiver.\"\r\r\t^ Bag withAll: self"},{"name":"do:displayingProgress:","linesOfCode":12,"sourceCode":"do: aBlock displayingProgress: aStringOrBlock\r\t\"Enumerate aBlock displaying progress information. \r \t If the argument is a string, use a static label for the process. \r\t If the argument is a block, evaluate it with the element to retrieve the label.\r\t\r\t\tSmalltalk allClasses \r\t\t\tdo:[:aClass| (Delay forMilliseconds: 1) wait]\r\t\t\tdisplayingProgress: 'Processing...'.\r\t\tSmalltalk allClasses \r\t\t\tdo:[:aClass| (Delay forMilliseconds: 1) wait]\r\t\t\tdisplayingProgress:[:aClass| 'Processing ', aClass name].\r\t\"\r\t^self do: aBlock displayingProgress: aStringOrBlock every: 20"},{"name":"/","linesOfCode":2,"sourceCode":"/ arg\r\r\t^ arg adaptToCollection: self andSend: #/"},{"name":"gtIterator","linesOfCode":2,"sourceCode":"gtIterator\r\t^ [ :filter | self do: filter ] gtIterator"},{"name":"asShortcut","linesOfCode":2,"sourceCode":"asShortcut\r\t^ self asKeyCombination"},{"name":"asRWElementList","linesOfCode":2,"sourceCode":"asRWElementList\r\t^ RWElementList withAll: self"},{"name":"ifNotEmpty:","linesOfCode":6,"sourceCode":"ifNotEmpty: aBlock\r\t\"Evaluate the given block with the receiver as argument, answering its value\r    unless the receiver is empty, in which case answer the receiver.\"\r\r\t^ self isEmpty\r\t\tifTrue: [ self ]\r\t\tifFalse: [ aBlock cull: self ]"},{"name":"ifEmpty:","linesOfCode":6,"sourceCode":"ifEmpty: aBlock\r\t\"Evaluate the given block, answering its value if the receiver is empty, otherwise answer the receiver.\"\r\r\t\"Note that the fact that this method returns its receiver in case the receiver is not empty allows one to write expressions like the following ones: self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified'])\"\r\r\t^ self isEmpty\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ self ]"},{"name":"adaptToNumber:andSend:","linesOfCode":4,"sourceCode":"adaptToNumber: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a scalar, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t^ self collect: [:element | rcvr perform: selector with: element]"},{"name":"collect:into:","linesOfCode":4,"sourceCode":"collect: aBlock into: aCollection\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into aCollection. Answer aCollection.\"\r\r\t^aCollection fillFrom: self with: aBlock"},{"name":"ceiling","linesOfCode":2,"sourceCode":"ceiling\r\t^ self collect: [:a | a ceiling]"},{"name":"asSortedCollection","linesOfCode":3,"sourceCode":"asSortedCollection\r\t\"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is the default less than or equal. Note that you should use #sorted: if you don't really need a SortedCollection, but a sorted collection.\"\r\r\t^ self as: SortedCollection"},{"name":"collect:thenReject:","linesOfCode":3,"sourceCode":"collect: collectBlock thenReject: selectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self collect: collectBlock) reject: selectBlock"},{"name":"count:","linesOfCode":8,"sourceCode":"count: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tAnswer the number of elements that answered true.\"\r\t\"#(1 2 3 4) count: [ :each | each even ] >>> true\"\r\r\t| sum |\r\tsum := 0.\r\tself do: [:each | (aBlock value: each) ifTrue: [sum := sum + 1]].\r\t^ sum"},{"name":"\\\\","linesOfCode":2,"sourceCode":"\\\\ arg\r\r\t^ arg adaptToCollection: self andSend: #\\\\"},{"name":"asKeyCombination","linesOfCode":6,"sourceCode":"asKeyCombination\r\t| shortcut |\r\tself size = 1 ifTrue: [ ^self first asKeyCombination ].\r\r\tshortcut := KMKeyCombinationSequence new.\r\tself do: [ :each | shortcut addShortcut: each asKeyCombination ].\r\t^shortcut."},{"name":"copyWithoutAll:","linesOfCode":4,"sourceCode":"copyWithoutAll: aCollection\r\t\"Answer a copy of the receiver that does not contain any elements \r\tequal to those in aCollection.\"\r\r\t^ self reject: [:each | aCollection includes: each]"},{"name":"exp","linesOfCode":2,"sourceCode":"exp\r\t^self collect: [:each | each exp]"},{"name":"sum:","linesOfCode":7,"sourceCode":"sum: aBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t^ self sum: aBlock ifEmpty: [ 0 ]"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t^ self anySatisfy: [:each | each = anObject]"},{"name":"intersection:","linesOfCode":6,"sourceCode":"intersection: aCollection\r\t\"Answer the set theoretic intersection of two collections.\"\r\r\t\"(#(1 2 3 4) intersection: #(3 4 5)) >>> #(3 4)\"\r\r\t\"(#(1 2 3 4) intersection: #()) >>> #()\"\r\r\t\"(#() intersection: #(1 2 3 4)) >>> #()\"\r\r\t^ self species withAll: (self asSet intersection: aCollection) asArray"},{"name":"collect:","linesOfCode":8,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself do: [:each | newCollection add: (aBlock value: each)].\r\t^ newCollection"},{"name":"removeAllSuchThat:","linesOfCode":5,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Evaluate aBlock for each element and remove all that elements from\r\tthe receiver for that aBlock evaluates to true.  Use a copy to enumerate \r\tcollections whose order changes when an element is removed (i.e. Sets).\"\r\r\tself copy do: [:each | (aBlock value: each) ifTrue: [self remove: each]]"},{"name":"asArray","linesOfCode":10,"sourceCode":"asArray\r\t\"Answer an Array whose elements are the elements of the receiver.\r\tImplementation note: Cannot use ''Array withAll: self'' as that only\r\tworks for SequenceableCollections which support the replacement \r\tprimitive.\"\r\r\t| newArray index |\r\tnewArray := Array new: self size.\r\tindex := 0.\r\tself do: [:each | newArray at: (index := index + 1) put: each].\r\t^ newArray"},{"name":"groupedBy:","linesOfCode":13,"sourceCode":"groupedBy: aBlock\r\t\"Answer a dictionary whose keys are the result of evaluating aBlock for all my elements, and the value for each key is the selection of my elements that evaluated to that key. Uses species.\r\t\r\tExample of use:\r\t(#(1 2 3 4 5) groupedBy: [ :v | v odd ]) asString >>> 'an OrderedDictionary(true->#(1 3 5) false->#(2 4))'\r\t\"\r\t\r\t\r\t\r\t| groups |\r\tgroups := OrderedDictionary new.\r\tself do: [ :each |\r\t\t(groups at: (aBlock value: each) ifAbsentPut: [ OrderedCollection new ]) add: each ].\r\tself species ~~ OrderedCollection ifTrue: [\r\t\tgroups associationsDo: [ :association |\r\t\t\tassociation value: (self species withAll: association value) ]].\r\t^ groups\r"},{"name":"ifEmpty:ifNotEmpty:","linesOfCode":6,"sourceCode":"ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock\r\t\"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise\"\r\t\"If the notEmptyBlock has an argument, eval with the receiver as its argument\"\r\r\t^ self isEmpty\r\t\tifTrue: [ emptyBlock value ]\r\t\tifFalse: [ notEmptyBlock cull: self ]"},{"name":"spotterItemsFor:","linesOfCode":14,"sourceCode":"spotterItemsFor: aStep\r\t<spotterOrder: 10>\r\t| processor |\r\t(self isEmpty or: [ self size > self gtCollectionSizeThreshold ]) ifTrue: [ ^ self ].\r\tprocessor := aStep previousProcessorFrom: self.\r\t^ aStep listProcessor\r\t\ttitle: processor title;\r\t\tcandidatesLimit: 100;\r\t\titems: [ self collect: [ :each | each asSpotterCandidateLink value] as: OrderedCollection ];\r\t\titemName: processor itemName;\r\t\titemIcon: processor itemIcon;\r\t\tactLogic: processor actLogic; \r\t\tfilter: processor filter gtListFilter;\r\t\twantsToDisplayOnEmptyQuery: true"},{"name":"select:thenDo:","linesOfCode":7,"sourceCode":"select: selectBlock thenDo: doBlock\r    \"Utility method to improve readability.\r\tDo not create the intermediate collection.\"\r\r    self do: [: each |\r        ( selectBlock value: each ) \r\t\t\tifTrue: [ doBlock value: each ]\r    ]."},{"name":"selectEverySecond","linesOfCode":5,"sourceCode":"selectEverySecond\r\t\"#(1 2 3 4) selectEverySecond asArray \r\t>>> #(2 4)\r\t\"\r\t^ self selectEvery: [ :i | i \\\\ 2 = 0 ]"},{"name":"asGPoint","linesOfCode":2,"sourceCode":"asGPoint\r\t^ GPoint withCollection: self"},{"name":"degreeSin","linesOfCode":2,"sourceCode":"degreeSin\r\t^self collect: [:each | each degreeSin]"},{"name":"isEmptyOrNil","linesOfCode":3,"sourceCode":"isEmptyOrNil\r\t\"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil\"\r\r\t^ self isEmpty"},{"name":"maxValue:","linesOfCode":2,"sourceCode":"maxValue: aBlock\r\t^ self inject: (aBlock value: self anyOne) into: [ :max :each | max max: (aBlock value: each) ]"},{"name":"atRandom:","linesOfCode":9,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver. Uses aGenerator which\rshould be kept by the user in a variable and used every time. Use\rthis instead of #atRandom for better uniformity of random numbers because \r\tonly you use the generator. Causes an error if self has no elements.\"\r\t| rand |\r\r\tself emptyCheck.\r\trand := aGenerator nextInteger: self size.\r\tself withIndexDo: [:each :index | index = rand ifTrue: [^each]]"},{"name":"identityIncludes:","linesOfCode":4,"sourceCode":"identityIncludes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\tself do: [:each | anObject == each ifTrue: [^true]].\r\t^false"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeList: self"},{"name":"asWBTVarSubstitution","linesOfCode":8,"sourceCode":"asWBTVarSubstitution\r\tself ifEmpty: [ ^ '' ].\r\t\r\t^ ByteString streamContents: [ :out |\r\t\tself doWithIndex: [ :each :index |\r\t\t\tindex > 1 ifTrue: [ out space ].\r\t\t\tout nextPutAll: each asWBTVarSubstitution\r\t\t]\r\t]"},{"name":"copyWithDependent:","linesOfCode":4,"sourceCode":"copyWithDependent: newElement\r\t\"Answer a new collection with newElement added (as last\r\telement if sequenceable).\"\r\t^self copyWith: newElement"},{"name":"withIndexDo:","linesOfCode":6,"sourceCode":"withIndexDo: elementAndIndexBlock\r\t\"Just like do: except that the iteration index supplies the second argument to the block\"\r\t\"Support collection enumeration with a counter, even though not ordered\"\r\t| index |\r\tindex := 0.\r\tself do: [:item | elementAndIndexBlock value: item value: (index := index+1)]"},{"name":"addAssignToFloatArray:","linesOfCode":3,"sourceCode":"addAssignToFloatArray: aFloatArray\r\t1 to: aFloatArray size do: [ :i | aFloatArray at: i put: (aFloatArray at: i) + (self at: i) ].\r\t^ aFloatArray"},{"name":"truncated","linesOfCode":2,"sourceCode":"truncated\r\t^ self collect: [:a | a truncated]"},{"name":"setImportInVersionSpec:","linesOfCode":2,"sourceCode":"setImportInVersionSpec: aMetacelloVersionSpec\r  aMetacelloVersionSpec setImport: self asArray"},{"name":"asByteArray","linesOfCode":10,"sourceCode":"asByteArray\r\t\"Answer a ByteArray whose elements are the elements of the receiver.\r\tImplementation note: Cannot use ''ByteArray withAll: self'' as that only\r\tworks for SequenceableCollections which support the replacement \r\tprimitive.\"\r\r\t| array index |\r\tarray := ByteArray new: self size.\r\tindex := 0.\r\tself do: [:each | array at: (index := index + 1) put: each].\r\t^ array"},{"name":"write:","linesOfCode":6,"sourceCode":"write: anObject\r\r\tself\r\t\tdeprecated: 'Please use #add: instead'\r\t\ttransformWith: '`@receiver write: `@statements1' \r\t\t\t\t\t\t-> '`@receiver add: `@statements1'.\r\t^ self add: anObject"},{"name":"add:withOccurrences:","linesOfCode":4,"sourceCode":"add: newObject withOccurrences: anInteger\r\t\"Add newObject anInteger times to the receiver. Answer newObject.\"\r\r\tanInteger timesRepeat: [self add: newObject].\r\t^ newObject"},{"name":"contains:","linesOfCode":3,"sourceCode":"contains: aBlock\r\t\"For compatibility, please use #anySatisfy: instead!\"\r\t^self anySatisfy: aBlock"},{"name":"*","linesOfCode":2,"sourceCode":"* arg\r\r\t^ arg adaptToCollection: self andSend: #*"},{"name":"log","linesOfCode":2,"sourceCode":"log\r\t^ self collect: [:each | each log]"},{"name":"setForDo:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: self do: aBlock"},{"name":"asEmailHeaderString","linesOfCode":5,"sourceCode":"asEmailHeaderString\r\r\t^ String streamContents: [ :str | \r\t\t\tself\r\t\t\t\tdo: [ :e | str nextPutAll: e asEmailHeaderString ]\r\t\t\t\tseparatedBy: [ str nextPutAll: ', ' ] ]"},{"name":"gtDisplayOn:","linesOfCode":11,"sourceCode":"gtDisplayOn: stream\r\tself printNameOn: stream.\r\tstream\r\t\tspace;\r\t\tnextPut: $[;\r\t\tprint: self size;\r\t\tnextPutAll: (' item' asPluralBasedOn: self size);\r\t\tnextPut: $];\r\t\tspace.\r\tself size <= self gtCollectionSizeThreshold \r\t\tifTrue: [ self printElementsOn: stream ]"},{"name":"adaptToPoint:andSend:","linesOfCode":4,"sourceCode":"adaptToPoint: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a scalar, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t^ self collect: [:element | rcvr perform: selector with: element]"},{"name":"sorted:","linesOfCode":6,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\r\t^self asArray sort: aSortBlockOrNil"},{"name":"groupedBy:having:","linesOfCode":5,"sourceCode":"groupedBy: aBlock having: aSelectionBlock\r\t\"Like in SQL operation - Split the recievers contents into collections of \r\telements for which keyBlock returns the same results, and return those \r\tcollections allowed by selectBlock.\"\r\t^ (self groupedBy: aBlock) select: aSelectionBlock\r"},{"name":"hash","linesOfCode":9,"sourceCode":"hash\r\t\"Answer an integer hash value for the receiver such that,\r\t  -- the hash value of an unchanged object is constant over time, and\r\t  -- two equal objects have equal hash values\"\r\r\t| hash |\r\r\thash := self species hash.\r\tself size <= 10 ifTrue:\r\t\t[self do: [:elem | hash := hash bitXor: elem hash]].\r\t^hash bitXor: self size hash"},{"name":"reciprocal","linesOfCode":4,"sourceCode":"reciprocal\r\t\"Return the reciever full of reciprocated elements\"\r\t\"#(1 11 0.5) reciprocal >>> {1 . 1/11 . 2.0}\"\r\t^ self collect: [:a | a reciprocal]"},{"name":"mergeIntoMetacelloRepositories:","linesOfCode":2,"sourceCode":"mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"detect:","linesOfCode":5,"sourceCode":"detect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the first element for which aBlock evaluates to true.\"\r\t\"(#(1 2 3 4) detect: [ :each | each even ]) >>> 2\"\r\r\t^ self detect: aBlock ifNone: [self errorNotFound: aBlock]"},{"name":"isSequenceable","linesOfCode":2,"sourceCode":"isSequenceable\r\t^ false"},{"name":"errorNotFound:","linesOfCode":3,"sourceCode":"errorNotFound: anObject\r\t\"Raise a NotFound exception.\"\r\r\tNotFound signalFor: anObject"},{"name":"average","linesOfCode":7,"sourceCode":"average\r\t\"Calculate the average of a collection, return a CollectionIsEmpty exception if the collection is empty. Look averageIfEmpty: aBlock\"\r\t\r\t\" #(2 6 7) average   \r\t>>> 5 \"\r\t\r\t\" #(3 5 7 7) average \r\t>>> (11/2) \"\r\r\t^ self sum / self size"},{"name":"+","linesOfCode":2,"sourceCode":"+ arg\r\r\t^ arg adaptToCollection: self andSend: #+"},{"name":"abs","linesOfCode":3,"sourceCode":"abs\r\t\"Absolute value of all elements in the collection\"\r\t^ self collect: [:a | a abs]"},{"name":"includesSubstringAnywhere:","linesOfCode":12,"sourceCode":"includesSubstringAnywhere: testString\r\t\"Answer whether the receiver includes, anywhere in its nested structure, a string that has testString as a substring\"\r\tself do:\r\t\t[:element |\r\t\t\t(element isString)\r\t\t\t\tifTrue:\r\t\t\t\t\t[(element includesSubstring: testString) ifTrue: [^ true]].\r\t\t\t(element isCollection)\r\t\t\t\tifTrue:\r\t\t\t\t\t[(element includesSubstringAnywhere: testString) ifTrue: [^ true]]].\r\t^ false\r\r\"#(first (second third) ((allSentMessages ('Elvis' includes:)))) includesSubstringAnywhere:  'lvi'\""},{"name":"\\","linesOfCode":4,"sourceCode":"\\ aCollection\r\t\"Return all the elements in self that are not in aCollection\"\r\t\"'abc' \\ 'cbe' >>> 'a'.\"\r\t\r\t^ self difference: aCollection"},{"name":"setForVersion:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForVersion: aString withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: self version: aString"},{"name":"asMetacelloAttributeList","linesOfCode":2,"sourceCode":"asMetacelloAttributeList\r    ^ self"},{"name":"detectMax:","linesOfCode":17,"sourceCode":"detectMax: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the element for which aBlock evaluates to the highest magnitude.\r\tIf collection empty, return nil.  This method might also be called elect:.\"\r\r\t| maxElement maxValue |\r\tself do: [:each | | val | \r\t\tmaxValue == nil\r\t\t\tifFalse: [\r\t\t\t\t(val := aBlock value: each) > maxValue ifTrue: [\r\t\t\t\t\tmaxElement := each.\r\t\t\t\t\tmaxValue := val]]\r\t\t\tifTrue: [\"first element\"\r\t\t\t\tmaxElement := each.\r\t\t\t\tmaxValue := aBlock value: each].\r\t\t\t\t\"Note that there is no way to get the first element that works \r\t\t\t\tfor all kinds of Collections.  Must test every one.\"].\r\t^ maxElement"},{"name":"median","linesOfCode":8,"sourceCode":"median\r\t\"Return the middle element, or as close as we can get.\r\t\r\tExample of use:\r\t{1 . 2 . 3 . 4 . 5} median >>> 3\r\t{1 . 2 . 4 . 5} median >>> 3\r\t{1 . 2 . 5 . 5} median >>> (7/2)\r\t\"\r\t\r\t^ self asSortedCollection median"},{"name":"--","linesOfCode":2,"sourceCode":"-- other\r\t^ self , other"},{"name":"setLoadsInMetacelloProject:","linesOfCode":2,"sourceCode":"setLoadsInMetacelloProject: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setLoads: self asArray."},{"name":"includesAnyOf:","linesOfCode":3,"sourceCode":"includesAnyOf: aCollection \r\t\r\tself flag: 'use includesAny: instead'.\r\t\r\t^ self includesAny: aCollection.\r\t"},{"name":"asIdentitySet","linesOfCode":2,"sourceCode":"asIdentitySet\r\t^(IdentitySet new: self size) addAll: self; yourself"}],"meta":{"name":"Collection class","instanceVariables":[],"methods":[{"name":"with:with:with:with:with:with:","linesOfCode":10,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject\r\t\"Answer an instance of me, containing the six arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tadd: fifthObject;\r\t\tadd: sixthObject;\r\t\tyourself"},{"name":"with:with:with:with:","linesOfCode":8,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject \r\t\"Answer an instance of me, containing the four arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tyourself"},{"name":"fromSton:","linesOfCode":9,"sourceCode":"fromSton: stonReader\r\t\"For collections we chose to instanciate based a list of elements using #add:\r\tThis is not the best or most correct solution for all subclasses though,\r\tso some will revert to standard object behavior or chose another solution.\"\r\t\r\t| collection |\r\tcollection := self new.\r\tstonReader parseListDo: [ :each |\r\t\tcollection add: each ].\r\t^ collection"},{"name":"systemIconName","linesOfCode":2,"sourceCode":"systemIconName\r\r\t^ #collectionIcon"},{"name":"with:","linesOfCode":5,"sourceCode":"with: anObject \r\t\"Answer an instance of me containing anObject.\"\r\r\t^ self empty\r\t\tadd: anObject;\r\t\tyourself"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #Collection"},{"name":"with:with:with:with:with:","linesOfCode":9,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject\r\t\"Answer an instance of me, containing the five arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tadd: fifthObject;\r\t\tyourself"},{"name":"with:with:with:","linesOfCode":7,"sourceCode":"with: firstObject with: secondObject with: thirdObject \r\t\"Answer an instance of me containing the three arguments as elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tyourself"},{"name":"with:with:","linesOfCode":6,"sourceCode":"with: firstObject with: secondObject \r\t\"Answer an instance of me containing the two arguments as elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tyourself"},{"name":"canonicalArgumentName","linesOfCode":2,"sourceCode":"canonicalArgumentName\r\r\t^ 'aCollection'."},{"name":"approvedSelectorsForMethodFinder","linesOfCode":2,"sourceCode":"approvedSelectorsForMethodFinder\r\r\t ^ self selectors"},{"name":"withAll:","linesOfCode":5,"sourceCode":"withAll: aCollection\r\t\"Create a new collection containing all the elements from aCollection.\"\r\r\t^ (self new: aCollection size)\r\t\taddAll: aCollection;\r\t\tyourself"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ self new"}],"meta":null}},{"name":"ManifestCollectionsArithmetic","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsArithmetic class","instanceVariables":[],"methods":[{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Native' #'Collections-Unordered' #'Collections-Sequenceable' #Kernel #'Collections-Abstract')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Arithmetic'"}],"meta":null}}]},{"name":"Collections-Streams","classes":[{"name":"Stream","instanceVariables":[],"methods":[{"name":"write:","linesOfCode":7,"sourceCode":"write: anObject\r\r\tself\r\t\tdeprecated: 'Please use #putOn: on the argument instead'\r\t\ttransformWith: '`@receiver write: `@statements1' \r\t\t\t\t\t\t-> '`@statements1 putOn: `@receiver' .\r\tanObject putOn: self.\t\t\r\t^ anObject.\r\t"},{"name":"flush","linesOfCode":2,"sourceCode":"flush\r\t\"Do nothing by default\" "},{"name":"next:","linesOfCode":6,"sourceCode":"next: anInteger \r\t\"Answer the next anInteger number of objects accessible by the receiver.\"\r\t\r\t| aCollection |\r\taCollection := OrderedCollection new.\r\tanInteger timesRepeat: [aCollection addLast: self next].\r\t^aCollection"},{"name":"next","linesOfCode":3,"sourceCode":"next\r\t\"Answer the next object accessible by the receiver.\"\r\r\tself subclassResponsibility "},{"name":"localName","linesOfCode":2,"sourceCode":"localName\r\t^'a stream'"},{"name":"next:put:","linesOfCode":6,"sourceCode":"next: anInteger put: anObject \r\t<compilerOptions: #(+ optionInlineTimesRepeat)>\r\t\r\t\"Make anObject be the next anInteger number of objects accessible by the \r\treceiver. Answer anObject.\"\r\t\r\tanInteger timesRepeat: [ self nextPut: anObject ].\r\t^ anObject"},{"name":"closed","linesOfCode":2,"sourceCode":"closed\r\t^ false"},{"name":"basicNextPutAll:","linesOfCode":2,"sourceCode":"basicNextPutAll: aCollection \r\r\t^ self nextPutAll: aCollection.\r"},{"name":"print:","linesOfCode":3,"sourceCode":"print: anObject\r\t\"Have anObject print itself on the receiver.\"\r\r\tanObject printOn: self"},{"name":"nextPutAll:","linesOfCode":5,"sourceCode":"nextPutAll: aCollection \r\t\"Append the elements of aCollection to the sequence of objects accessible \r\tby the receiver. Answer aCollection.\"\r\t\r\taCollection do: [:v | self nextPut: v].\r\t^aCollection"},{"name":"atEnd","linesOfCode":3,"sourceCode":"atEnd\r\t\"Answer whether the receiver can access any more objects.\"\r\r\tself subclassResponsibility "},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock \r\t\"Evaluate aBlock for each of the objects accessible by receiver.\"\r\r\t[self atEnd]\r\t\twhileFalse: [aBlock value: self next]"},{"name":"openReadOnly","linesOfCode":2,"sourceCode":"openReadOnly\r\t^self"},{"name":"asPetit2Stream","linesOfCode":4,"sourceCode":"asPetit2Stream\r\t^ PP2BufferStream \r\t\ton: self \r\t\tbufferSize: 4*1024"},{"name":"nextMatchFor:","linesOfCode":4,"sourceCode":"nextMatchFor: anObject \r\t\"Gobble the next object and answer whether it is equal to the argument, \r\tanObject.\"\r\r\t^anObject = self next"},{"name":"nextPut:","linesOfCode":4,"sourceCode":"nextPut: anObject \r\t\"Insert the argument, anObject, as the next object accessible by the \r\treceiver. Answer anObject.\"\r\t\r\tself subclassResponsibility "},{"name":"isBinary","linesOfCode":2,"sourceCode":"isBinary\r\t^false"},{"name":"close","linesOfCode":4,"sourceCode":"close\r\t\"Presumably sets the status of the receiver to be closed. This message does \r\tnothing at this level, but is included for FileStream compatibility.\"\r\r\t^self "},{"name":"<<","linesOfCode":7,"sourceCode":"<< anObject\r\t\"Write anObject to the receiver, dispatching using #putOn:\r\tThis is a shortcut for both nextPut: and nextPutAll: since anObject can be both\r\tthe element type of the receiver as well as a collection of those elements.\r\tNo further conversions of anObject are applied.\r\tReturn self to accomodate chaining.\"\r\r \tanObject putOn: self"},{"name":"basicNext","linesOfCode":2,"sourceCode":"basicNext\r\r\t^ self next.\r"},{"name":"readOnly","linesOfCode":3,"sourceCode":"readOnly\r\t\"do nothing\"\r\t^self"},{"name":"contents","linesOfCode":3,"sourceCode":"contents\r\t\"Answer all of the contents of the receiver.\"\r\r\tself subclassResponsibility"},{"name":"binary","linesOfCode":3,"sourceCode":"binary\r\t\"do nothing\"\r\t^self "},{"name":"asPetitStream","linesOfCode":2,"sourceCode":"asPetitStream\r\t^ self contents asPetitStream"},{"name":"basicNextPut:","linesOfCode":2,"sourceCode":"basicNextPut: anObject \r\r\t^ self nextPut: anObject"},{"name":"isStream","linesOfCode":3,"sourceCode":"isStream\r\t\"Return true if the receiver responds to the stream protocol\"\r\t^true"},{"name":"asPetit2Context","linesOfCode":2,"sourceCode":"asPetit2Context\r\t^ self asPetit2Stream asPetit2Context "},{"name":"nextBytesPutAll:","linesOfCode":4,"sourceCode":"nextBytesPutAll: aCollection\r\t\"Append the bytes of aCollection to the sequence of bytes accessible \r\tby the receiver. Answer aCollection.\"\r\r\t^self nextPutAll: aCollection"},{"name":"closureDescriptionForCaching","linesOfCode":2,"sourceCode":"closureDescriptionForCaching\r\t^ 'st ' , (SHA256 hashStream: self) hex"},{"name":"basicNext:putAll:startingAt:","linesOfCode":2,"sourceCode":"basicNext: anAmount putAll: aCollection startingAt: startIndex\r\r\t^ self next: anAmount putAll: aCollection startingAt: startIndex.\r"},{"name":"nextWordsPutAll:","linesOfCode":8,"sourceCode":"nextWordsPutAll: aCollection\r\t\"Write the argument a word-like object in big endian format on the receiver.\r\tMay be used to write other than plain word-like objects (such as ColorArray).\"\r\t\r\t(aCollection class isPointers or: [ aCollection class isWords not ])\r\t\tifTrue: [ ^ self error: aCollection class name,' is not word-like'].\r\t1 to: aCollection basicSize do: [ :i |\r\t\tself nextNumber: 4 put: (aCollection basicAt: i) ].\r\t^ aCollection"},{"name":"next:putAll:startingAt:","linesOfCode":5,"sourceCode":"next: anInteger putAll: aCollection startingAt: startIndex\r\t\"Store the next anInteger elements from the given collection.\"\r\t(startIndex = 1 and:[anInteger = aCollection size])\r\t\tifTrue:[^self nextPutAll: aCollection].\r\t^self nextPutAll: (aCollection copyFrom: startIndex to: startIndex+anInteger-1)"},{"name":"upToEnd","linesOfCode":7,"sourceCode":"upToEnd\r\t\"answer the remaining elements in the string\"\r\t| elements |\r\telements := OrderedCollection new.\r\t[ self atEnd ] whileFalse: [ \r\t\telements add: self next ].\r\t^elements"},{"name":"nextMatchAll:","linesOfCode":11,"sourceCode":"nextMatchAll: aColl\r    \"Answer true if next N objects are the ones in aColl,\r     else false.  Advance stream of true, leave as was if false.\"\r    | save |\r    save := self position.\r    aColl do: [:each |\r       (self next) = each ifFalse: [\r            self position: save.\r            ^ false]\r        ].\r    ^ true"}],"meta":{"name":"Stream class","instanceVariables":[],"methods":[{"name":"new","linesOfCode":2,"sourceCode":"new\r\r\tself error: 'Streams are created with on: and with:'"}],"meta":null}},{"name":"DecoratorStream","instanceVariables":[{"name":"decoratedStream"}],"methods":[{"name":"nextPut:","linesOfCode":5,"sourceCode":"nextPut: anObject \r\t\"Insert the argument, anObject, as the next object accessible by the \r\treceiver. Answer anObject.\"\r\t\r\tdecoratedStream nextPut: anObject.\r\t^anObject "},{"name":"position","linesOfCode":2,"sourceCode":"position\r\t\r\t^ decoratedStream position"},{"name":"atEnd","linesOfCode":2,"sourceCode":"atEnd\r\t^ decoratedStream atEnd"},{"name":"on:","linesOfCode":3,"sourceCode":"on: aStream\r\r\tself initialize.\r\tdecoratedStream := aStream."},{"name":"contents","linesOfCode":3,"sourceCode":"contents\r\t\"Answer all of the contents of the receiver.\"\r\r\t^decoratedStream contents"},{"name":"next","linesOfCode":2,"sourceCode":"next\r\r\t^ decoratedStream next"},{"name":"peek","linesOfCode":2,"sourceCode":"peek\r\r\t^ decoratedStream peek"},{"name":"store:","linesOfCode":2,"sourceCode":"store: anObject\r\r\tanObject storeOn: self"}],"meta":{"name":"DecoratorStream class","instanceVariables":[],"methods":[{"name":"on:","linesOfCode":4,"sourceCode":"on: aStream\r\r\t^ self basicNew\r\t\ton: aStream;\r\t\tyourself."}],"meta":null}},{"name":"WriteStream","instanceVariables":[{"name":"writeLimit"}],"methods":[{"name":"lf","linesOfCode":3,"sourceCode":"lf\r\t\"Append a line feed character to the receiver.\"\r\r\tself nextPut: Character lf"},{"name":"resetToStart","linesOfCode":2,"sourceCode":"resetToStart\r\treadLimit := position := 0."},{"name":"growTo:","linesOfCode":7,"sourceCode":"growTo: anInteger\r \r    \" anInteger is the required minimal new size of the collection \"\r \t| oldSize length |\r \toldSize := collection size.\r      length := anInteger + (oldSize // 4 max: 20) - oldSize.\r \tcollection := collection grownBy: length.\r \twriteLimit := collection size.\r "},{"name":"cr","linesOfCode":3,"sourceCode":"cr\r\t\"Append a return character to the receiver.\"\r\r\tself nextPut: Character cr"},{"name":"tab:","linesOfCode":3,"sourceCode":"tab: anInteger \r\t\"Append anInteger tab characters to the receiver.\"\r\t\r\tself next: anInteger put: Character tab"},{"name":"space:","linesOfCode":3,"sourceCode":"space: anInteger \r\t\"Append anInteger space characters to the receiver.\"\r\t\r\tself next: anInteger put: Character space\r\t"},{"name":"on:","linesOfCode":4,"sourceCode":"on: aCollection\r\r\tsuper on: aCollection.\r\treadLimit := 0.\r\twriteLimit := aCollection size"},{"name":"peekLast","linesOfCode":5,"sourceCode":"peekLast\r\t\"Return that item just put at the end of the stream\"\r\r\t^ position > 0 \r\t\tifTrue: [collection at: position]\r\t\tifFalse: [nil]"},{"name":"position:","linesOfCode":4,"sourceCode":"position: anInteger \r\t\"Refer to the comment in PositionableStream|position:.\"\r\r\treadLimit := readLimit max: position.\r\tsuper position: anInteger"},{"name":"next","linesOfCode":2,"sourceCode":"next\r\r\tself shouldNotImplement"},{"name":"withAttributes:do:","linesOfCode":3,"sourceCode":"withAttributes: attributes do: strmBlock \r\t\"No-op here is overriden in TextStream for font emphasis\"\r\t^ strmBlock value"},{"name":"nextPutAll:","linesOfCode":10,"sourceCode":"nextPutAll: aCollection\r \r \t| newEnd |\r \tcollection class == aCollection class ifFalse:\r \t\t[^ super nextPutAll: aCollection ].\r \r \tnewEnd := position + aCollection size.\r \tnewEnd > writeLimit ifTrue:\r \t\t[self growTo: newEnd + 10].\r \r \tcollection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.\r \tposition := newEnd.\r\t\r\t^ aCollection"},{"name":"with:from:to:","linesOfCode":2,"sourceCode":"with: aCollection from: firstIndex to: lastIndex\r\tself with: (aCollection copyFrom: firstIndex to: lastIndex)"},{"name":"on:from:to:","linesOfCode":10,"sourceCode":"on: aCollection from: firstIndex to: lastIndex\r\r\t| len |\r\tcollection := aCollection.\r\treadLimit := \r\t\twriteLimit := lastIndex > (len := collection size)\r\t\t\t\t\t\tifTrue: [len]\r\t\t\t\t\t\tifFalse: [lastIndex].\r\tposition := firstIndex <= 1\r\t\t\t\tifTrue: [0]\r\t\t\t\tifFalse: [firstIndex - 1]"},{"name":"ensureASpace","linesOfCode":4,"sourceCode":"ensureASpace\r\t\"Append a space character to the receiver IFF there is not one on the end.\"\r\r\t(position > 0 and: [(collection at: position) = Character space]) ifTrue: [^self].\r\tself nextPut: Character space"},{"name":"crtab","linesOfCode":4,"sourceCode":"crtab\r\t\"Append a return character, followed by a single tab character, to the \r\treceiver.\"\r\r\tself cr; tab"},{"name":"nextPut:","linesOfCode":11,"sourceCode":"nextPut: anObject\r\t\"Primitive. Insert the argument at the next position in the Stream\r\trepresented by the receiver. Fail if the collection of this stream is not an\r\tArray or a String. Fail if the stream is positioned at its end, or if the\r\tposition is out of bounds in the collection. Fail if the argument is not\r\tof the right type for the collection. Optional. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t^ position >= writeLimit\r\t\tifTrue: [ self pastEndPut: anObject ]\r\t\tifFalse: [ position := position + 1.\r\t\t\tcollection at: position put: anObject ]"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\r\t^readLimit := readLimit max: position"},{"name":"ensureEndsWith:","linesOfCode":4,"sourceCode":"ensureEndsWith: anObject\r\t\"Append anObject to the receiver IFF it is non-empty and there is not one on the end.\"\r\r\t(position == 0 or: [(collection at: position) = anObject]) ifTrue: [^self].\r\tself nextPut: anObject"},{"name":"nextChunkPut:","linesOfCode":13,"sourceCode":"nextChunkPut: aString\r\t\"Append the argument, aString, to the receiver, doubling embedded ! terminators and adding a extra one\"\r \r\t| string start bangIndex |\r\tstring := aString asString.\r\tstart := 1.\r\t[ (bangIndex := string indexOf: $! startingAt: start) = 0 ]\r\t\twhileFalse: [\r\t\t\tself next: bangIndex - start + 1 putAll: string startingAt: start.\r\t\t\tself nextPut: $!. \"double it\"\r\t\t\tstart := bangIndex + 1 ].\r\tself next: string size - start + 1 putAll: string startingAt: start.\r\tself nextPut: $!. \"one extra\"\r\tself flush"},{"name":"ensureNoSpace","linesOfCode":6,"sourceCode":"ensureNoSpace\r\t\"If there is not one on the end, remove it.\"\r\t| space |\r\t\r\tspace := Character space.\r\t\r\t[ position > 0 and: [(collection at: position) = space ]]\r\t\twhileTrue: [ self skip: -1 ]"},{"name":"<<","linesOfCode":10,"sourceCode":"<< anObject\r\t\"Write anObject to the receiver, dispatching using #putOn:\r\tThis is a shortcut for both nextPut: and nextPutAll: since anObject can be both\r\tthe element type of the receiver as well as a collection of those elements.\r\tNo further conversions of anObject are applied.\r\tThis is an optimisation.\r\tReturn self to accomodate chaining.\"\r\r \tanObject class == collection class\r\t\tifTrue: [ self nextPutAll: anObject ]\r\t\tifFalse: [ anObject putOn: self ]"},{"name":"reset","linesOfCode":4,"sourceCode":"reset \r\t\"Refer to the comment in PositionableStream|reset.\"\r\r\treadLimit := readLimit max: position.\r\tposition := 0"},{"name":"tab","linesOfCode":3,"sourceCode":"tab\r\t\"Append a tab character to the receiver.\"\r\r\tself nextPut: Character tab"},{"name":"contents","linesOfCode":3,"sourceCode":"contents\r\r\treadLimit := readLimit max: position.\r\t^collection copyFrom: 1 to: position"},{"name":"with:","linesOfCode":3,"sourceCode":"with: aCollection\r\r\tsuper on: aCollection.\r\tposition := readLimit := writeLimit := aCollection size"},{"name":"store:","linesOfCode":3,"sourceCode":"store: anObject \r\t\"Have anObject print on the receiver for purposes of rereading.\"\r\r\tanObject storeOn: self"},{"name":"withAttribute:do:","linesOfCode":3,"sourceCode":"withAttribute: att do: strmBlock \r\t\"No-op here is overriden in TextStream for font emphasis\"\r\t^ strmBlock value"},{"name":"braceArray:","linesOfCode":7,"sourceCode":"braceArray: anArray\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\tcollection := anArray.\r\tposition := 0.\r\treadLimit := 0.\r\twriteLimit := anArray size."},{"name":"braceArray","linesOfCode":4,"sourceCode":"braceArray\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t^ collection"},{"name":"setToEnd","linesOfCode":4,"sourceCode":"setToEnd \r\t\"Refer to the comment in PositionableStream|setToEnd.\"\r\r\treadLimit := readLimit max: position.\r\tsuper setToEnd."},{"name":"space","linesOfCode":3,"sourceCode":"space\r\t\"Append a space character to the receiver.\"\r\r\tself nextPut: Character space"},{"name":"nextBytesPutAll:","linesOfCode":12,"sourceCode":"nextBytesPutAll: aCollection\r\t\"Append the bytes of aCollection to the sequence of bytes accessible \r\tby the receiver. Answer aCollection.\"\r \r \t| newEnd |\r \tcollection class instSpec == aCollection class instSpec ifFalse:\r \t\t[^ super nextPutAll: aCollection ].\r \r \tnewEnd := position + aCollection size.\r \tnewEnd > writeLimit ifTrue:\r \t\t[self growTo: newEnd + 10].\r \r \tcollection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.\r \tposition := newEnd.\r\t\r\t^ aCollection"},{"name":"pastEndPut:","linesOfCode":7,"sourceCode":"pastEndPut: anObject\r\t\"Grow the collection by doubling the size, but keeping the growth between 20 and 1000000.\r\tThen put <anObject> at the current write position.\"\r\r\tcollection := collection grownBy: ((collection size max: 20) min: 1000000).\r\twriteLimit := collection size.\r\tcollection at: (position := position + 1) put: anObject.\r\t^ anObject"},{"name":"crlf","linesOfCode":3,"sourceCode":"crlf\r\t\"Append a line feed character to the receiver.\"\r\r\tself cr; lf"},{"name":"ensureCr","linesOfCode":3,"sourceCode":"ensureCr\r\t\"Append a cr character to the receiver IFF there is not one on the end.\"\r\r\tself ensureEndsWith: Character cr"},{"name":"timeStamp","linesOfCode":5,"sourceCode":"timeStamp\r\t\"Append the current time to the receiver as a String.\"\r\tself nextChunkPut:\t\"double string quotes and !s\"\r\t\t(String streamContents: [:s | Smalltalk timeStamp: s]) printString.\r\tself cr"},{"name":"next:putAll:startingAt:","linesOfCode":11,"sourceCode":"next: anInteger putAll: aCollection startingAt: startIndex\r\t\"Store the next anInteger elements from the given collection.\"\r\r\t| newEnd numPut |\r\tcollection class == aCollection class ifFalse:\r\t\t[^ super next: anInteger putAll: aCollection startingAt: startIndex ].\r\r\tnumPut := anInteger min: (aCollection size - startIndex + 1).\r\tnewEnd := position + numPut.\r\tnewEnd > writeLimit ifTrue:\r\t\t[^ super next: anInteger putAll: aCollection startingAt: startIndex \"Trigger normal pastEndPut: logic\"].\r\r\tcollection replaceFrom: position+1 to: newEnd with: aCollection startingAt: startIndex.\r\tposition := newEnd.\r"},{"name":"crtab:","linesOfCode":4,"sourceCode":"crtab: anInteger \r\t\"Append a return character, followed by anInteger tab characters, to the \r\treceiver.\"\r\r\tself cr; tab: anInteger"}],"meta":{"name":"WriteStream class","instanceVariables":[],"methods":[{"name":"with:","linesOfCode":4,"sourceCode":"with: aCollection \r\t\"Answer an instance of me on the argument, aCollection, positioned to \r\tstore objects at the end of aCollection.\"\r\r\t^self basicNew with: aCollection"},{"name":"with:from:to:","linesOfCode":8,"sourceCode":"with: aCollection from: firstIndex to: lastIndex \r\t\"Answer an instance of me on the subcollection of the argument, \r\taCollection, determined by the indices firstIndex and lastIndex. Position \r\tthe instance to store at the end of the subcollection.\"\r\r\t^self basicNew\r\t\twith: aCollection\r\t\tfrom: firstIndex\r\t\tto: lastIndex "}],"meta":null}},{"name":"LimitedWriteStream","instanceVariables":[{"name":"limit"},{"name":"limitBlock"}],"methods":[{"name":"nextPut:","linesOfCode":6,"sourceCode":"nextPut: anObject\r\t\"Ensure that the limit is not exceeded\"\r\r\tposition >= limit\r\t\tifTrue: [ limitBlock value ]\r\t\tifFalse: [ super nextPut: anObject ].\r\t^ anObject"},{"name":"limit","linesOfCode":2,"sourceCode":"limit\r\t^ limit"},{"name":"limit:","linesOfCode":6,"sourceCode":"limit: anInteger\r\tlimit := anInteger.\r\r\tposition > limit\r\t\tifTrue: [\r\t\t\tposition := limit.\r\t\t\tlimitBlock value ]"},{"name":"nextPutAll:","linesOfCode":16,"sourceCode":"nextPutAll: aCollection\r\r\t| newEnd |\r\tcollection class == aCollection class \r\t\tifFalse: [ ^ super nextPutAll: aCollection ].\r\r\tnewEnd := position + aCollection size.\r\tnewEnd > limit ifTrue: [\r\t\tsuper nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).\r\t\tlimitBlock value.\r\t\t^ aCollection\r\t].\r\tnewEnd > writeLimit ifTrue: [\r\t\tself growTo: newEnd + 10\r\t].\r\r\tcollection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.\r\tposition := newEnd.\r\t\r\t^ aCollection"},{"name":"pastEndPut:","linesOfCode":3,"sourceCode":"pastEndPut: anObject\r\tcollection size >= limit ifTrue: [limitBlock value].  \"Exceptional return\"\r\t^ super pastEndPut: anObject"},{"name":"setLimit:limitBlock:","linesOfCode":10,"sourceCode":"setLimit: anInteger limitBlock: aBlock\r\t\"Limit the numer of elements this stream will write...\"\r\tlimit := anInteger.\r\r\t\"Execute this (typically ^ contents) when that limit is exceded\"\r\tlimitBlock := aBlock.\r\r\t\"To support legacy users, this test must be here too\"\r\tposition > limit\r\t\tifTrue: [\r\t\t\tposition := limit.\r\t\t\tlimitBlock value ]"},{"name":"limitBlock","linesOfCode":2,"sourceCode":"limitBlock\r\t^ limitBlock"},{"name":"limitBlock:","linesOfCode":2,"sourceCode":"limitBlock: aBlock\r\tlimitBlock := aBlock"}],"meta":{"name":"LimitedWriteStream class","instanceVariables":[],"methods":[{"name":"on:","linesOfCode":4,"sourceCode":"on: aCollection\r\t^ (self basicNew on: aCollection)\r\t\tsetLimit: self defaultLimit\r\t\tlimitBlock: nil"},{"name":"on:from:to:","linesOfCode":4,"sourceCode":"on: aCollection from: firstIndex to: lastIndex\r\t^ (self basicNew on: aCollection from: firstIndex to: lastIndex)\r\t\tsetLimit: self defaultLimit\r\t\tlimitBlock: nil"},{"name":"defaultLimit","linesOfCode":2,"sourceCode":"defaultLimit\r\t^ 1000"},{"name":"with:","linesOfCode":4,"sourceCode":"with: aCollection\r\t^ (self basicNew with: aCollection)\r\t\tsetLimit: self defaultLimit\r\t\tlimitBlock: nil"},{"name":"with:from:to:","linesOfCode":4,"sourceCode":"with: aCollection from: firstIndex to: lastIndex\r\t^ (self basicNew with: aCollection from: firstIndex to: lastIndex)\r\t\tsetLimit: self defaultLimit\r\t\tlimitBlock: nil"},{"name":"on:limit:limitBlock:","linesOfCode":4,"sourceCode":"on: aCollection limit: anInteger limitBlock: aLimitBlock\r\t^ (self basicNew on: aCollection)\r\t\tsetLimit: anInteger\r\t\tlimitBlock: aLimitBlock"}],"meta":null}},{"name":"ReadStream","instanceVariables":[],"methods":[{"name":"nextPut:","linesOfCode":2,"sourceCode":"nextPut: anObject\r\tself shouldNotImplement"},{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"Compatibility with other streams (e.g., FileStream)\"\r\t^readLimit"},{"name":"next:","linesOfCode":7,"sourceCode":"next: anInteger \r\t\"Answer the next anInteger elements of my collection.  overriden for efficiency\"\r\r\t| ans endPosition |\r\r\tendPosition := position + anInteger  min:  readLimit.\r\tans := collection copyFrom: position+1 to: endPosition.\r\tposition := endPosition.\r\t^ans\r"},{"name":"next","linesOfCode":9,"sourceCode":"next\r\t\"Primitive. Answer the next object in the Stream represented by the\r\treceiver. Fail if the collection of this stream is not an Array or a String.\r\tFail if the stream is positioned at its end, or if the position is out of\r\tbounds in the collection. Optional. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t^ position >= readLimit\r\t\tifTrue: [ nil ]\r\t\tifFalse: [ collection at: (position := position + 1) ]"},{"name":"localName","linesOfCode":2,"sourceCode":"localName\r\t^'ReadStream'"},{"name":"readStream","linesOfCode":3,"sourceCode":"readStream\r\t\"polymorphic with SequenceableCollection.  Return self\"\r\r\t^ self"},{"name":"ascii","linesOfCode":1,"sourceCode":"ascii"},{"name":"upToAnyOf:do:","linesOfCode":9,"sourceCode":"upToAnyOf: aCollection do: aBlock\r\t\"Overriden for speed\"\r\t| end result |\r\tend := collection indexOfAnyOf: aCollection startingAt: 1 + position ifAbsent: [0].\r\t(end = 0 or: [end > readLimit]) ifTrue: [^self upToEnd].\r\tresult := collection copyFrom: 1 + position to: -1 + end.\r\tposition := end.\r\taBlock value: (collection at: end).\r\t^result"},{"name":"skipTo:","linesOfCode":7,"sourceCode":"skipTo: anObject\r\t\"fast version using indexOf:\"\r\t| end |\r\tend := collection indexOf: anObject startingAt: position+1 ifAbsent: [ 0 ].\r\r\t^(end = 0 or: [end > readLimit]) \r\t\tifTrue: [ self setToEnd. false ]\r\t\tifFalse: [ position := end. true]"},{"name":"on:from:to:","linesOfCode":9,"sourceCode":"on: aCollection from: firstIndex to: lastIndex\r\r\t| len |\r\tcollection := aCollection.\r\treadLimit :=  lastIndex > (len := collection size)\r\t\t\t\t\t\tifTrue: [len]\r\t\t\t\t\t\tifFalse: [lastIndex].\r\tposition := firstIndex <= 1\r\t\t\t\tifTrue: [0]\r\t\t\t\tifFalse: [firstIndex - 1]"},{"name":"gtInspectorStreamStateIn:","linesOfCode":6,"sourceCode":"gtInspectorStreamStateIn: composite\r\t<gtInspectorPresentationOrder: 50>\r\tcomposite text\r\t\ttitle: 'Contents';\r\t\tdisplay: [ self contents ];\r\t\tinitialize: [ :aPresentation | aPresentation selectionInterval: (1 to: self position) ]"},{"name":"readInto:startingAt:count:","linesOfCode":12,"sourceCode":"readInto: aCollection startingAt: startIndex count: n\r\t\"Read n objects into the given collection. \r\tReturn number of elements that have been read.\"\r\t\r\t| max |\r\tmax := (readLimit - position) min: n.\r\taCollection \r\t\treplaceFrom: startIndex \r\t\tto: startIndex + max - 1\r\t\twith: collection\r\t\tstartingAt: position + 1.\r\tposition := position + max.\r\t^ max"},{"name":"upToEnd","linesOfCode":5,"sourceCode":"upToEnd\r\t| start |\r\tstart := 1 + position.\r\tposition := readLimit.\r\t^collection copyFrom: start to: position"},{"name":"upTo:","linesOfCode":10,"sourceCode":"upTo: anObject\r\t\"fast version using indexOf:\"\r\t| start end |\r\r\tstart := position+1.\r\tend := collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].\r\r\t\"not present--return rest of the collection\"\t\r\t(end = 0 or: [end > readLimit]) ifTrue: [ ^self upToEnd ].\r\r\t\"skip to the end and return the data passed over\"\r\tposition := end.\r\t^collection copyFrom: start to: (end-1)"}],"meta":{"name":"ReadStream class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Generator","instanceVariables":[{"name":"block"},{"name":"next"},{"name":"continue"},{"name":"home"}],"methods":[{"name":"nextPut:","linesOfCode":7,"sourceCode":"nextPut: anObject\r\t\"Add anObject into the generator. A synonym to #yield: and value:.\"\r\r\t| previous |\r\tprevious := next.\r\tnext := anObject.\r\tcontinue := thisContext swapSender: continue.\r\t^ previous"},{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"A generator does not know its size.\"\r\r\t^ self shouldNotImplement"},{"name":"initializeOn:","linesOfCode":3,"sourceCode":"initializeOn: aBlock\r\tblock := aBlock.\r\tself reset"},{"name":"printOn:","linesOfCode":2,"sourceCode":"printOn: aStream\r\taStream nextPutAll: self class name; nextPutAll: ' on: '; print: block"},{"name":"value:","linesOfCode":4,"sourceCode":"value: anObject \r\t\"Allows passing generators as arguments to methods expecting blocks.\r\tA synonym for #yield: / #nextPut:.\"\r\t^ self nextPut: anObject"},{"name":"close","linesOfCode":4,"sourceCode":"close\r\t\"Close the receiving generator and unwind its ensure-blocks.\"\r\r\tcontinue ifNotNil:[continue unwindTo: home].\r\tcontinue := block := next := nil"},{"name":"reset","linesOfCode":6,"sourceCode":"reset\r\t\"Reset the generator, i.e., start it over\"\r\tcontinue ifNotNil:[continue unwindTo: home].\r\tnext := nil.\r\tcontinue := thisContext.\r\tself fork"},{"name":"contents","linesOfCode":7,"sourceCode":"contents\r\t\"Answer the contents of this generator. Do not call this method on infinite generators.\"\r\r\t| stream |\r\tstream := (Array new: 10) writeStream.\r\t[ self atEnd ]\r\t\twhileFalse: [ stream nextPut: self next ].\r\t^ stream contents"},{"name":"next","linesOfCode":6,"sourceCode":"next\r\t\"Generate and answer the next object in the receiver.\"\r\r\t^ self atEnd ifFalse: [\r\t\thome swapSender: thisContext sender.\r\t\tcontinue := thisContext swapSender: continue\r\t]"},{"name":"fork","linesOfCode":8,"sourceCode":"fork\r\t| result |\r\thome := thisContext.\r\tblock reentrant value: self.\r\tthisContext swapSender: continue.\r\tresult := next.\r\tcontinue := next := home := nil.\r\t^ result"},{"name":"atEnd","linesOfCode":3,"sourceCode":"atEnd\r\t\"Answer whether the receiver can access any more objects.\"\r\r\t^ continue isNil or: [ continue isDead ]"},{"name":"yield:","linesOfCode":4,"sourceCode":"yield: anObject \r\t\"Yield the next value to the consumer of the generator.\r\tA synonym for #nextPut:\"\r\t^ self nextPut: anObject"},{"name":"peek","linesOfCode":3,"sourceCode":"peek\r\t\"Answer the upcoming object of the receiver.\"\r\r\t^ next"}],"meta":{"name":"Generator class","instanceVariables":[],"methods":[{"name":"on:","linesOfCode":2,"sourceCode":"on: aBlock\r\t^ self basicNew initializeOn: aBlock"},{"name":"somePrimes","linesOfCode":6,"sourceCode":"somePrimes\r\t\"self somePrimes\" \r\t\r\t^ String streamContents: [ :str | \r\t\t| generator |\r\t\tgenerator := Generator on: [:g| Integer primesUpTo: 100 do:[:prime| g yield: prime]].\r\t\t[generator atEnd] whileFalse:[ str nextPutAll: generator next printString; cr]]"}],"meta":null}},{"name":"PositionableStream","instanceVariables":[{"name":"collection"},{"name":"position"},{"name":"readLimit"}],"methods":[{"name":"nextNumber:","linesOfCode":7,"sourceCode":"nextNumber: n \r\t\"Answer the next n bytes as a positive Integer or LargePositiveInteger.\"\r\t| s |\r\ts := 0.\r\t1 to: n do: \r\t\t[:i | s := (s bitShift: 8) bitOr: self next asInteger].\r\t^ s normalize"},{"name":"uint24:","linesOfCode":7,"sourceCode":"uint24: anInteger\r\t\"Store the given unsigned, 24-bit integer on this (binary) stream.\"\r\r\t(anInteger < 0 or: [ anInteger >= 16r1000000 ])\r\t\tifTrue: [self error: 'outside unsigned 24-bit integer range'].\r\r\tself nextPut: (anInteger byteAt: 3).\r\tself nextPut: (anInteger byteAt: 2).\r\tself nextPut: (anInteger byteAt: 1).\r"},{"name":"isEmpty","linesOfCode":5,"sourceCode":"isEmpty\r\t\"Answer whether the receiver's contents has no elements.\"\r\r\t\"Returns true if both the set of past and future sequence values of\rthe receiver are empty. Otherwise returns false\"\r\r\t^ self atEnd and: [position = 0]"},{"name":"setFrom:to:","linesOfCode":3,"sourceCode":"setFrom: newStart to: newStop\r\r\tposition := newStart - 1.\r\treadLimit := newStop"},{"name":"nextNumber:put:","linesOfCode":6,"sourceCode":"nextNumber: n put: v \r\t\"Append to the receiver the argument, v, which is a positive \r\tSmallInteger or a LargePositiveInteger, as the next n bytes.\r\tPossibly pad with leading zeros.\"\r\r\t1 to: n do: [:i | self nextPut: (v byteAt: n+1-i)].\r\t^ v\r"},{"name":"nextInt32","linesOfCode":8,"sourceCode":"nextInt32\r\t\"Read a 32-bit signed integer from the next 4 bytes\"\r\r\t| s |\r\ts := 0.\r\t1 to: 4 do: [ :i | s := (s bitShift: 8) + self next ].\r\t^ (s bitAnd: 16r80000000) = 0\r\t\tifTrue: [ s ]\r\t\tifFalse: [ -1 - s bitInvert32 ]"},{"name":"oldBack","linesOfCode":7,"sourceCode":"oldBack\r\t\"Go back one element and return it.  Use indirect messages in case I am a StandardFileStream\"\r\t\"The method is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. This method considers that the pointer is *on* an element. Please consider unit tests which verifies #back and #oldBack behavior. (Damien Cassou - 1 August 2007)\"\r\tself position = 0 ifTrue: [self positionError].\r\tself position = 1 ifTrue: [self position: 0.  ^ nil].\r\tself skip: -2.\r\t^ self next\r"},{"name":"fuelNextWordsInto:","linesOfCode":25,"sourceCode":"fuelNextWordsInto: aWordObject \r\t\"This method is the same as nextWordsInto: but the restoreEndianness is only done if needed\"\r\t| blt pos source byteSize |\r\r\tbyteSize := aWordObject byteSize.\r\t\"is the test on collection basicSize \\\\ 4 necessary?\"\r\t\r\t((self position bitAnd: 3) = 0 and: [ (collection basicSize bitAnd: 3) = 0])\r\t\tifTrue: [source := collection.\r\t\t\tpos := self position.\r\t\t\tself skip: byteSize]\r\t\tifFalse: [\"forced to copy it into a buffer\"\r\t\t\tsource := self next: byteSize.\r\t\t\tpos := 0].\r\r\t\"Now use BitBlt to copy the bytes to the bitmap.\"\r\tblt := (BitBlt\r\t\t\t\ttoForm: (Form new hackBits: aWordObject))\r\t\t\t\tsourceForm: (Form new hackBits: source).\r\tblt combinationRule: Form over. \"store\"\r\tblt sourceX: 0;\r\t\t sourceY: pos // 4;\r\t\t height: byteSize // 4;\r\t\t width: 4.\r\tblt destX: 0;\r\t\t destY: 0.\r\tblt copyBits.\r\r\t^ aWordObject \t\r"},{"name":"upToAnyOf:","linesOfCode":5,"sourceCode":"upToAnyOf: aCollection \r\t\"Answer a subcollection from the current access position to the \r\toccurrence (if any, but not inclusive) of any object in the collection. If \r\tno matching object is found, answer the entire rest of the receiver.\"\r\t^self upToAnyOf: aCollection do: [:matchingObject | ]"},{"name":"on:","linesOfCode":5,"sourceCode":"on: aCollection\r\r\tcollection := aCollection.\r\treadLimit := aCollection size.\r\tposition := 0.\r\tself reset"},{"name":"next:","linesOfCode":8,"sourceCode":"next: anInteger \r\t\"Answer the next anInteger elements of my collection. Must override \r\tbecause default uses self contents species, which might involve a large \r\tcollection.\"\r\r\t| newArray |\r\tnewArray := collection species new: anInteger.\r\t1 to: anInteger do: [:index | newArray at: index put: self next].\r\t^newArray"},{"name":"next:into:","linesOfCode":5,"sourceCode":"next: n into: aCollection\r\t\"Read n objects into the given collection.\r\tReturn aCollection or a partial copy if less than\r\tn elements have been read.\"\r\t^self next: n into: aCollection startingAt: 1"},{"name":"oldPeekBack","linesOfCode":7,"sourceCode":"oldPeekBack\r\t\"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream.\"\r\t\"The method is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. This method considers that the pointer is *on* an element. Please consider unit tests which verifies #peekBack and #oldPeekBack behavior. (Damien Cassou - 1 August 2007)\"\r\t| element |\r\telement := self oldBack.\r\tself skip: 1.\r\t^ element\r"},{"name":"position:","linesOfCode":7,"sourceCode":"position: anInteger\r\t\"Set the current position for accessing the objects to be anInteger, as long \r\tas anInteger is within the bounds of the receiver's contents. If it is not, \r\tcreate an error notification.\"\r\r\t(anInteger between: 0 and: readLimit)\r\t\tifTrue: [ position := anInteger ]\r\t\tifFalse: [ self positionError ]"},{"name":"boolean","linesOfCode":3,"sourceCode":"boolean\r\t\"Answer the next boolean value from this (binary) stream.\"\r\r\t^ self next ~= 0\r"},{"name":"positionOfSubCollection:ifAbsent:","linesOfCode":16,"sourceCode":"positionOfSubCollection: subCollection ifAbsent: exceptionBlock \r\t\"Return a position such that that element at the new position equals the first element of sub, and the next elements equal the rest of the elements of sub. Begin the search at the current position.\r\tIf no such match is found, answer the result of evaluating argument, exceptionBlock.\"\r\t| pattern startPosition currentPosition |\r\tpattern := subCollection readStream.\r\tstartPosition := self position.\r\t[ pattern atEnd ] whileFalse: \r\t\t[ self atEnd ifTrue: [ ^ exceptionBlock value ].\r\t\tself next = pattern next ifFalse: \r\t\t\t[ self position: self position - pattern position + 1.\r\t\t\tpattern reset ] ].\r\tcurrentPosition := self position.\r\tself position: startPosition.\r\t^ pattern atEnd \r\t\tifTrue: [ currentPosition + 1 - subCollection size ]\r\t\tifFalse: [ exceptionBlock value ]"},{"name":"uint32:","linesOfCode":8,"sourceCode":"uint32: anInteger\r\t\"Store the given unsigned, 32-bit integer on this (binary) stream.\"\r\r\t(anInteger < 0 or: [ anInteger >= 16r100000000 ])\r\t\tifTrue: [self error: 'outside unsigned 32-bit integer range'].\r\r\tself nextPut: (anInteger byteAt: 4).\r\tself nextPut: (anInteger byteAt: 3).\r\tself nextPut: (anInteger byteAt: 2).\r\tself nextPut: (anInteger byteAt: 1).\r"},{"name":"basicNextChunk","linesOfCode":15,"sourceCode":"basicNextChunk\r\t\"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.\"\r\r\t| terminator out ch |\r\tterminator := $!.\r\tout := (String new: 1000) writeStream.\r\tself skipSeparators.\r\t[ (ch := self next) isNil ]\r\t\twhileFalse: [ \r\t\t\tch == terminator\r\t\t\t\tifTrue: [ \r\t\t\t\t\tself peek == terminator\r\t\t\t\t\t\tifTrue: [ self next\t\"skip doubled terminator\" ]\r\t\t\t\t\t\tifFalse: [ ^ out contents\t\"terminator is not doubled; we're done!\" ] ].\r\t\t\tout nextPut: ch ].\r\t^ out contents"},{"name":"asZLibReadStream","linesOfCode":2,"sourceCode":"asZLibReadStream\r\t^ZLibReadStream on: collection from: position+1 to: readLimit"},{"name":"nextLittleEndianNumber:","linesOfCode":7,"sourceCode":"nextLittleEndianNumber: n \r\t\"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant.\"\r\r\t| bytes s |\r\tbytes := self next: n.\r\ts := 0.\r\tn to: 1 by: -1 do: [:i | s := (s bitShift: 8) bitOr: (bytes at: i)].\r\t^ s\r"},{"name":"upToAll:","linesOfCode":12,"sourceCode":"upToAll: aCollection\r\t\"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream.\"\r\r\t| startPos endMatch result |\r\tstartPos := self position.\r\t^ (self match: aCollection)\r\t\tifTrue: [ endMatch := self position.\r\t\t\tself position: startPos.\r\t\t\tresult := self upToPosition: endMatch - aCollection size.\r\t\t\tself position: endMatch.\r\t\t\tresult ]\r\t\tifFalse: [ self position: startPos.\r\t\t\tself upToEnd ]"},{"name":"pushBack:","linesOfCode":3,"sourceCode":"pushBack: aString\r\t\"Compatibility with SocketStreams\"\r\tself skip: aString size negated"},{"name":"contentsOfEntireFile","linesOfCode":3,"sourceCode":"contentsOfEntireFile\r\t\"For non-file streams\"\r\t^ self contents"},{"name":"nextDelimited:","linesOfCode":17,"sourceCode":"nextDelimited: terminator\r\t\"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator.\"\r\r\t| out ch |\r\tout := (String new: 1000) writeStream.\r\tself atEnd ifTrue: [^ ''].\r\tself next == terminator ifFalse: [self skip: -1].\t\"absorb initial terminator\"\r\t[(ch := self next) == nil] whileFalse: [\r\t\t(ch == terminator) ifTrue: [\r\t\t\tself peek == terminator ifTrue: [\r\t\t\t\tself next.  \"skip doubled terminator\"\r\t\t\t] ifFalse: [\r\t\t\t\t^ out contents  \"terminator is not doubled; we're done!\"\r\t\t\t].\r\t\t].\r\t\tout nextPut: ch.\r\t].\r\t^ out contents"},{"name":"on:from:to:","linesOfCode":2,"sourceCode":"on: aCollection from: firstIndex to: lastIndex\r\tself on: (aCollection copyFrom: firstIndex to: lastIndex)"},{"name":"int32:","linesOfCode":12,"sourceCode":"int32: anInteger\r\t\"Store the given signed, 32-bit integer on this (binary) stream.\"\r\r\t| n |\r\t(anInteger < -16r80000000 or: [ anInteger >= 16r80000000 ])\r\t\tifTrue: [ self error: 'outside 32-bit integer range' ].\r\tn := anInteger < 0\r\t\tifTrue: [ 16r100000000 + anInteger ]\r\t\tifFalse: [ anInteger ].\r\tself nextPut: (n byteAt: 4).\r\tself nextPut: (n byteAt: 3).\r\tself nextPut: (n byteAt: 2).\r\tself nextPut: (n byteAt: 1)"},{"name":"skipSeparators","linesOfCode":4,"sourceCode":"skipSeparators\r\t[self atEnd]\r\t\twhileFalse:\r\t\t[self next isSeparator ifFalse: [^ self position: self position-1]]"},{"name":"position","linesOfCode":3,"sourceCode":"position\r\t\"Answer the current position of accessing the sequence of objects.\"\r\r\t^position"},{"name":"peekFor:","linesOfCode":13,"sourceCode":"peekFor: anObject \r\t\"Answer false and do not move over the next element if it is not equal to \r\tthe argument, anObject, or if the receiver is at the end. Answer true \r\tand increment the position for accessing elements, if the next element is \r\tequal to anObject.\"\r\r\t| nextObject |\r\tself atEnd ifTrue: [^false].\r\tnextObject := self next.\r\t\"peek for matching element\"\r\tanObject = nextObject ifTrue: [^true].\r\t\"gobble it if found\"\r\tposition := position - 1.\r\t^false"},{"name":"uint16:","linesOfCode":6,"sourceCode":"uint16: anInteger\r\t\"Store the given unsigned, 16-bit integer on this (binary) stream.\"\r\r\t(anInteger < 0 or: [ anInteger >= 16r10000 ])\r\t\tifTrue: [self error: 'outside unsigned 16-bit integer range'].\r\r\tself nextPut: (anInteger byteAt: 2).\r\tself nextPut: (anInteger byteAt: 1).\r"},{"name":"uint24","linesOfCode":7,"sourceCode":"uint24\r\t\"Answer the next unsigned, 24-bit integer from this (binary) stream.\"\r\r\t| n |\r\tn := self next.\r\tn := (n bitShift: 8) + self next.\r\tn := (n bitShift: 8) + self next.\r\t^ n\r"},{"name":"upTo:","linesOfCode":9,"sourceCode":"upTo: anObject \r\t\"Answer a subcollection from the current access position to the \r\toccurrence (if any, but not inclusive) of anObject in the receiver. If \r\tanObject is not in the collection, answer the entire rest of the receiver.\"\r\t| newStream element |\r\tnewStream := (collection species new: 100) writeStream.\r\t[self atEnd or: [(element := self next) = anObject]]\r\t\twhileFalse: [newStream nextPut: element].\r\t^newStream contents"},{"name":"boolean:","linesOfCode":3,"sourceCode":"boolean: aBoolean\r\t\"Store the given boolean value on this (binary) stream.\"\r\r\tself nextPut: (aBoolean ifTrue: [1] ifFalse: [0]).\r"},{"name":"nextStringPut:","linesOfCode":12,"sourceCode":"nextStringPut: s \r\t\"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256.\"\r\r\t| length |\r\t(length := s size) < 192\r\t\tifTrue: [self nextPut: length]\r\t\tifFalse: \r\t\t\t[self nextPut: (length byteAt: 4)+192.\r\t\t\tself nextPut: (length byteAt: 3).\r\t\t\tself nextPut: (length byteAt: 2).\r\t\t\tself nextPut: (length byteAt: 1)].\r\tself nextPutAll: s asByteArray.\r\t^s"},{"name":"reset","linesOfCode":3,"sourceCode":"reset\r\t\"Set the receiver's position to the beginning of the sequence of objects.\"\r\r\tposition := 0"},{"name":"backUpTo:","linesOfCode":21,"sourceCode":"backUpTo: subCollection \r\t\"Back up the position to he subCollection.  Position must be somewhere within the stream initially.  Leave it just after it.  Return true if succeeded.  No wildcards, and case does matter.\"\r\t\"Example:\r\t| strm | strm := ReadStream on: 'zabc abdc'.\r\tstrm setToEnd; backUpTo: 'abc'; position \r\"\r\t| pattern startMatch |\r\tpattern := subCollection reversed readStream.\r\tstartMatch := nil.\r\t[ pattern atEnd ] whileFalse: \r\t\t[ self position = 0 ifTrue: [ ^ false ].\r\t\tself skip: -1.\r\t\tself next = pattern next \r\t\t\tifTrue: [ pattern position = 1 ifTrue: [ startMatch := self position ] ]\r\t\t\tifFalse: \r\t\t\t\t[ pattern position: 0.\r\t\t\t\tstartMatch ifNotNil: \r\t\t\t\t\t[ self position: startMatch - 1.\r\t\t\t\t\tstartMatch := nil ] ].\r\t\tself skip: -1 ].\r\tself position: startMatch.\r\t^ true"},{"name":"string","linesOfCode":5,"sourceCode":"string\r\t\"Answer the next string from this (binary) stream.\"\r\r\t| size |\r\tsize := self uint16.\r\t^ (self next: size) asString\r"},{"name":"decodeString:andRuns:","linesOfCode":22,"sourceCode":"decodeString: string andRuns: runsRaw\r\t| strm runLength runValues newString index |\r\tstrm := ReadStream on: runsRaw from: 1 to: runsRaw size.\r\t(strm peekFor: $()\r\t\tifFalse: [ ^ nil ].\r\trunLength := OrderedCollection new.\r\t[ \r\tstrm skipSeparators.\r\tstrm peekFor: $) ] whileFalse: [ runLength add: (Number readFrom: strm) ].\r\trunValues := OrderedCollection new.\r\t[ strm atEnd ]\r\t\twhileFalse: [ \r\t\t\trunValues add: (Number readFrom: strm).\r\t\t\tstrm next ].\r\tnewString := WideString new: string size.\r\tindex := 1.\r\trunLength\r\t\twith: runValues\r\t\tdo: [ :length :leadingChar | \r\t\t\tindex to: index + length - 1 do: [ :pos | newString at: pos put: (Character leadingChar: leadingChar code: (string at: pos) charCode) ].\r\t\t\tindex := index + length ].\r\t^ newString"},{"name":"resetContents","linesOfCode":4,"sourceCode":"resetContents\r\t\"Set the position and limits to 0.\"\r\r\tposition := 0.\r\treadLimit := 0"},{"name":"nextChunkText","linesOfCode":15,"sourceCode":"nextChunkText\r\t\"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk.\"\r\t| string runsRaw strm runs peek pos |\r\t\"Read the plain text\"\r\tstring := self nextChunk.\r\t\r\t\"Test for ]style[ tag\"\r\tpos := self position.\r\tpeek := self skipSeparatorsAndPeekNext.\r\tpeek = $] ifFalse: [self position: pos. ^ string asText].  \"no tag\"\r\t(self upTo: $[) = ']style' ifFalse: [self position: pos. ^ string asText].  \"different tag\"\r\r\t\"Read and decode the style chunk\"\r\trunsRaw := self basicNextChunk.\t\"style encoding\"\r\tstrm := ReadStream on: runsRaw from: 1 to: runsRaw size.\r\truns := RunArray scanFrom: strm.\r\r\t^ Text basicNew setString: string setRunsChecking: runs.\r"},{"name":"asPetitStream","linesOfCode":7,"sourceCode":"asPetitStream\r\t\"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases.\"\r\r\"\r\tDisabled until we agree on some way how to optimize this\r\r\t^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])\r\t\tifFalse: [ PPStream on: collection from: ( position + 1 ) to: readLimit ]\r      ifTrue: [ super asPetitStream ]\r\"\r\t^ super asPetitStream"},{"name":"int32","linesOfCode":10,"sourceCode":"int32\r\t\"Answer the next signed, 32-bit integer from this (binary) stream.\"\r\t\"Details: As a fast check for negative number, check the high bit of the first digit\"\r\r\t| n firstDigit |\r\tn := firstDigit := self next.\r\tn := (n bitShift: 8) + self next.\r\tn := (n bitShift: 8) + self next.\r\tn := (n bitShift: 8) + self next.\r\tfirstDigit >= 128 ifTrue: [n := -16r100000000 + n].  \"decode negative 32-bit integer\"\r\t^ n\r"},{"name":"nextWordPut:","linesOfCode":5,"sourceCode":"nextWordPut: aWord \r\t\"Append to the receiver an Integer as the next two bytes.\"\r\r\tself nextPut: ((aWord bitShift: -8) bitAnd: 255).\r\tself nextPut: (aWord bitAnd: 255).\r\t^aWord"},{"name":"peekBack","linesOfCode":6,"sourceCode":"peekBack\r\t\"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream.\"\r\r\t| element |\r\telement := self back.\r\tself skip: 1.\r\t^ element"},{"name":"nextInto:startingAt:","linesOfCode":5,"sourceCode":"nextInto: aCollection startingAt: startIndex\r\t\"Read the next elements of the receiver into aCollection.\r\tReturn aCollection or a partial copy if less than aCollection\r\tsize elements have been read.\"\r\t^self next: (aCollection size - startIndex+1) into: aCollection startingAt: startIndex."},{"name":"skip:","linesOfCode":6,"sourceCode":"skip: anInteger \r\t\"Set the receiver's position to be the current position+anInteger. A \r\tsubclass might choose to be more helpful and select the minimum of the \r\treceiver's size and position+anInteger, or the maximum of 1 and \r\tposition+anInteger for the repositioning.\"\r\r\tself position: position + anInteger"},{"name":"upToAnyOf:do:","linesOfCode":8,"sourceCode":"upToAnyOf: subcollection do: aBlock\r\t\"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of any object in the collection.\r\tEvaluate aBlock with this occurrence as argument.\r\tIf no matching object is found, don't evaluate aBlock and answer the entire rest of the receiver.\"\r\t\r\t^self collectionSpecies new: 1000 streamContents: [ :stream |\r\t\t| ch |\r\t\t[ self atEnd or: [ (subcollection includes: (ch := self next)) and: [aBlock value: ch. true] ] ] \r\t\t\twhileFalse: [ stream nextPut: ch ] ]"},{"name":"padTo:put:","linesOfCode":6,"sourceCode":"padTo: nBytes put: aCharacter \r\t\"Pad using the argument, aCharacter, to the next boundary of nBytes characters.\"\r\t| rem |\r\trem := nBytes - (self position \\\\ nBytes).\r\trem = nBytes ifTrue: [^ 0].\r\tself next: rem put: aCharacter."},{"name":"upToAny:","linesOfCode":9,"sourceCode":"upToAny: aCollection \r\t\"Answer a subcollection from the current access position to the \r\toccurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If \r\tany of these is not in the collection, answer the entire rest of the receiver.\"\r\t\r\t| newStream element |\r\tnewStream := (collection species new: 100) writeStream.\r\t[self atEnd or: [aCollection includes: (element := self next)]]\r\t\twhileFalse: [newStream nextPut: element].\r\t^newStream contents"},{"name":"header","linesOfCode":2,"sourceCode":"header\r\t\"If the stream requires a standard header, override this message.  See HtmlFileStream\""},{"name":"upToEnd","linesOfCode":6,"sourceCode":"upToEnd\r\t\"Answer a subcollection from the current access position through the last element of the receiver.\"\r\r\t| newStream |\r\tnewStream := (collection species new: 100) writeStream.\r\t[self atEnd] whileFalse: [ newStream nextPut: self next ].\r\t^ newStream contents"},{"name":"match:","linesOfCode":11,"sourceCode":"match: subCollection \r\t\"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter.\"\r\t| pattern |\r\tpattern := subCollection readStream.\r\t[ self atEnd or: [pattern atEnd] ] whileFalse: \r\t\t[self skip: pattern position negated.\r\t\tpattern setToStart. \r\t\t(self skipTo: pattern next) ifFalse: [ ^false ].\r\t\t[pattern atEnd not and: [self next = pattern peek]] whileTrue: [pattern next]\r\t].\r\t^ pattern atEnd"},{"name":"skipSeparatorsAndPeekNext","linesOfCode":7,"sourceCode":"skipSeparatorsAndPeekNext\r\t\"A special function to make nextChunk fast\"\r\t| peek |\r\t[self atEnd]\r\t\twhileFalse:\r\t\t[(peek := self next) isSeparator\r\t\t\tifFalse: [self position: self position-1. ^ peek]]"},{"name":"peekTwice","linesOfCode":9,"sourceCode":"peekTwice\r\t\"Answer what would be returned if the message next were sent to the \r\treceiver. If the receiver is at the end, answer nil.\"\r\r\t| array |\r\tself atEnd \r\t\tifTrue: [^Array with: nil with: nil].\r\tarray := Array with: (self next) with: (self peek).\r\tposition := position - 1.\r\t^array"},{"name":"skipStyleChunk","linesOfCode":11,"sourceCode":"skipStyleChunk\r\t\"Get to the start of the next chunk that is not a style for the previous chunk\"\r\r\t| pos |\r\tpos := self position.\r\tself skipSeparators.\r\tself peek == $] \r\t\tifTrue: [(self upTo: $[) = ']text' \t\"old -- no longer needed\"\r\t\t\t\t\"now positioned past the open bracket\"\r\t\t\tifFalse: [self nextChunk]]\t\"absorb ]style[ and its whole chunk\"\r\t\t\t\t\r\t\tifFalse: [self position: pos]\t\"leave untouched\"\r"},{"name":"uint16","linesOfCode":6,"sourceCode":"uint16\r\t\"Answer the next unsigned, 16-bit integer from this (binary) stream.\"\r\r\t| n |\r\tn := self next.\r\tn := (n bitShift: 8) + (self next).\r\t^ n\r"},{"name":"untilEnd:displayingProgress:","linesOfCode":8,"sourceCode":"untilEnd: aBlock displayingProgress: aString\r\taString\r\t\tdisplayProgressFrom: 0 to: self size\r\t\tduring:\r\t\t\t[:bar |\r\t\t\t[self atEnd] whileFalse:\r\t\t\t\t[bar current: self position.\r\t\t\t\taBlock value]]."},{"name":"untilEndWithFork:displayingProgress:","linesOfCode":17,"sourceCode":"untilEndWithFork: aBlock displayingProgress: aString\r\t| sem done result |\r\tsem := Semaphore new.\r\tdone := false.\r\t[ \r\tresult := [ aBlock value ]\r\t\tensure: [ \r\t\t\tdone := true.\r\t\t\tsem signal ] ] fork.\r\tself\r\t\tuntilEnd: [ \r\t\t\tdone\r\t\t\t\tifTrue: [ ^ result ].\r\t\t\t(Delay forSeconds: 0.2) wait ]\r\t\tdisplayingProgress: aString.\r\tsem wait.\r\t^ result"},{"name":"nextWord","linesOfCode":8,"sourceCode":"nextWord\r\t\"Answer the next two bytes from the receiver as an Integer.\"\r\r\t| high low |\r\thigh := self next.\r\t\thigh==nil ifTrue: [^false].\r\tlow := self next.\r\t\tlow==nil ifTrue: [^false].\r\t^(high asInteger bitShift: 8) + low asInteger"},{"name":"uint32","linesOfCode":8,"sourceCode":"uint32\r\t\"Answer the next unsigned, 32-bit integer from this (binary) stream.\"\r\r\t| n |\r\tn := self next.\r\tn := (n bitShift: 8) + self next.\r\tn := (n bitShift: 8) + self next.\r\tn := (n bitShift: 8) + self next.\r\t^ n\r"},{"name":"nextStringOld","linesOfCode":10,"sourceCode":"nextStringOld\r\t\"Read a string from the receiver. The first byte is the length of the \r\tstring, unless it is greater than 192, in which case the first *two* bytes \r\tencode the length.  Max size 16K. \"\r\r\t| aString length |\r\tlength := self next.\t\t\"first byte.\"\r\tlength >= 192 ifTrue: [length := (length - 192) * 256 + self next].\r\taString := String new: length.\r\t1 to: length do: [:ii | aString at: ii put: self next asCharacter].\r\t^aString"},{"name":"back","linesOfCode":5,"sourceCode":"back\r\t\"Go back one element and return it.\"\r\r\tself position = 0 ifTrue: [self positionError].\r\tself skip: -1.\r\t^ self peek"},{"name":"int16","linesOfCode":7,"sourceCode":"int16\r\t\"Answer the next signed, 16-bit integer from this (binary) stream.\"\r\r\t| n |\r\tn := self next.\r\tn := (n bitShift: 8) + (self next).\r\tn >= 16r8000 ifTrue: [n := n - 16r10000].\r\t^ n\r"},{"name":"next:into:startingAt:","linesOfCode":8,"sourceCode":"next: requestedCount into: aCollection startingAt: startIndex\r\t\"Read requestedCount objects into the given collection. \r\tReturn aCollection or a partial copy if less elements have been read.\"\r\r\t| readCount |\r\treadCount := self readInto: aCollection startingAt: startIndex count: requestedCount.\r\t^ readCount = requestedCount\r\t\tifTrue: [ aCollection ]\r\t\tifFalse: [ aCollection copyFrom: 1 to: startIndex + readCount - 1 ]"},{"name":"upToPosition:","linesOfCode":3,"sourceCode":"upToPosition: anInteger\r\t\"Answer a subcollection containing items starting from the current position and ending including the given position. Usefully different to #next: in that in the case of MultiByteFileStream, and perhaps others, positions measure in terms of encoded items, while #next: convention is to name a number of items, independent of their encoding in the underlying buffer.\"\r\t^ self next: anInteger - position"},{"name":"atEnd","linesOfCode":4,"sourceCode":"atEnd\r\t\"Primitive. Answer whether the receiver can access any more objects.\r\tOptional. See Object documentation whatIsAPrimitive.\"\r\r\t^position >= readLimit"},{"name":"originalContents","linesOfCode":3,"sourceCode":"originalContents\r\t\"Answer the receiver's actual contents collection, NOT a copy.\"\r\r\t^ collection"},{"name":"asPetit2Stream","linesOfCode":2,"sourceCode":"asPetit2Stream\r\t^ PP2Stream on: self contents"},{"name":"nextLittleEndianNumber:put:","linesOfCode":6,"sourceCode":"nextLittleEndianNumber: n put: value\r\t\"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant.\"\r\t| bytes |\r\tbytes := ByteArray new: n.\r\t1 to: n do: [:i | bytes at: i put: (value byteAt: i)].\r\tself nextPutAll: bytes"},{"name":"peek","linesOfCode":8,"sourceCode":"peek\r\t\"Answer what would be returned if the message next were sent to the \r\treceiver. If the receiver is at the end, answer nil.\"\r\r\t| nextObject |\r\tself atEnd ifTrue: [^nil].\r\tnextObject := self next.\r\tposition := position - 1.\r\t^nextObject"},{"name":"collectionSpecies","linesOfCode":3,"sourceCode":"collectionSpecies\r\t\"Answer the species of collection into which the receiver can stream\"\r\t\r\t^collection species"},{"name":"isBinary","linesOfCode":3,"sourceCode":"isBinary\r\t\"Return true if the receiver is a binary byte stream\"\r\t^collection class == ByteArray"},{"name":"nextInt32Put:","linesOfCode":8,"sourceCode":"nextInt32Put: int32\r\t\"Write a signed integer to the next 4 bytes\"\r\t| pos |\r\tpos := int32 < 0\r\t\tifTrue: [(0-int32) bitInvert32 + 1]\r\t\tifFalse: [int32].\r\t1 to: 4 do: [:i | self nextPut: (pos byteAt: 5-i)].\r\t^ int32"},{"name":"padToNextLongPut:","linesOfCode":5,"sourceCode":"padToNextLongPut: char \r\t\"Make position be on long word boundary, writing the padding \r\tcharacter, char, if necessary.\"\r\t[self position \\\\ 4 = 0]\r\t\twhileFalse: [self nextPut: char]"},{"name":"nextLine","linesOfCode":6,"sourceCode":"nextLine\r\t\"Answer next line (may be empty) without line end delimiters, or nil if at end.\r\tLet the stream positioned after the line delimiter(s).\r\tHandle a zoo of line delimiters CR, LF, or CR-LF pair\"\r\r\tself atEnd ifTrue: [^nil].\r\t^self upToAnyOf: CharacterSet crlf do: [:char | char = Character cr ifTrue: [self peekFor: Character lf]]"},{"name":"nextString","linesOfCode":11,"sourceCode":"nextString\r\t\"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary).\"\r\r\t| length aByteArray |\r\r\t\"read the length in binary mode\"\r\tself binary.\r\tlength := self next.\t\t\"first byte.\"\r\tlength >= 192 ifTrue: [length := length - 192.\r\t\t1 to: 3 do: [:ii | length := length * 256 + self next]].\r\taByteArray := ByteArray new: length.\r\r\tself nextInto: aByteArray.\r\t^aByteArray asString.\r"},{"name":"contents","linesOfCode":3,"sourceCode":"contents\r\t\"Answer with a copy of my collection from 1 to readLimit.\"\r\r\t^collection copyFrom: 1 to: readLimit"},{"name":"nextWordsInto:","linesOfCode":31,"sourceCode":"nextWordsInto: aBitmap \r\t\"Fill the word based buffer from my collection. \r\tStored on stream as Big Endian. Optimized for speed. \r\tRead in BigEndian, then restoreEndianness.\"\r\t| blt pos source byteSize |\r\tcollection class isBytes\r\t\tifFalse: [^ self next: aBitmap size into: aBitmap startingAt: 1].\r\r\tbyteSize := aBitmap byteSize.\r\t\"is the test on collection basicSize \\\\ 4 necessary?\"\r\t((self position bitAnd: 3) = 0 and: [ (collection basicSize bitAnd: 3) = 0])\r\t\tifTrue: [source := collection.\r\t\t\tpos := self position.\r\t\t\tself skip: byteSize]\r\t\tifFalse: [\"forced to copy it into a buffer\"\r\t\t\tsource := self next: byteSize.\r\t\t\tpos := 0].\r\r\t\"Now use BitBlt to copy the bytes to the bitmap.\"\r\tblt := (BitBlt\r\t\t\t\ttoForm: (Form new hackBits: aBitmap))\r\t\t\t\tsourceForm: (Form new hackBits: source).\r\tblt combinationRule: Form over. \"store\"\r\tblt sourceX: 0;\r\t\t sourceY: pos // 4;\r\t\t height: byteSize // 4;\r\t\t width: 4.\r\tblt destX: 0;\r\t\t destY: 0.\r\tblt copyBits.\r\r\t\"And do whatever the bitmap needs to do to convert from big-endian order.\"\r\taBitmap restoreEndianness.\r\r\t^ aBitmap \t\"May be WordArray, ColorArray, etc\"\r"},{"name":"positionError","linesOfCode":4,"sourceCode":"positionError\r\t\"Since I am not necessarily writable, it is up to my subclasses to override \r\tposition: if expanding the collection is preferrable to giving this error.\"\r\r\tself error: 'Attempt to set the position of a PositionableStream out of bounds'"},{"name":"nextInto:","linesOfCode":5,"sourceCode":"nextInto: aCollection\r\t\"Read the next elements of the receiver into aCollection.\r\tReturn aCollection or a partial copy if less than aCollection\r\tsize elements have been read.\"\r\t^self next: aCollection size into: aCollection startingAt: 1."},{"name":"parseLangTagFor:","linesOfCode":14,"sourceCode":"parseLangTagFor: aString\r\r\t| string peek runsRaw pos |\r\tstring := aString.\r\t\"Test for ]lang[ tag\"\r\tpos := self position.\r\tpeek := self skipSeparatorsAndPeekNext.\r\tpeek = $] ifFalse: [self position: pos. ^ string].  \"no tag\"\r\t(self upTo: $[) = ']lang' ifTrue: [\r\t\trunsRaw := self basicNextChunk.\r\t\tstring := self decodeString: aString andRuns: runsRaw\r\t] ifFalse: [\r\t\tself position: pos\r\t].\r\t^ string.\r"},{"name":"nextPreamble","linesOfCode":15,"sourceCode":"nextPreamble\r\t\"Assuming that preamble part does not contain ]lang[ tag\"\r\t| terminator out ch |\r\tterminator := $!.\r\tout := (String new: 1000) writeStream.\r\tself skipSeparators.\r\t[ (ch := self next) isNil ]\r\t\twhileFalse: [ \r\t\t\tch == terminator\r\t\t\t\tifTrue: [ \r\t\t\t\t\tself peek == terminator\r\t\t\t\t\t\tifTrue: [ self next\t\"skip doubled terminator\" ]\r\t\t\t\t\t\tifFalse: [ ^out contents\t\"terminator is not doubled; we're done!\" ] ].\r\t\t\tout nextPut: ch ].\r\t^ out contents"},{"name":"int16:","linesOfCode":10,"sourceCode":"int16: anInteger\r\t\"Store the given signed, 16-bit integer on this (binary) stream.\"\r\r\t| n |\r\t(anInteger < -16r8000 or: [ anInteger >= 16r8000 ])\r\t\tifTrue: [ self error: 'outside 16-bit integer range' ].\r\tn := anInteger < 0\r\t\tifTrue: [ 16r10000 + anInteger ]\r\t\tifFalse: [ anInteger ].\r\tself nextPut: (n byteAt: 2).\r\tself nextPut: (n byteAt: 1)"},{"name":"setToEnd","linesOfCode":3,"sourceCode":"setToEnd\r\t\"Set the position of the receiver to the end of the sequence of objects.\"\r\r\tposition := readLimit"},{"name":"skipTo:","linesOfCode":6,"sourceCode":"skipTo: anObject \r\t\"Set the access position of the receiver to be past the next occurrence of \r\tanObject. Answer whether anObject is found.\"\r\r\t[self atEnd]\r\t\twhileFalse: [self next = anObject ifTrue: [^true]].\r\t^false"},{"name":"next:putAll:","linesOfCode":3,"sourceCode":"next: anInteger putAll: aCollection\r\t\"Store the next anInteger elements from the given collection.\"\r\t^self next: anInteger putAll: aCollection startingAt: 1"},{"name":"string:","linesOfCode":5,"sourceCode":"string: aString\r\t\"Store the given string on this (binary) stream. The string must contain 65535 or fewer characters.\"\r\r\taString size > 16rFFFF ifTrue: [self error: 'string too long for this format'].\r\tself uint16: aString size.\r\tself nextPutAll: aString asByteArray.\r"},{"name":"nextChunk","linesOfCode":15,"sourceCode":"nextChunk\r\t\"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.\"\r\r\t| terminator out ch |\r\tterminator := $!.\r\tout := (String new: 1000) writeStream.\r\tself skipSeparators.\r\t[ (ch := self next) isNil ]\r\t\twhileFalse: [ \r\t\t\tch == terminator\r\t\t\t\tifTrue: [ \r\t\t\t\t\tself peek == terminator\r\t\t\t\t\t\tifTrue: [ self next\t\"skip doubled terminator\" ]\r\t\t\t\t\t\tifFalse: [ ^ self parseLangTagFor: out contents\t\"terminator is not doubled; we're done!\" ] ].\r\t\t\tout nextPut: ch ].\r\t^ self parseLangTagFor: out contents"},{"name":"readInto:startingAt:count:","linesOfCode":8,"sourceCode":"readInto: aCollection startingAt: startIndex count: n\r\t\"Read n objects into the given collection. \r\tReturn number of elements that have been read.\"\r\t\r\t| obj |\r\t0 to: n - 1 do: [ :i |\r\t\t(obj := self next) == nil ifTrue: [ ^ i ].\r\t\taCollection at: startIndex + i put: obj ].\r\t^ n"},{"name":"positionOfSubCollection:","linesOfCode":4,"sourceCode":"positionOfSubCollection: subCollection\r\t\"Return a position such that that element at the new position equals the first element of sub, and the next elements equal the rest of the elements of sub. Begin the search at the current position.\r\tIf no such match is found, answer 0.\"\r\r\t^self positionOfSubCollection: subCollection ifAbsent: [0]"},{"name":"verbatim:","linesOfCode":3,"sourceCode":"verbatim: aString\r\t\"Do not attempt to translate the characters.  Use to override nextPutAll:\"\r\t^ self nextPutAll: aString"},{"name":"setToStart","linesOfCode":3,"sourceCode":"setToStart\r\t\"Set the position of the receiver to the start of the sequence of objects.\"\r\r\tself reset"}],"meta":{"name":"PositionableStream class","instanceVariables":[],"methods":[{"name":"with:do:","linesOfCode":5,"sourceCode":"with: aCollectionOrStream do: aBlock\r\t\"Evaluates a block with a new stream based on the collection or stream. Answers the result of the block evaluation. Follows the style of FileStream>>fileNamed:do:.\"\r\t| aStream |\r\taStream := self on: aCollectionOrStream.\r\t[ ^ aBlock value: aStream ] ensure: [ aStream close ]"},{"name":"on:","linesOfCode":3,"sourceCode":"on: aCollection \r\t\"Answer an instance of me, streaming over the elements of aCollection.\"\r\r\t^self basicNew on: aCollection"},{"name":"on:from:to:","linesOfCode":8,"sourceCode":"on: aCollection from: firstIndex to: lastIndex \r\t\"Answer an instance of me on a copy of the argument, aCollection, \r\tdetermined by the indices firstIndex and lastIndex. Position the instance \r\tat the beginning of the collection.\"\r\r\t^self basicNew\r\t\ton: aCollection\r\t\tfrom: firstIndex\r\t\tto: lastIndex"}],"meta":null}},{"name":"ManifestCollectionsStreams","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsStreams class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#UIManager #'Collections-Abstract')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Strings' #'Collections-Support' #'Collections-Sequenceable' #Kernel #'Collections-Native')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Streams'"}],"meta":null}},{"name":"ReadWriteStream","instanceVariables":[],"methods":[{"name":"=","linesOfCode":4,"sourceCode":"= other\r\r\t(self class == ReadWriteStream and: [other class == ReadWriteStream]) ifFalse: [\r\t\t^ super = other].\t\"does an identity test.  Don't read contents of FileStream\"\r\t^ self position = other position and: [self contents = other contents]"},{"name":"readStream","linesOfCode":3,"sourceCode":"readStream\r\t\"polymorphic with SequenceableCollection.  Return self\"\r\r\t^ self"},{"name":"isZipArchive","linesOfCode":7,"sourceCode":"isZipArchive\r\t\"Determine if this appears to be a valid Zip archive\"\r\t| sig |\r\tself binary.\r\tsig := self next: 4.\r\tself position: self position - 4. \"rewind\"\r\t^ZipArchive validSignatures includes: sig"},{"name":"next:","linesOfCode":8,"sourceCode":"next: anInteger \r\t\"Answer the next anInteger elements of my collection.  overriden for efficiency\"\r\r\t| ans endPosition |\r\treadLimit := readLimit max: position.\r\r\tendPosition := position + anInteger  min:  readLimit.\r\tans := collection copyFrom: position+1 to: endPosition.\r\tposition := endPosition.\r\t^ans\r"},{"name":"hash","linesOfCode":3,"sourceCode":"hash\r\r\tself class == ReadWriteStream ifFalse: [^ super hash].\r\t^ (self position + readLimit + 53) hash"},{"name":"contents","linesOfCode":3,"sourceCode":"contents\r\r\treadLimit := readLimit max: position.\r\t^ collection copyFrom: 1 to: readLimit"},{"name":"next","linesOfCode":10,"sourceCode":"next\r\t\"Primitive. Return the next object in the Stream represented by the\r\treceiver. Fail if the collection of this stream is not an Array or a String.\r\tFail if the stream is positioned at its end, or if the position is out of\r\tbounds in the collection. Optional. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t\"treat me as a FIFO\"\r\tposition >= readLimit\r\t\tifTrue: [^nil]\r\t\tifFalse: [^collection at: (position := position + 1)]"},{"name":"readInto:startingAt:count:","linesOfCode":12,"sourceCode":"readInto: aCollection startingAt: startIndex count: n\r\t\"Read n objects into the given collection. \r\tReturn number of elements that have been read.\"\r\t\r\t| max |\r\tmax := (readLimit - position) min: n.\r\taCollection \r\t\treplaceFrom: startIndex \r\t\tto: startIndex + max - 1\r\t\twith: collection\r\t\tstartingAt: position + 1.\r\tposition := position + max.\r\t^ max"},{"name":"name","linesOfCode":2,"sourceCode":"name\r\t^ 'a stream'   \"for fileIn compatibility\""}],"meta":{"name":"ReadWriteStream class","instanceVariables":[],"methods":[],"meta":null}},{"name":"NullStream","instanceVariables":[{"name":"binary"},{"name":"position"},{"name":"lastElement"}],"methods":[{"name":"lf","linesOfCode":2,"sourceCode":"lf\r\t^ self nextPut: Character lf"},{"name":"isEmpty","linesOfCode":3,"sourceCode":"isEmpty\r\t\"Answer whether the receiver's contents has no elements.\"\r\r\t^false\r"},{"name":"cr","linesOfCode":2,"sourceCode":"cr\r\t^ self nextPut: Character cr"},{"name":"element","linesOfCode":3,"sourceCode":"element\r\t\"The element returned by the stream\"\r\r\t^binary ifTrue: [0] ifFalse: [Character value: 0]"},{"name":"peekLast","linesOfCode":2,"sourceCode":"peekLast\r\t^ lastElement"},{"name":"next:","linesOfCode":6,"sourceCode":"next: anInteger \r\t\"Answer the next anInteger elements of my collection. Must override \r\tbecause default uses self contents species, which might involve a large \r\tcollection.\"\r\r\tposition := position + anInteger.\r\t^self collectionSpecies new: anInteger"},{"name":"next:into:","linesOfCode":5,"sourceCode":"next: n into: aCollection\r\t\"Read n objects into the given collection.\r\tReturn aCollection or a partial copy if less than\r\tn elements have been read.\"\r\r\t^self next: n into: aCollection startingAt: 1"},{"name":"position:","linesOfCode":7,"sourceCode":"position: anInteger \r\t\"Set the current position for accessing the objects to be anInteger, as long \r\tas anInteger is within the bounds of the receiver's contents. If it is not, \r\tcreate an error notification.\"\r\r\t(anInteger >= 0)\r\t\tifTrue: [position := anInteger]\r\t\tifFalse: [self positionError]"},{"name":"next","linesOfCode":4,"sourceCode":"next\r\t\"Answer the next object accessible by the receiver.\"\r\r\tposition := position + 1.\r\t^self element"},{"name":"next:into:startingAt:","linesOfCode":6,"sourceCode":"next: n into: aCollection startingAt: startIndex\r\t\"Read n objects into the given collection. \r\tReturn aCollection or a partial copy if less than\r\tn elements have been read.\"\r\r\tposition := position + n.\r\t^aCollection"},{"name":"nextPutAll:","linesOfCode":7,"sourceCode":"nextPutAll: aCollection\r\t\"Append the elements of aCollection to the sequence of objects accessible \r\tby the receiver. Answer aCollection.\"\r\r\tposition := position + aCollection size.\r\taCollection isEmpty\r\t\tifFalse: [ lastElement := aCollection last ].\r\t^ aCollection"},{"name":"atEnd","linesOfCode":3,"sourceCode":"atEnd\r\t\"Answer whether the receiver can access any more objects.\"\r\r\t^false"},{"name":"peek","linesOfCode":4,"sourceCode":"peek\r\t\"Answer what would be returned if the message next were sent to the \r\treceiver. If the receiver is at the end, answer nil.\"\r\r\t^self element"},{"name":"collectionSpecies","linesOfCode":3,"sourceCode":"collectionSpecies\r\t\"The type of collection returned by the stream\"\r\r\t^binary ifTrue: [ByteArray] ifFalse: [ByteString]"},{"name":"nextPut:","linesOfCode":6,"sourceCode":"nextPut: anObject \r\t\"Insert the argument, anObject, as the next object accessible by the \r\treceiver. Answer anObject.\"\r\r\tposition := position + 1.\r\tlastElement := anObject.\r\t^anObject"},{"name":"position","linesOfCode":3,"sourceCode":"position\r\t\"Answer the current position of accessing the sequence of objects.\"\r\r\t^position"},{"name":"isBinary","linesOfCode":3,"sourceCode":"isBinary\r\t\"Return true if the receiver is a binary byte stream\"\r\r\t^binary "},{"name":"printOn:","linesOfCode":2,"sourceCode":"printOn: aStream\r\taStream nextPutAll: 'a '; nextPutAll: self class name."},{"name":"reset","linesOfCode":3,"sourceCode":"reset\r\t\"Set the receiver's position to the beginning of the sequence of objects.\"\r\r\tposition := 0"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\t\"Initialize the receiver\"\r\r\tbinary := false.\r\tposition := 0."},{"name":"tab","linesOfCode":2,"sourceCode":"tab\r\t^ self nextPut: Character tab"},{"name":"contents","linesOfCode":3,"sourceCode":"contents\r\t\"Answer all of the contents of the receiver.\"\r\r\tself shouldNotImplement"},{"name":"binary","linesOfCode":3,"sourceCode":"binary\r\t\"Switches the stream to binary mode\"\r\r\tbinary := true"},{"name":"positionError","linesOfCode":4,"sourceCode":"positionError\r\t\"Since I am not necessarily writable, it is up to my subclasses to override \r\tposition: if expanding the collection is preferrable to giving this error.\"\r\r\tself error: 'Attempt to set the position of a PositionableStream out of bounds'"},{"name":"nextInto:","linesOfCode":5,"sourceCode":"nextInto: aCollection\r\t\"Read the next elements of the receiver into aCollection.\r\tReturn aCollection or a partial copy if less than aCollection\r\tsize elements have been read.\"\r\r\t^self next: aCollection size into: aCollection startingAt: 1."},{"name":"ascii","linesOfCode":3,"sourceCode":"ascii\r\t\"Switches the stream to ascii mode\"\r\r\tbinary := false."},{"name":"nextInto:startingAt:","linesOfCode":5,"sourceCode":"nextInto: aCollection startingAt: startIndex\r\t\"Read the next elements of the receiver into aCollection.\r\tReturn aCollection or a partial copy if less than aCollection\r\tsize elements have been read.\"\r\r\t^self next: (aCollection size - startIndex +1) into: aCollection startingAt: startIndex."},{"name":"skip:","linesOfCode":6,"sourceCode":"skip: anInteger \r\t\"Set the receiver's position to be the current position+anInteger. A \r\tsubclass might choose to be more helpful and select the minimum of the \r\treceiver's size and position+anInteger, or the maximum of 1 and \r\tposition+anInteger for the repositioning.\"\r\r\tself position: position + anInteger"},{"name":"space","linesOfCode":2,"sourceCode":"space\r\t^ self nextPut: Character space"},{"name":"next:putAll:","linesOfCode":3,"sourceCode":"next: anInteger putAll: aCollection\r\t\"Store the next anInteger elements from the given collection.\"\r\r\t^self next: anInteger putAll: aCollection startingAt: 1"},{"name":"next:putAll:startingAt:","linesOfCode":5,"sourceCode":"next: anInteger putAll: aCollection startingAt: startIndex\r\t\"Store the next anInteger elements from the given collection.\"\r\r\tposition := position + anInteger.\r\tlastElement := aCollection at: anInteger + startIndex - 1.\r\t^aCollection"},{"name":"readInto:startingAt:count:","linesOfCode":5,"sourceCode":"readInto: collection startingAt: startIndex count: n\r\t\"Read n objects into the given collection. \r\tReturn number of elements that have been read.\"\r\r\tposition := position + n.\r\t^ n"}],"meta":{"name":"NullStream class","instanceVariables":[],"methods":[{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"Creates a new instance\"\r\r\t^self basicNew initialize"}],"meta":null}}]},{"name":"Collections-Streams-Tests","classes":[{"name":"LimitedWriteStreamTest","instanceVariables":[],"methods":[{"name":"testNextPutAll","linesOfCode":15,"sourceCode":"testNextPutAll\r\t| stream overLimit |\r\tsuper testNextPutAll.\r\tstream := self streamClass on: String new limit: self stringSize limitBlock: [ overLimit := true ].\r\toverLimit := false.\r\tself\r\t\tassert: (stream nextPutAll: self string) equals: self string;\r\t\tassert: stream position equals: self stringSize;\r\t\tassert: stream contents equals: self string;\r\t\tdeny: overLimit.\r\tself\r\t\tassert: (stream nextPutAll: self string) equals: self string;\r\t\tassert: stream position equals: self stringSize;\r\t\tassert: stream contents equals: self string;\r\t\tassert: overLimit"},{"name":"testOnLimitLimitBlock","linesOfCode":12,"sourceCode":"testOnLimitLimitBlock\r\t| collection overLimit limitBlock stream |\r\tcollection := String new.\r\toverLimit := false.\r\tlimitBlock := [ overLimit := true ].\r\tstream := self streamClass on: collection limit: self stringSize limitBlock: limitBlock.\r\tself\r\t\tassert: stream originalContents identicalTo: collection;\r\t\tassert: stream position isZero;\r\t\tassert: stream limit equals: self stringSize;\r\t\tassert: stream limitBlock equals: limitBlock;\r\t\tdeny: overLimit"},{"name":"testLimitBlock","linesOfCode":10,"sourceCode":"testLimitBlock\r\t| stream overLimit limitBlock |\r\tstream := self newStream.\r\toverLimit := false.\r\tlimitBlock := [ overLimit := true ].\r\tself\r\t\tassert: stream limitBlock isNil;\r\t\tassert: (stream limitBlock: limitBlock) identicalTo: stream;\r\t\tassert: stream limitBlock identicalTo: limitBlock;\r\t\tdeny: overLimit"},{"name":"testOnFromTo","linesOfCode":7,"sourceCode":"testOnFromTo\r\t| stream |\r\tsuper testOnFromTo.\r\tstream := self streamClass on: self string , self string from: self stringSize + 1 to: self stringSize * 2.\r\tself\r\t\tassert: stream limit equals: self streamClass defaultLimit;\r\t\tassert: stream limitBlock isNil"},{"name":"testWithFromTo","linesOfCode":25,"sourceCode":"testWithFromTo\r\t\"like with: except it paritions its argument collection first using the\r\tfrom:/to: indexes\"\r\r\t| stream overLimit |\r\tsuper testWithFromTo.\r\r\tstream := self streamClass with: self string , self string from: 1 to: self stringSize.\r\toverLimit := false.\r\tstream\r\t\tlimit: self stringSize * 2;\r\t\tlimitBlock: [ overLimit := true ].\r\tself string\r\t\twithIndexDo: [ :each :i | \r\t\t\tself\r\t\t\t\tassert: (stream nextPut: each) equals: each;\r\t\t\t\tassert: stream position equals: self stringSize + i;\r\t\t\t\tassert: stream contents equals: self string , (self string first: i);\r\t\t\t\tdeny: overLimit ].\r\tself string\r\t\tdo: [ :each | \r\t\t\toverLimit := false.\r\t\t\tself\r\t\t\t\tassert: (stream nextPut: each) equals: each;\r\t\t\t\tassert: stream position equals: self stringSize * 2;\r\t\t\t\tassert: stream contents equals: self string , self string;\r\t\t\t\tassert: overLimit ]"},{"name":"testSetLimitLimitBlock","linesOfCode":15,"sourceCode":"testSetLimitLimitBlock\r\t| stream overLimit |\r\tstream := self newStream.\r\toverLimit := false.\r\tself assert: (stream setLimit: self stringSize limitBlock: [ overLimit := true ]) identicalTo: stream.\r\tstream nextPutAll: self string.\r\tself deny: overLimit.\r\r\tself stringSize - 1 to: 0 by: -1 do: [ :i | \r\t\toverLimit := false.\r\t\t\"ensure the new block argument is used when the new limit is less than\r\t\tthe position by setting it to nil first\"\r\t\tself assert: (stream setLimit: stream position limitBlock: nil) identicalTo: stream.\r\t\tself deny: overLimit.\r\t\tself assert: (stream setLimit: i limitBlock: [ overLimit := true ]) identicalTo: stream.\r\t\tself assert: overLimit ]"},{"name":"testOn","linesOfCode":7,"sourceCode":"testOn\r\t| stream |\r\tsuper testOn.\r\tstream := self newStream.\r\tself\r\t\tassert: stream limit equals: self streamClass defaultLimit;\r\t\tassert: stream limitBlock isNil"},{"name":"testWith","linesOfCode":26,"sourceCode":"testWith\r\t\"like on: except it starts writing at the end of its argument collection,\r\tand the initial position is the collection size and the initial contents\r\tis the collection\"\r\r\t| stream overLimit |\r\tsuper testWith.\r\r\tstream := self streamClass with: self string.\r\toverLimit := false.\r\tstream\r\t\tlimit: self stringSize * 2;\r\t\tlimitBlock: [ overLimit := true ].\r\tself string\r\t\twithIndexDo: [ :each :i | \r\t\t\tself\r\t\t\t\tassert: (stream nextPut: each) equals: each;\r\t\t\t\tassert: stream position equals: self stringSize + i;\r\t\t\t\tassert: stream contents equals: self string , (self string first: i);\r\t\t\t\tdeny: overLimit ].\r\tself string\r\t\tdo: [ :each | \r\t\t\toverLimit := false.\r\t\t\tself\r\t\t\t\tassert: (stream nextPut: each) equals: each;\r\t\t\t\tassert: stream position equals: self stringSize * 2;\r\t\t\t\tassert: stream contents equals: self string , self string;\r\t\t\t\tassert: overLimit ]"},{"name":"streamClass","linesOfCode":2,"sourceCode":"streamClass\r\t^ LimitedWriteStream"},{"name":"testNextPut","linesOfCode":20,"sourceCode":"testNextPut\r\t| stream overLimit |\r\tsuper testNextPut.\r\r\tstream := self streamClass on: String new limit: self stringSize limitBlock: [ overLimit := true ].\r\toverLimit := false.\r\tself string\r\t\twithIndexDo: [ :each :i | \r\t\t\tself\r\t\t\t\tassert: (stream nextPut: each) equals: each;\r\t\t\t\tassert: stream position equals: i;\r\t\t\t\tassert: stream contents equals: (self string first: i);\r\t\t\t\tdeny: overLimit ].\r\tself string\r\t\tdo: [ :each | \r\t\t\toverLimit := false.\r\t\t\tself\r\t\t\t\tassert: (stream nextPut: each) equals: each;\r\t\t\t\tassert: stream position equals: self stringSize;\r\t\t\t\tassert: stream contents equals: self string;\r\t\t\t\tassert: overLimit ]"},{"name":"testLimit","linesOfCode":20,"sourceCode":"testLimit\r\t| stream overLimit |\r\tstream := self newStream.\r\toverLimit := false.\r\tstream\r\t\tlimitBlock: [ overLimit := true ];\r\t\tnextPutAll: self string.\r\tself\r\t\tassert: stream limit equals: self streamClass defaultLimit;\r\t\tassert: (stream limit: self stringSize) identicalTo: stream;\r\t\tassert: stream limit equals: self stringSize;\r\t\tdeny: overLimit.\r\r\tself stringSize - 1 to: 0 by: -1 do: [ :i | \r\t\toverLimit := false.\r\t\tself\r\t\t\tassert: (stream limit: i) identicalTo: stream;\r\t\t\tassert: stream limit equals: i;\r\t\t\tassert: stream position equals: i;\r\t\t\tassert: stream contents equals: (self string first: i);\r\t\t\tassert: overLimit ]"}],"meta":{"name":"LimitedWriteStreamTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"NullStreamTest","instanceVariables":[{"name":"stream"}],"methods":[{"name":"testCounting","linesOfCode":25,"sourceCode":"testCounting\r\t| expectedPosition |\r\texpectedPosition := 0.\r\tself assert: stream position equals: expectedPosition.\r\t\r\tstream nextPut: $a.\r\texpectedPosition := expectedPosition + 1.\r\tself assert: stream position equals: expectedPosition.\r\t\r\tstream nextPutAll: 'bcd'.\r\texpectedPosition := expectedPosition + 3.\r\tself assert: stream position equals: expectedPosition.\r\t\r\tstream cr.\r\texpectedPosition := expectedPosition + 1.\r\tself assert: stream position equals: expectedPosition.\r\t\r\tstream lf.\r\texpectedPosition := expectedPosition + 1.\r\tself assert: stream position equals: expectedPosition.\r\t\r\tstream space.\r\texpectedPosition := expectedPosition + 1.\r\tself assert: stream position equals: expectedPosition.\r\t\r\tstream tab.\r\texpectedPosition := expectedPosition + 1.\r\tself assert: stream position equals: expectedPosition.\r\t\r\tstream next: 4 putAll: 'abcdefgh' startingAt: 3.\r\texpectedPosition := expectedPosition + 4.\r\tself assert: stream position equals: expectedPosition."},{"name":"setUp","linesOfCode":3,"sourceCode":"setUp\r\tsuper setUp.\r\tstream := NullStream new."},{"name":"testPeekLast","linesOfCode":16,"sourceCode":"testPeekLast\r\tself assert: stream peekLast equals: nil.\r\tstream nextPut: $a.\r\tself assert: stream peekLast equals: $a.\r\tstream nextPutAll: 'bcd'.\r\tself assert: stream peekLast equals: $d.\r\tstream cr.\r\tself assert: stream peekLast equals: Character cr.\r\tstream lf.\r\tself assert: stream peekLast equals: Character lf.\r\tstream space.\r\tself assert: stream peekLast equals: Character space.\r\tstream tab.\r\tself assert: stream peekLast equals: Character tab.\r\tstream next: 4 putAll: 'abcdefgh' startingAt: 3.\r\tself assert: stream peekLast equals: $f."},{"name":"testNextPutAllEmpty","linesOfCode":6,"sourceCode":"testNextPutAllEmpty\r\tself assert: stream position equals: 0.\r\tself assert: stream peekLast equals: nil.\r\tstream nextPutAll: ''.\r\tself assert: stream position equals: 0.\r\tself assert: stream peekLast equals: nil."}],"meta":{"name":"NullStreamTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WriteStreamTest","instanceVariables":[],"methods":[{"name":"stringSize","linesOfCode":2,"sourceCode":"stringSize\r\t^ self string size"},{"name":"testEnsureNoSpace","linesOfCode":12,"sourceCode":"testEnsureNoSpace\r\t \r\t| stream |\r\tstream := self newStream.\r\tstream ensureNoSpace.\r\t\r\tself assert: stream contents equals: ''.\r\t\r\tstream nextPutAll: ' a '.\r\tstream ensureNoSpace.\r\tself assert: stream contents equals: ' a'.\r\t\r\tstream nextPutAll: 'b  '.\r\tstream ensureNoSpace.\r\tself assert: stream contents equals: ' ab'.\r\r\t\r\t\r\t"},{"name":"testSetToEnd","linesOfCode":14,"sourceCode":"testSetToEnd\r\t| stream |\r\tstream := self newStream.\r\tself\r\t\tassert: stream setToEnd identicalTo: stream;\r\t\tassert: stream position isZero;\r\t\tassert: stream contents isEmpty.\r\tstream nextPutAll: self string.\r\tself stringSize - 1 to: 0 by: -1 do: [ :i | \r\t\tstream position: i.\r\t\tself\r\t\t\tassert: stream setToEnd identicalTo: stream;\r\t\t\tassert: stream position equals: self stringSize;\r\t\t\tassert: stream contents equals: self string ]"},{"name":"newStream","linesOfCode":2,"sourceCode":"newStream\r\t^ self newStreamOn: String new"},{"name":"streamClass","linesOfCode":2,"sourceCode":"streamClass\r\t^ WriteStream"},{"name":"string","linesOfCode":2,"sourceCode":"string\r\t^ 'testing'"},{"name":"testIsEmpty","linesOfCode":8,"sourceCode":"testIsEmpty\r\t| stream |\r\tstream := self newStream.\r\tself assert: stream isEmpty.\r\tstream nextPut: $a.\r\tself deny: stream isEmpty.\r\tstream reset.\r\tself deny: stream isEmpty."},{"name":"newStreamOn:","linesOfCode":2,"sourceCode":"newStreamOn: aCollection\r\t^ self streamClass on: aCollection"},{"name":"testLessThanLessThan","linesOfCode":14,"sourceCode":"testLessThanLessThan\r\t\"Tests for #<< output operator shortcut on WriteStreams\"\r\t\r\tself \r\t\tassert: (String streamContents: [ :out | out << $a << 'bcd' << $e ])\r\t\tequals: 'abcde'.\r\tself \r\t\tassert: (ByteArray streamContents: [ :out | out << 1 << #[2 3 4] << 5 ])\r\t\tequals: #[1 2 3 4 5].\r\tself \r\t\tassert: (Array streamContents: [ :out | out << 1 << #(2 3 4) asOrderedCollection << 5 ])\r\t\tequals: #(1 2 3 4 5).\r\t\"no conversions, wrong element type\"\r\tself should: [ String streamContents: [ :out | out << 1234 ] ] raise: Error.\r\tself should: [ ByteArray streamContents: [ :out | out << 1234 ] ] raise: Error"},{"name":"testNextPutAll","linesOfCode":7,"sourceCode":"testNextPutAll\r\t| stream |\r\tstream := self newStream.\r\tself\r\t\tassert: (stream nextPutAll: self string) equals: self string;\r\t\tassert: stream position equals: self stringSize;\r\t\tassert: stream contents equals: self string"},{"name":"testWith","linesOfCode":11,"sourceCode":"testWith\r\t\"like on: except it starts writing at the end of its argument collection,\r\tand the initial position is the collection size and the initial contents\r\tis the collection\"\r\r\t| stream |\r\tstream := self streamClass with: self string.\r\tself\r\t\tassert: stream originalContents equals: self string;\r\t\tassert: stream position equals: self stringSize;\r\t\tassert: stream contents equals: self string;\r\t\tassert: stream size equals: self stringSize"},{"name":"testEnsureASpace2","linesOfCode":5,"sourceCode":"testEnsureASpace2\r\t| stream |\r\tstream := self newStream.\r\tstream ensureASpace.\r\tself assert: stream contents equals: ' '"},{"name":"testOnFromTo","linesOfCode":8,"sourceCode":"testOnFromTo\r\t| stream |\r\tstream := self streamClass on: self string , self string from: self stringSize + 1 to: self stringSize * 2.\r\tself\r\t\tassert: stream originalContents equals: self string , self string;\r\t\tassert: stream position equals: self stringSize;\r\t\tassert: stream contents equals: self string;\r\t\tassert: stream size equals: self stringSize * 2"},{"name":"testWithFromTo","linesOfCode":10,"sourceCode":"testWithFromTo\r\t\"like with: except it paritions its argument collection first using the\r\tfrom:/to: indexes\"\r\r\t| stream |\r\tstream := self streamClass with: self string , self string from: 1 to: self stringSize.\r\tself\r\t\tassert: stream originalContents equals: self string;\r\t\tassert: stream position equals: self stringSize;\r\t\tassert: stream contents equals: self string;\r\t\tassert: stream size equals: self stringSize"},{"name":"testOn","linesOfCode":9,"sourceCode":"testOn\r\t| collection stream |\r\tcollection := String new.\r\tstream := self streamClass on: collection.\r\tself\r\t\tassert: stream originalContents identicalTo: collection;\r\t\tassert: stream position isZero;\r\t\tassert: stream contents isEmpty;\r\t\tassert: stream size isZero"},{"name":"testEnsureEndsWith","linesOfCode":17,"sourceCode":"testEnsureEndsWith\r\t\r\t| stream |\r\tstream := self newStream.\r\tstream nextPutAll: 'this is a test'.\r\tstream ensureEndsWith: Character cr.\r\tstream nextPutAll: 'for WriteStreamTest'.\r\tself assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').\r\t\r\t\"Manually put a new line and verify there are no 2 new lines\"\r\tstream := self newStream.\r\tstream nextPutAll: ('this is a test' copyWith: Character cr).\r\tstream ensureEndsWith: Character cr.\r\tstream nextPutAll: 'for WriteStreamTest'.\r\tself assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').\r\t\r\t\"Test with a empty stream\"\r\tstream := self newStream.\r\tstream ensureEndsWith: Character cr.\r\tself assert: stream contents equals: ''."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ self streamClass"},{"name":"testPosition","linesOfCode":13,"sourceCode":"testPosition\r\t| stream |\r\tstream := self newStream.\r\tstream nextPutAll: self string.\r\t0 to: self stringSize do: [ :i | \r\t\tself\r\t\t\tassert: stream position equals: self stringSize;\r\t\t\tassert: (stream position: i) identicalTo: stream;\r\t\t\tassert: stream position equals: i;\r\t\t\tassert: stream contents equals: (self string first: i).\r\t\tstream position: self stringSize ].\r\tself should: [ stream position: -1 ] raise: Error.\r\tself should: [ stream position: self stringSize + 1 ] raise: Error"},{"name":"testNew","linesOfCode":2,"sourceCode":"testNew\r\r\tself should: [self streamClass new] raise: Error. "},{"name":"testNextPut","linesOfCode":9,"sourceCode":"testNextPut\r\t| stream |\r\tstream := self newStream.\r\tself string\r\t\twithIndexDo: [ :each :i | \r\t\t\tself\r\t\t\t\tassert: (stream nextPut: each) equals: each;\r\t\t\t\tassert: stream position equals: i;\r\t\t\t\tassert: stream contents equals: (self string first: i) ]"},{"name":"testEnsureASpace","linesOfCode":13,"sourceCode":"testEnsureASpace\r\t| stream |\r\tstream := self newStream.\r\tstream nextPutAll: 'this is a test'.\r\tstream ensureASpace.\r\tstream nextPutAll: 'for WriteStreamTest'.\r\tself assert: stream contents equals: 'this is a test for WriteStreamTest'.\r\r\t\"Manually put a space and verify there are no 2 consecutive spaces\"\r\tstream := self newStream.\r\tstream nextPutAll: 'this is a test '.\r\tstream ensureASpace.\r\tstream nextPutAll: 'for WriteStreamTest'.\r\tself assert: stream contents equals: 'this is a test for WriteStreamTest'"}],"meta":{"name":"WriteStreamTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\t^ true"}],"meta":null}},{"name":"StreamBugsTest","instanceVariables":[],"methods":[{"name":"testReadWriteStreamNextNBug","linesOfCode":5,"sourceCode":"testReadWriteStreamNextNBug\r\t| aStream |\r\taStream := ReadWriteStream on: String new.\r\taStream nextPutAll: 'Hello World'.\r\taStream next: 5"}],"meta":{"name":"StreamBugsTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"GeneratorTest","instanceVariables":[],"methods":[{"name":"testClose","linesOfCode":24,"sourceCode":"testClose\r\t| generator doEnsure notEnsure |\r\tdoEnsure := notEnsure := 0.\r\t[ generator := Generator\r\t\ton: [ :g | \r\t\t\t[ g\r\t\t\t\tyield: 1;\r\t\t\t\tyield: 2 ]\r\t\t\t\tensure: [ doEnsure := doEnsure + 1 ] ].\r\tself\r\t\tassert: doEnsure equals: 0;\r\t\tassert: notEnsure equals: 0.\r\tself assert: generator peek equals: 1.\r\tself\r\t\tassert: doEnsure equals: 0;\r\t\tassert: notEnsure equals: 0.\r\tgenerator close.\r\tself\r\t\tassert: doEnsure equals: 1;\r\t\tassert: notEnsure equals: 0 ]\r\t\tensure: [ notEnsure := notEnsure + 1 ].\r\tself\r\t\tassert: doEnsure equals: 1;\r\t\tassert: notEnsure equals: 1"},{"name":"fibonacciSequence","linesOfCode":8,"sourceCode":"fibonacciSequence\r\t\"Yields an infinite sequence of fibonacci numbers.\"\r\t\r\t^ Generator on: [ :generator |\r\t\t| a b |\r\t\ta := 0. b := 1.\r\t\t[ a := b + (b := a).\r\t\t  generator yield: a ]\r\t\t\trepeat ]"},{"name":"testPeek","linesOfCode":7,"sourceCode":"testPeek\r\t| generator |\r\tgenerator := self numbersBetween: 1 and: 3.\r\tself assert: generator peek equals: 1.\r\tself assert: generator peek equals: 1.\r\tgenerator next.\r\tself assert: generator peek equals: 2"},{"name":"testReset","linesOfCode":12,"sourceCode":"testReset\r\t| generator |\r\tgenerator := self numbersBetween: 1 and: 3.\r\tself assert: generator next equals: 1.\r\tself assert: generator next equals: 2.\r\tgenerator reset.\r\tself assert: generator next equals: 1.\r\tself assert: generator next equals: 2.\r\tself assert: generator next equals: 3.\r\tself assert: generator next equals: nil.\r\tgenerator reset.\r\tself assert: generator next equals: 1"},{"name":"testEmpty","linesOfCode":6,"sourceCode":"testEmpty\r\t| generator |\r\tgenerator := Generator on: [ :g | ].\r\tself assert: generator atEnd.\r\tself assert: generator peek isNil.\r\tself assert: generator next isNil"},{"name":"numbersBetween:and:","linesOfCode":5,"sourceCode":"numbersBetween: aStartInteger and: aStopInteger\r\t\"Yields the nubmers between aStartInteger and aStopInteger.\"\r\t\r\t^ Generator on: [ :generator |\r\t\taStartInteger to: aStopInteger \r\t\t\tdo: [ :value | generator yield: value ] ]"},{"name":"testFibonacci","linesOfCode":4,"sourceCode":"testFibonacci\r\t| generator |\r\tgenerator := self fibonacciSequence.\r\tself assert: (generator next: 10) asArray equals: #(1 1 2 3 5 8 13 21 34 55)"},{"name":"testNext","linesOfCode":7,"sourceCode":"testNext\r\t| generator |\r\tgenerator := self numbersBetween: 1 and: 3.\r\tself assert: generator next equals: 1.\r\tself assert: generator next equals: 2.\r\tself assert: generator next equals: 3.\r\tself assert: generator next isNil"},{"name":"testAtEnd","linesOfCode":10,"sourceCode":"testAtEnd\r\t| generator |\r\tgenerator := self numbersBetween: 1 and: 3.\r\tself deny: generator atEnd.\r\tgenerator next.\r\tself deny: generator atEnd.\r\tgenerator next.\r\tself deny: generator atEnd.\r\tgenerator next.\r\tself assert: generator atEnd"},{"name":"testErrorPropagation","linesOfCode":8,"sourceCode":"testErrorPropagation\r\t\"Ensure that errors in the generator block are properly propagated\"\r\r\t| generator |\r\tgenerator := Generator\r\t\ton: [ :g | \r\t\t\tg yield: 1.\r\t\t\tg error: 'yo' ].\r\tself should: [ generator next ] raise: Error"},{"name":"testResetUnwind","linesOfCode":25,"sourceCode":"testResetUnwind\r\t\"Just like close, just using reset\"\r\r\t| generator doEnsure notEnsure |\r\tdoEnsure := notEnsure := 0.\r\t[ generator := Generator\r\t\ton: [ :g | \r\t\t\t[ g\r\t\t\t\tyield: 1;\r\t\t\t\tyield: 2 ]\r\t\t\t\tensure: [ doEnsure := doEnsure + 1 ] ].\r\tself\r\t\tassert: doEnsure equals: 0;\r\t\tassert: notEnsure equals: 0.\r\tself assert: generator peek equals: 1.\r\tself\r\t\tassert: doEnsure equals: 0;\r\t\tassert: notEnsure equals: 0.\r\tgenerator reset.\r\tself\r\t\tassert: doEnsure equals: 1;\r\t\tassert: notEnsure equals: 0 ]\r\t\tensure: [ notEnsure := notEnsure + 1 ].\r\tself\r\t\tassert: doEnsure equals: 1;\r\t\tassert: notEnsure equals: 1"},{"name":"testSimple","linesOfCode":8,"sourceCode":"testSimple\r\t| generator |\r\tgenerator := Generator\r\t\ton: [ :g | \r\t\t\tg\r\t\t\t\tyield: 1;\r\t\t\t\tyield: 2 ].\r\tself assert: generator upToEnd asArray equals: #(1 2)"},{"name":"testEnsure","linesOfCode":9,"sourceCode":"testEnsure\r\t| generator |\r\tgenerator := Generator\r\t\ton: [ :g | \r\t\t\t[ g\r\t\t\t\tyield: 1;\r\t\t\t\tyield: 2 ]\r\t\t\t\tensure: [ g yield: 3 ] ].\r\tself assert: generator upToEnd asArray equals: #(1 2 3)"},{"name":"testContents","linesOfCode":4,"sourceCode":"testContents\r\t| generator |\r\tgenerator := self numbersBetween: 1 and: 3.\r\tself assert: generator contents equals: #(1 2 3)"}],"meta":{"name":"GeneratorTest class","instanceVariables":[],"methods":[{"name":"packageNamesUnderTest","linesOfCode":2,"sourceCode":"packageNamesUnderTest\r\t^ #('Generator')"}],"meta":null}},{"name":"ReadWriteStreamTest","instanceVariables":[],"methods":[{"name":"testUpToEnd","linesOfCode":26,"sourceCode":"testUpToEnd\r\t| stream |\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abcd';\r\t\treset.\r\tself assert: stream upToEnd equals: 'abcd'.\r\tself assert: stream atEnd.\r\tself assert: stream upToEnd equals: ''.\r\tself assert: stream atEnd.\r\tstream reset.\r\tstream upTo: $b.\r\tself assert: stream upToEnd equals: 'cd'.\r\tself assert: stream atEnd.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abcd' asByteArray;\r\t\treset.\r\tself assert: stream upToEnd equals: #(97 98 99 100) asByteArray.\r\tself assert: stream atEnd.\r\tself assert: stream upToEnd equals: #() asByteArray.\r\tself assert: stream atEnd.\r\tstream reset.\r\tstream upTo: 98.\r\tself assert: stream upToEnd equals: #(99 100) asByteArray.\r\tself assert: stream atEnd"},{"name":"emptyStream","linesOfCode":2,"sourceCode":"emptyStream\r\t^ ReadWriteStream on: (String new: 4096)."},{"name":"emptyByteStream","linesOfCode":2,"sourceCode":"emptyByteStream\r\t^ ReadWriteStream on: (ByteArray new: 4096)."},{"name":"streamOnString","linesOfCode":2,"sourceCode":"streamOnString\r\t^ ReadWriteStream with: 'abcde'."},{"name":"testPeek","linesOfCode":14,"sourceCode":"testPeek\r\t| stream |\r\tstream := self emptyStream.\r\tself assert: stream peek isNil.\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abcd';\r\t\treset.\r\tself assert: stream peek equals: $a.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abcd' asByteArray;\r\t\treset.\r\tself assert: stream peek equals: 97"},{"name":"testIsEmpty","linesOfCode":10,"sourceCode":"testIsEmpty\r\t| stream |\r\tstream := self emptyStream.\r\tself assertEmpty: stream.\r\tstream nextPut: $a.\r\tself deny: stream isEmpty.\r\tstream reset.\r\tself deny: stream isEmpty.\r\tstream next.\r\tself deny: stream isEmpty."},{"name":"testReset","linesOfCode":22,"sourceCode":"testReset\r\t| stream |\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abc';\r\t\treset.\r\tstream next: 2.\r\tstream reset.\r\tself assert: stream next equals: $a.\r\tstream := self emptyStream.\r\tstream \r\t\tnextPutAll: 'abc';\r\t\treset.\r\tstream nextPutAll: 'def'.\r\tself assert: stream contents equals: 'def'.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abc' asByteArray;\r\t\treset.\r\tstream next: 2.\r\tstream reset.\r\tself assert: stream next equals: 97"},{"name":"testConstructionUsingWith","linesOfCode":5,"sourceCode":"testConstructionUsingWith\r\t\"Use the with: constructor.\"\r\r\t| aStream |\r\taStream := ReadWriteStream with: #(1 2).\r\tself assert: (aStream contents = #(1 2)) description: 'Ensure correct initialization.'"},{"name":"testNextPutAll","linesOfCode":11,"sourceCode":"testNextPutAll\r\t| stream |\r\tstream := self emptyStream.\r\tstream nextPutAll: 'abc'.\r\tself assert: stream contents equals: 'abc'.\r\tstream := self emptyStream.\r\tstream nextPutAll: #($a $b $c).\r\tself assert: stream contents equals: 'abc'.\r\tstream := self emptyByteStream.\r\tstream nextPutAll: #(97 98 99 ) asByteArray.\r\tself assert: stream contents equals: 'abc' asByteArray"},{"name":"testNext","linesOfCode":18,"sourceCode":"testNext\r\t| stream |\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abcd';\r\t\treset.\r\tself assert: stream next equals: $a.\r\tself assert: (stream next: 0) equals: ''.\r\tself assert: (stream next: 1) equals: 'b'.\r\tself assert: (stream next: 2) equals: 'cd'.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abcd' asByteArray;\r\t\treset.\r\tself assert: stream next equals: 97.\r\tself assert: (stream next: 0) equals: '' asByteArray.\r\tself assert: (stream next: 1) equals: 'b' asByteArray.\r\tself assert: (stream next: 2) equals: 'cd' asByteArray"},{"name":"testUpTo","linesOfCode":26,"sourceCode":"testUpTo\r\t| stream |\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abcd';\r\t\treset.\r\tself assert: (stream upTo: $c) equals: 'ab'.\r\tself assert: stream next equals: $d.\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abcd';\r\t\treset.\r\tself assert: (stream upTo: $x) equals: 'abcd'.\r\tself assert: stream atEnd.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abcd' asByteArray;\r\t\treset.\r\tself assert: (stream upTo: 99) equals: #(97 98) asByteArray.\r\tself assert: stream next equals: 100.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abcd' asByteArray;\r\t\treset.\r\tself assert: (stream upTo: 120) equals: #(97 98 99 100) asByteArray.\r\tself assert: stream atEnd"},{"name":"testAtEnd","linesOfCode":8,"sourceCode":"testAtEnd\r\t| stream |\r\tstream := self emptyStream.\r\tself assert: stream atEnd.\r\tstream\r\t\tnextPut: $a;\r\t\treset.\r\tself deny: stream atEnd"},{"name":"testTab","linesOfCode":5,"sourceCode":"testTab\r\t| stream |\r\tstream := self emptyStream.\r\tstream tab.\r\tself assert: stream contents first equals: Character tab"},{"name":"testPosition","linesOfCode":40,"sourceCode":"testPosition\r\t| stream |\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abc';\r\t\treset.\r\tself assert: stream position equals: 0.\r\tstream next.\r\tself assert: stream position equals: 1.\r\tstream next.\r\tself assert: stream position equals: 2.\r\tstream next.\r\tself assert: stream position equals: 3.\r\tstream position: 1.\r\tself assert: stream position equals: 1.\r\tself assert: stream next equals: $b.\r\tstream position: 0.\r\tself assert: stream position equals: 0.\r\tself assert: stream next equals: $a.\r\tstream position: 3.\r\tself assert: stream atEnd.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abc' asByteArray;\r\t\treset.\r\tself assert: stream position equals: 0.\r\tstream next.\r\tself assert: stream position equals: 1.\r\tstream next.\r\tself assert: stream position equals: 2.\r\tstream next.\r\tself assert: stream position equals: 3.\r\tstream position: 1.\r\tself assert: stream position equals: 1.\r\tself assert: stream next equals: 98.\r\tstream position: 0.\r\tself assert: stream position equals: 0.\r\tself assert: stream next equals: 97.\r\tstream position: 3.\r\tself assert: stream atEnd"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ ReadWriteStream"},{"name":"testNew","linesOfCode":2,"sourceCode":"testNew\r\r\tself should: [ ReadWriteStream new ] raise: Error."},{"name":"testNextPut","linesOfCode":8,"sourceCode":"testNextPut\r\t| stream |\r\tstream := self emptyStream.\r\tstream nextPut: $a.\r\tself assert: stream contents equals: 'a'.\r\tstream := self emptyByteStream.\r\tstream nextPut: 97.\r\tself assert: stream contents equals: 'a' asByteArray"},{"name":"testSkip","linesOfCode":12,"sourceCode":"testSkip\r\t| stream |\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abcd';\r\t\treset.\r\tself assert: (stream skip: 2; peek) equals: $c.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abcd' asByteArray;\r\t\treset.\r\tself assert: (stream skip: 2; peek) equals: 99"},{"name":"testContents","linesOfCode":16,"sourceCode":"testContents\r\t| stream |\r\tstream := self emptyStream.\r\tstream\r\t\tnextPutAll: 'abc';\r\t\treset.\r\tself assert: stream contents equals: 'abc'.\r\tstream next: 2.\r\tself assert: stream contents equals: 'abc'.\r\tstream := self emptyByteStream.\r\tstream\r\t\tnextPutAll: 'abc' asByteArray;\r\t\treset.\r\tself assert: stream contents equals: 'abc' asByteArray.\r\tstream next: 2.\r\tself assert: stream contents equals: 'abc' asByteArray"}],"meta":{"name":"ReadWriteStreamTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ReadStreamTest","instanceVariables":[],"methods":[{"name":"testUpToAll","linesOfCode":20,"sourceCode":"testUpToAll\r\tself assert: (self streamOn: 'abcdefgh' upToAll: 'cd') equals: 'ab'.\r\tself assert: (self streamOn: 'abcdefgh' upToAll: 'cd' upToAll: 'gh') equals: 'ef'.\r\tself assert: (self streamOn: '' upToAll: '') equals: ''.\r\tself assert: (self streamOn: 'a' upToAll: '') equals: ''.\r\tself assert: (self streamOn: 'a' upToAll: 'a') equals: ''.\r\tself assert: (self streamOn: 'a' upToAll: 'b') equals: 'a'.\r\tself assert: (self streamOn: 'ab' upToAll: '') equals: ''.\r\tself assert: (self streamOn: 'ab' upToAll: 'a') equals: ''.\r\tself assert: (self streamOn: 'ab' upToAll: 'b') equals: 'a'.\r\tself assert: (self streamOn: 'ab' upToAll: 'c') equals: 'ab'.\r\tself assert: (self streamOn: 'ab' upToAll: 'ab') equals: ''.\r\tself assert: (self streamOn: 'abc' upToAll: '') equals: ''.\r\tself assert: (self streamOn: 'abc' upToAll: 'a') equals: ''.\r\tself assert: (self streamOn: 'abc' upToAll: 'b') equals: 'a'.\r\tself assert: (self streamOn: 'abc' upToAll: 'c') equals: 'ab'.\r\tself assert: (self streamOn: 'abc' upToAll: 'd') equals: 'abc'.\r\tself assert: (self streamOn: 'abc' upToAll: 'ab') equals: ''.\r\tself assert: (self streamOn: 'abc' upToAll: 'bc') equals: 'a'.\r\tself assert: (self streamOn: 'abc' upToAll: 'cd') equals: 'abc'"},{"name":"emptyStream","linesOfCode":2,"sourceCode":"emptyStream\r\t^ ReadStream on: String new."},{"name":"testBackOnPosition1","linesOfCode":6,"sourceCode":"testBackOnPosition1\r\t\"Test the new implementation of the method back.\"\r\t| stream |\r\tstream := 'abc' readStream.\r\tstream next.\r\tself assert: stream back equals: $a.\r"},{"name":"streamOn:upToAll:","linesOfCode":2,"sourceCode":"streamOn: collection upToAll: subcollection \r\t^ collection readStream upToAll: subcollection"},{"name":"streamOnString","linesOfCode":2,"sourceCode":"streamOnString\r\t^ ReadStream on: 'abcde'."},{"name":"testUpTo3","linesOfCode":12,"sourceCode":"testUpTo3\r\t| stream string |\r\tstring := 'XYZabcdUVW'.\r\tstream := ReadStream on: string from: (string indexOf: $a) to: (string indexOf: $d).\r\tself assert: stream upToEnd equals: 'abcd'.\r\tself assert: stream atEnd.\r\tstream := ReadStream on: string from: (string indexOf: $a) to: (string indexOf: $d).\r\tself assert: (stream upTo: $c) equals: 'ab'.\r\tself assert: stream next equals: $d.\r\tstream := ReadStream on: string from: (string indexOf: $a) to: (string indexOf: $d).\r\tself assert: (stream upTo: $e) equals: 'abcd'.\r\tself assert: stream atEnd"},{"name":"streamOnArray","linesOfCode":2,"sourceCode":"streamOnArray\r\t^ ReadStream on: (Array with: 1 with: #(a b c) with: false)."},{"name":"streamOn:upToAll:upToAll:","linesOfCode":4,"sourceCode":"streamOn: collection upToAll: subcollection1 upToAll: subcollection2 \r\t^ collection readStream\r\t\tupToAll: subcollection1;\r\t\tupToAll: subcollection2"},{"name":"testOldBack","linesOfCode":6,"sourceCode":"testOldBack\r\t\"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)\"\r\t| stream |\r\tstream := 'abc' readStream.\r\tstream setToEnd.\r\tself assert: stream oldBack equals: $b.\r"},{"name":"testIsEmpty","linesOfCode":13,"sourceCode":"testIsEmpty\r\t| stream |\r\tself assert: self emptyStream isEmpty.\r\t\r\tstream := self streamOnArray.\r\tself deny: stream isEmpty.\r\tstream skip: 3.\r\tself deny: stream isEmpty.\r\t\r\tstream := self streamOnString.\r\tself deny: stream isEmpty.\r\tstream next;next;next.\r\tself deny: stream isEmpty.\r\tstream setToEnd.\r\tself deny: stream isEmpty."},{"name":"testBack","linesOfCode":5,"sourceCode":"testBack\r\t| stream |\r\tstream := 'abc' readStream.\r\tstream setToEnd.\r\tself assert: stream back equals: $c.\r"},{"name":"testPositionOfSubCollection","linesOfCode":5,"sourceCode":"testPositionOfSubCollection\r\t\r\tself assert: ('xyz' readStream positionOfSubCollection: 'q' ) equals: 0.\r\tself assert: ('xyz' readStream positionOfSubCollection: 'x' ) equals: 1.\r\r\tself assert: ('xyz' readStream positionOfSubCollection: 'y' ) equals: 2.\r\tself assert: ('xyz' readStream positionOfSubCollection: 'z' ) equals: 3."},{"name":"testAtEnd","linesOfCode":3,"sourceCode":"testAtEnd\r\tself assert: self emptyStream atEnd.\r\tself deny: self streamOnString atEnd"},{"name":"testOldPeekBack","linesOfCode":6,"sourceCode":"testOldPeekBack\r\t\"Test the old behavior of the method peekBack. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)\"\r\t| stream |\r\tstream := 'abc' readStream.\r\tstream setToEnd.\r\tself assert: stream oldPeekBack equals: $b.\r"},{"name":"testPeekBack","linesOfCode":6,"sourceCode":"testPeekBack\r\t\"Test the new implementation of the method peekBack due to changing #back.\"\r\t| stream |\r\tstream := 'abc' readStream.\r\tstream setToEnd.\r\tself assert: stream peekBack equals: $c.\r"},{"name":"testOldBackOnPosition1","linesOfCode":6,"sourceCode":"testOldBackOnPosition1\r\t\"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)\"\r\r\t| stream |\r\tstream := 'abc' readStream.\r\tstream next.\r\tself assert: stream oldBack isNil"},{"name":"testContents","linesOfCode":6,"sourceCode":"testContents\r\t| stream |\r\tstream := self streamOnString.\r\tself assert: stream contents equals: 'abcde'.\r\tstream next: 2.\r\tself assert: stream contents equals: 'abcde'"}],"meta":{"name":"ReadStreamTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Arithmetic-Tests","classes":[{"name":"CollectionArithmeticTest","instanceVariables":[],"methods":[{"name":"testAverageIfEmptyWithEmptyArray","linesOfCode":2,"sourceCode":"testAverageIfEmptyWithEmptyArray\r\tself assert: (#() averageIfEmpty: [ 0 ]) equals: 0"},{"name":"testRunningAverageWithFullSubsetSizeIsSameAsAverage","linesOfCode":6,"sourceCode":"testRunningAverageWithFullSubsetSizeIsSameAsAverage\r\t| collection |\r\tcollection := #(1 1 2 2 3 3).\r\t\r\tself\r\t\tassert: (collection runningAverage: collection size) \r\t\tequals: { collection average }.\r"},{"name":"testAverageWithEmptyArray","linesOfCode":2,"sourceCode":"testAverageWithEmptyArray\r\tself should: [ #() average ] raise: CollectionIsEmpty"},{"name":"testRunningAverageWithSubsetSize1IsSameAsCollection","linesOfCode":6,"sourceCode":"testRunningAverageWithSubsetSize1IsSameAsCollection\r\t| collection |\r\tcollection := #(1 1 2 2 3 3).\r\t\r\tself\r\t\tassert: (collection runningAverage: 1) \r\t\tequals: collection.\r"},{"name":"testAdd","linesOfCode":5,"sourceCode":"testAdd\r\t| collection |\r\tcollection := #(1 2 3).\r\tself assert: collection + 1 equals: #(2 3 4).\r\tself assert: 1 + collection  equals: #(2 3 4)"},{"name":"testDevision","linesOfCode":5,"sourceCode":"testDevision\r\t| collection |\r\tcollection := #(2 4).\r\tself assert: collection / 2 equals: #(1 2).\r\tself assert: 10 / #(20) equals: {1/2}"},{"name":"testAverageIfEmptyWithEmptyCollection","linesOfCode":2,"sourceCode":"testAverageIfEmptyWithEmptyCollection\r\tself should: [#() averageIfEmpty: [ CollectionIsEmpty signal: 'Collection empty' ]] raise: CollectionIsEmpty"},{"name":"testAverageWithEmptyOrderedCollection","linesOfCode":2,"sourceCode":"testAverageWithEmptyOrderedCollection\r\tself should: [ OrderedCollection new average ] raise: CollectionIsEmpty"},{"name":"testAverageWithEmptySet","linesOfCode":2,"sourceCode":"testAverageWithEmptySet\r\tself should: [ Set new average ] raise: CollectionIsEmpty"},{"name":"testAverageWithEmptyDictionary","linesOfCode":2,"sourceCode":"testAverageWithEmptyDictionary\r\tself should: [ Dictionary new average ] raise: CollectionIsEmpty"},{"name":"testAverageWithEmptyArrayShouldRaiseExecption","linesOfCode":2,"sourceCode":"testAverageWithEmptyArrayShouldRaiseExecption\r\tself should: [ #() average ] raise: CollectionIsEmpty"},{"name":"testAverageIfEmpty","linesOfCode":4,"sourceCode":"testAverageIfEmpty\r\t| collection |\r\tcollection := #(1 2 3 4).\r\tself assert: (collection averageIfEmpty: [ 0 ]) equals: 2.5"},{"name":"testAverage","linesOfCode":4,"sourceCode":"testAverage\r\t| collection |\r\tcollection := #(1 2 3).\r\tself assert: collection average equals: 2"},{"name":"testRunningAverageSubscriptOutOfBounds","linesOfCode":5,"sourceCode":"testRunningAverageSubscriptOutOfBounds\r\t| collection |\r\tcollection := #(1 1 2 2 3 3).\r\r\tself should: [ collection runningAverage: 7 ] raise: SubscriptOutOfBounds.\r\tself  should: [ collection runningAverage: -2 ] raise: SubscriptOutOfBounds.\r"},{"name":"testRunningAverage","linesOfCode":5,"sourceCode":"testRunningAverage\r\t| result collection |\r\tcollection := #(1 1 2 2 3 3).\r\tresult := collection runningAverage: 2. \r\r\tself assert: result equals: {1 . (3/2) . 2 . (5/2) . 3}.\r"},{"name":"testRunningMax","linesOfCode":5,"sourceCode":"testRunningMax\r\t| result collection |\r\tcollection := #(1 1 2 2 3 3).\r\tresult := collection runningMax: 3. \r\r\tself assert: result equals: {2 . 2 . 3 . 3}.\r"},{"name":"testRunningMin","linesOfCode":5,"sourceCode":"testRunningMin\r\t| result collection |\r\tcollection := #(1 1 2 2 3 3).\r\tresult := collection runningMin: 3. \r\r\tself assert: result equals: {1 . 1 . 2 . 2}.\r"}],"meta":{"name":"CollectionArithmeticTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Unordered-Tests","classes":[{"name":"PluggableDictionaryTest","instanceVariables":[],"methods":[{"name":"testEqualBlockEquality","linesOfCode":11,"sourceCode":"testEqualBlockEquality\r\t| pluggableDict pluggableDict2 equalBlock |\r\tpluggableDict := self nonEmptyDict.\r\tpluggableDict2 := self nonEmptyDict copy.\r\r\tequalBlock := [ :a :b | a = b ].\r\tpluggableDict2 equalBlock: equalBlock.\r\tself deny: pluggableDict equals: pluggableDict2.\r\tself deny: pluggableDict2 equals: pluggableDict.\r\r\tpluggableDict equalBlock: equalBlock.\r\tself assert: pluggableDict equals: pluggableDict2.\r\tself assert: pluggableDict2 equals: pluggableDict"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ PluggableDictionary"},{"name":"testCopyEmpty","linesOfCode":9,"sourceCode":"testCopyEmpty\r\t| pluggableDict copiedPluggableDict |\r\tsuper testCopyEmpty.\r\r\t(pluggableDict := self emptyDict)\r\t\tequalBlock: [ :a :b | a = b ];\r\t\thashBlock: [ :a | a hash ].\r\r\tcopiedPluggableDict := pluggableDict copyEmpty.\r\tself assert: copiedPluggableDict equalBlock identicalTo: pluggableDict equalBlock.\r\tself assert: copiedPluggableDict hashBlock identicalTo: pluggableDict hashBlock"},{"name":"testHashBlock","linesOfCode":8,"sourceCode":"testHashBlock\r\t| pluggableDict keys |\r\tpluggableDict := self nonEmptyDict.\r\tkeys := pluggableDict keys.\r\tself assert: pluggableDict hashBlock isNil.\r\tself assert: (pluggableDict hashBlock: [ :a | a hash ]) identicalTo: pluggableDict.\r\r\tkeys do: [ :each | self assert: (pluggableDict includesKey: each) ].\r\tself deny: (pluggableDict includesKey: self keyNotIn)"},{"name":"testEqualBlock","linesOfCode":16,"sourceCode":"testEqualBlock\r\t| pluggableDict assoc |\r\tpluggableDict := self emptyDict.\r\tself assert: pluggableDict equalBlock isNil.\r\tself assert: (pluggableDict equalBlock: [ :a :b | a = b ]) identicalTo: pluggableDict.\r\r\tassoc := 'newKey' -> 'newValue'.\r\tpluggableDict add: assoc.\r\tself assert: (pluggableDict includesAssociation: assoc).\r\r\tpluggableDict equalBlock: [ :a :b | a == b ].\r\tself assert: (pluggableDict includesAssociation: assoc).\r\tpluggableDict\r\t\tremoveKey: assoc key;\r\t\tadd: assoc key copy -> assoc value.\r\tself deny: (pluggableDict includesAssociation: assoc).\r\r\tpluggableDict equalBlock: [ :a :b | a = b ].\r\tself assert: (pluggableDict includesAssociation: assoc)"},{"name":"testHashBlockEquality","linesOfCode":11,"sourceCode":"testHashBlockEquality\r\t| pluggableDict pluggableDict2 hashBlock |\r\tpluggableDict := self nonEmptyDict.\r\tpluggableDict2 := self nonEmptyDict copy.\r\r\thashBlock := [ :a | a hash ].\r\tpluggableDict2 hashBlock: hashBlock.\r\tself deny: pluggableDict equals: pluggableDict2.\r\tself deny: pluggableDict2 equals: pluggableDict.\r\r\tpluggableDict hashBlock: hashBlock.\r\tself assert: pluggableDict equals: pluggableDict2.\r\tself assert: pluggableDict2 equals: pluggableDict"}],"meta":{"name":"PluggableDictionaryTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r^true"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ IdentitySet"}],"meta":null}},{"name":"TDictionaryIncludesTest","instanceVariables":[],"methods":[{"name":"valueNotInNonEmpty","linesOfCode":3,"sourceCode":"valueNotInNonEmpty\r\t\" return a value not included in nonEmpty\"\r\t^ self explicitRequirement"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r^self explicitRequirement"},{"name":"testIncludesComportementForDictionnary","linesOfCode":9,"sourceCode":"testIncludesComportementForDictionnary\r\t| valueIn collection keyIn |\r\tcollection := self nonEmpty.\r\tvalueIn := collection values anyOne.\r\tkeyIn := collection keys anyOne.\r\tself assert: (collection includes: valueIn).\r\tself deny: (collection includes: self valueNotInNonEmpty).\r\t\" testing that includes take only care of values :\"\r\tself deny: (collection includes: keyIn)"},{"name":"testIncludesKey","linesOfCode":7,"sourceCode":"testIncludesKey\r\r\t| collection keyIn nonExistantKey |\r\r\tcollection := self nonEmpty .\r\tkeyIn := collection keys anyOne.\r\tnonExistantKey := self keyNotInNonEmpty. \r\r\tself assert: ( collection includesKey: keyIn ).\r\tself deny: ( collection includesKey: nonExistantKey )."},{"name":"testIncludesAssociation","linesOfCode":12,"sourceCode":"testIncludesAssociation\r\r\t|  nonExistantAssociation associationIn keyIn valueIn |\r\r\tkeyIn := self nonEmpty keys anyOne.\r\tvalueIn := self nonEmpty values anyOne. \r\tnonExistantAssociation := self keyNotInNonEmpty -> self valueNotInNonEmpty .\r\tassociationIn := self nonEmpty associations anyOne.\t\r\r\tself assert:  (self nonEmpty includesAssociation: associationIn ).\r\tself deny:  (self nonEmpty includesAssociation: nonExistantAssociation ).\r\t\" testing the case where key is included but not with the same value :\"\r\tself deny: (self nonEmpty includesAssociation: (keyIn-> self valueNotInNonEmpty )).\r\t\" testing the case where value is included but not corresponding key :\"\r\tself deny: (self nonEmpty includesAssociation: (self keyNotInNonEmpty -> valueIn  )).\r\r\r\r"},{"name":"test0FixtureDictionaryIncludes","linesOfCode":12,"sourceCode":"test0FixtureDictionaryIncludes\r\t| in |\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself valueNotInNonEmpty.\r\tin := false.\r\tself nonEmpty valuesDo: [ :assoc | assoc = self valueNotInNonEmpty ifTrue: [ in := true ] ].\r\tself deny: in.\r\tself keyNotInNonEmpty.\r\tin := false.\r\tself nonEmpty keysDo: [ :assoc | assoc = self keyNotInNonEmpty ifTrue: [ in := true ] ].\r\tself deny: in"},{"name":"keyNotInNonEmpty","linesOfCode":3,"sourceCode":"keyNotInNonEmpty\r\t\" return a key not included in nonEmpty\"\r\t^ self explicitRequirement"},{"name":"testIncludesIdentityBasicComportement","linesOfCode":6,"sourceCode":"testIncludesIdentityBasicComportement\r\r| valueIn collection |\rcollection := self nonEmpty .\rvalueIn := collection  values anyOne.\r\rself assert: (collection includesIdentity: valueIn ) .\rself deny: (collection includesIdentity: self valueNotInNonEmpty )."}],"meta":{"name":"TDictionaryIncludesTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryIncludesWithIdentityCheckTest","instanceVariables":[],"methods":[{"name":"valueNotInNonEmpty","linesOfCode":3,"sourceCode":"valueNotInNonEmpty\r\t\" return a value not included in nonEmpty\"\r\t^ self explicitRequirement"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r^self explicitRequirement"},{"name":"testIncludesComportementForDictionnary","linesOfCode":9,"sourceCode":"testIncludesComportementForDictionnary\r\t| valueIn collection keyIn |\r\tcollection := self nonEmpty.\r\tvalueIn := collection values anyOne.\r\tkeyIn := collection keys anyOne.\r\tself assert: (collection includes: valueIn).\r\tself deny: (collection includes: self valueNotInNonEmpty).\r\t\" testing that includes take only care of values :\"\r\tself deny: (collection includes: keyIn)"},{"name":"testIncludesKey","linesOfCode":7,"sourceCode":"testIncludesKey\r\r\t| collection keyIn nonExistantKey |\r\r\tcollection := self nonEmpty .\r\tkeyIn := collection keys anyOne.\r\tnonExistantKey := self keyNotInNonEmpty. \r\r\tself assert: ( collection includesKey: keyIn ).\r\tself deny: ( collection includesKey: nonExistantKey )."},{"name":"testIncludesAssociation","linesOfCode":12,"sourceCode":"testIncludesAssociation\r\r\t|  nonExistantAssociation associationIn keyIn valueIn |\r\r\tkeyIn := self nonEmpty keys anyOne.\r\tvalueIn := self nonEmpty values anyOne. \r\tnonExistantAssociation := self keyNotInNonEmpty -> self valueNotInNonEmpty .\r\tassociationIn := self nonEmpty associations anyOne.\t\r\r\tself assert:  (self nonEmpty includesAssociation: associationIn ).\r\tself deny:  (self nonEmpty includesAssociation: nonExistantAssociation ).\r\t\" testing the case where key is included but not with the same value :\"\r\tself deny: (self nonEmpty includesAssociation: (keyIn-> self valueNotInNonEmpty )).\r\t\" testing the case where value is included but not corresponding key :\"\r\tself deny: (self nonEmpty includesAssociation: (self keyNotInNonEmpty -> valueIn  )).\r\r\r\r"},{"name":"nonEmptyWithCopyNonIdentical","linesOfCode":3,"sourceCode":"nonEmptyWithCopyNonIdentical\r\" return a collection including elements for wich copy is not identical to the initial element ( this is not the cas of Integer )\"\r^self explicitRequirement"},{"name":"test0FixtureDictionaryIncludes","linesOfCode":12,"sourceCode":"test0FixtureDictionaryIncludes\r\t| in |\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself valueNotInNonEmpty.\r\tin := false.\r\tself nonEmpty valuesDo: [ :assoc | assoc = self valueNotInNonEmpty ifTrue: [ in := true ] ].\r\tself deny: in.\r\tself keyNotInNonEmpty.\r\tin := false.\r\tself nonEmpty keysDo: [ :assoc | assoc = self keyNotInNonEmpty ifTrue: [ in := true ] ].\r\tself deny: in"},{"name":"keyNotInNonEmpty","linesOfCode":3,"sourceCode":"keyNotInNonEmpty\r\t\" return a key not included in nonEmpty\"\r\t^ self explicitRequirement"},{"name":"test0FixtureDictionaryIncludesIdentity","linesOfCode":4,"sourceCode":"test0FixtureDictionaryIncludesIdentity\r\tself nonEmptyWithCopyNonIdentical.\r\tself denyEmpty: self nonEmptyWithCopyNonIdentical.\r\tself nonEmptyWithCopyNonIdentical do: [ :each | self deny: each == each copy ]"},{"name":"testIncludesIdentitySpecificComportement","linesOfCode":6,"sourceCode":"testIncludesIdentitySpecificComportement\r\r| valueIn collection |\rcollection := self nonEmptyWithCopyNonIdentical  .\rvalueIn := collection  values anyOne.\r\rself assert: (collection includesIdentity: valueIn ) .\rself deny: (collection includesIdentity: valueIn copy ) .\r"},{"name":"testIncludesIdentityBasicComportement","linesOfCode":6,"sourceCode":"testIncludesIdentityBasicComportement\r\r| valueIn collection |\rcollection := self nonEmpty .\rvalueIn := collection  values anyOne.\r\rself assert: (collection includesIdentity: valueIn ) .\rself deny: (collection includesIdentity: self valueNotInNonEmpty )."}],"meta":{"name":"TDictionaryIncludesWithIdentityCheckTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"PluggableSetTest","instanceVariables":[],"methods":[{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ PluggableSet"}],"meta":{"name":"PluggableSetTest class","instanceVariables":[],"methods":[{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ IdentitySet"}],"meta":null}},{"name":"MethodDictionaryTest","instanceVariables":[{"name":"nonEmptyDict"}],"methods":[{"name":"testIdentityKeyAtExistantValueCopyReturnsFailBlock","linesOfCode":7,"sourceCode":"testIdentityKeyAtExistantValueCopyReturnsFailBlock\r\t| methodSelector result aMethod error |\r\tmethodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.\r\terror := #error.\r\r\taMethod := (self class >> methodSelector) copy.\r\tresult := self class methodDict keyAtIdentityValue: aMethod ifAbsent: [ error ].\r\r\tself assert: result equals: error"},{"name":"anIndex","linesOfCode":2,"sourceCode":"anIndex\r\r\t^ #aMethodName"},{"name":"testBehaviorLocalyDefined","linesOfCode":4,"sourceCode":"testBehaviorLocalyDefined\r\t\"method not acquired from a trait or from its superclass\"\r\r\tself assert: (Object methodDict isKindOf: MethodDictionary).\r\tself assert: Object selectors asSortedCollection equals: Object selectors asSortedCollection"},{"name":"keyNotIn","linesOfCode":3,"sourceCode":"keyNotIn\r\" return a key not included in nonEmpty\"\r^ #bouba"},{"name":"testRehashPreservesElements","linesOfCode":6,"sourceCode":"testRehashPreservesElements\r\t| oldDictionary rehashedDictionary |\r\toldDictionary := self modifiedMethodDictionaryCopy.\r\t\r\trehashedDictionary := oldDictionary copy rehash.\r\t\r\tself assertPreservesElements: oldDictionary comparedTo: rehashedDictionary.\r\tself assertPreservesElements: rehashedDictionary comparedTo: oldDictionary."},{"name":"assertPreservesCapacity:comparedTo:","linesOfCode":2,"sourceCode":"assertPreservesCapacity: oldDictionary comparedTo: rehashedDictionary\r\tself assert: oldDictionary capacity equals: rehashedDictionary capacity"},{"name":"testIdentityKeyAtExistantValueReturnsOkKey","linesOfCode":6,"sourceCode":"testIdentityKeyAtExistantValueReturnsOkKey\r\t| methodSelector result aMethod |\r\tmethodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.\r\r\taMethod := self class >> methodSelector.\r\tresult := self class methodDict keyAtIdentityValue: aMethod ifAbsent: [ self error ].\r\r\tself assert: result equals: methodSelector"},{"name":"testRehashPreservesCapacity","linesOfCode":5,"sourceCode":"testRehashPreservesCapacity\r\t| oldDictionary rehashedDictionary |\r\toldDictionary := self modifiedMethodDictionaryCopy.\r\r\trehashedDictionary := oldDictionary copy rehash.\r\t\r\tself assertPreservesCapacity: oldDictionary comparedTo: rehashedDictionary."},{"name":"modifiedMethodDictionaryCopy","linesOfCode":5,"sourceCode":"modifiedMethodDictionaryCopy\r\t| copy |\r\t\r\tcopy := self class methodDict copy.\r\tcopy at: #methodAddedToIncreaseTheDict put: Object >> #=.\r\t^copy."},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t^ MethodDictionary"},{"name":"testKeyAtExistantValueCopyReturnsOkKey","linesOfCode":6,"sourceCode":"testKeyAtExistantValueCopyReturnsOkKey\r\t| methodSelector result aMethod |\r\tmethodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.\r\taMethod := (self class >> methodSelector) copy.\r\tresult := self class methodDict keyAtValue: aMethod ifAbsent: [ self error ].\r\r\tself assert: result equals: methodSelector"},{"name":"testGrowDoublesCapacity","linesOfCode":6,"sourceCode":"testGrowDoublesCapacity\r\t| methodDictionary oldCapacity |\r\tmethodDictionary := MethodDictionary new.\r\toldCapacity := methodDictionary capacity.\r\tmethodDictionary grow.\r\tself assert: oldCapacity * 2 equals: methodDictionary capacity"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ nonEmptyDict"},{"name":"testAtExistantKeyReturnsOkCompiledMethod","linesOfCode":5,"sourceCode":"testAtExistantKeyReturnsOkCompiledMethod\r\t| methodSelector method |\r\tmethodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.\r\tmethod := self class methodDict at: methodSelector ifAbsent: [ self error ].\r\r\tself assert: method class equals: CompiledMethod"},{"name":"testKeyAtValueIfAbsentLocalyDefined","linesOfCode":5,"sourceCode":"testKeyAtValueIfAbsentLocalyDefined\r\tself\r\t\tassert: (self class methodDict keyAtValue: self class >> #testKeyAtValueIfAbsentLocalyDefined ifAbsent: [  ])\r\t\tidenticalTo: #testKeyAtValueIfAbsentLocalyDefined.\r\r\tself assert: (self class methodDict keyAtValue: Object >> #printOn: ifAbsent: [ #notFound ]) identicalTo: #notFound"},{"name":"testKeyAtExistantValueReturnsOkKey","linesOfCode":6,"sourceCode":"testKeyAtExistantValueReturnsOkKey\r\t| methodSelector result aMethod |\r\tmethodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.\r\taMethod := self class >> methodSelector.\r\tresult := self class methodDict keyAtValue: aMethod ifAbsent: [ self error ].\r\r\tself assert: result equals: methodSelector"},{"name":"testGrowPreservesElements","linesOfCode":6,"sourceCode":"testGrowPreservesElements\r\t| methodDictionary growedMethodDictionary |\r\tmethodDictionary := self class methodDict copy.\r\tgrowedMethodDictionary := methodDictionary copy; grow; yourself.\r\r\tself assertPreservesElements: methodDictionary comparedTo: growedMethodDictionary.\r\tself assertPreservesElements: growedMethodDictionary comparedTo: methodDictionary."},{"name":"testAtNonexistantKeyExecutesFailBlock","linesOfCode":6,"sourceCode":"testAtNonexistantKeyExecutesFailBlock\r\t| methodSelector result error |\r\tmethodSelector := #inexistant:method:larala:.\r\terror := #error.\r\tresult := self class methodDict at: methodSelector ifAbsent: [ error ].\r\r\tself assert: result equals: error"},{"name":"assertPreservesElements:comparedTo:","linesOfCode":5,"sourceCode":"assertPreservesElements: oldDictionary comparedTo: newDictionary\r\tself assert: (oldDictionary keys allSatisfy: [ :key |\r\t\t(newDictionary includesKey: key) &\r\t\t((newDictionary at: key) == (oldDictionary at: key))\r\t\t])"},{"name":"keyNotInNonEmptyDict","linesOfCode":3,"sourceCode":"keyNotInNonEmptyDict\r\" return a key not included in nonEmptyDict\"\r\t^ #keyNotInNonEmptyDict"},{"name":"nonEmptyDifferentFromNonEmptyDict","linesOfCode":4,"sourceCode":"nonEmptyDifferentFromNonEmptyDict\r\t\" return a dictionary for which all keys are not included in nonEmptyDict\"\r\t^ MethodDictionary new\r\t\tat: #nonEmptyDifferentFromNonEmptyDict put: (self class >> #nonEmptyDifferentFromNonEmptyDict)"},{"name":"newEmptyDict","linesOfCode":2,"sourceCode":"newEmptyDict\r\t^ MethodDictionary new"},{"name":"nonEmptyDict","linesOfCode":2,"sourceCode":"nonEmptyDict\r\t^ nonEmptyDict "},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\"return an element not included in 'nonEmpty' \"\r\r\t^ self class >> #elementNotIn"},{"name":"testAssociationAtNonexistantKeyExecutesFailBlock","linesOfCode":6,"sourceCode":"testAssociationAtNonexistantKeyExecutesFailBlock\r\t| methodSelector result error |\r\tmethodSelector := #inexistant:method:larala:.\r\terror := #error.\r\tresult := self class methodDict associationAt: methodSelector ifAbsent: [ error ].\r\r\tself assert: result equals: error"},{"name":"testIdentityKeyAtNonExistantValueReturnsFailBlock","linesOfCode":5,"sourceCode":"testIdentityKeyAtNonExistantValueReturnsFailBlock\r\t| result error |\r\terror := #error.\r\r\tresult := self class methodDict keyAtIdentityValue: self ifAbsent: [ error ].\r\r\tself assert: result equals: error"},{"name":"testAssociationsDoGoesOverEntireDictionary","linesOfCode":5,"sourceCode":"testAssociationsDoGoesOverEntireDictionary\r\t| associations |\r\tassociations := MethodDictionary new.\r\t\r\tself class methodDict associationsDo:[ :association | associations add: association ].\r\t\r\tself assertPreservesElements: self class methodDict comparedTo: associations."},{"name":"testIncludesKeyLocalyDefined","linesOfCode":2,"sourceCode":"testIncludesKeyLocalyDefined\r\r\tself assert: (self class includesSelector: #testIncludesKeyLocalyDefined)."},{"name":"testAssociationAtExistantKeyReturnsOkAssociation","linesOfCode":6,"sourceCode":"testAssociationAtExistantKeyReturnsOkAssociation\r\t| methodSelector association |\r\tmethodSelector := #testAssociationAtExistantKeyReturnsOkAssociation.\r\tassociation := self class methodDict associationAt: methodSelector ifAbsent: [ self error ].\r\r\tself assert: association key equals: methodSelector.\r\tself assert: association value equals: self class >> methodSelector"},{"name":"anotherElementNotIn","linesOfCode":3,"sourceCode":"anotherElementNotIn\r\" return an element different of 'elementNotIn'  not included in 'nonEmpty' \"\r\t^ self class >> #anotherElementNotIn"},{"name":"setUp","linesOfCode":5,"sourceCode":"setUp\r\tsuper setUp.\r\tnonEmptyDict := MethodDictionary new.\r\tnonEmptyDict at: #setUp put: (self class >> #setUp).\r\tnonEmptyDict at: #nonEmpty put: (self class >> #nonEmpty)."},{"name":"anotherValue","linesOfCode":2,"sourceCode":"anotherValue\r\r\t^ self class >> #anotherValue"},{"name":"testKeyAtNonexistantValueExecutesFailBlock","linesOfCode":5,"sourceCode":"testKeyAtNonexistantValueExecutesFailBlock\r\t| result error |\r\terror := #error.\r\tresult := self class methodDict keyAtValue: self ifAbsent: [ error ].\r\r\tself assert: result equals: error"},{"name":"emptyDict","linesOfCode":2,"sourceCode":"emptyDict\r\t^ self empty"},{"name":"testRemoveAllPreservesCapacity","linesOfCode":8,"sourceCode":"testRemoveAllPreservesCapacity\r\t| methodSelector dictionary oldSize |\r\tmethodSelector := #testRemoveAllPreservesCapacity.\r\tdictionary := MethodDictionary new.\r\tdictionary at: methodSelector put: self class >> methodSelector.\r\r\toldSize := dictionary basicSize.\r\tdictionary removeAll.\r\tself assert: oldSize equals: dictionary basicSize"},{"name":"aValue","linesOfCode":2,"sourceCode":"aValue\r\r\t^ self class >> #aValue"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ MethodDictionary new"}],"meta":{"name":"MethodDictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"KeyedTreeTest","instanceVariables":[],"methods":[{"name":"testAtPathIfAbsent","linesOfCode":17,"sourceCode":"testAtPathIfAbsent\r\t\"Test the at path if absent method for success and failure modes.\"\r\r\t|tree t2|\r\ttree := KeyedTree new\r\t\tat: 1 put: (t2 := KeyedTree new\r\t\t\t\t\tat: #two put: 'One-Two';\r\t\t\t\t\tat: #three put: 'One-Three';\r\t\t\t\t\tyourself);\r\t\tat: 2 put: 'Two';\r\t\tyourself.\r\tself should: [(tree atPath: #(1) ifAbsent: []) = t2].\r\tself should: [(tree atPath: #(1 two) ifAbsent: []) = 'One-Two'].\r\tself should: [(tree atPath: #(1 three) ifAbsent: []) = 'One-Three'].\r\tself should: [(tree atPath: #(2) ifAbsent: []) = 'Two'].\r\tself should: [(tree atPath: #(2 4) ifAbsent: [#missing]) = #missing].\r\tself should: [(tree atPath: #(1 two three) ifAbsent: [#missing]) = #missing] raise: self defaultTestError.\r\tself should: [(tree atPath: #(3) ifAbsent: [#missing]) = #missing]."},{"name":"testAtPathIfAbsentPut","linesOfCode":20,"sourceCode":"testAtPathIfAbsentPut\r\t\"Test the at path if absent put method for success and failure modes.\"\r\r\t|tree t2|\r\ttree := KeyedTree new\r\t\tat: 1 put: (t2 := KeyedTree new\r\t\t\t\t\tat: #two put: 'One-Two';\r\t\t\t\t\tat: #three put: 'One-Three';\r\t\t\t\t\tyourself);\r\t\tat: 2 put: 'Two';\r\t\tyourself.\r\tself should: [(tree atPath: #(1) ifAbsentPut: [#new]) = t2].\r\tself should: [(tree atPath: #(1 two) ifAbsentPut: [#new]) = 'One-Two'].\r\tself should: [(tree atPath: #(1 three) ifAbsentPut: [#new]) = 'One-Three'].\r\tself should: [(tree atPath: #(2) ifAbsentPut: [#new]) = 'Two'].\r\tself should: [tree atPath: #(2 4) ifAbsentPut: [#new]] raise: self defaultTestError.\r\tself should: [tree atPath: #(1 two three) ifAbsentPut: [#new]] raise: self defaultTestError.\r\tself should: [(tree atPath: #(1 four one) ifAbsentPut: [#anotherNew]) = #anotherNew].\r\tself should: [(tree atPath: #(1 four one)) = #anotherNew].\r\tself should: [(tree atPath: #(3) ifAbsentPut: [#yetAnotherNew]) = #yetAnotherNew].\r\tself should: [(tree atPath: #(3)) = #yetAnotherNew]."},{"name":"testCopy","linesOfCode":18,"sourceCode":"testCopy\r\t\"Test the copy method for success and failure modes.\"\r\r\t|c tree t2 t3|\r\ttree := KeyedTree new\r\t\tat: 1 put: (t2 := KeyedTree new\r\t\t\t\t\tat: #two put: 'One-Two';\r\t\t\t\t\tat: #three put: 'One-Three';\r\t\t\t\t\tat: #four put: (t3 := KeyedTree new);\r\t\t\t\t\tyourself);\r\t\tat: 2 put: 'Two';\r\t\tyourself.\r\tc := tree copy.\r\tself should: [c = tree].\r\tself shouldnt: [c == tree].\r\tself should: [(c at: 1) = t2].\r\tself shouldnt: [(c at: 1) == t2].\r\tself should: [(c atPath: #(1 four)) = t3].\r\tself shouldnt: [(c atPath: #(1 four)) == t3]."},{"name":"testAtPathPut","linesOfCode":18,"sourceCode":"testAtPathPut\r\t\"Test the at path put method for success and failure modes.\"\r\r\t|tree t2|\r\ttree := KeyedTree new\r\t\tat: 1 put: (KeyedTree new\r\t\t\t\t\tat: #two put: 'One-Two';\r\t\t\t\t\tat: #three put: 'One-Three';\r\t\t\t\t\tyourself);\r\t\tat: 2 put: 'Two';\r\t\tyourself.\r\tself should: [(tree atPath: #(1 two) put: #new) = #new].\r\tself should: [(tree atPath: #(1 two)) = #new].\r\tself should: [(tree atPath: #(1 three) put: (t2 := KeyedTree new)) = t2].\r\tself should: [(tree atPath: #(1 three $1) put: #anotherNew) = #anotherNew].\r\tself should: [(tree atPath: #(1 three $1)) = #anotherNew].\r\tself should: [tree atPath: #(2 4) put: [#new]] raise: self defaultTestError.\r\tself should: [(tree atPath: #(1 four one) put: #anotherNew) = #anotherNew].\r\tself should: [(tree atPath: #(1 four one)) = #anotherNew]."},{"name":"testAtPath","linesOfCode":17,"sourceCode":"testAtPath\r\t\"Test the at path method for success and failure modes.\"\r\r\t|tree t2|\r\ttree := KeyedTree new\r\t\tat: 1 put: (t2 := KeyedTree new\r\t\t\t\t\tat: #two put: 'One-Two';\r\t\t\t\t\tat: #three put: 'One-Three';\r\t\t\t\t\tyourself);\r\t\tat: 2 put: 'Two';\r\t\tyourself.\r\tself should: [(tree atPath: #(1)) = t2].\r\tself should: [(tree atPath: #(1 two)) = 'One-Two'].\r\tself should: [(tree atPath: #(1 three)) = 'One-Three'].\r\tself should: [(tree atPath: #(2)) = 'Two'].\r\tself should: [tree atPath: #(2 4)] raise: self defaultTestError.\r\tself should: [tree atPath: #(1 two three)] raise: self defaultTestError.\r\tself should: [tree atPath: #(3)] raise: self defaultTestError."},{"name":"testSubtrees","linesOfCode":20,"sourceCode":"testSubtrees\r\t\"Test the subtrees method for success and failure modes.\"\r\r\t|t1 t2 t3 t4|\r\tt1 := KeyedTree new\r\t\tat: 1 put: (t2 := KeyedTree new\r\t\t\t\t\tat: 1 put: '1-1';\r\t\t\t\t\tat: 2 put: '1-2';\r\t\t\t\t\tat: 3 put: (t3 := KeyedTree new\r\t\t\t\t\t\t\t\tat: 1 put: '1-3-1';\r\t\t\t\t\t\t\t\tat: 2 put: '1-3-2';\r\t\t\t\t\t\t\t\tyourself);\r\t\t\t\t\tyourself);\r\t\tat: 2 put: '2';\r\t\tat: 3 put: (t4 := KeyedTree new\r\t\t\t\t\tat: 1 put: '1-3-1';\r\t\t\t\t\tat: 2 put: '1-3-2';\r\t\t\t\t\tyourself);\r\t\tyourself.\r\tself should: [t1 subtrees = {t2. t4}].\r\tself should: [(t1 at: 1) subtrees = {t3}]."},{"name":"testRemovePathIfAbsent","linesOfCode":16,"sourceCode":"testRemovePathIfAbsent\r\t\"Test the remove path if absent method for success and failure modes.\"\r\r\t|tree|\r\ttree := KeyedTree new\r\t\tat: 1 put: (KeyedTree new\r\t\t\t\t\tat: #two put: 'One-Two';\r\t\t\t\t\tat: #three put: 'One-Three';\r\t\t\t\t\tyourself);\r\t\tat: 2 put: 'Two';\r\t\tyourself.\r\tself should: [(tree removePath: #(4) ifAbsent: [#none]) = #none].\r\tself should: [(tree removePath: #(1 2 3 4) ifAbsent: [#none]) = #none].\r\tself should: [(tree removePath: #(1 two) ifAbsent: [#none]) = 'One-Two'].\r\tself should: [(tree atPath: #(1 two) ifAbsent: []) = nil].\r\tself should: [(tree removePath: #(2) ifAbsent: [#none]) = 'Two'].\r\tself should: [(tree atPath: #(2) ifAbsent: []) = nil]."},{"name":"testMerge","linesOfCode":32,"sourceCode":"testMerge\r\t\"Test the merge method for success and failure modes.\"\r\r\t|t1 t2 m|\r\tt1 := KeyedTree new\r\t\tat: 1 put: (KeyedTree new\r\t\t\t\t\tat: 1 put: '1-1';\r\t\t\t\t\tat: 2 put: '1-2';\r\t\t\t\t\tat: 3 put: (KeyedTree new\r\t\t\t\t\t\t\t\tat: 1 put: '1-3-1';\r\t\t\t\t\t\t\t\tat: 2 put: '1-3-2';\r\t\t\t\t\t\t\t\tyourself);\r\t\t\t\t\tyourself);\r\t\tat: 2 put: '2';\r\t\tyourself.\r\tt2 := KeyedTree new\r\t\tat: 1 put: (KeyedTree new\r\t\t\t\t\tat: 1 put: (KeyedTree new\r\t\t\t\t\t\t\t\tat: 1 put: '1-1-1';\r\t\t\t\t\t\t\t\tat: 2 put: '1-1-2';\r\t\t\t\t\t\t\t\tyourself);\r\t\t\t\t\tat: 2 put: '1-2*';\r\t\t\t\t\tyourself);\r\t\tat: 3 put: '3';\r\t\tyourself.\r\tm := t1 merge: t2.\r\tself should: [(m at: 2) = '2'].\r\tself should: [(m at: 3) = '3'].\r\tself should: [(m atPath: #(1 2)) = '1-2*'].\r\tself should: [(m atPath: #(1 1 1)) = '1-1-1'].\r\tself should: [(m atPath: #(1 1 2)) = '1-1-2'].\r\tself should: [(m atPath: #(1 3 1)) = '1-3-1'].\r\tself should: [(m atPath: #(1 3 2)) = '1-3-2']."},{"name":"testRemovePath","linesOfCode":16,"sourceCode":"testRemovePath\r\t\"Test the remove path method for success and failure modes.\"\r\r\t|tree|\r\ttree := KeyedTree new\r\t\tat: 1 put: (KeyedTree new\r\t\t\t\t\tat: #two put: 'One-Two';\r\t\t\t\t\tat: #three put: 'One-Three';\r\t\t\t\t\tyourself);\r\t\tat: 2 put: 'Two';\r\t\tyourself.\r\tself should: [tree removePath: #(4)] raise: self defaultTestError.\r\tself should: [tree removePath: #(1 one)] raise: self defaultTestError.\r\tself should: [(tree removePath: #(1 two)) = 'One-Two'].\r\tself should: [(tree atPath: #(1 two) ifAbsent: []) = nil].\r\tself should: [(tree removePath: #(2)) = 'Two'].\r\tself should: [(tree atPath: #(2) ifAbsent: []) = nil]."}],"meta":{"name":"KeyedTreeTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryEnumeratingTest","instanceVariables":[],"methods":[{"name":"testDo","linesOfCode":8,"sourceCode":"testDo\r\t| t collection |\r\tcollection := self nonEmptyDict .\r\tt := OrderedCollection new.\r\tcollection do: [:\r\t\tvalue | t add: value\r\t\t].\r\t\r\tt do: [ :each | self assert: (t occurrencesOf: each ) = ( collection values occurrencesOf: each) ]."},{"name":"newEmptyDict","linesOfCode":2,"sourceCode":"newEmptyDict\r\tself explicitRequirement"},{"name":"testAssociationsDo","linesOfCode":9,"sourceCode":"testAssociationsDo\r\r\t| collection keys |\r\tcollection := self nonEmptyDict .\r\r\tkeys := OrderedCollection new.\r\t\r\tcollection associationsDo: [ :assoc | \r\t\tkeys add: assoc key.\r\t\tself assert: ( collection at: assoc key ) = assoc value.\t\t\r\t\t].\r\t\r\tcollection keys do: [:key | self assert: ( keys occurrencesOf: key ) = (collection keys occurrencesOf: key)]."},{"name":"testSelect","linesOfCode":9,"sourceCode":"testSelect\r\t| collection values result |\r\tcollection := self nonEmptyDict .\r\tvalues := OrderedCollection new.\r\tresult := collection select: [ :value  | \r\t\tvalues add: value.\r\t\ttrue].\r\t\r\tcollection values do: [ :value| self assert: (collection values occurrencesOf: value) = (values occurrencesOf: value)].\r\tself assert: result = collection."},{"name":"nonEmptyDict","linesOfCode":2,"sourceCode":"nonEmptyDict\r\tself explicitRequirement"},{"name":"testCollect","linesOfCode":9,"sourceCode":"testCollect\r\t| collection values result |\r\tcollection := self nonEmptyDict .\r\tvalues := OrderedCollection new.\r\tresult := collection collect: [ :value  | \r\t\tvalues add: value.\r\t\t].\r\t\r\tcollection values do: [ :value | self assert: (collection values occurrencesOf: value) = (values occurrencesOf: value)].\r\tself assert: result = collection."},{"name":"testAssociationsSelect","linesOfCode":9,"sourceCode":"testAssociationsSelect\r\t| collection keys result |\r\tcollection := self nonEmptyDict .\r\tkeys := OrderedCollection new.\r\tresult := collection associationsSelect: [ :assoc  | \r\t\tkeys add: assoc key.\r\t\ttrue].\r\t\r\tcollection keys do: [ :key | self assert: (collection keys occurrencesOf: key) = (keys occurrencesOf: key)].\r\tself assert: result = collection."},{"name":"testValuesDo","linesOfCode":8,"sourceCode":"testValuesDo\r\t| collection values |\r\tcollection := self nonEmptyDict .\r\tvalues := OrderedCollection new.\r\tcollection valuesDo: [ :value  | \r\t\tvalues add: value.\r\t\t].\r\t\r\tcollection values do: [ :value | self assert: (collection values occurrencesOf: value) = (values occurrencesOf: value)]"},{"name":"testKeysAndValuesDo","linesOfCode":8,"sourceCode":"testKeysAndValuesDo\r\r\t\r\t| collection keys |\r\tcollection := self nonEmptyDict .\r\tkeys := OrderedCollection new.\r\tcollection keysAndValuesDo: [ :key :value | \r\t\tkeys add: key.\r\t\tself assert: (collection at: key) = value ].\r\t\r\tcollection keys do: [ :key | self assert: (collection keys occurrencesOf: key) = (keys occurrencesOf: key)]"},{"name":"testReject","linesOfCode":6,"sourceCode":"testReject\r\t\"Ensure that Dictionary>>reject: answers a dictionary not something else\"\r\t\r\t| collection result |\r\tcollection := self nonEmptyDict .\r\tresult := collection reject: [ :each | false].\r\t\r\tself assert: result = collection. "},{"name":"test0FixtureDictionaryEnumeratingTest","linesOfCode":3,"sourceCode":"test0FixtureDictionaryEnumeratingTest\r\tself nonEmptyDict.\r\tself denyEmpty: self nonEmptyDict"},{"name":"testKeysDo","linesOfCode":8,"sourceCode":"testKeysDo\r\t| collection keys |\r\tcollection := self nonEmptyDict .\r\tkeys := OrderedCollection new.\r\tcollection keysDo: [ :key  | \r\t\tkeys add: key.\r\t\t].\r\t\r\tcollection keys do: [ :key | self assert: (collection keys occurrencesOf: key) = (keys occurrencesOf: key)]"},{"name":"emptyDict","linesOfCode":2,"sourceCode":"emptyDict\r\tself explicitRequirement"}],"meta":{"name":"TDictionaryEnumeratingTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryAssociationAccessTest","instanceVariables":[],"methods":[{"name":"testAssociationAt","linesOfCode":7,"sourceCode":"testAssociationAt\r\t| collection keyIn result |\r\tcollection := self nonEmpty.\r\tkeyIn := collection keys anyOne.\r\r\tresult := collection associationAt: keyIn.\r\r\tself assert: result key equals: keyIn.\r\tself assert: result value equals: (collection at: keyIn)"},{"name":"testAssociationAtIfPresent","linesOfCode":16,"sourceCode":"testAssociationAtIfPresent\r\r\t| collection keyIn result |\r\tcollection := self nonEmpty.\r\tkeyIn := collection keys anyOne.\r\r\tresult := collection associationAt: keyIn ifPresent: [:assoc | {#present. assoc}].\r\tself\r\t\tassert: result isArray;\r\t\tassert: result size = 2;\r\t\tassert: result first = #present;\r\t\tassert: result second key = keyIn;\r\t\tassert: result second value = (collection at: keyIn).\r\r\t\"test that cull: is used to support zero-arg blocks\"\r\tresult := collection associationAt: keyIn ifPresent: [#present].\r\tself assert: result = #present.\r\r\tresult := collection associationAt: self keyNotIn ifPresent: [:assoc | {#present. assoc}].\r\tself assert: result isNil."},{"name":"testAssociationAtIfAbsent","linesOfCode":8,"sourceCode":"testAssociationAtIfAbsent\r\r\t| collection keyIn result |\r\tcollection := self nonEmpty.\r\tkeyIn := collection keys anyOne.\r\r\tresult := collection associationAt: keyIn ifAbsent: [888]. \r\r\tself assert: (result key) = keyIn.\r\tself assert: (result value ) = (collection at: keyIn ).\r\r\tself assert: (collection associationAt: self keyNotIn  ifAbsent: [888] ) = 888"},{"name":"keyNotIn","linesOfCode":3,"sourceCode":"keyNotIn\r\" return a key not included in nonEmpty\"\rself explicitRequirement"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r^ self explicitRequirement"},{"name":"testAssociationAtIfPresentifAbsent","linesOfCode":9,"sourceCode":"testAssociationAtIfPresentifAbsent\r\t| collection keyIn found |\r\tfound := false.\r\tcollection := self nonEmpty.\r\tkeyIn := collection keys anyOne.\r\tcollection associationAt: keyIn ifPresent: [ found := true ] ifAbsent: [ 888 ].\r\tself assert: found.\r\r\tself assert: (collection associationAt: self keyNotIn ifAbsent: [ 888 ]) = 888.\r\r\tself assert: (collection associationAt: self keyNotIn ifPresent: [ 666 ] ifAbsent: [ 888 ]) = 888"},{"name":"testAssociationAtError","linesOfCode":5,"sourceCode":"testAssociationAtError\r\r\t| collection nonExistantKey |\r\tcollection := self nonEmpty.\r\tnonExistantKey := self keyNotIn .\r\r\tself should: [collection associationAt: nonExistantKey] raise: Error. \r\r"},{"name":"test0FixtureDictionaryAssocitionAccess","linesOfCode":5,"sourceCode":"test0FixtureDictionaryAssocitionAccess\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself keyNotIn.\r\tself deny: (self nonEmpty keys includes: self keyNotIn)"}],"meta":{"name":"TDictionaryAssociationAccessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryKeyAccessTest","instanceVariables":[],"methods":[{"name":"testKeyAtValue","linesOfCode":9,"sourceCode":"testKeyAtValue\r\t\"self run: #testKeyAtValue\"\r\t\r\t| dict value result |\r\tdict := self nonEmpty .\r\tvalue := dict values anyOne.\r\t\r\tresult := dict keyAtValue: value.\r\tself assert: (dict at: result) = value.\r\t\t\r\tself should: [dict keyAtValue: self valueNotIn ] raise: Error\r\t\r\t"},{"name":"test0FixtureDictionaryKeyAccess","linesOfCode":10,"sourceCode":"test0FixtureDictionaryKeyAccess\r\t| collection equals |\r\tself nonEmptyWithoutEqualsValues.\r\tself denyEmpty: self nonEmptyWithoutEqualsValues.\r\tequals := true.\r\tcollection := self nonEmptyWithoutEqualsValues values.\r\tcollection detect: [ :each | (collection occurrencesOf: each) > 1 ] ifNone: [ equals := false ].\r\tself deny: equals.\r\tself valueNotIn.\r\tself deny: (self nonEmptyWithoutEqualsValues values includes: self valueNotIn)"},{"name":"valueNotIn","linesOfCode":3,"sourceCode":"valueNotIn\r\" return a value not included in nonEmptyWithoutEqualValues \"\r^self explicitRequirement"},{"name":"testKeyAtIdentityValue","linesOfCode":8,"sourceCode":"testKeyAtIdentityValue\r\t\r\t\r\t| dict value result |\r\tdict := self nonEmpty .\r\tvalue := dict values anyOne.\r\t\r\tresult := dict keyAtIdentityValue: value.\r\tself assert: (dict at: result) = value.\r\t\t\r\tself should: [dict keyAtIdentityValue: self valueNotIn ] raise: Error\r\t\r\t"},{"name":"testKeyAtValueIfAbsent","linesOfCode":9,"sourceCode":"testKeyAtValueIfAbsent\r\t\"self run: #testKeyAtValue\"\r\t\r\t| dict value result |\r\tdict := self nonEmpty .\r\tvalue := dict values anyOne.\r\t\r\tresult := dict keyAtValue: value ifAbsent: [nil].\r\tself assert: (dict at: result) = value.\r\t\t\r\tself assert: (dict keyAtValue: self valueNotIn ifAbsent: [nil] ) = nil. \r\t\r\t"},{"name":"nonEmptyWithoutEqualsValues","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualsValues\r\" return a dictionary that doesn't include equal values'\"\r^self explicitRequirement"},{"name":"testKeyAtIdentityValueIfAbsent","linesOfCode":9,"sourceCode":"testKeyAtIdentityValueIfAbsent\r\t\"self run: #testKeyAtValue\"\r\t\r\t| dict value result |\r\tdict := self nonEmpty .\r\tvalue := dict values anyOne.\r\t\r\tresult := dict keyAtIdentityValue: value ifAbsent: [nil].\r\tself assert: (dict at: result) = value.\r\t\t\r\tself assert: (dict keyAtIdentityValue: self valueNotIn ifAbsent: [nil] ) = nil. \r\t"}],"meta":{"name":"TDictionaryKeyAccessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryAddingTest","instanceVariables":[],"methods":[{"name":"testDeclareFrom","linesOfCode":16,"sourceCode":"testDeclareFrom\r\t| newDict v dictionary keyIn associationKeyNotIn |\r\tdictionary := self nonEmptyDict.\r\tkeyIn := dictionary keys anyOne.\r\tassociationKeyNotIn := self associationWithKeyNotInToAdd.\r\tnewDict := self collectionClass new\r\t\tadd: associationKeyNotIn;\r\t\tyourself.\r\r\t\"if the key already exist, nothing changes\"\r\tv := dictionary at: keyIn.\r\tdictionary declare: keyIn from: newDict.\r\tself assert: (dictionary at: keyIn) equals: v.\r\r\t\"if the key does not exist, then it gets removed from newDict and is added to the receiver\"\r\tself nonEmptyDict declare: associationKeyNotIn key from: newDict.\r\tself assert: (dictionary at: associationKeyNotIn key) equals: associationKeyNotIn value.\r\tself assert: newDict size equals: 0"},{"name":"testAddWithKeyAlreadyIn","linesOfCode":9,"sourceCode":"testAddWithKeyAlreadyIn\r\t| dictionary result association oldSize |\r\tdictionary := self nonEmptyDict.\r\toldSize := dictionary size.\r\tassociation := self associationWithKeyAlreadyInToAdd.\r\tresult := dictionary add: association.\r\r\tself assert: result = association.\r\tself assert: (dictionary at: association key) = association value.\r\tself assert: dictionary size equals: oldSize"},{"name":"testAddWithKeyNotIn","linesOfCode":9,"sourceCode":"testAddWithKeyNotIn\r\t| dictionary result association oldSize |\r\tdictionary := self nonEmptyDict.\r\toldSize := dictionary size.\r\tassociation := self associationWithKeyNotInToAdd.\r\tresult := dictionary add: association.\r\r\tself assert: result equals: association.\r\tself assert: (dictionary at: association key) equals: association value.\r\tself assert: dictionary size equals: oldSize + 1"},{"name":"testAddAll","linesOfCode":13,"sourceCode":"testAddAll\r\t\r\t| collectionToAdd collection result oldSize |\r\tcollection := self nonEmptyDict .\r\toldSize := collection size.\r\tcollectionToAdd := self collectionClass new \r\t\tadd: self associationWithKeyAlreadyInToAdd ; \r\t\tadd: self associationWithKeyNotInToAdd ; \r\t\tyourself.\r\t\r\tresult := collection addAll: collectionToAdd .\r\t\r\tself assert: result = collectionToAdd .\r\t\"  the association with the key already in should have replaced the oldest :\"\r\tself assert: collection  size = (oldSize + 1).\r\t\r\tresult associationsDo: [:assoc | self assert: (collection at:  (assoc key) ) = assoc value]."},{"name":"test0FixtureDictionaryAddingTest","linesOfCode":7,"sourceCode":"test0FixtureDictionaryAddingTest\r\tself nonEmptyDict.\r\tself denyEmpty: self nonEmptyDict.\r\tself associationWithKeyNotInToAdd.\r\tself deny: (self nonEmptyDict keys includes: self associationWithKeyNotInToAdd key).\r\tself associationWithKeyAlreadyInToAdd.\r\tself assert: (self nonEmptyDict keys includes: self associationWithKeyAlreadyInToAdd key)"},{"name":"associationWithKeyNotInToAdd","linesOfCode":3,"sourceCode":"associationWithKeyNotInToAdd\r\t\" return an association that will be used to add to nonEmptyDict (the key of this association is not included in nonEmptyDict)\"\r\tself explicitRequirement"},{"name":"nonEmptyDict","linesOfCode":2,"sourceCode":"nonEmptyDict\r\tself explicitRequirement"},{"name":"associationWithKeyAlreadyInToAdd","linesOfCode":3,"sourceCode":"associationWithKeyAlreadyInToAdd\r\t\" return an association that will be used to add to nonEmptyDict (the key of this association is already included in nonEmptyDict)\"\r\tself explicitRequirement"}],"meta":{"name":"TDictionaryAddingTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"BagTest","instanceVariables":[{"name":"empty"},{"name":"nonEmpty"},{"name":"collectResult"},{"name":"emptyButAllocatedWith20"},{"name":"collectionWithElement"},{"name":"collectionIn"},{"name":"collectionNotIn"},{"name":"collectionOfString"},{"name":"elementNotIn"},{"name":"collectionWithCharacters"},{"name":"otherCollectionWithoutEqualElements"},{"name":"collectionWithoutNilMoreThan5"}],"methods":[{"name":"collectionNotIncluded","linesOfCode":2,"sourceCode":"collectionNotIncluded\r\t^ collectionNotIn "},{"name":"elementsCopyNonIdenticalWithoutEqualElements","linesOfCode":4,"sourceCode":"elementsCopyNonIdenticalWithoutEqualElements\r\t\" return a collection that does niot incllude equal elements ( classic equality )\r\tall elements included are elements for which copy is not identical to the element  \"\r\t^ collectionOfString "},{"name":"collectionWithCharacters","linesOfCode":2,"sourceCode":"collectionWithCharacters\r\t^ collectionWithCharacters ."},{"name":"testCopy","linesOfCode":8,"sourceCode":"testCopy\r\t\r\t| aBag newBag |\r\taBag := Bag new.\r\taBag add:'a' withOccurrences: 4.\r\taBag add:'b' withOccurrences: 2.\r\tnewBag := aBag copy.\r\tself assert: newBag equals: newBag.\r\tself assert: newBag asSet size equals: 2"},{"name":"testCreation","linesOfCode":5,"sourceCode":"testCreation\r\t| bag |\r\tbag := Bag new.\r\tself assert: bag size equals: 0.\r\tself assertEmpty: bag"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":2,"sourceCode":"integerCollectionWithoutEqualElements\r\t^ otherCollectionWithoutEqualElements"},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\" return a collection  including equal elements (classic equality)\"\r\t^ nonEmpty ."},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ collectionOfString"},{"name":"collectionWithElementsToRemove","linesOfCode":2,"sourceCode":"collectionWithElementsToRemove\r\t^ collectionIn"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ nonEmpty "},{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\" return a collection without equal elements \"\r\t^ otherCollectionWithoutEqualElements "},{"name":"testAddWithOccurrences","linesOfCode":5,"sourceCode":"testAddWithOccurrences\r\t| aBag |\r\taBag := Bag new.\r\taBag add: 'a' withOccurrences: 3.\r\tself assert: aBag size equals: 3"},{"name":"collectionWithEqualElements","linesOfCode":2,"sourceCode":"collectionWithEqualElements\r\t^ nonEmpty "},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection anyOne"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ 666"},{"name":"testAdd","linesOfCode":9,"sourceCode":"testAdd\r\r\t| aBag |\r\taBag := Bag new.\r\taBag add: 'a'.\r\taBag add: 'b'.\r\t\r\tself assert: aBag size equals: 2.\r\taBag add: 'a'.\r\tself assert: aBag size equals: 3.\r\tself assert: (aBag occurrencesOf: 'a') equals: 2"},{"name":"testAsDictionary","linesOfCode":11,"sourceCode":"testAsDictionary\r\t| aBag aDictonary |\r\taBag := Bag new.\r\taBag add: 'a' withOccurrences: 4.\r\taBag add: 'b' withOccurrences: 2.\r\taDictonary := aBag asDictionary.\r\tself assert: aDictonary size equals: 2.\r\tself assert: (aBag as: Dictionary) equals: aDictonary.\r\tself assert: (aDictonary at: 'a') equals: 4.\r\tself assert: aBag asDictionary equals: aBag valuesAndCounts.\r\tself deny: aBag asDictionary identicalTo: aBag valuesAndCounts"},{"name":"testFlatCollect","linesOfCode":8,"sourceCode":"testFlatCollect\r\t| bag |\r\tbag := Bag new.\r\tbag add: {1 . 2 . 3}.\r\tbag add: {4 . 5 . 6}.\r\r\tself assert: (bag flatCollect: [ :x | x ]) equals: #(1 2 3 4 5 6) asBag.\r\tself assert: (bag flatCollect: [ :x | x ]) class identicalTo: Bag.\r\tself assertEmpty: (#() asBag flatCollect: [ :x | 1 to: 4 ])"},{"name":"testSortedCounts","linesOfCode":11,"sourceCode":"testSortedCounts\r\t\r\t| bag sortedCounts|\r\tbag := Bag new.\r\tbag add: '1' withOccurrences: 10.\r\tbag add: '2' withOccurrences: 1.\r\tbag add: '3' withOccurrences: 5.\r\t\r\tsortedCounts := bag sortedCounts.\r\tself assert: sortedCounts size equals: 3.\r\t\r\tself assert: sortedCounts first equals: (10->'1').\r\tself assert: sortedCounts second equals: (5->'3').\r\tself assert: sortedCounts third equals: (1->'2')"},{"name":"elementNotIn","linesOfCode":2,"sourceCode":"elementNotIn\r\r\t^elementNotIn "},{"name":"nonEmpty1Element","linesOfCode":2,"sourceCode":"nonEmpty1Element\r\r\t^ self speciesClass  new add: self element ;yourself."},{"name":"elementTwiceIn","linesOfCode":2,"sourceCode":"elementTwiceIn\r\t^ super elementTwiceIn"},{"name":"otherCollection","linesOfCode":2,"sourceCode":"otherCollection\r\t^ otherCollectionWithoutEqualElements"},{"name":"result","linesOfCode":2,"sourceCode":"result\r\r\t^ collectResult.\r\t"},{"name":"testEqual","linesOfCode":20,"sourceCode":"testEqual\r\t| bag1 bag2 |\r\tbag1 := Bag new.\r\tbag2 := Bag new.\r\tself assert: bag1 equals: bag2.\r\tbag1\r\t\tadd: #a;\r\t\tadd: #b.\r\tbag2\r\t\tadd: #a;\r\t\tadd: #a.\r\tself deny: bag1 equals: bag2.\r\tself assert: bag1 equals: bag1.\r\tbag1 add: #a.\r\tbag2 add: #b.\r\tself assert: bag1 equals: bag2.\r\tbag1 add: #c.\r\tself deny: bag1 equals: bag2.\r\tbag2 add: #c.\r\tself assert: bag1 equals: bag2"},{"name":"testIdentityIncludes","linesOfCode":8,"sourceCode":"testIdentityIncludes\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\r\t| collection anElement |\r\tself collectionWithCopyNonIdentical.\r\tcollection := self collectionWithCopyNonIdentical.\r\tanElement := collection anyOne copy.\t\"self assert: (collection includes: element).\"\r\tself deny: (collection identityIncludes: anElement)"},{"name":"testOccurrencesOf","linesOfCode":14,"sourceCode":"testOccurrencesOf\t\r\r\t| aBag |\r \taBag := Bag new.\t\r\taBag add: 'a' withOccurrences: 3.\r\taBag add: 'b'.\r\taBag add: 'b'.\r\taBag add: 'b'.\r\taBag add: 'b'.\t\r\tself assert: (aBag occurrencesOf: 'a') equals: 3.\r\tself assert: (aBag occurrencesOf: 'b') equals: 4.\r\tself assert: (aBag occurrencesOf: 'c') equals: 0.\r\tself assert: (aBag occurrencesOf: nil) equals: 0.\r\taBag add: nil.\r\tself assert: (aBag occurrencesOf: nil) equals: 1."},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\r\t^ nonEmpty.\r\t"},{"name":"collectionOfFloat","linesOfCode":2,"sourceCode":"collectionOfFloat\r\t^ collectionOfString"},{"name":"testSortedElements","linesOfCode":11,"sourceCode":"testSortedElements\r\t\r\t| bag sortedElements|\r\tbag := Bag new.\r\tbag add: '2' withOccurrences: 1.\r\tbag add: '1' withOccurrences: 10.\r\tbag add: '3' withOccurrences: 5.\r\t\r\tsortedElements := bag sortedElements.\r\t\r\tself assert: sortedElements size equals: 3.\r\t\r\tself assert: sortedElements first equals: ('1'->10).\r\tself assert: sortedElements second equals: ('2'->1).\r\tself assert: sortedElements third equals: ('3'->5)"},{"name":"testRemoveAll","linesOfCode":9,"sourceCode":"testRemoveAll\r\t\"Allows one to remove all elements of a collection\"\r\r\t| c1 c2 s2 |\r\tc1 := #(10 9 8 7 5 4 4 2) asBag.\r\tc2 := c1 copy.\r\ts2 := c2 size.\r\r\tc1 removeAll.\r\r\tself assert: c1 size equals: 0.\r\tself assert: c2 size = s2 description: 'the copy has not been modified'"},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^ Bag"},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\t^ collectionWithCharacters "},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ empty\r\t\r\t"},{"name":"testAsBag","linesOfCode":4,"sourceCode":"testAsBag\r\t| aBag |\r\taBag := Bag new.\r\r\tself assert: aBag asBag equals: aBag"},{"name":"testRemoveElementThatExistsTwice","linesOfCode":6,"sourceCode":"testRemoveElementThatExistsTwice\r\t| size |\r\tsize := self nonEmpty size.\r\tself assert: (self nonEmpty includes: self elementTwiceIn).\r\tself nonEmpty remove: self elementTwiceIn.\r\tself assert: size - 1 equals: self nonEmpty size"},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\t^ nonEmpty "},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ elementNotIn "},{"name":"collectionWithoutEqualElements","linesOfCode":2,"sourceCode":"collectionWithoutEqualElements\r\t^ otherCollectionWithoutEqualElements"},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ super element"},{"name":"expectedSizeAfterReject","linesOfCode":2,"sourceCode":"expectedSizeAfterReject\r\t^ 2"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\t\"Returns a collection that already includes what is returned by #element.\"\r\t^ collectionWithElement"},{"name":"sizeCollection","linesOfCode":2,"sourceCode":"sizeCollection\r\t^ otherCollectionWithoutEqualElements"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\t\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^ collectionWithoutNilMoreThan5"},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\" return a collection including at least 5 elements\"\r\t\r\t^ collectionWithoutNilMoreThan5 "},{"name":"doWithoutNumber","linesOfCode":2,"sourceCode":"doWithoutNumber\r\r\t^ 4"},{"name":"testCopyNonEmptyWithoutAllNotIncluded","linesOfCode":1,"sourceCode":"testCopyNonEmptyWithoutAllNotIncluded\r\t"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ nonEmpty\r\t\r\t"},{"name":"elementInForIncludesTest","linesOfCode":2,"sourceCode":"elementInForIncludesTest\r\r\t^ self element "},{"name":"selectedNumber","linesOfCode":2,"sourceCode":"selectedNumber\r\t^ 4"},{"name":"collectionInForIncluding","linesOfCode":2,"sourceCode":"collectionInForIncluding\r\t ^ collectionIn "},{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotInForOccurrences)"},{"name":"testAsSet","linesOfCode":8,"sourceCode":"testAsSet\r\t| aBag aSet |\r\taBag := Bag new.\r\taBag add: 'a' withOccurrences: 4.\r\taBag add: 'b' withOccurrences: 2.\r\taSet := aBag asSet.\r\tself assert: aSet size equals: 2.\r\tself assert: (aSet occurrencesOf: 'a') equals: 1"},{"name":"elementToAdd","linesOfCode":2,"sourceCode":"elementToAdd\r\t^ 42"},{"name":"testAnySastify","linesOfCode":3,"sourceCode":"testAnySastify\r\r\tself assert: ( self collection anySatisfy: [:each | each = self element]).\r\tself deny: (self collection anySatisfy: [:each | each isString])."},{"name":"testCumulativeCounts","linesOfCode":11,"sourceCode":"testCumulativeCounts\r\t| bag cumulativeCounts |\r\tbag := Bag new.\r\tbag add: '1' withOccurrences: 50.\r\tbag add: '2' withOccurrences: 40.\r\tbag add: '3' withOccurrences: 10.\r\t\r\tcumulativeCounts := bag cumulativeCounts.\r\t\r\tself assert: cumulativeCounts size equals: 3.\r\tself assert: cumulativeCounts first equals: (50 -> '1').\r\tself assert: cumulativeCounts second equals: (90 -> '2').\r\tself assert: cumulativeCounts third equals: (100 -> '3')"},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t^ 42"},{"name":"elementInForOccurrences","linesOfCode":3,"sourceCode":"elementInForOccurrences\r\" return an element included in nonEmpty\"\r\t^self nonEmpty anyOne."},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ Bag"},{"name":"setUp","linesOfCode":58,"sourceCode":"setUp\r\tsuper setUp.\r\tempty := self speciesClass new.\r\tnonEmpty := self speciesClass new\r\t\tadd: 13;\r\t\tadd: -2;\r\t\tadd: self elementTwiceIn;\r\t\tadd: 10;\r\t\tadd: self elementTwiceIn;\r\t\tadd: self element;\r\t\tyourself.\r\telementNotIn := 0.\r\tcollectionIn := self speciesClass new\r\t\tadd: -2;\r\t\tadd: self elementTwiceIn;\r\t\tadd: 10;\r\t\tyourself.\r\tcollectionNotIn := self speciesClass new\r\t\tadd: self elementNotIn;\r\t\tadd: 5;\r\t\tyourself.\r\tcollectionOfString := self speciesClass new\r\t\tadd: 'a';\r\t\tadd: 'b';\r\t\tadd: 'c';\r\t\tyourself.\r\totherCollectionWithoutEqualElements := self speciesClass new\r\t\tadd: 1;\r\t\tadd: 20;\r\t\tadd: 30;\r\t\tadd: 40;\r\t\tyourself.\r\tcollectionWithoutNilMoreThan5 := self speciesClass new\r\t\tadd: 1;\r\t\tadd: 2;\r\t\tadd: 3;\r\t\tadd: 4;\r\t\tadd: 5;\r\t\tadd: 6;\r\t\tyourself.\r\tcollectResult := self speciesClass new\r\t\tadd: SmallInteger;\r\t\tadd: SmallInteger;\r\t\tadd: SmallInteger;\r\t\tadd: SmallInteger;\r\t\tadd: SmallInteger;\r\t\tadd: SmallInteger;\r\t\tyourself.\r\temptyButAllocatedWith20 := self speciesClass new: 20.\r\tcollectionWithElement := self speciesClass new\r\t\tadd: self element;\r\t\tyourself.\r\tcollectionWithCharacters := self speciesClass new\r\t\tadd: $p;\r\t\tadd: $v;\r\t\tadd: $i;\r\t\tadd: $y;\r\t\tyourself"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ Bag"},{"name":"testRemove","linesOfCode":13,"sourceCode":"testRemove\r\t| bag item |\r\titem := 'test item'.\r\tbag := Bag new.\r\r\tbag add: item.\r\tself assert: bag size equals: 1.\r\tbag remove: item.\r\tself assertEmpty: bag.\r\r\tbag add: item withOccurrences: 2.\r\tbag remove: item.\r\tbag remove: item.\r\tself assert: bag size equals: 0.\r\r\tself should: [ bag remove: item ] raise: Error"},{"name":"emptyButAllocatedWith20","linesOfCode":2,"sourceCode":"emptyButAllocatedWith20 \r\t\r\t\t^ emptyButAllocatedWith20"},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\" return an element included exactly two time in # collectionWithEqualElements\"\r^ self elementTwiceIn "}],"meta":{"name":"BagTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"NestedDictionaryTest","instanceVariables":[],"methods":[{"name":"testAtAtOnIdentityDictinary","linesOfCode":13,"sourceCode":"testAtAtOnIdentityDictinary\r\r\t| dct key1 key2 subDct |\r\r\tdct := IdentityDictionary new.\r\tkey1 := 'a'.\r\tkey2 := key1 copy.\r\tdct\r\t\tat: #a at: key1 put: 1;\r\t\tat: #a at: key2 put: 2.\r\tsubDct := dct at: #a.\r\tTestCase new\r\t\tassert: subDct size equals: 2;\r\t\tassert: (subDct at: key1) equals: 1;\r\t\tassert: (subDct at: key2) equals: 2"},{"name":"testAtAtIfAbsent","linesOfCode":11,"sourceCode":"testAtAtIfAbsent\r\t| d |\r\td := Dictionary new.\r\td at: #top at: #below1 put: 1.\r\td at: #top at: #below1 put: 2.\r\td at: #fop at: #below1 put: 1.\r\tself assert: (d at: #top at: #below1) equals: 2.\r\tself assert: (d at: #fop at: #below666 ifAbsent: [ 666 ]) equals: 666.\r\tself assert: (d at: #fop666 at: #below1 ifAbsent: [ 666 ]) equals: 666.\r\t\"when the first key is not found do not execute the second one.\"\r\tself assert: (d at: #fop666 at: [ 1 / 0 ] ifAbsent: [ 666 ]) equals: 666"},{"name":"testAtAtputHasLastPutLastStayBehavior","linesOfCode":6,"sourceCode":"testAtAtputHasLastPutLastStayBehavior\r\t| d |\r\td := Dictionary new.\r\td at: #top at: #below1 put: 1.\r\td at: #top at: #below1 put: 2.\r\tself assert: (d at: #top at: #below1) equals: 2"},{"name":"testAtAtIfAbsentPut","linesOfCode":10,"sourceCode":"testAtAtIfAbsentPut\r\t| d |\r\td := Dictionary new.\r\td at: #first at: #second put: [ 2 ].\r\td at: #first at: #second42 ifAbsentPut: [ 142 ].\r\td at: #first42 at: #second ifAbsentPut: [ 42 ].\r\td at: #first42 at: #second42 ifAbsentPut: [ 0 ].\r\tself assert: (d at: #first at: #second42) equals: 142.\r\tself assert: (d at: #first42 at: #second) equals: 42.\r\tself assert: (d at: #first42 at: #second42) equals: 0.\r\t"},{"name":"testAtAtPut","linesOfCode":8,"sourceCode":"testAtAtPut\r\t| d |\r\td := Dictionary new.\r\td at: #top at: #below1 put: 1.\r\td at: #top at: #below1 put: 2.\r\td at: #fop at: #below1 put: 1.\r\tself assert: (d at: #top at: #below1) equals: 2.\r\tself assert: (d at: #fop at: #below1) equals: 1"},{"name":"testAtAtputEffectivelyPutAValue","linesOfCode":5,"sourceCode":"testAtAtputEffectivelyPutAValue\r\t| d |\r\td := Dictionary new.\r\td at: #top at: #below1 put: 1.\r\tself assert: (d at: #top at: #below1) equals: 1"}],"meta":{"name":"NestedDictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SmallIdentityDictionaryTest","instanceVariables":[],"methods":[{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r \r\t^ SmallIdentityDictionary"},{"name":"canBeUnhealthy","linesOfCode":2,"sourceCode":"canBeUnhealthy\r\t^ false"}],"meta":{"name":"SmallIdentityDictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ObjectWithSettableHash","instanceVariables":[{"name":"hash"}],"methods":[{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\r\t\"Make sure hash answers a SmallInteger, even if we haven't set it yet.\"\r\r\tsuper initialize.\r\thash := 0"},{"name":"hash:","linesOfCode":2,"sourceCode":"hash: anObject\r\r\thash := anObject"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\r\t^ hash"}],"meta":{"name":"ObjectWithSettableHash class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentityDictionaryTest","instanceVariables":[],"methods":[{"name":"canBeUnhealthy","linesOfCode":2,"sourceCode":"canBeUnhealthy\r\t^ false"},{"name":"testIdentity","linesOfCode":12,"sourceCode":"testIdentity\r\t| dict key |\r\tdict := self classToBeTested new.\r\tkey := 'key'.\r\tdict at: key put: 2.5.\r\t \r\t\r\tself assert: (dict includesKey: key).\r\tself deny: (dict includesKey: key copy).\r\t\r\"\tdict at: 1 put: 'djdh'.\r\tdict at: 'sksl' put: 1.0.\r\tself deny: (dict includesKey: 1.0) .\r\tself assert: (dict includes: 1)\"\r"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ IdentityDictionary"}],"meta":{"name":"IdentityDictionaryTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r^true"}],"meta":null}},{"name":"TDictionaryValueAccessTest","instanceVariables":[],"methods":[{"name":"testAtIfPresentIfAbsentPut","linesOfCode":29,"sourceCode":"testAtIfPresentIfAbsentPut\r\t\"self run: #testAtIfPresentIfAbsentPut\"\r\r\t| collection association arg |\r\tcollection := self nonEmpty.\r\tassociation := collection associations anyOne.\r\targ := nil.\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: association key\r\t\t\t\tifPresent: [ :value | \r\t\t\t\t\targ := value.\r\t\t\t\t\t#present ]\r\t\t\t\tifAbsentPut: [ Error signal ]) = #present.\r\tself assert: arg = association value.\r\r\t\"ensure cull: is used to support blocks that take no args\"\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: association key\r\t\t\t\tifPresent: [ #present ]\r\t\t\t\tifAbsentPut: [ Error signal ]) = #present.\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: self keyNotIn\r\t\t\t\tifPresent: [ :value | Error signal ]\r\t\t\t\tifAbsentPut: [ self valueNotIn ]) = self valueNotIn.\r\tself assert: (collection at: self keyNotIn) = self valueNotIn"},{"name":"testAtIfAbsent","linesOfCode":13,"sourceCode":"testAtIfAbsent\r\t\"self run: #testAtIfAbsent\"\r\r\t| collection association |\r\tcollection := self nonEmpty.\r\tassociation := collection associations anyOne.\r\tself\r\t\tassert:\r\t\t\t(collection at: association key ifAbsent: [ Error signal ])\r\t\t\t\t= association value.\r\tself\r\t\tassert:\r\t\t\t(collection at: self keyNotIn ifAbsent: [ self valueNotIn ])\r\t\t\t\t= self valueNotIn"},{"name":"keyNotIn","linesOfCode":3,"sourceCode":"keyNotIn\r\" return a key not included in nonEmpty\"\r^ self explicitRequirement"},{"name":"valueNotIn","linesOfCode":2,"sourceCode":"valueNotIn\r\tself explicitRequirement"},{"name":"testAtIfPresent","linesOfCode":22,"sourceCode":"testAtIfPresent\r\t\"self run: #testAtIfPresent\"\r\r\t| collection association arg |\r\tcollection := self nonEmpty.\r\tassociation := collection associations anyOne.\r\targ := nil.\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: association key\r\t\t\t\tifPresent: [ :value | \r\t\t\t\t\targ := value.\r\t\t\t\t\t#present ]) = #present.\r\tself assert: arg = association value.\r\r\t\"ensure cull: is used to support blocks that take no args\"\r\tself\r\t\tassert: (collection at: association key ifPresent: [ #present ]) = #present.\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: self keyNotIn\r\t\t\t\tifPresent: [ :value | Error signal ]) isNil"},{"name":"testAtPutDict","linesOfCode":18,"sourceCode":"testAtPutDict\r\t\"Do not rename to testAtPut, will conflict with TPutBasicTest>>#testAtPut\"\r\r\t\"self run: #testAtPutDict\"\r\r\t| collection keyIn newValue |\r\tcollection := self nonEmpty.\r\tkeyIn := collection keys anyOne.\r\tnewValue := self valueNotIn.\r\r\t\"use == to ensure the exact object argument to put: is stored and returned\"\r\tself assert: (collection at: keyIn put: newValue) == newValue.\r\tself assert: (collection at: keyIn) == newValue.\r\r\tnewValue := self valueNotIn -> self valueNotIn.\r\tself assert: (collection at: keyIn put: newValue) == newValue.\r\tself assert: (collection at: keyIn) == newValue.\r\r\tnewValue := {self valueNotIn.\r\tself valueNotIn.\r\tself valueNotIn}.\r\tself assert: (collection at: self keyNotIn put: newValue) == newValue.\r\tself assert: (collection at: self keyNotIn) == newValue"},{"name":"testAtIfAbsentPut","linesOfCode":15,"sourceCode":"testAtIfAbsentPut\r\t\"self run: #testAtIfAbsentPut\"\r\r\t| collection association |\r\tcollection := self nonEmpty.\r\tassociation := collection associations anyOne.\r\tself\r\t\tassert:\r\t\t\t(collection at: association key ifAbsentPut: [ Error signal ])\r\t\t\t\t= association value.\r\tself assert: (collection at: association key) = association value.\r\tself\r\t\tassert:\r\t\t\t(collection at: self keyNotIn ifAbsentPut: [ self valueNotIn ])\r\t\t\t\t= self valueNotIn.\r\tself assert: (collection at: self keyNotIn) = self valueNotIn"},{"name":"testAtPutNil","linesOfCode":18,"sourceCode":"testAtPutNil\r\t\"self run: #testAtPutNil\"\r\r\t| collection keyIn newValue |\r\tcollection := self nonEmpty.\r\tkeyIn := collection keys anyOne.\r\tnewValue := self valueNotIn.\r\tself assert: (collection at: nil put: newValue) == newValue.\r\tself supportsNilKey\r\t\tifTrue: [ self assert: (collection at: nil) == newValue ]\r\t\tifFalse: [ self deny: (collection includesKey: nil) ].\r\tself assert: (collection at: keyIn put: nil) isNil.\r\tself assert: (collection at: keyIn) isNil.\r\tself assert: (collection at: self keyNotIn put: nil) isNil.\r\tself assert: (collection at: self keyNotIn) isNil.\r\tself assert: (collection at: nil put: nil) isNil.\r\tself supportsNilKey\r\t\tifTrue: [ self assert: (collection at: nil) isNil ]\r\t\tifFalse: [ self deny: (collection includesKey: nil) ]"},{"name":"testAt","linesOfCode":7,"sourceCode":"testAt\r\t\"self run: #testAt\"\r\r\t| collection association |\r\tcollection := self nonEmpty.\r\tassociation := collection associations anyOne.\r\tself assert: (collection at: association key) = association value.\r\tself should: [ collection at: self keyNotIn ] raise: Error"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r^ self explicitRequirement"},{"name":"testAtIfPresentIfAbsent","linesOfCode":28,"sourceCode":"testAtIfPresentIfAbsent\r\t\"self run: #testAtIfPresentIfAbsent\"\r\r\t| collection association arg |\r\tcollection := self nonEmpty.\r\tassociation := collection associations anyOne.\r\targ := nil.\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: association key\r\t\t\t\tifPresent: [ :value | \r\t\t\t\t\targ := value.\r\t\t\t\t\t#present ]\r\t\t\t\tifAbsent: [ Error signal ]) = #present.\r\tself assert: arg = association value.\r\r\t\"ensure cull: is used to support blocks that take no args\"\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: association key\r\t\t\t\tifPresent: [ #present ]\r\t\t\t\tifAbsent: [ Error signal ]) = #present.\r\tself\r\t\tassert:\r\t\t\t(collection\r\t\t\t\tat: self keyNotIn\r\t\t\t\tifPresent: [ :value | Error signal ]\r\t\t\t\tifAbsent: [ self valueNotIn ]) = self valueNotIn"},{"name":"test0FixtureDictionaryElementAccess","linesOfCode":8,"sourceCode":"test0FixtureDictionaryElementAccess\r\t| in |\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself keyNotIn.\r\tin := true.\r\tself nonEmpty keys detect: [ :key | key = self keyNotIn ] ifNone: [ in := false ].\r\tself deny: in"},{"name":"supportsNilKey","linesOfCode":2,"sourceCode":"supportsNilKey\r\t^ true"}],"meta":{"name":"TDictionaryValueAccessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryCopyingTest","instanceVariables":[],"methods":[{"name":"testDictionaryConcatenationWithoutCommonKeys","linesOfCode":8,"sourceCode":"testDictionaryConcatenationWithoutCommonKeys\r\r\t| dictionary1 dictionary2 result |\r\tdictionary1 := self nonEmptyDict.\r\tdictionary2 := self nonEmptyDifferentFromNonEmptyDict.\r\tresult := dictionary1 , dictionary2.\r\tself assert: result size = (dictionary1 size + dictionary2 size).\r\tdictionary1 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ].\r\tdictionary2 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ]"},{"name":"testCopyNonEmpty","linesOfCode":6,"sourceCode":"testCopyNonEmpty\r\t| copy |\r\tcopy := self nonEmpty copy.\r\tself denyEmpty: copy.\r\tself assert: copy size = self nonEmpty size.\r\tself nonEmpty do: [ :each | copy includes: each ]"},{"name":"testDictionaryConcatenationWithCommonKeysDifferentValues","linesOfCode":9,"sourceCode":"testDictionaryConcatenationWithCommonKeysDifferentValues\r\r\t| dictionary1 dictionary2 result value |\r\t\r\tdictionary1 := self nonEmptyDict.\r\tvalue := self nonEmptyDifferentFromNonEmptyDict   values anyOne.\r\tdictionary2 := dictionary1 copy.\r\tdictionary2 keys do: [ :key | dictionary2 at: key put: value ].\r\t\r\t\r\tresult := dictionary1 , dictionary2.\r\tself assert: result size = ( dictionary2 size).\r\t\r\tdictionary2 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ]"},{"name":"nonEmptyDifferentFromNonEmptyDict","linesOfCode":3,"sourceCode":"nonEmptyDifferentFromNonEmptyDict\r\" return a dictionary for which all keys are not included in nonEmptyDict\"\rself explicitRequirement."},{"name":"newEmptyDict","linesOfCode":2,"sourceCode":"newEmptyDict\r\tself explicitRequirement"},{"name":"testCopyCreatesNewObject","linesOfCode":4,"sourceCode":"testCopyCreatesNewObject\r\t\r\t| copy | \r\tcopy := self nonEmpty copy.\r\tself deny: self nonEmpty == copy.\r\t"},{"name":"nonEmptyDict","linesOfCode":2,"sourceCode":"nonEmptyDict\r\tself explicitRequirement"},{"name":"test0FixtureDictionaryCopyingTest","linesOfCode":9,"sourceCode":"test0FixtureDictionaryCopyingTest\r\t| duplicateKey |\r\tself nonEmptyDict.\r\tself denyEmpty: self nonEmptyDict.\r\tself nonEmptyDifferentFromNonEmptyDict.\r\tself denyEmpty: self nonEmptyDifferentFromNonEmptyDict.\r\tduplicateKey := true.\r\tself nonEmptyDict keys detect: [ :key | self nonEmptyDifferentFromNonEmptyDict includes: key ] ifNone: [ duplicateKey := false ].\r\tself deny: duplicateKey"},{"name":"testCopyEmpty","linesOfCode":2,"sourceCode":"testCopyEmpty\r\tself assertEmpty: self empty copy"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ self explicitRequirement"},{"name":"test0FixtureCloneTest","linesOfCode":5,"sourceCode":"test0FixtureCloneTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"testDictionaryConcatenationWithCommonKeys","linesOfCode":7,"sourceCode":"testDictionaryConcatenationWithCommonKeys\r\r\t| dictionary1 dictionary2 result |\r\tdictionary1 := self nonEmptyDict.\r\tdictionary2 := self nonEmptyDict.\r\tresult := dictionary1 , dictionary2.\r\tself assert: result size = ( dictionary2 size).\r\t\r\tdictionary2 associationsDo: [ :assoc | self assert: (result at: assoc key) = assoc value ]"},{"name":"emptyDict","linesOfCode":2,"sourceCode":"emptyDict\r\tself explicitRequirement"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ self explicitRequirement"}],"meta":{"name":"TDictionaryCopyingTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentityBagTest","instanceVariables":[{"name":"equalNotIdenticalElement"},{"name":"elementToCopy"},{"name":"identityBagNonEmptyNoDuplicate5Elements"}],"methods":[{"name":"equalNotIdenticalElement","linesOfCode":2,"sourceCode":"equalNotIdenticalElement\r\t^ equalNotIdenticalElement ifNil: [ equalNotIdenticalElement := self elementToCopy copy ]"},{"name":"testIdentityAdd","linesOfCode":7,"sourceCode":"testIdentityAdd\r\t| added |\r\tself collection add: self elementToCopy.\r\tself deny: (self collection includes: self equalNotIdenticalElement).\r\r\tadded := self collection add: self equalNotIdenticalElement.\r\tself assert: added identicalTo: self equalNotIdenticalElement.\r\tself assert: (self collection includes: self equalNotIdenticalElement)"},{"name":"elementToCopy","linesOfCode":2,"sourceCode":"elementToCopy\r\t^ elementToCopy ifNil: [ elementToCopy := 'element to copy' ]"},{"name":"testAsSetWithEqualsElements","linesOfCode":5,"sourceCode":"testAsSetWithEqualsElements\r\t| t1 |\r\tt1 := self withEqualElements asSet.\r\tself withEqualElements do: [ :t2 | self assert: (t1 occurrencesOf: t2) equals: 1 ].\r\tself assert: t1 class equals: IdentitySet"},{"name":"identityCollectionWithElementsCopyNotIdentical","linesOfCode":4,"sourceCode":"identityCollectionWithElementsCopyNotIdentical\r\"Returns a collection including elements for which #copy doesn't return the same object.\"\r\t^ identityBagNonEmptyNoDuplicate5Elements ifNil: [ \r\tidentityBagNonEmptyNoDuplicate5Elements := IdentityBag new add: 2.5 ; add: 1.5  ;add: 5.5 ; yourself ]"},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t^ IdentityBag"},{"name":"testIdentity","linesOfCode":18,"sourceCode":"testIdentity\r \r\t| bag identityBag aString anOtherString |\r\t\r\taString := 'hello'.\r\tanOtherString := aString copy.\r\t\r\tself assert: aString equals: anOtherString.\r\tself assert: (aString == anOtherString) not.\r\r\tbag := Bag new.\r\tbag add: aString.\r\tbag add: aString.\r\tbag add: anOtherString.\r\tself assert: (bag occurrencesOf: aString) equals: 3.\r\tself assert: (bag occurrencesOf: anOtherString) equals: 3.\r\t\r\tidentityBag := IdentityBag new.\r\tidentityBag add: aString.\r\tidentityBag add: aString.\r\tidentityBag add: anOtherString.\r\t\r\tself assert: (identityBag occurrencesOf: aString) equals: 2.\r\tself assert: (identityBag occurrencesOf: anOtherString) equals: 1.\r\r\r\r"}],"meta":{"name":"IdentityBagTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryComparingTest","instanceVariables":[],"methods":[{"name":"testEquality","linesOfCode":5,"sourceCode":"testEquality\r\t| nonEmptyDict2 |\r\tnonEmptyDict2 := self nonEmpty class new.\r\tself nonEmpty keysAndValuesDo:  [ :key :value | nonEmptyDict2 at: key put: value  ].\r\t\r\tself assert: (self nonEmptyDict = nonEmptyDict2)"}],"meta":{"name":"TDictionaryComparingTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryKeysValuesAssociationsAccess","instanceVariables":[],"methods":[{"name":"testKeys","linesOfCode":7,"sourceCode":"testKeys\r\t| collection result |\r\tcollection := self nonEmpty.\r\tresult := collection keys.\r\tresult do: [ :key | collection at: key ].\r\tself assert: result size = collection size.\r\tself should: [ result detect: [ :each | (result occurrencesOf: each) > 1 ] ] raise: Error"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\rself explicitRequirement."},{"name":"testAssociations","linesOfCode":7,"sourceCode":"testAssociations\r\r\t| collection result  |\r\tcollection := self nonEmpty .\r\tresult := collection associations.\r\t\r\tself assert: result size = collection size.\r\tresult do: [:assoc | self assert: (assoc value) = (collection at: assoc key) ].\r\t\"keys do: [ :key | self assert: ( result at: key ) = ( collection at: key )] .\"\r\t"},{"name":"test0FixtureDictionaryKeysValuesAssociationsAccess","linesOfCode":3,"sourceCode":"test0FixtureDictionaryKeysValuesAssociationsAccess\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty"},{"name":"testKeysSortedSafely","linesOfCode":8,"sourceCode":"testKeysSortedSafely\r\t| collection result |\r\tcollection := self nonEmpty.\r\tresult := collection keysSortedSafely.\r\tresult do: [ :key | collection at: key ].\r\tself assert: result size = collection size.\r\tself should: [ result detect: [ :each | (result occurrencesOf: each) > 1 ] ] raise: Error.\r\tself assert: result asArray isSorted"},{"name":"testValues","linesOfCode":6,"sourceCode":"testValues\r\t\r\t| collection result |\r\tcollection := self nonEmpty .\r\tresult := collection values.\r\t\r\tself assert: result size = collection size.\r\tresult do: [:each | self assert: (collection occurrencesOf:each ) = (result occurrencesOf: each) ].\r\t"}],"meta":{"name":"TDictionaryKeysValuesAssociationsAccess classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"SmallDictionaryTest","instanceVariables":[],"methods":[{"name":"testStoreOn","linesOfCode":4,"sourceCode":"testStoreOn\r\tself\r\t\tassert: self nonEmptyDict storeString\r\t\tequals: '((' , self nonEmptyDict class printString , ' new) add: (#a->1); add: (#b->30); add: (#c->1); add: (#d-> -2); yourself)'"},{"name":"testNewFromKeysAndValues2","linesOfCode":9,"sourceCode":"testNewFromKeysAndValues2\r \r\t| dict newDict |\r\tdict := self classToBeTested new\r\t\tat: #a put: 1;\r\t\tat: #b put: 2;\r\t\tat: #c put: 3; yourself.\r\tnewDict := self classToBeTested newFromKeys: dict keys andValues: dict values.\r\tdict keysAndValuesDo: [:k :v|\r\t\tself assert: (newDict at: k) equals: v ]. "},{"name":"testAtUpdateInitial","linesOfCode":7,"sourceCode":"testAtUpdateInitial\r\t| dict |\r\tdict := SmallDictionary newFrom: {2->10. 100->5} .\r\tdict at: 5 update: [ :v | v+1 ] initial: 17.\r\tdict at: 2 update: [ :v | v+10 ] initial: [0].\r\tself assert: (dict at: 5) equals: 17.\r\tself assert: (dict at: 2) equals: 20\r\t"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ SmallDictionary"},{"name":"testAtUpdate","linesOfCode":6,"sourceCode":"testAtUpdate\r\t| dict |\r\tdict := SmallDictionary newFrom: {2->10. 100->5} .\r\t\r\tdict at: 2 update: [ :v | v+10 ].\r\tself assert: (dict at: 2) equals: 20.\r\tself should: [ dict at: 5 update: [ :v | v+1 ] ] raise: KeyNotFound .\r\t\r"},{"name":"testStoreOnRoundTrip","linesOfCode":11,"sourceCode":"testStoreOnRoundTrip\r\t| dictionary storeString evalutated |\r\tdictionary := self classToBeTested new.\r\tdictionary\r\t\tadd: #a -> 1;\r\t\tadd: #b -> 30;\r\t\tadd: #c -> 1;\r\t\tadd: #d -> -2.\r\tstoreString := String streamContents: [ :s | dictionary storeOn: s ].\r\tevalutated := Smalltalk compiler evaluate: storeString.\r\tself assert: dictionary equals: evalutated"}],"meta":{"name":"SmallDictionaryTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r^true"}],"meta":null}},{"name":"TDictionaryRemovingTest","instanceVariables":[],"methods":[{"name":"testKeysAndValuesRemove","linesOfCode":10,"sourceCode":"testKeysAndValuesRemove\r\t| oldSize collection keyIn |\r\t\r\tcollection := self nonEmptyDict .\r\toldSize := collection  size.\r\tkeyIn := collection keys anyOne.\r\t\r\tcollection  keysAndValuesRemove: [:key :value | key == self keyNotInNonEmptyDict ].\r\tself assert: (collection  size = (oldSize )).\r\t\r\tcollection  keysAndValuesRemove: [:key :value | key == keyIn ].\r\tself assert: (collection  size = (oldSize - 1)).\r\tself should: [ collection at: keyIn  ] raise: Error."},{"name":"keyNotInNonEmptyDict","linesOfCode":3,"sourceCode":"keyNotInNonEmptyDict\r\" return a key not included in nonEmptyDict\"\r\tself explicitRequirement"},{"name":"newEmptyDict","linesOfCode":2,"sourceCode":"newEmptyDict\r\tself explicitRequirement"},{"name":"testRemoveKeyIfAbsent","linesOfCode":11,"sourceCode":"testRemoveKeyIfAbsent\r\t\r\t| collection oldSize keyIn value result |\r\tcollection := self nonEmptyDict .\r\toldSize := collection size.\r\tkeyIn := collection  keys anyOne.\r\tvalue := collection at: keyIn .\r\t\r\tresult := collection removeKey: keyIn ifAbsent: [888].\r\t\r\tself assert: result = value.\r\tself assert: (collection  size = (oldSize - 1)).\r\tself should: [ (collection  at: keyIn )] raise: Error.\r\t\r\tself assert: (collection removeKey: self keyNotInNonEmptyDict ifAbsent: [888] ) = 888."},{"name":"testRemoveKey","linesOfCode":9,"sourceCode":"testRemoveKey\r\t\r\t| collection oldSize keyIn |\r\tcollection := self nonEmptyDict .\r\toldSize := collection size.\r\tkeyIn := collection  keys anyOne.\r\t\r\tcollection removeKey: keyIn .\r\tself assert: (collection  size = (oldSize - 1)).\r\tself should: [ (collection  at: keyIn )] raise: Error.\r\t\r\tself should: [collection removeKey: self keyNotInNonEmptyDict ] raise: Error"},{"name":"testRemove","linesOfCode":3,"sourceCode":"testRemove\r\r\tself should: [self nonEmptyDict remove: nil] raise: Error.\r\tself should: [self nonEmptyDict remove: nil ifAbsent: ['What ever here']] raise: Error."},{"name":"emptyDict","linesOfCode":2,"sourceCode":"emptyDict\r\tself explicitRequirement"},{"name":"test0FixtureDictionaryRemovingTest","linesOfCode":5,"sourceCode":"test0FixtureDictionaryRemovingTest\r\tself nonEmptyDict.\r\tself denyEmpty: self nonEmptyDict.\r\tself keyNotInNonEmptyDict.\r\tself deny: (self nonEmptyDict keys includes: self keyNotInNonEmptyDict)"},{"name":"nonEmptyDict","linesOfCode":2,"sourceCode":"nonEmptyDict\r\tself explicitRequirement"}],"meta":{"name":"TDictionaryRemovingTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"DictionaryTest","instanceVariables":[{"name":"emptyDict"},{"name":"nonEmptyDict"},{"name":"nonEmpty5ElementsNoDuplicates"},{"name":"indexArray"},{"name":"valueArray"},{"name":"nonEmpty1Element"},{"name":"collectionNotIncluded"},{"name":"collectionIncluded"},{"name":"associationNotIn"},{"name":"valueNotIn"},{"name":"keyNotIn"},{"name":"dictionaryNotIncluded"},{"name":"dictionaryWithDuplicateValues"},{"name":"duplicateValue"},{"name":"nonEmptyWithString"}],"methods":[{"name":"associationWithKeyAlreadyInToAdd","linesOfCode":3,"sourceCode":"associationWithKeyAlreadyInToAdd\r\t\" return an association that will be used to add to nonEmptyDict (the key of this association is already included in nonEmptyDict)\"\r\t^ (self nonEmptyDict keys anyOne)->valueNotIn ."},{"name":"collectionNotIncluded","linesOfCode":3,"sourceCode":"collectionNotIncluded\r\" return a collection for wich each element is not included in 'nonEmpty' \"\r\t^collectionNotIncluded "},{"name":"keyNotIn","linesOfCode":3,"sourceCode":"keyNotIn\r\" return a key not included in nonEmpty\"\r^ keyNotIn "},{"name":"integerCollectionWithoutEqualElements","linesOfCode":3,"sourceCode":"integerCollectionWithoutEqualElements\r\" return a collection of integer without equal elements\"\r\t^ nonEmpty5ElementsNoDuplicates "},{"name":"testIncludeAssociation","linesOfCode":3,"sourceCode":"testIncludeAssociation\r\tself assert: (nonEmptyDict includesAssociation: #a -> self elementTwiceIn).\r\tself assert: (nonEmptyDict includesAssociation: (nonEmptyDict associations first)).\r"},{"name":"nonEmptyWithoutEqualsValues","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualsValues\r\" return a dictionary that doesn't include equal values'\"\r^nonEmpty5ElementsNoDuplicates "},{"name":"associationWithKeyNotInToAdd","linesOfCode":3,"sourceCode":"associationWithKeyNotInToAdd\r\t\" return an association that will be used to add to nonEmptyDict\"\r\t^ associationNotIn "},{"name":"collectionWithElementsToRemove","linesOfCode":3,"sourceCode":"collectionWithElementsToRemove\r\" return a collection of elements included in 'nonEmpty'  \"\r\t^ collectionIncluded  "},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ nonEmpty5ElementsNoDuplicates "},{"name":"testDictionaryPublicProtocolCompatibility","linesOfCode":18,"sourceCode":"testDictionaryPublicProtocolCompatibility\r\t\"Tests that other dictionaries and their classes respond to the messages\r\tin the public protocols (ignoring extensions, private, printing, copying,\r\tand comparing) that Dictionary and its metaclass implement.\"\r\r\t| dict |\r\tself collectionClass == Dictionary\r\t\tifTrue: [ ^ self ].\r\tdict := self emptyDict.\r\t{(dict -> Dictionary).\r\t(dict class -> Dictionary class)}\r\t\tdo: [ :assoc | \r\t\t\tassoc value protocols\r\t\t\t\treject: [ :protocol | \r\t\t\t\t\t#('private' 'print' 'undeclared' 'copy' 'compar' '*')\r\t\t\t\t\t\tanySatisfy: [ :each | protocol asString beginsWith: each ] ]\r\t\t\t\tthenDo: [ :protocol | \r\t\t\t\t\t(assoc value selectorsInProtocol: protocol)\r\t\t\t\t\t\tdo: [ :each | self assert: (assoc key respondsTo: each) ] ] ]"},{"name":"testAddWithKeyNotIn","linesOfCode":7,"sourceCode":"testAddWithKeyNotIn\r\t| dictionary result association |\r\tdictionary := self nonEmptyDict.\r\tassociation := self associationWithKeyNotInToAdd.\r\tresult := dictionary add: association.\r\tself assert: result equals: association.\r\tself assert: (dictionary at: association key) equals: association value"},{"name":"testIsHealthy","linesOfCode":20,"sourceCode":"testIsHealthy\r\t| dict |\r\tself canBeUnhealthy\r\t\tifFalse: [\r\t\t\tself assert: self nonEmpty isHealthy.\r\t\t\t^ self ].\r\tdict := self emptyDict.\r\t[ | a1 a2 |\r\t\"we use associations as keys on purpose, because they change their\r\thash depending on the key\"\r\ta1 := 1 -> 2.\r\ta2 := 2 -> 2.\r\tdict\r\t\tat: a1 put: 2;\r\t\tat: a2 put: 3.\r\tself assert: dict isHealthy.\r\ta1 key: 0.\r\ta2 key: 0.\r\tself deny: dict isHealthy ]\r\t\tensure: [ dict removeAll ]"},{"name":"collectionWithEqualElements","linesOfCode":3,"sourceCode":"collectionWithEqualElements\r\" return a collecition including atLeast two elements equal\"\r\r^ dictionaryWithDuplicateValues "},{"name":"testNewFromKeysAndValues2","linesOfCode":9,"sourceCode":"testNewFromKeysAndValues2\r \r\t| dict newDict |\r\tdict := self classToBeTested new\r\t\tat: #a put: 1;\r\t\tat: #b put: 2;\r\t\tat: #c put: 3; yourself.\r\tnewDict := self classToBeTested newFromKeys: dict keys andValues: dict values.\r\tdict keysAndValuesDo: [:k :v|\r\t\tself assert: (newDict at: k) equals: v ]. "},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection associations anyOne."},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ 666"},{"name":"testAdd","linesOfCode":11,"sourceCode":"testAdd\r\t\"| dict |\r\tdict := self emptyDict.\r\tdict add: #a -> 1.\r\tdict add: #b -> 2.\r\tself assert: (dict at: #a) = 1.\r\tself assert: (dict at: #b) = 2\"\r\r\t| dictionary result |\r\tdictionary := self nonEmptyDict.\r\tresult := dictionary add: self associationWithKeyNotInToAdd.\r\tself assert: result equals: self associationWithKeyNotInToAdd"},{"name":"nonEmptyDifferentFromNonEmptyDict","linesOfCode":3,"sourceCode":"nonEmptyDifferentFromNonEmptyDict\r\" return a dictionary for which all keys are not included in nonEmptyDict\"\r^ dictionaryNotIncluded "},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index key between bounds of 'nonEmpty'\"\r\r\t^ #a"},{"name":"newEmptyDict","linesOfCode":2,"sourceCode":"newEmptyDict\r\t^ self emptyDict copy"},{"name":"testAtUpdate","linesOfCode":6,"sourceCode":"testAtUpdate\r\t| dict |\r\tdict := {2->10. 100->5} asDictionary.\r\tdict at: 2 update: [ :v | v+10 ].\r\tself assert: (dict at: 2) equals: 20.\r\tself should: [ dict at: 5 update: [ :v | v+1 ] ] raise: KeyNotFound .\r\t\r\t\r\t"},{"name":"testAtUpdateInitial","linesOfCode":7,"sourceCode":"testAtUpdateInitial\r\t| dict |\r\tdict := {2->10. 100->5} asDictionary.\r\tdict at: 5 update: [ :v | v+1 ] initial: [17].\r\tdict at: 2 update: [ :v | v+10 ] initial: [0].\r\tself assert: (dict at: 5) equals: 17.\r\tself assert: (dict at: 2) equals: 20\r\t"},{"name":"testFlatCollect","linesOfCode":4,"sourceCode":"testFlatCollect\r\r\t| res |\r \tres := {#first -> -1. #second -> 5 . #three -> -33} asDictionary flatCollect: [:e | { e abs } ].\r \tself assert: res asSet equals: #(1 5 33) asSet. \r\t\r "},{"name":"testFlatCollect3","linesOfCode":4,"sourceCode":"testFlatCollect3\r\r\t| res |\r \tres := {#first -> #(-2 3). #second -> #(-4 5)} asDictionary flatCollect: [:e | {e collect: [:each | each abs]}].\r \tself assert: res asSet equals: #(#(2 3) #(4 5)) asSet. \r\t\r "},{"name":"canBeUnhealthy","linesOfCode":2,"sourceCode":"canBeUnhealthy\r\t^ true"},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\t\"return an element not included in 'nonEmpty' \"\r\t^ valueNotIn"},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^ nonEmpty1Element "},{"name":"otherCollection","linesOfCode":3,"sourceCode":"otherCollection\r\t\"Returns a collection that does not include what is returned by #element.\"\r\t^ nonEmpty5ElementsNoDuplicates "},{"name":"result","linesOfCode":6,"sourceCode":"result\r\t^ self collectionClass newFromPairs: {\r\t\t#a . SmallInteger .\r\t\t#b . SmallInteger .\r\t\t#c . SmallInteger .\r\t\t#d . SmallInteger }"},{"name":"testOccurrencesOf","linesOfCode":14,"sourceCode":"testOccurrencesOf\r\t\r\t| dict |\r\tdict := self collectionClass new.\r\tdict at: #a put: 1.\r\tdict at: #b put: 2.\r\tdict at: #c put: 1.\r\tdict at: #d put: 3.\r\tdict at: nil put: nil.\r\tdict at: #z put: nil.\r\t\t\r\tself assert: (dict occurrencesOf: 1 ) equals: 2.\r\tself supportsNilKey \r\t\tifTrue: [ self assert: (dict occurrencesOf: nil ) equals: 2 ]\r\t\tifFalse: [ self assert: (dict occurrencesOf: nil ) equals: 1 ]\t\r\t\r\t\r\t"},{"name":"testOtherDictionaryEquality","linesOfCode":10,"sourceCode":"testOtherDictionaryEquality\r\tself otherDictionaryClasses\r\t\tdo: [ :each | \r\t\t\t| nonEmptyDict2 |\r\t\t\tnonEmptyDict2 := each new.\r\t\t\tself deny: self empty equals: nonEmptyDict2.\r\t\t\tself deny: nonEmptyDict2 equals: self empty.\r\r\t\t\tself nonEmptyDict keysAndValuesDo: [ :key :value | nonEmptyDict2 at: key put: value ].\r\t\t\tself deny: self nonEmptyDict equals: nonEmptyDict2.\r\t\t\tself deny: nonEmptyDict2 equals: self nonEmptyDict ]"},{"name":"testSelectIsNotShallowCopy","linesOfCode":10,"sourceCode":"testSelectIsNotShallowCopy\r\t\t\r\t| original even |\r\toriginal := self collectionClass new.\r\toriginal at: #one put: 1.\r\toriginal at: #two put: 2.\r\r\teven := original select: [:value |value even].\r\teven at: #two put: 'deux'.\r\r\tself assert: (original at: #two) = 2\r \t   description: 'modifying a selection should not modify the original'"},{"name":"valueNotIn","linesOfCode":3,"sourceCode":"valueNotIn\r\" return a value not included in nonEmpty \"\r^valueNotIn "},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\t^ self nonEmptyDict"},{"name":"keyNotInNonEmpty","linesOfCode":3,"sourceCode":"keyNotInNonEmpty\r\t\" return a key not included in nonEmpty\"\r\t^ keyNotIn "},{"name":"anotherValue","linesOfCode":2,"sourceCode":"anotherValue\r\r\t^ 66"},{"name":"testRemoveAll","linesOfCode":12,"sourceCode":"testRemoveAll\r\t\"Allows one to remove all elements of a collection\"\r\r\t| dict1 dict2 s2 |\r\tdict1 := self collectionClass new.\r\tdict1\r\t\tat: #a put: 1;\r\t\tat: #b put: 2.\r\r\tdict2 := dict1 copy.\r\ts2 := dict2 size.\r\r\tdict1 removeAll.\r\r\tself assert: dict1 size equals: 0.\r\tself assert: dict2 size = s2 description: 'the copy has not been modified'"},{"name":"emptyDict","linesOfCode":2,"sourceCode":"emptyDict\r\t^ emptyDict"},{"name":"aValue","linesOfCode":2,"sourceCode":"aValue\r\r\t^ 33"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ emptyDict"},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t^ Dictionary"},{"name":"anIndex","linesOfCode":2,"sourceCode":"anIndex\r\r\t^ #GG"},{"name":"testAddWithKeyAlreadyIn","linesOfCode":7,"sourceCode":"testAddWithKeyAlreadyIn\r\t| dictionary result association |\r\tdictionary := self nonEmptyDict.\r\tassociation := self associationWithKeyNotInToAdd.\r\tresult := dictionary add: association.\r\tself assert: result equals: association.\r\tself assert: (dictionary at: association key) equals: association value"},{"name":"testIncludesAssociationNoValue","linesOfCode":7,"sourceCode":"testIncludesAssociationNoValue\r\r\t| association dictionary |\r\t\r\tassociation := Association key: #key.\r\t\r\tself assert: association value isNil.\r\t\r\tdictionary := self collectionClass new.\r\t\r\tdictionary add: association.\r\t\r\tself assert: (dictionary at: #key) isNil\r\r\t\r\t\r\t"},{"name":"testNewFrom","linesOfCode":6,"sourceCode":"testNewFrom\r\t| assocs |\r\tself assert: (self classToBeTested newFrom: {}) equals: self emptyDict.\r\r\tself assert: (self classToBeTested newFrom: nonEmptyDict copy) equals: self nonEmptyDict.\r\r\tassocs := self nonEmptyDict associations collect: [ :each | each copy ].\r\tself assert: (self classToBeTested newFrom: assocs) equals: self nonEmptyDict"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t\r\t^ associationNotIn "},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\" return a collection without equal elements\"\r\t^ nonEmpty5ElementsNoDuplicates "},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ 30"},{"name":"sizeCollection","linesOfCode":2,"sourceCode":"sizeCollection\r\t^ nonEmptyDict"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\t\"Returns a collection that already includes what is returned by #element.\"\r\t^ nonEmpty5ElementsNoDuplicates add: self element ;yourself."},{"name":"testHasBindingThatBeginsWith","linesOfCode":10,"sourceCode":"testHasBindingThatBeginsWith\r\t| newDict |\r\tnewDict := self collectionClass new \r\t\tat: #abc put: 10; \r\t\tat: #abcd put: 100; \r\t\tat: #def put: 20; \r\t\tyourself.\r\tself assert: (newDict hasBindingThatBeginsWith: 'ab').\r\tself assert: (newDict hasBindingThatBeginsWith: 'def').\r\tself deny: (newDict hasBindingThatBeginsWith: 'defg')."},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^nonEmpty5ElementsNoDuplicates "},{"name":"testNewFromPairs","linesOfCode":14,"sourceCode":"testNewFromPairs\r\t| assocs pairs |\r\tassocs := self nonEmptyDict associations.\r\tpairs := OrderedCollection new.\r\tassocs\r\t\tdo: [ :each | \r\t\t\tpairs\r\t\t\t\tadd: each key;\r\t\t\t\tadd: each value ].\r\t0 to: pairs size do: [ :i | \r\t\t| dictFromPairs dictFromAssocs |\r\t\tdictFromPairs := self classToBeTested newFromPairs: (pairs copyFrom: 1 to: i).\r\t\tdictFromAssocs := self classToBeTested newFrom: (assocs copyFrom: 1 to: (i / 2) floor).\r\t\tself assert: dictFromPairs equals: dictFromAssocs ]"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ nonEmptyDict"},{"name":"otherDictionaryClasses","linesOfCode":6,"sourceCode":"otherDictionaryClasses\r\t\"(DictionaryTest withAllSubclasses collect: [:each | each new classToBeTested]) asArray\"\r\t^ {SmallDictionary. IdentityDictionary. PluggableDictionary.\r\t\tWeakValueDictionary. SystemDictionary. WeakKeyDictionary. SmallIdentityDictionary.\r\t\tWeakIdentityKeyDictionary. WeakKeyToCollectionDictionary. Dictionary}\r\t\t\treject: [:each | each new species == self classToBeTested new species]"},{"name":"testIncludes","linesOfCode":10,"sourceCode":"testIncludes\r\t| o1 o2 newDict |\r\tself assert: (nonEmptyDict includes: self element).\r\r\to1 := 2 @ 3.\r\to2 := 2 @ 3.\r\tself deny: o1 identicalTo: o2.\r\tself assert: o1 equals: o2.\r\tnewDict := self collectionClass new.\r\tnewDict at: #a put: o1.\r\r\tself assert: (newDict includes: o2)"},{"name":"keyNotInNonEmptyDict","linesOfCode":3,"sourceCode":"keyNotInNonEmptyDict\r\" return a key not included in nonEmptyDict\"\r\t^ keyNotIn "},{"name":"testIncludesAssociationWithValue","linesOfCode":6,"sourceCode":"testIncludesAssociationWithValue\r\t| association dictionary |\r\tassociation := Association key: #key value: 1.\r\tdictionary := self collectionClass new.\r\tdictionary add: association.\r\r\tself assert: (dictionary at: #key) equals: 1"},{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotInForOccurrences)"},{"name":"testAsSet","linesOfCode":13,"sourceCode":"testAsSet\r\t\r\t| aDictionary aSet assoc0 assoc1 |\r\taDictionary := Dictionary new.\r\taSet := aDictionary asSet.\r\t\"Add two associations to it\"\t\r\tassoc0 := #first -> 0.\r\tassoc1 := #first -> 1.\r\taSet add: assoc0 copy; add: assoc1.\r\t\r\t\"Check if the two associations were added (that should happen if they are different)\"\r\tself\r\t\tassert: (assoc0 copy ~= assoc1) ==> (aSet size > 1)\r\t\tdescription:\r  \t\t\t'When adding two different elements, the set size should be greater than one'"},{"name":"testKeyForIdentity","linesOfCode":4,"sourceCode":"testKeyForIdentity\r\tself assert: (nonEmptyDict keyForIdentity: 30) equals: #b.\r\r\t\"The value 20 is associated to two different associations\"\r\tself assert: (#(a c) includes: (nonEmptyDict keyForIdentity: self elementTwiceIn))"},{"name":"testNewFromKeysAndValues","linesOfCode":7,"sourceCode":"testNewFromKeysAndValues\r \r\t| keys values newDict |\r\tkeys := self nonEmptyDict keys.\r\tvalues := self nonEmptyDict values.\r\tnewDict := self classToBeTested newFromKeys: keys andValues: values.\r\tself nonEmptyDict keysAndValuesDo: [:k :v|\r\t\tself assert: (newDict at: k) equals: v ]. "},{"name":"testStoreOnWithNegativeInteger","linesOfCode":6,"sourceCode":"testStoreOnWithNegativeInteger\r\t| dictionary |\r\tdictionary := { 'x' -> -1 } as: self classToBeTested.\r\t\r\tself\r\t\tassert: (String streamContents: [ :s | dictionary storeOn: s ])\r\t\tequals: '((',self classToBeTested name,' new) add: (''x''-> -1); yourself)'"},{"name":"valueNotInNonEmpty","linesOfCode":3,"sourceCode":"valueNotInNonEmpty\r\t\" return a value not included in nonEmpty\"\r\t^ valueNotIn "},{"name":"elementToAdd","linesOfCode":3,"sourceCode":"elementToAdd\r\" return an element of type 'nonEmpy' elements'type'\"\r\t^ #u->5."},{"name":"nonEmptyDict","linesOfCode":2,"sourceCode":"nonEmptyDict\r\t^ nonEmptyDict "},{"name":"testNilHashCollision","linesOfCode":14,"sourceCode":"testNilHashCollision\r\r\t\"Ensures that fixCollisionsFrom: does the right thing in the presence of a nil key.\r\tTo do that, we must have a key with the same hash as nil.\"\r\r\t| dict key |\r\tself supportsNilKey ifFalse: [ ^ self ].\r\tdict := self collectionClass new.\r\tkey := ObjectWithSettableHash new.\r\tkey hash: nil hash.\r\tself assert: key hash equals: nil hash.\r\tdict at: key put: 1.\r\tdict at: nil put: 2.\r\tself assert: (dict includesKey: nil).\r\tdict removeKey: key.\r\tself assert: (dict includesKey: nil)"},{"name":"testIsDictionary","linesOfCode":4,"sourceCode":"testIsDictionary\r\tself deny: Object new isDictionary.\r\tself assert: nonEmptyDict isDictionary.\r\tself assert: emptyDict isDictionary."},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t\r\t^ 42"},{"name":"setUp","linesOfCode":40,"sourceCode":"setUp\r\tsuper setUp.\r\temptyDict := self classToBeTested new.\r\tnonEmptyDict := self classToBeTested new.\r\tnonEmptyDict\r\t\tat: #a\r\t\t\tput: self elementTwiceIn;\r\t\tat: #b\r\t\t\tput: 30;\r\t\tat: #c\r\t\t\tput: self elementTwiceIn;\r\t\tat: #d\r\t\t\tput: -2.\r\tnonEmpty5ElementsNoDuplicates := self classToBeTested new\r\t\tat: #a\r\t\t\tput: 5;\r\t\tat: #b\r\t\t\tput: 4;\r\t\tat: #c\r\t\t\tput: 7;\r\t\tat: #d\r\t\t\tput: 6;\r\t\tat: #e\r\t\t\tput: 9;\r\t\tyourself.\r\tvalueNotIn := 666.\r\tkeyNotIn := #z .\r\tassociationNotIn := keyNotIn->valueNotIn.\r\tdictionaryNotIncluded := Dictionary new add: associationNotIn ;yourself.\r\tcollectionNotIncluded := {  valueNotIn. valueNotIn  }.\r\tcollectionIncluded := {  (self elementTwiceIn)  }.\r\tindexArray := #(2 3 1 ).\r\tvalueArray := #(5 5 5 ).\r\tnonEmpty1Element := self classToBeTested new\r\t\tat: #a\r\t\t\tput: 5;\r\t\tyourself.\r\tnonEmptyWithString := Dictionary new add: #A->'foo'; add: #b->'bar' ; yourself.\r\tduplicateValue := 2.5.\r\tdictionaryWithDuplicateValues := \tDictionary new add: #A->duplicateValue ; add: #b->3.5 ; add: #C->duplicateValue  ; yourself.\r\r"},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\r\t^ self classToBeTested"},{"name":"expectedElementByDetect","linesOfCode":2,"sourceCode":"expectedElementByDetect\r\t^ 30"},{"name":"nonEmptyWithCopyNonIdentical","linesOfCode":3,"sourceCode":"nonEmptyWithCopyNonIdentical\r\" return a collection including elements for wich copy is not identical to the initial element ( this is not the cas of Integer )\"\r^nonEmptyWithString "},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested \r\r\t^ Dictionary"},{"name":"testFlatCollect2","linesOfCode":4,"sourceCode":"testFlatCollect2\r\r\t| res |\r \tres := {#first -> #(-2 3). #second -> #(-4 5)} asDictionary flatCollect: [:e | e collect: [:each | each abs]].\r \tself assert: res asSet equals: #(2 3 4 5) asSet. \r\t\r "},{"name":"testKeyAtValueIfAbsent","linesOfCode":7,"sourceCode":"testKeyAtValueIfAbsent\r \r\t| dict value result |\r\tdict := self nonEmpty.\r\tvalue := dict values anyOne.\r\tresult := dict keyAtValue: value ifAbsent: [ nil ].\r\tself assert: (dict at: result) equals: value.\r\tself assert: (dict keyAtValue: self valueNotIn ifAbsent: [ nil ]) isNil"},{"name":"testNew","linesOfCode":6,"sourceCode":"testNew\r\t| d |\r\td := self classToBeTested new: 10.\r\tself assert: d size equals: 0\r\r\t\"Why 14? Mysterious\"\r\t\"self assert: d capacity = 14\""},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\" return an element included exactly two time in # collectionWithEqualElements\"\r^ duplicateValue "}],"meta":{"name":"DictionaryTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryPrintingTest","instanceVariables":[],"methods":[{"name":"testStoreOn","linesOfCode":5,"sourceCode":"testStoreOn\r\t| str |\r\tstr := String new writeStream.\r\tself nonEmptyDict storeOn: str.\r\tself assert: str contents = '((Dictionary new) add: (#b->30); add: (#c->1); add: (#d->-2); add: (#a->1); yourself)'"},{"name":"testPrintElementsOn","linesOfCode":5,"sourceCode":"testPrintElementsOn\r\t| str |\r\tstr := String new writeStream.\r\tself nonEmptyDict printElementsOn: str.\r\tself assert: (str contents = '(#a->1 #b->30 #c->1 #d->-2 )')"},{"name":"emptyDict","linesOfCode":2,"sourceCode":"emptyDict\r\tself explicitRequirement"},{"name":"nonEmptyDict","linesOfCode":2,"sourceCode":"nonEmptyDict\r\tself explicitRequirement"},{"name":"newEmptyDict","linesOfCode":2,"sourceCode":"newEmptyDict\r\tself explicitRequirement"}],"meta":{"name":"TDictionaryPrintingTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"IdentitySetTest","instanceVariables":[{"name":"floatCollection"}],"methods":[{"name":"testGrowWithNil","linesOfCode":7,"sourceCode":"testGrowWithNil\r\t\"This test covers that grow take into account that nil are wrapped elements of sets\"\r\t| set |\r\tset := IdentitySet new.\r\tset add: nil.\r\tset grow.\r\tself assert: (set includes: nil)"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ IdentitySet"},{"name":"identityCollectionWithElementsCopyNotIdentical","linesOfCode":3,"sourceCode":"identityCollectionWithElementsCopyNotIdentical\r\" return a collection including elements for which #copy return a new object \"\r\t^ floatCollection ifNil: [ floatCollection := IdentitySet new add: 2.5 ; add: 4.5 ; add:5.5 ; yourself ]."},{"name":"testIdentity","linesOfCode":12,"sourceCode":"testIdentity\r\t| identitySet aString anOtherString |\r\taString := 'hello'.\r\tanOtherString := aString copy.\r\r\tself assert: aString equals: anOtherString.\r\tself deny: aString identicalTo: anOtherString.\r\r\tidentitySet := self classToBeTested new.\r\tidentitySet add: aString.\r\r\tself assert: (identitySet occurrencesOf: aString) equals: 1.\r\tself assert: (identitySet occurrencesOf: anOtherString) equals: 0.\r\r\tself assert: (identitySet includes: aString).\r\tself deny: (identitySet includes: anOtherString) equals: 0"}],"meta":{"name":"IdentitySetTest class","instanceVariables":[],"methods":[{"name":"shouldInheritSelectors","linesOfCode":2,"sourceCode":"shouldInheritSelectors\r\r^true"}],"meta":null}},{"name":"SetTest","instanceVariables":[{"name":"full"},{"name":"empty"},{"name":"collectResult"},{"name":"emptyButAllocatedWith20"},{"name":"elementNotIn"},{"name":"collectionOfFloat"},{"name":"collectionIncluded"},{"name":"nonEmpty1element"},{"name":"withoutEqualElements"},{"name":"collection5Elements"},{"name":"collectionWith3Elements"},{"name":"collectionOfNonIdentical"}],"methods":[{"name":"testDoWithoutNoDuplicates","linesOfCode":5,"sourceCode":"testDoWithoutNoDuplicates\r\t| res |\r\tres := self speciesClass new.\r\tself collection do: [ :each | res add: each ] without: -2.\r\tself assert: res size equals: self doWithoutNumber"},{"name":"testCopy","linesOfCode":8,"sourceCode":"testCopy\r\t| newFull |\r\tfull add: 3.\r\tfull add: 2.\r\tnewFull := full copy.\r\tself assert: full size equals: newFull size.\r\tself assertEmpty: (full select: [ :each | (newFull includes: each) not ]).\r\tself assertEmpty: (newFull select: [ :each | (full includes: each) not ])"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":3,"sourceCode":"integerCollectionWithoutEqualElements\r\" return a collection of integer without equal elements\"\r\t^ withoutEqualElements "},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ collectionOfNonIdentical"},{"name":"collectionWithElementsToRemove","linesOfCode":2,"sourceCode":"collectionWithElementsToRemove\r\t^ collectionIncluded "},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^collectionOfFloat "},{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\" return a collection without equal elements \"\r\t^ withoutEqualElements "},{"name":"test0FixtureAddForUniquenessTest","linesOfCode":6,"sourceCode":"test0FixtureAddForUniquenessTest\r\tself element.\r\tself collectionWithElement.\r\tself assert: (self collectionWithElement includes: self element).\r\tself collectionWithoutElement.\r\tself assert: (self collectionWithElement includes: self element)"},{"name":"testCollect","linesOfCode":8,"sourceCode":"testCollect\r\t| res element collection |\r\tcollection := self collectionWithoutNilElements.\r\telement := self element.\r\tres := collection collect: [ :each | element ].\r\r\tself assert: res class identicalTo: self classToBeTested.\r\tself assert: res size equals: 1.\r\r\tres do: [ :each | self assert: each equals: element ]"},{"name":"testCollect2","linesOfCode":12,"sourceCode":"testCollect2\r\t| newFull result |\r\tnewFull := Set withAll: (1 to: 10).\r\tresult := newFull collect: [ :each | each >= 1 ifTrue: [ each ] ifFalse: [ 'no' ] ].\r\tself assert: result equals: newFull.\r\tresult := newFull collect: [ :each | each >= 5 ifTrue: [ each ] ifFalse: [ 'no' ] ].\r\tself\r\t\tassert: result\r\t\tequals:\r\t\t\t((Set withAll: (5 to: 10))\r\t\t\t\tadd: 'no';\r\t\t\t\tyourself)"},{"name":"testMax","linesOfCode":5,"sourceCode":"testMax\r\t| set |\r\tset := self empty.\r\tset add: 1; add: 2.\r\tself assert: (set max: [ :each | each + 1 ]) equals: 3"},{"name":"testIsHealthy","linesOfCode":20,"sourceCode":"testIsHealthy\r\r\t\"we use associations as keys on purpose, because they changing\r\thash depending on the key\"\r\r\t| a1 a2 set |\r\t\"There is a probability that nil will hash to 0 in some builds,\r\tso the nil key will still be in the correct position after\r\tit is changed to 0. The larger the set's capacity, the lower the\r\tprobability of this failure. Also, the default size of a set\r\thappens to have the same correct position for 3 and 0.\"\r\tset := Set new: 50000.\r\t[ \r\ta1 := 3 -> nil.\r\ta2 := nil -> 3.\r\tset\r\t\tadd: a1;\r\t\tadd: a2.\r\tself assert: set isHealthy.\r\ta1 key: 0.\r\ta2 key: 0.\r\tself assert: set isHealthy not ] ensure: [ set removeAll ]"},{"name":"testAddNonEmptyGrowsWhenNewElement","linesOfCode":6,"sourceCode":"testAddNonEmptyGrowsWhenNewElement\r\t\r\t| oldSize |\r\toldSize := self nonEmpty size.\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself nonEmpty add: self elementNotInForOccurrences.\r\tself assert: self nonEmpty size > oldSize"},{"name":"testAddWithOccurrences","linesOfCode":4,"sourceCode":"testAddWithOccurrences\r\tempty add: 2 withOccurrences: 3.\r\tself assert: (empty includes: 2).\r\tself assert: (empty occurrencesOf: 2) equals: 1"},{"name":"testIntersection","linesOfCode":16,"sourceCode":"testIntersection\r\t| newFull col |\r\tfull\r\t\tadd: 3;\r\t\tadd: 2.\r\tcol := full intersection: full.\r\tself assert: full equals: col.\r\r\tnewFull := Set with: 8 with: 9 with: #z.\r\tcol := newFull intersection: full.\r\tself assertEmpty: col.\r\r\tnewFull\r\t\tadd: 5;\r\t\tadd: #abc;\r\t\tadd: 7.\r\tcol := newFull intersection: full.\r\tself assert: (full select: [ :each | newFull includes: each ]) equals: col"},{"name":"testUnion","linesOfCode":20,"sourceCode":"testUnion\r\t| newFull col newCol |\r\tfull add: 3.\r\tfull add: 2.\r\tcol := full union: full.\r\tself assert: full equals: col.\r\r\tnewFull := Set with: 8 with: 9 with: #z.\r\tcol := newFull union: full.\r\tself assert: col size equals: full size + newFull size.\r\tself assert: (col select: [ :each | (full includes: each) not ]) equals: newFull.\r\tself assert: (col select: [ :each | (newFull includes: each) not ]) equals: full.\r\r\tfull add: 9.\r\tcol := newFull union: full.\r\tnewCol := newFull copy.\r\tnewCol remove: 9.\r\tself assert: col size equals: full size + newFull size - 1.\r\tself assert: (col select: [ :each | (full includes: each) not ]) equals: newCol.\r\tnewCol := full copy.\r\tnewCol remove: 9.\r\tself assert: (col select: [ :each | (newFull includes: each) not ]) equals: newCol"},{"name":"testAllowInclusionOfNils","linesOfCode":7,"sourceCode":"testAllowInclusionOfNils\r\t| set |\r\tset := self classToBeTested new.\r\tset add: nil.\r\tself assert: (set includes: nil).\r\tset remove: nil.\r\tself deny: (set includes: nil)"},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection  anyOne"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ 666"},{"name":"testAdd","linesOfCode":3,"sourceCode":"testAdd \r\tempty add: 5.\r\tself assert: (empty includes: 5)."},{"name":"testFlatCollect","linesOfCode":3,"sourceCode":"testFlatCollect\r\tself assert: (#(1 2) asSet flatCollect: [ :x | 1 to: 2 * x ]) equals: #(1 2 3 4) asSet.\r\tself assertEmpty: (#() asSet flatCollect: [ :x | 1 to: 4 ])"},{"name":"testCopyWithout","linesOfCode":9,"sourceCode":"testCopyWithout\r\t| newFull |\r\tfull add: 3.\r\tfull add: 2.\r\tnewFull := full copyWithout: 3.\r\tself assert: newFull size equals: full size - 1.\r\tself deny: (newFull includes: 3).\r\tself assertEmpty: (newFull select: [ :each | (full includes: each) not ]).\r\tself assert: (full select: [ :each | (newFull includes: each) not ]) equals: (Set with: 3)"},{"name":"collectionWithoutElement","linesOfCode":3,"sourceCode":"collectionWithoutElement\r\t\" return a collection that does not include 'element' \"\r\t^ collectionWith3Elements  "},{"name":"elementNotIn","linesOfCode":2,"sourceCode":"elementNotIn\r\t^elementNotIn "},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^ nonEmpty1element "},{"name":"result","linesOfCode":2,"sourceCode":"result\r\r\t ^ collectResult"},{"name":"testIdentityIncludes","linesOfCode":8,"sourceCode":"testIdentityIncludes\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\r\t| collection element |\r\tself collectionWithCopyNonIdentical.\r\tcollection := self collectionWithCopyNonIdentical.\r\telement := collection anyOne copy.\t\"self assert: (collection includes: element).\"\r\tself deny: (collection identityIncludes: element)"},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\r\t^ collectionWith3Elements"},{"name":"testRemoveAll","linesOfCode":9,"sourceCode":"testRemoveAll\r\t\"Allows one to remove all elements of a collection\"\r\r\t| c1 c2 s2 |\r\tc1 := full.\r\tc2 := c1 copy.\r\ts2 := c2 size.\r\r\tc1 removeAll.\r\r\tself assert: c1 size equals: 0.\r\tself assert: c2 size = s2 description: 'the copy has not been modified'"},{"name":"speciesClass","linesOfCode":2,"sourceCode":"speciesClass\r\t\r\t^ Set"},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\t^ collectionWith3Elements  "},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r\t^ empty"},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\t^ nonEmpty1element "},{"name":"testGrow","linesOfCode":3,"sourceCode":"testGrow\r\tempty addAll: (1 to: 100).\r\tself assert: empty size equals: 100"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ elementNotIn "},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\" return a collection without equal elements\"\r\t^ withoutEqualElements "},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ 4"},{"name":"expectedSizeAfterReject","linesOfCode":2,"sourceCode":"expectedSizeAfterReject\r\t^1"},{"name":"collectionWithElement","linesOfCode":2,"sourceCode":"collectionWithElement\r\t^ full"},{"name":"sizeCollection","linesOfCode":2,"sourceCode":"sizeCollection\r\r\t^ full"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^ collectionWith3Elements  "},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\" return a collection including at least 5 elements\"\r\t\r\t^ collection5Elements "},{"name":"testCopyNonEmptyWithoutAllNotIncluded","linesOfCode":1,"sourceCode":"testCopyNonEmptyWithoutAllNotIncluded\r\t"},{"name":"testLike","linesOfCode":3,"sourceCode":"testLike\r\tself assert: (full like: 3) equals: 3.\r\tself assert: (full like: 8) isNil"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r\t^ full"},{"name":"testRemoveIfAbsent","linesOfCode":4,"sourceCode":"testRemoveIfAbsent\r\t\t\r\tself assert: (full remove: 8 ifAbsent: [true]).\r\tself assert: (full remove: 4 ifAbsent: [false]) isNumber.\r\t\r\t\r\t"},{"name":"testSize2","linesOfCode":10,"sourceCode":"testSize2\r\tself assert: empty size equals: 0.\r\tself assert: full size equals: 4.\r\tempty add: 2.\r\tempty add: 1.\r\tfull add: 2.\r\tself assert: empty size equals: 2.\r\tself assert: full size equals: 4.\r\tempty remove: 2.\r\tself assert: empty size equals: 1"},{"name":"elementInForIncludesTest","linesOfCode":3,"sourceCode":"elementInForIncludesTest\r\" return an element included in nonEmpty \"\r\t^ self nonEmpty anyOne"},{"name":"selectedNumber","linesOfCode":2,"sourceCode":"selectedNumber\r\r\t^ 2\r\t"},{"name":"testIllegal","linesOfCode":4,"sourceCode":"testIllegal\r\tself should: [empty at: 5] raise: self defaultTestError.\r\tself should: [empty at: 5 put: #abc] raise: self defaultTestError.\r\t\t\t"},{"name":"collectionInForIncluding","linesOfCode":2,"sourceCode":"collectionInForIncluding\r\t^ collectionIncluded "},{"name":"testDo2","linesOfCode":6,"sourceCode":"testDo2\r\t| newFull result |\r\tnewFull := Set withAll: (1 to: 5).\r\tresult := 0.\r\tnewFull do: [ :each | result := result + each ].\r\tself assert: result equals: 15"},{"name":"testIncludes","linesOfCode":5,"sourceCode":"testIncludes\r\tself assert: (full includes: 4).\r\tself assert: (full includes: 3).\r\tself deny: (full includes: 6).\r\t\t\t"},{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotInForOccurrences)"},{"name":"testAsSet","linesOfCode":6,"sourceCode":"testAsSet\r\t\"could be moved in Array or Collection\"\r\r\t| newFull |\r\tnewFull := #(1 2 3) asSet.\r\tnewFull add: 4.\r\tself assert: newFull equals: full"},{"name":"elementToAdd","linesOfCode":2,"sourceCode":"elementToAdd\r\t^ 42"},{"name":"testOccurrences","linesOfCode":5,"sourceCode":"testOccurrences\r\tself assert: (empty occurrencesOf: 0) equals: 0.\r\tself assert: (full occurrencesOf: 4) equals: 1.\r\tfull add: 4.\r\tself assert: (full occurrencesOf: 4) equals: 1"},{"name":"testMaxIfNil","linesOfCode":4,"sourceCode":"testMaxIfNil\r\t| emptySet |\r\temptySet := self empty.\r\tself assert: (emptySet max: [ :each | each + 1 ]) equals: nil"},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t^ 42"},{"name":"setUp","linesOfCode":15,"sourceCode":"setUp\r\tsuper setUp.\r\tempty := self classToBeTested  new.\r\tfull := self classToBeTested  with: 1 with: 2 with: 3 with: 4.\r\tcollectionIncluded := self classToBeTested  with: 2 with: 3 .\r\tcollectionWith3Elements := self classToBeTested  new.\r\tcollectionWith3Elements add: 1; add: -2; add: 3. \r\tcollectResult := self classToBeTested  new add: SmallInteger ; yourself.\r\temptyButAllocatedWith20 := self classToBeTested  new: 20.\r\telementNotIn := 99.\r\tcollectionOfFloat := self classToBeTested  with: 2.5 with: 4.6 with: 4.2.\r\tcollectionOfNonIdentical := self classToBeTested  with: 'a' with: 'b' with: 'c'.\r\tnonEmpty1element := self classToBeTested  with: 32.\r\twithoutEqualElements := self classToBeTested  with: 4 with: 5 with: 2.\r\tcollection5Elements := self classToBeTested with: 1 with: 2 with: 3 with: 4 with: 5."},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ self classToBeTested"},{"name":"testSetWithNilItemsIsHealthy","linesOfCode":4,"sourceCode":"testSetWithNilItemsIsHealthy\r\tself classToBeTested = Set\r\t\tifFalse: [ ^ self\t\"only works on Dictionary\" ].\r\tself assert: {nil} asSet isHealthy"},{"name":"testAtRandom","linesOfCode":8,"sourceCode":"testAtRandom\r\t| rand |\r\trand := Random new.\r\tfull add: 3.\r\tfull add: 2.\r\tfull add: 4.\r\tfull add: 1.\r\tself assert: (full includes: (full atRandom: rand)).\r\t"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\r\t^ Set"},{"name":"testRemove","linesOfCode":4,"sourceCode":"testRemove\r\tfull remove: 4.\r\tself assert: (full includes: 3).\r\tself deny: (full includes: 4)."},{"name":"testFlatCollectAsSet","linesOfCode":2,"sourceCode":"testFlatCollectAsSet\r\tself assert: (#(1 2) asSet flatCollect: [ :x | 1 to: 2 * x ]) equals: #(1 2 3 4) asSet"},{"name":"emptyButAllocatedWith20","linesOfCode":2,"sourceCode":"emptyButAllocatedWith20\r\r\t^ emptyButAllocatedWith20"},{"name":"collectionNotIncluded","linesOfCode":2,"sourceCode":"collectionNotIncluded\r\t^ self classToBeTested  with: elementNotIn. "}],"meta":{"name":"SetTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"HashTableSizesTest","instanceVariables":[],"methods":[{"name":"testAtLeast","linesOfCode":23,"sourceCode":"testAtLeast\r\t-1000 to: 1000 do: [ :limit | \r\t\t| size |\r\t\t\"#atLeast: should answer the next known good prime not less than i, or\r\t\tthe next odd integer if i is greater than the largest known good prime.\"\r\t\tsize := HashTableSizes atLeast: limit.\r\t\tself\r\t\t\tassert: size >= limit;\r\t\t\tassert: size positive;\r\t\t\tassert: size isInteger;\r\t\t\tassert: (size isPrime or: [ size odd ]).\r\t\t\"it should behave the same as the lower-level #basicAtLeast: it relies on\"\r\t\tself assert: size equals: (HashTableSizes basicAtLeast: limit) ].\r\r\t-1000.1 to: 1000.1 do: [ :limit | \r\t\t| size |\r\t\tsize := HashTableSizes atLeast: limit.\r\t\tself\r\t\t\tassert: size > limit;\r\t\t\t\"do not round fractional limits down\"\r\t\t\t\tassert: size positive;\r\t\t\tassert: size isInteger;\r\t\t\tassert: (size isPrime or: [ size odd ]);\r\t\t\tassert: size equals: (HashTableSizes basicAtLeast: limit) ]"}],"meta":{"name":"HashTableSizesTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"TDictionaryImplementationTest","instanceVariables":[],"methods":[{"name":"testSpecies","linesOfCode":3,"sourceCode":"testSpecies\r\tself assert: self nonEmptyDict species == self nonEmptyDict class.\r\tself assert: self emptyDict species == self emptyDict class"},{"name":"testScanFor","linesOfCode":7,"sourceCode":"testScanFor\r\t\"Set>>scanFor: return an integer \"\r\t| assoc indexForG |\r\tassoc := #g -> 100.\r\tself assert: (self nonEmptyDict scanFor: assoc) = (self nonEmptyDict array indexOf: nil).\r\r\tindexForG := (#g hash \\\\ self emptyDict array size) + 1.\r\tself assert: (self emptyDict scanFor: assoc) = ((self emptyDict array indexOf: nil) max: indexForG).\r"},{"name":"testPseudoVariablesAreValidKeys","linesOfCode":9,"sourceCode":"testPseudoVariablesAreValidKeys\r\t\"(self run: #testPseudoVariablesAreValidKeys)\"\r\r\t\"true and false are valid keys\"\r\r\t| dict1 |\r\tdict1 := self emptyDict.\r\tdict1 at: true put: #true.\r\tself assert: (dict1 at: true) = #true.\r\tdict1 at: false put: #false.\r\tself assert: (dict1 at: false) = #false"},{"name":"testPseudo","linesOfCode":9,"sourceCode":"testPseudo\r\t\"(self run: #testPseudo)\"\r\r\t\"true and false are valid keys\"\r\r\t| dict1 |\r\tdict1 := self emptyDict.\r\tdict1 at: true put: #true.\r\tself assert: (dict1 at: true) = #true.\r\tdict1 at: false put: #false.\r\tself assert: (dict1 at: false) = #false"},{"name":"testFindElementOrNil","linesOfCode":8,"sourceCode":"testFindElementOrNil\r\t\"Set>>findElementOrNil: takes an associaiton (when called on a dictionary) an integer, the index of the first\r\tposition at is either equal to the assocation or which is nil\"\r\t| assoc indexForG |\r\tassoc := #g -> 100.\r\tself assert: (self nonEmptyDict findElementOrNil: assoc key) = (self nonEmptyDict array indexOf: nil).\r\t\r\tindexForG := (#g hash \\\\ self emptyDict array size) + 1.\r\tself assert: (self emptyDict findElementOrNil: assoc key) = ((self emptyDict array indexOf: nil) max: indexForG)."},{"name":"testNew","linesOfCode":6,"sourceCode":"testNew\r\t| d |\r\td := self classToBeTested new: 10.\r\tself assert: d size = 0.\r\t\r\t\"Why 14? Mysterious\"\r\tself assert: d capacity = 14"},{"name":"testAtNil","linesOfCode":17,"sourceCode":"testAtNil\r\t\"(self run: #testAtNil)\"\r\r\t\"nil is a valid key in Pharo. In VW nil is not a valid key\"\r\r\t\"Ansi 1.9 p, 168\r    \t\t5.7.2.5 Message: at: key put: newElement\r    \t\tSynopsis\r    \t\t\tStore newElement at key in the receiver. Answer newElement.\r    \t\tDefinition: <abstractDictionary>\r    \t\tIf lookup succeeds for key, then newElement replaces the element previously stored at key.\r    \t\tOtherwise, the newElement is stored at the new key. In either case, subsequent successful\r    \t\tlookups for key will answer newElement.  Answer newElement.\r\r    \t\tThe result is undefined if the key is nil.\r\r\t\tThis clearly indicates that different smalltalks where doing different assumptions.\"\r\r\t| dict1 |\r\tdict1 := self emptyDict.\r\tdict1 at: nil put: #none.\r\tself assert: (dict1 at: nil) = #none"}],"meta":{"name":"TDictionaryImplementationTest classTrait","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Strings","classes":[{"name":"ByteString","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size"},{"name":"asByteArray","linesOfCode":6,"sourceCode":"asByteArray\r\t| ba sz |\r\tsz := self byteSize.\r\tba := ByteArray new: sz.\r\tba replaceFrom: 1 to: sz with: self startingAt: 1.\r\t^ba"},{"name":"asOctetString","linesOfCode":2,"sourceCode":"asOctetString\r\r\t^ self.\r"},{"name":"byteAt:","linesOfCode":3,"sourceCode":"byteAt: index\r\t<primitive: 60>\r\t^(self at: index) asciiValue"},{"name":"serializeOn:","linesOfCode":2,"sourceCode":"serializeOn: anEncoder\r\r\tanEncoder encodeString: self"},{"name":"indexOfAnyOf:startingAt:","linesOfCode":3,"sourceCode":"indexOfAnyOf: aCollection startingAt: start\r\t\"Use double dispatching for speed\"\r\t^aCollection findFirstInByteString: self startingAt: start"},{"name":"isByteString","linesOfCode":4,"sourceCode":"isByteString\r\t\"Answer whether the receiver is a ByteString\"\r\t\"'abc' isByteString >>> true\"\r\t^true"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":7,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\treplacement class == WideString ifTrue: [\r\t\tself becomeForward: (WideString from: self).\r\t]. \r\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart.\r"},{"name":"convertFromSystemString","linesOfCode":8,"sourceCode":"convertFromSystemString\r\r\t| readStream |\r\treadStream := self readStream.\r\t^ self class new: self size streamContents: [ :writeStream |\r\t\t| converter |\r\t\tconverter := LanguageEnvironment defaultSystemConverter.\r\t\t[readStream atEnd] whileFalse: [\r\t\t\twriteStream nextPut: (converter nextFromStream: readStream)]].\r"},{"name":"findSubstring:in:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findSubstring: key in: body startingAt: start matchTable: matchTable\r\t\r\t^ key findIn: body startingAt: start matchTable: matchTable."},{"name":"isOctetString","linesOfCode":6,"sourceCode":"isOctetString\r\t\"Answer whether the receiver can be represented as a byte string. \r\tThis is different from asking whether the receiver *is* a ByteString \r\t(i.e., #isByteString)\"\r\t\"'abc' isOctetString >>> true\"\r\t\r\t^ true.\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":6,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a byte char string, I know that we have to scan single-byte characters and don't have to handle encodings etc\"\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\t^aFont scanByteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX"},{"name":"beginsWith:","linesOfCode":15,"sourceCode":"beginsWith: prefix\r\t\"Answer whether the receiver begins with the given prefix string.\r\tThe comparison is case-sensitive.\"\r\r\t\"IMPLEMENTATION NOTE:\r\tfollowing algorithm is optimized in primitive only in case self and prefix are bytes like.\r\tOtherwise, if self is wide, then super outperforms,\r\tOtherwise, if prefix is wide, primitive is not correct\"\r\t\r\t\"('pharo' beginsWith: '') >>> false\"\r\t\"('pharo' beginsWith: 'pharo-project') >>> false\"\r\t\"('pharo' beginsWith: 'phuro') >>> false\"\r\t\"('pharo' beginsWith: 'pha') >>> true\"\r\t\r\tprefix class isBytes ifFalse: [^super beginsWith: prefix].\r\t\r\tself size < prefix size ifTrue: [^ false].\r\t^ (self findSubstring: prefix in: self startingAt: 1\r\t\t\tmatchTable: CaseSensitiveOrder) = 1\r"},{"name":"isAsciiString","linesOfCode":2,"sourceCode":"isAsciiString\r\r\r ^(self class findFirstInString: self inSet: NonAsciiMap startingAt: 1) = 0"},{"name":"at:","linesOfCode":6,"sourceCode":"at: index \r\t\"Primitive. Answer the Character stored in the field of the receiver\r\tindexed by the argument. Fail if the index argument is not an Integer or\r\tis out of bounds. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 63>\r\t^ Character value: (super at: index)"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitHookPrimitive: self"},{"name":"asKeyCombination","linesOfCode":4,"sourceCode":"asKeyCombination\r\tself size > 1 \r\t\tifTrue: [ self error: 'Shortcuts only take a single letter'].\r\t^ KMSingleKeyCombination from: self first"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"indexOfAnyOf:startingAt:ifAbsent:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection startingAt: start ifAbsent: aBlock\r\t\"Use double dispatching for speed\"\r\t| index |\r\t^(index := aCollection findFirstInByteString: self startingAt: start) = 0\r\t\tifTrue: [aBlock value]\r\t\tifFalse: [index]"},{"name":"byteAt:put:","linesOfCode":4,"sourceCode":"byteAt: index put: value\r\t<primitive: 61>\r\tself at: index put: value asCharacter.\r\t^value"},{"name":"at:put:","linesOfCode":19,"sourceCode":"at: index put: aCharacter\r\t\"Primitive. Store the Character in the field of the receiver indicated by\r\tthe index. Fail if the index is not an Integer or is out of bounds, or if\r\tthe argument is not a Character. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 64>\r\taCharacter isCharacter \r\t\tifFalse:[^self errorImproperStore].\r\taCharacter isOctetCharacter ifFalse:[\r\t\t\"Convert to WideString\"\r\t\tself becomeForward: (WideString from: self).\r\t\t^self at: index put: aCharacter.\r\t].\r\tindex isInteger\r\t\tifTrue: [ (index between: 1 and: self size)\r\t\t\t\tifFalse: [ self errorSubscriptBounds: index ] ]\r\t\tifFalse: [self errorNonIntegerIndex].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #at:put: index: index value: aCharacter ].\r"},{"name":"hasWideCharacterFrom:to:","linesOfCode":3,"sourceCode":"hasWideCharacterFrom: start to: stop\r\t\"Only WideStrings contain these characters\"\r\t^false"}],"meta":{"name":"ByteString class","instanceVariables":[],"methods":[{"name":"stringHash:initialHash:","linesOfCode":14,"sourceCode":"stringHash: aString initialHash: speciesHash\r\r\t| stringSize hash low |\r\t<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>\r\r\t<var: #aHash declareC: 'int speciesHash'>\r\t<var: #aString declareC: 'unsigned char *aString'>\r\r\tstringSize := aString size.\r\thash := speciesHash bitAnd: 16rFFFFFFF.\r\t1 to: stringSize do: [:pos |\r\t\thash := hash + (aString basicAt: pos).\r\t\t\"Begin hashMultiply\"\r\t\tlow := hash bitAnd: 16383.\r\t\thash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.\r\t].\r\t^ hash"},{"name":"materializeFrom:","linesOfCode":2,"sourceCode":"materializeFrom: aDecoder\r\r\t^ aDecoder nextEncodedString"},{"name":"indexOfAscii:inString:startingAt:","linesOfCode":9,"sourceCode":"indexOfAscii: anInteger inString: aString startingAt: start\r\r\t| stringSize |\r\t<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>\r\t<var: #aCharacter declareC: 'int anInteger'>\r\t<var: #aString declareC: 'unsigned char *aString'>\r\r\tstringSize := aString size.\r\tstart to: stringSize do: [:pos |\r\t\t(aString basicAt: pos) = anInteger ifTrue: [^ pos]].\r\r\t^ 0"},{"name":"nonAsciiMap","linesOfCode":2,"sourceCode":"nonAsciiMap\r\t^NonAsciiMap"},{"name":"compare:with:collated:","linesOfCode":20,"sourceCode":"compare: string1 with: string2 collated: order\r\t\"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array.\"\r\r\t<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>\r\t<var: #string1 declareC: 'unsigned char *string1'>\r\t<var: #string2 declareC: 'unsigned char *string2'>\r\t<var: #order declareC: 'unsigned char *order'>\r\t| len1 len2 c1 c2 |\r\tlen1 := string1 size.\r\tlen2 := string2 size.\r\t1 to: (len1 min: len2) do: [ :i | \r\t\tc1 := order at: (string1 basicAt: i) + 1.\r\t\tc2 := order at: (string2 basicAt: i) + 1.\r\t\tc1 = c2\r\t\t\tifFalse: [ ^ c1 < c2\r\t\t\t\t\tifTrue: [ 1 ]\r\t\t\t\t\tifFalse: [ 3 ] ] ].\r\tlen1 = len2 ifTrue: [ ^ 2 ].\r\t^ len1 < len2\r\t\tifTrue: [ 1 ]\r\t\tifFalse: [ 3 ]"},{"name":"initialize","linesOfCode":7,"sourceCode":"initialize\r\t\"ByteString initialize\"\r\r\tNonAsciiMap := ByteArray new: 256.\r\t0 to: 255 do: [ :i | \r\t\ti < 128\r\t\t\tifTrue: [ NonAsciiMap at: i + 1 put: 0\t\"valid ascii subset\" ]\r\t\t\tifFalse: [ NonAsciiMap at: i + 1 put: 1\t\"extended charset\" ] ]"},{"name":"findFirstInString:inSet:startingAt:","linesOfCode":12,"sourceCode":"findFirstInString: aString  inSet: inclusionMap  startingAt: start\r\t| i stringSize |\r\t<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>\r\t<var: #aString declareC: 'unsigned char *aString'>\r\t<var: #inclusionMap  declareC: 'char *inclusionMap'>\r\r\tinclusionMap size ~= 256 ifTrue: [ ^0 ].\r\r\ti := start.\r\tstringSize := aString size.\r\t[ i <= stringSize and: [ (inclusionMap at: (aString basicAt: i) + 1) = 0 ] ] whileTrue: [ \r\t\ti := i + 1 ].\r\r\ti > stringSize ifTrue: [ ^0 ].\r\t^i"},{"name":"translate:from:to:table:","linesOfCode":7,"sourceCode":"translate: aString from: start  to: stop  table: table\r\t\"translate the characters in the string by the given table, in place\"\r\t<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>\r\t<var: #table  declareC: 'unsigned char *table'>\r\t<var: #aString  declareC: 'unsigned char *aString'>\r\r\tstart to: stop do: [ :i |\r\t\taString at: i put: (table at: (aString basicAt: i) + 1) ]"}],"meta":null}},{"name":"String","instanceVariables":[],"methods":[{"name":"withPlatformSpecificLineEndings","linesOfCode":4,"sourceCode":"withPlatformSpecificLineEndings\r\t^ Smalltalk os isWindows\r\t\tifTrue: [ self withInternetLineEndings ]\r\t\tifFalse: [ self withUnixLineEndings ]"},{"name":"llvmNameString","linesOfCode":5,"sourceCode":"llvmNameString\r\tself isValidLLVMSymbol ifTrue: [ ^ self ].\r\t^ ByteString streamContents: [ :out |\r\t\tself llvmPrintEscapedStringOn: out\r\t]"},{"name":"contractTo:","linesOfCode":14,"sourceCode":"contractTo: smallSize\r\t\"return myself or a copy shortened by ellipsis to smallSize\"\r\t\"('abcd' contractTo: 10) >>> 'abcd'\"\r\t\"('Pharo is really super cool' contractTo: 10) >>> 'Phar...ool'\"\r\t\"('A clear but rather long-winded summary' contractTo: 18) >>> 'A clear ...summary'\"\r\t\r\t| leftSize |\r\tself size <= smallSize\r\t\tifTrue: [^ self].  \"short enough\"\r\tsmallSize < 5\r\t\tifTrue: [^ self copyFrom: 1 to: smallSize].    \"First N characters\"\r\tleftSize := smallSize-2//2.\r\t^ self copyReplaceFrom: leftSize+1\t\t\"First N/2 ... last N/2\"\r\t\tto: self size - (smallSize - leftSize - 3)\r\t\twith: '...'\r"},{"name":"withInternetLineEndings","linesOfCode":3,"sourceCode":"withInternetLineEndings\r\t\"change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet\"\r\t\r\t^self withLineEndings: String crlf"},{"name":"asRegex","linesOfCode":6,"sourceCode":"asRegex\r\t\"Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal\r\tor RxParser>>compilationErrorSignal.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^RxParser preferredMatcherClass for: (RxParser new parse: self)"},{"name":"trimRight:","linesOfCode":3,"sourceCode":"trimRight: aBlock\r\t\"Trim characters satisfying the condition given in aBlock from the right side of the receiving string.\"\r\r\t^ self trimLeft: [ :char | false ] right: aBlock"},{"name":"skipAnySubstring:startingAt:","linesOfCode":20,"sourceCode":"skipAnySubstring: delimiters startingAt: start \r\t\"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1.\"\r\r\t| any this ind ii |\r\tii := start-1.\r\t[(ii := ii + 1) <= self size] whileTrue: [ \"look for char that does not match\"\r\t\tany := false.\r\t\tdelimiters do: [:delim |\r\t\t\tdelim isCharacter \r\t\t\t\tifTrue: [(self at: ii) == delim ifTrue: [any := true]]\r\t\t\t\tifFalse: [\"a substring\"\r\t\t\t\t\tdelim size > (self size - ii + 1) ifFalse: \"Here's where the one-off error was.\"\r\t\t\t\t\t\t[ind := 0.\r\t\t\t\t\t\tthis := true.\r\t\t\t\t\t\tdelim do: [:dd | \r\t\t\t\t\t\t\tdd == (self at: ii+ind) ifFalse: [this := false].\r\t\t\t\t\t\t\tind := ind + 1].\r\t\t\t\t\t\tthis ifTrue: [ii := ii + delim size - 1.  any := true]]\r\t\t\t\t\t\t\tifTrue: [any := false] \"if the delim is too big, it can't match\"]].\r\t\tany ifFalse: [^ ii]].\r\t^ self size + 1"},{"name":"surroundedBySingleQuotes","linesOfCode":6,"sourceCode":"surroundedBySingleQuotes\r\t\"Answer the receiver with leading and trailing quotes.\"\r\t\"'hello' surroundedBySingleQuotes >>>  '''hello'''\"\r\t\"'he''llo' surroundedBySingleQuotes >>> '''he''llo'''\"\r\t\"'  hello  ' surroundedBySingleQuotes >>>  '''  hello  '''\"\r\t\r\t^ self surroundedBy: ($' asString)"},{"name":"asZnMimeType","linesOfCode":2,"sourceCode":"asZnMimeType\r\t^ ZnMimeType fromString: self"},{"name":"findDelimiters:startingAt:","linesOfCode":7,"sourceCode":"findDelimiters: delimiters startingAt: start \r\t\"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.\"\r\r\tstart to: self size do: [:i |\r\t\tdelimiters do: [:delim | \r\t\t\tdelim = (self at: i) \r\t\t\t\tifTrue: [^ i]]].\r\t^ self size + 1"},{"name":"lastIndexOfPKSignature:","linesOfCode":15,"sourceCode":"lastIndexOfPKSignature: aSignature\r\t\"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found\"\r\t| a b c d |\r\ta := aSignature first.\r\tb := aSignature second.\r\tc := aSignature third.\r\td := aSignature fourth.\r\t(self size - 3) to: 1 by: -1 do: [ :i |\r\t\t(((self at: i) = a)\r\t\t\tand: [ ((self at: i + 1) = b)\r\t\t\t\tand: [ ((self at: i + 2) = c)\r\t\t\t\t\tand: [ ((self at: i + 3) = d) ]]])\r\t\t\t\t\t\tifTrue: [ ^i ]\r\t].\r\t^0"},{"name":"asClassIfPresent:","linesOfCode":3,"sourceCode":"asClassIfPresent: presentBlock\r\t\"returns a global class with my name\"\r\t^ presentBlock cull: (self asClassIfAbsent: [ ^ nil ])"},{"name":"displayStringOn:","linesOfCode":2,"sourceCode":"displayStringOn: aStream\r\t\r\taStream nextPutAll: self\r\t"},{"name":"removeFromMetacelloRepositories:","linesOfCode":5,"sourceCode":"removeFromMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\taMetacelloRepositoriesSpec addMember: \r\t\t(aMetacelloRepositoriesSpec removeMember \r\t\t\tname: self;\r\t\t\tyourself)"},{"name":"findCloseParenthesisFor:","linesOfCode":14,"sourceCode":"findCloseParenthesisFor: startIndex\r\t\"assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest.\"\r\t\" '(1+(2-3))-3.14159' findCloseParenthesisFor: 1 \"\r\t\" '(1+(2-3))-3.14159' findCloseParenthesisFor: 4 \"\r\t| pos nestLevel |\r\tpos := startIndex+1.\r\tnestLevel := 1.\r\t[ pos <= self size ] whileTrue: [\r\t\t(self at: pos) = $( ifTrue: [ nestLevel := nestLevel + 1 ].\r\t\t(self at: pos) = $) ifTrue: [ nestLevel := nestLevel - 1 ].\r\t\tnestLevel = 0 ifTrue: [ ^pos ].\r\t\tpos := pos + 1.\r\t].\r\t^self size + 1"},{"name":"stonOn:","linesOfCode":2,"sourceCode":"stonOn: stonWriter\r\tstonWriter writeString: self"},{"name":"asDraggableMorph","linesOfCode":2,"sourceCode":"asDraggableMorph\r\r\t^ self asStringMorph"},{"name":"widthToDisplayInList:","linesOfCode":2,"sourceCode":"widthToDisplayInList: aList\r\r\t^ aList font widthOfStringOrText: self contents"},{"name":"substrings","linesOfCode":5,"sourceCode":"substrings\r\t\"Answer an array of non-empty substrings from the receiver separated by\r\tone or more whitespace characters.\"\r\t\r\t\"'let us make seperate strings' substrings >>>  #('let' 'us' 'make' 'seperate' 'strings')\"\r\r\t^ self substrings: CSSeparators"},{"name":"gtDebuggerSUnitPrint","linesOfCode":2,"sourceCode":"gtDebuggerSUnitPrint\r\r\t^ self printString"},{"name":"isValidGlobalName","linesOfCode":9,"sourceCode":"isValidGlobalName\r\r\tself ifEmpty: [ ^ false ].\r\t\r\t\"reserverd default names\"\r\tself = 'NameOfSubclass' ifTrue: [ ^ false ].\r\tself = 'TNameOfTrait' ifTrue: [ ^ false ].\r\t\r\t^ (self first isLetter \r\t\t\t\tand: [self first isUppercase]) \r\t\t\t\tand: [ self allSatisfy: [:character | \r\t\t\t\t\t\tcharacter isAlphaNumeric or: [ character = $_ ]]]"},{"name":"listBuildSceneGraphWith:atRow:bounds:color:backgroundColor:from:","linesOfCode":2,"sourceCode":"listBuildSceneGraphWith: builder atRow: aRow bounds: bounds color: color backgroundColor: backgroundColor from: aMorph\r\t^ builder string: self in: bounds font: aMorph font color: color"},{"name":"expandMacrosWith:with:with:","linesOfCode":5,"sourceCode":"expandMacrosWith: anObject with: anotherObject with: thirdObject \r\t^self expandMacrosWithArguments: (Array \r\t\t\t\twith: anObject\r\t\t\t\twith: anotherObject\r\t\t\t\twith: thirdObject)"},{"name":"findSelector","linesOfCode":31,"sourceCode":"findSelector\r\t\"Extract a selector with keyword parts from the receiver. While this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it.\"\r\t\r\t\"'isSymbol' findSelector >>> #isSymbol\"\r\t\"'x isSymbol' findSelector >>> nil\"\r\t\"'x isSymbol: 33' findSelector >>> #isSymbol:\"\r\t\"'between:and:' findSelector >>> #'between:and:'\"\r\t\"'2 between: 0 and: 4' findSelector >>> #'between:and:'\"\r\t\"'2 between: ( 1 and: 4)' findSelector >>> #between:\"\r\t\"'( 1 and: 4)' findSelector >>> nil\"\r\t\r\t| sel possibleParens |\r\tsel := self trimBoth.\r\tsel := sel copyReplaceAll: '#' with: ''.\r\tsel := sel copyReplaceAll: '[' with: ' [ '.\r\t(sel includes: $:) ifTrue:\r\t\t[sel := sel copyReplaceAll: ':' with: ': '.\t\"for the style (aa max:bb) with no space\"\r\t\tpossibleParens := sel findTokens: Character separators.\r\t\tsel := self species streamContents:\r\t\t\t[:s | | level | level := 0.\r\t\t\tpossibleParens do:\r\t\t\t\t[:token | | n |\r\t\t\t\t(level = 0 and: [token endsWith: ':'])\r\t\t\t\t\tifTrue: [s nextPutAll: token]\r\t\t\t\t\tifFalse: [(n := token occurrencesOf: $( ) > 0 ifTrue: [level := level + n].\r\t\t\t\t\t\t\t(n := token occurrencesOf: $[ ) > 0 ifTrue: [level := level + n].\r\t\t\t\t\t\t\t(n := token occurrencesOf: $] ) > 0 ifTrue: [level := level - n].\r\t\t\t\t\t\t\t(n := token occurrencesOf: $) ) > 0 ifTrue: [level := level - n]]]]].\r\r\tsel isEmpty ifTrue: [^ nil].\r\tsel isOctetString ifTrue: [sel := sel asOctetString].\r\tSymbol hasInterned: sel ifTrue:\r\t\t[:aSymbol | ^ aSymbol].\r\t^ nil"},{"name":"zipped","linesOfCode":7,"sourceCode":"zipped\r\t| gzstream |\r\r\t^ String streamContents: [ :stream |\r\t\tgzstream := GZipWriteStream on: stream.\r\t\tgzstream nextPutAll: self.\r\t\tgzstream close.\r \t]"},{"name":"putOn:","linesOfCode":6,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream by iterating over its elements.\r\tIn general we assume aStream accepts the receiver's elements as element type.\r\tThis is an optimisation.\r\tReturn self.\"\r\r\taStream nextPutAll: self"},{"name":"unzipped","linesOfCode":6,"sourceCode":"unzipped\r\t| magic1 magic2 |\r\tmagic1 := (self at: 1) asInteger.\r\tmagic2 := (self at: 2) asInteger.\r\t(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].\r\t^(GZipReadStream on: self) upToEnd"},{"name":"trimBoth","linesOfCode":3,"sourceCode":"trimBoth\r\t\"Trim separators from both sides of the receiving string.\"\r\t\r\t^ self trimBoth: [ :char | char isSeparator ]"},{"name":"search:","linesOfCode":3,"sourceCode":"search: aString\r\t\"compatibility method to make regexp and strings work polymorphicly\"\r\t^ aString includesSubstring: self"},{"name":"includesUnifiedCharacter","linesOfCode":2,"sourceCode":"includesUnifiedCharacter\r\t^false"},{"name":"decodeMimeHeader","linesOfCode":42,"sourceCode":"decodeMimeHeader\r\t\"See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  \r\tText. Text containing non-ASCII characters is encoded by the sequence  \r\t=?character-set?encoding?encoded-text?=  \r\tEncoding is Q (quoted printable) or B (Base64), handled by  \r\tBase64MimeConverter / RFC2047MimeConverter.\r\r\tThanks to Yokokawa-san, it works in m17n package.  Try the following:\r\r\t'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader.\r\"\r\t| input |\r\tinput := self readStream.\r\t^String streamContents: [ :output | | temp |\r\t\t[ output nextPutAll: (input upTo: $=).\r\t\t\"ASCII Text\"\r\t\tinput atEnd ] whileFalse: \r\t\t[ (temp := input next) = $? \r\t\t\tifTrue: \r\t\t\t\t[ | pos charset mimeEncoding mimeDecoder charsetStream  |\r\t\t\t\tcharset := input upTo: $?.\r\t\t\t\t(charset isNil or: [ charset isEmpty ]) ifTrue: [ charset := 'LATIN-1' ].\r\t\t\t\tmimeEncoding := (input upTo: $?) asUppercase.\r\t\t\t\ttemp := input upTo: $?.\r\t\t\t\t\"Skip final =\"\r\t\t\t\tinput next.\r\t\t\t\tpos := input position.\r\t\t\t\tinput skipSeparators.\r\t\t\t\t\"Delete spaces if followed by =\"\r\t\t\t\tinput peek = $= ifFalse: [ input position: pos ]. \r\t\t\t\t\t\r\t\t\t\tcharsetStream :=  String new writeStream.\r\t\t\t\tmimeDecoder := mimeEncoding = 'B' \r\t\t\t\t\tifTrue: [ Base64MimeConverter new ]\r\t\t\t\t\tifFalse: [ RFC2047MimeConverter new ].\r\t\t\t\tmimeDecoder\r\t\t\t\t\tmimeStream: temp readStream;\r\t\t\t\t\tdataStream: charsetStream;\r\t\t\t\t\tmimeDecode.\r\t\t\t\toutput nextPutAll: (charsetStream contents convertFromEncoding: charset).\r\t\t\t\t]\r\t\t\tifFalse: \r\t\t\t\t[ output\r\t\t\t\t\tnextPut: $=;\r\t\t\t\t\tnextPut: temp ] ] ]"},{"name":"copyUpToSubstring:","linesOfCode":6,"sourceCode":"copyUpToSubstring: aSubstring\r\r\taSubstring ifEmpty: [ \r\t\t\"preserve compatiblity with `readStream upToAll:`\"\r\t\t^ String new ].\r\t\r\t^ (self findString: aSubstring)\r\t\tin: [ :index | index > 0 ifTrue: [ self copyFrom: 1 to: index-1 ] ifFalse: [ self ] ]"},{"name":"withoutPrefix:","linesOfCode":3,"sourceCode":"withoutPrefix: prefix\r\t\"Remove the given prefix, if present.\"\r\r\t^(self beginsWith: prefix) ifTrue: [ self copyFrom: 1 + prefix size to: self size ] ifFalse: [ self ]"},{"name":"copyReplaceTokens:with:","linesOfCode":4,"sourceCode":"copyReplaceTokens: oldSubstring with: newSubstring \r\t\"Replace all occurrences of oldSubstring that are surrounded by non-alphanumeric characters\"\r\t\"('File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick') >>> 'Snick asFile Files Snick''s Snick'\"\r\t\r\t^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true\r\t"},{"name":"encodedCharSetAt:","linesOfCode":3,"sourceCode":"encodedCharSetAt: index\r\t\"return the character encoding in place at index; the actual EncodedCharSet, not just a number. A bad index is an Error\"\r\t^EncodedCharSet charsetAt: 0 \"previous leadingChar\""},{"name":"uncapitalized","linesOfCode":7,"sourceCode":"uncapitalized\r\t\"Return a copy with the first letter downShifted (in lower case)\"\r\t\r\t| answer |\r\tself ifEmpty: [ ^ self copy ].\r\tanswer := self copy.\r\tanswer at: 1 put: answer first asLowercase.\r\t^ answer"},{"name":"findTokens:includes:","linesOfCode":5,"sourceCode":"findTokens: delimiters includes: substring\r\t\"Divide self into pieces using delimiters.  Return the piece that includes substring anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive).\"\r\r^ (self findTokens: delimiters) \r\tdetect: [:str | (str includesSubstring: substring)] \r\tifNone: [nil]"},{"name":"parseLiterals","linesOfCode":2,"sourceCode":"parseLiterals\r\t^ self class compiler parseLiterals: self"},{"name":"occursInWithEmpty:caseSensitive:","linesOfCode":14,"sourceCode":"occursInWithEmpty: prefix caseSensitive: aBoolean \r\t\"Answer whether the receiver begins with the given prefix string. \r\tThe comparison is case-sensitive.\" \r\t| matchTable |\r\tprefix isEmpty ifTrue: [ ^ true ].\r\tself size < prefix size ifTrue: [ ^ false ].\r\tmatchTable := aBoolean \r\t\tifTrue: [ CaseSensitiveOrder ]\r\t\tifFalse: [ CaseInsensitiveOrder ].\r\t^ (self \r\t\tfindSubstring: prefix\r\t\tin: self\r\t\tstartingAt: 1\r\t\tmatchTable: matchTable) > 0"},{"name":"regex:matchesDo:","linesOfCode":2,"sourceCode":"regex: rxString matchesDo: aBlock\r\r\t^rxString asRegex matchesIn: self do: aBlock"},{"name":"setDescriptionInMetacelloVersion:","linesOfCode":5,"sourceCode":"setDescriptionInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setDescription: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"displayOn:at:textColor:","linesOfCode":3,"sourceCode":"displayOn: aDisplayMedium at: aPoint textColor: aColor\r\t\"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color\"\r\taDisplayMedium getCanvas drawString: self from: 1 to: self size at: aPoint font: nil color: aColor\r"},{"name":"asStringOrText","linesOfCode":3,"sourceCode":"asStringOrText\r\t\"Answer this string.\"\r\r\t^ self\r"},{"name":"asMorph","linesOfCode":4,"sourceCode":"asMorph \r\t\"Answer the receiver as a StringMorph\"\r\r\t^ StringMorph contents: self\r\r\"'bugs black blood' asMorph openInHand\""},{"name":"splitCamelCase","linesOfCode":15,"sourceCode":"splitCamelCase\r\t\r\t| results accum previousIsLower |\r\t\r\tresults := OrderedCollection new.\r\taccum := \tself first asString.\r\tpreviousIsLower := self first isLowercase.\r\t\r\t2 to: self size do: [ :index | | currentCharacter |\r\t\tcurrentCharacter := self at: index.\r\t\t(currentCharacter isUppercase and: [ previousIsLower ])\r\t\t\tifTrue: [ results add: accum. accum := '' ].\r\t\t\t\r\t\taccum := accum copyWith: currentCharacter.\r\t\tpreviousIsLower := currentCharacter isLowercase.\r\t].\t\r\t\r\tresults add: accum.\r\t\r\t^ results."},{"name":"byteAt:put:","linesOfCode":2,"sourceCode":"byteAt: index put: value\r\t^self subclassResponsibility"},{"name":"expandMacros","linesOfCode":5,"sourceCode":"expandMacros\r\t\"'<t>' expandMacros >>> String tab\"\r\t\"'<r>' expandMacros >>> String cr\"\r\t\"'<n>' expandMacros >>> OSPlatform current lineEnding\"\r\t\r\t^self expandMacrosWithArguments: #()"},{"name":"hasWideCharacterFrom:to:","linesOfCode":4,"sourceCode":"hasWideCharacterFrom: start to: stop\r\t\"Return true if one of my character in the range does not fit in a single byte\"\r\t\r\t\"Implementation note: inline #anySatisfy: here for efficiency reasons\"\r\t^(self indexOfWideCharacterFrom: start to: stop) ~= 0"},{"name":"deepCopy","linesOfCode":4,"sourceCode":"deepCopy\r\t\"DeepCopy would otherwise mean make a copy of the character;  since \r\tcharacters are unique, just return a shallowCopy.\"\r\r\t^self shallowCopy"},{"name":"endsWithAColon","linesOfCode":5,"sourceCode":"endsWithAColon \r\t\"Answer whether the final character of the receiver is a colon\"\r\t\"'displayStringOn:' endsWithAColon >>> true\"\r\t\"'displayStringOn:foo' endsWithAColon >>> false\"\r\t\r\t^ self notEmpty and: [ self last == $: ]\r"},{"name":"asPathWith:","linesOfCode":2,"sourceCode":"asPathWith: anObject \r\t^ anObject pathFromString: self"},{"name":"indentationIfBlank:","linesOfCode":15,"sourceCode":"indentationIfBlank: aBlock \r\t\"Answer the number of leading tabs in the receiver.  If there are\r\t no visible characters, pass the number of tabs to aBlock and return its value.\"\r\t| reader leadingTabs lastSeparator cr tab ch |\r\tcr := Character cr.\r\ttab := Character tab.\r\treader := self readStream.\r\tleadingTabs := 0.\r\t[ reader atEnd not and: [ (ch := reader next) = tab ] ] whileTrue: [ leadingTabs := leadingTabs + 1 ].\r\tlastSeparator := leadingTabs + 1.\r\t[ reader atEnd not and: [ ch isSeparator and: [ ch ~= cr ] ] ] whileTrue: \r\t\t[ lastSeparator := lastSeparator + 1.\r\t\tch := reader next ].\r\t(lastSeparator = self size or: [ ch = cr ]) ifTrue: [ ^ aBlock value: leadingTabs ].\r\t^ leadingTabs"},{"name":"withSqueakLineEndings","linesOfCode":8,"sourceCode":"withSqueakLineEndings\r\t\"Answer a new instance where all occurrences of CRLF and LF are substituted with CR.\"\r\t\r\tself\r\t\tdeprecated: 'Should use withInternalLineEndings instead'\r\t\ton: '30 October 2020'\r\t\tin: #Pharo9\r\t\ttransformWith: '`@rec withSqueakLineEndings' -> '`@rec withInternalLineEndings'.\r\t\r\t^ self withInternalLineEndings"},{"name":"asPrettySymbolName","linesOfCode":2,"sourceCode":"asPrettySymbolName\r\t^ self"},{"name":"withoutPeriodSuffix","linesOfCode":7,"sourceCode":"withoutPeriodSuffix\r\t\"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. \"\r\r\t| likely |\r\tlikely := self copyUpTo: $..\r\t^ likely size = 0\r\t\tifTrue: [ self ]\r\t\tifFalse: [ likely ]"},{"name":"beginsWith:fromList:","linesOfCode":2,"sourceCode":"beginsWith: aString fromList: aMorph\r\r\t^ self trimBoth asLowercase beginsWith: aString"},{"name":"slvmUTF8Encoded","linesOfCode":2,"sourceCode":"slvmUTF8Encoded\r\t^ self utf8Encoded"},{"name":"isPatternVariable","linesOfCode":2,"sourceCode":"isPatternVariable\r\r\t ^self keywords anySatisfy: [:each | each first = $`]"},{"name":"asDateAndTime","linesOfCode":3,"sourceCode":"asDateAndTime\r \t\"Convert from UTC format\" \t\r\t\r\t^ DateAndTime fromString: self"},{"name":"lineIndicesDo:","linesOfCode":32,"sourceCode":"lineIndicesDo: aBlock\r\t\"execute aBlock with 3 arguments for each line:\r\t- start index of line\r\t- end index of line without line delimiter\r\t- end index of line including line delimiter(s) CR, LF or CRLF\"\r\t\r\t| cr lf start sz nextLF nextCR |\r\tstart := 1.\r\tsz := self size.\r\tcr := Character cr.\r\tnextCR := self indexOf: cr startingAt: 1.\r\tlf := Character lf.\r\tnextLF := self indexOf: lf startingAt: 1.\r\t[ start <= sz ] whileTrue: [\r\t\t(nextLF = 0 and: [ nextCR = 0 ])\r\t\t\tifTrue: [ \"No more CR, nor LF, the string is over\"\r\t\t\t\t\taBlock value: start value: sz value: sz.\r\t\t\t\t\t^self ].\r\t\t(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])\r\t\t\tifTrue: [ \"Found a LF\"\r\t\t\t\t\taBlock value: start value: nextLF - 1 value: nextLF.\r\t\t\t\t\tstart := 1 + nextLF.\r\t\t\t\t\tnextLF := self indexOf: lf startingAt: start ]\r\t\t\tifFalse: [ 1 + nextCR = nextLF\r\t\t\t\tifTrue: [ \"Found a CR-LF pair\"\r\t\t\t\t\taBlock value: start value: nextCR - 1 value: nextLF.\r\t\t\t\t\tstart := 1 + nextLF.\r\t\t\t\t\tnextCR := self indexOf: cr startingAt: start.\r\t\t\t\t\tnextLF := self indexOf: lf startingAt: start ]\r\t\t\t\tifFalse: [ \"Found a CR\"\r\t\t\t\t\taBlock value: start value: nextCR - 1 value: nextCR.\r\t\t\t\t\tstart := 1 + nextCR.\r\t\t\t\t\tnextCR := self indexOf: cr startingAt: start ]]]"},{"name":"withoutQuoting","linesOfCode":10,"sourceCode":"withoutQuoting\r\t\"remove the initial and final quote marks (single quote for string, or double quotes for comments), if present (and if matches nesting quotes). Have a look at testWithoutQuoting. If you want to remove single/double quotes not in first and last positions of the strings, have a look at copyWithout: $' \"\r\r\t\"'''h''' withoutQuoting >>> 'h'\"\r\r\t\"' ''h'' ' withoutQuoting >>>  ' ''h'' '\"\r\r\t| quote |\r\tself size < 2 ifTrue: [ ^ self ].\r\tquote := self first.\r\t^ (quote = self last and: [ quote = $' or: [ quote = $\" ] ])\r\t\tifTrue: [ self copyFrom: 2 to: self size - 1 ]\r\t\tifFalse: [ self ]"},{"name":"isAsciiString","linesOfCode":2,"sourceCode":"isAsciiString\r\r\t^ self allSatisfy: [ :each | each asciiValue <= 127 ]\r"},{"name":"nullTerminatedEncodeWith:","linesOfCode":8,"sourceCode":"nullTerminatedEncodeWith: encoding\r\t\"Produce a ByteArray that encodes the receiver, using a specified encoding and adding a null terminator.\r\tEncoding is either a ZnCharacterEncoder instance or an identifier for one.\r\tUseful extension for FFI and C integration\"\r\t\r\t\" 'Les lves franais' nullTerminatedEncodeWith: #utf8 \"\r\t\r\t^ ByteArray streamContents: [ :stream |\r\t\tencoding asZnCharacterEncoder next: self size putAll: self startingAt: 1 toStream: stream.\r\t\tstream nextPut: 0 \"Null terminator\" ]"},{"name":"wordBefore:","linesOfCode":15,"sourceCode":"wordBefore: anIndex \r\t\"('word before index' wordBefore: 4) >>> 'word'\"\r\t\"('word before index' wordBefore: 16) >>> 'inde'\"\r\t\r\t| sep tok |\r\ttok := false.\r\tsep := anIndex.\r\t[ sep > 0 and: [ (self at: sep) tokenish ] ] whileTrue: \r\t\t[ tok := true.\r\t\tsep := sep - 1 ]. \r\t^ tok \r\t\tifTrue: \r\t\t\t[ self \r\t\t\t\tcopyFrom: sep + 1\r\t\t\t\tto: anIndex ]\r\t\tifFalse: [ String new ]"},{"name":"findTokens:","linesOfCode":14,"sourceCode":"findTokens: delimiters\r\t\"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character.\"\r\r\t| tokens keyStart keyStop separators |\r\r\ttokens := OrderedCollection new.\r\tseparators := delimiters isCharacter \r\t\tifTrue: [Array with: delimiters]\r\t\tifFalse: [delimiters].\r\tkeyStop := 1.\r\t[keyStop <= self size] whileTrue:\r\t\t[keyStart := self skipDelimiters: separators startingAt: keyStop.\r\t\tkeyStop := self findDelimiters: separators startingAt: keyStart.\r\t\tkeyStart < keyStop\r\t\t\tifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].\r\t^tokens"},{"name":"asFileReference","linesOfCode":2,"sourceCode":"asFileReference\r\r\t^ FileSystem disk referenceTo: self"},{"name":"stemAndNumericSuffix","linesOfCode":12,"sourceCode":"stemAndNumericSuffix\r\t\"Parse the receiver into a string-valued stem and a numeric-valued suffix.\"\r\t\"'Fred2305' stemAndNumericSuffix\"\r\r\t| stem suffix position |\r\r\tstem := self.\r\tsuffix := 0.\r\tposition := 1.\r\t[stem endsWithDigit and: [stem size > 1]] whileTrue:\r\t\t[suffix :=  stem last digitValue * position + suffix.\r\t\tposition := position * 10.\r\t\tstem := stem copyFrom: 1 to: stem size - 1].\r\t^ Array with: stem with: suffix\r"},{"name":"withoutSuffix:","linesOfCode":3,"sourceCode":"withoutSuffix: suffix\r\t\"Remove the given suffix, if present.\"\r\r\t^(self endsWith: suffix) ifTrue: [ self copyFrom: 1 to: self size - suffix size ] ifFalse: [ self ]"},{"name":"encompassLine:","linesOfCode":8,"sourceCode":"encompassLine: anInterval\r\t\"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.\r\tAnswer starts at the position following a cr (or eventually 1) and ends before a cr (or eventually at self size)\r\tSee also encompassParagraph:\"\r\t| left right |\r\tleft := (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.\r\tright := (self indexOf: Character cr startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.\r\t^left to: right"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: encoder\r\t^ self"},{"name":">=","linesOfCode":7,"sourceCode":">= aString \r\t\"Answer whether the receiver sorts after or equal to aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'def' >= 'abc' >>> true\"\r\t\" 'def' >= 'def' >>> true\"\r\t\" 'abc' >= 'def' >>> false\"\r\r\t^ (self compare: self with: aString collated: AsciiOrder) >= 2"},{"name":"asAlphaNumeric:extraChars:mergeUID:","linesOfCode":87,"sourceCode":"asAlphaNumeric: totalSize extraChars: additionallyAllowed mergeUID: minimalSizeOfRandomPart \r\t\"Generates a String with unique identifier ( UID ) qualities, the difference to a\r\t UUID is that its beginning is derived from the receiver, so that it has a meaning\r\t for a human reader.\r\r\t Answers a String of totalSize, which consists of 3 parts\r\t 1.part: the beginning of the receiver only consisting of\r\t\ta-z, A-Z, 0-9 and extraChars in Collection additionallyAllowed ( which can be nil )\r\t 2.part: a single _\r\t 3.part: a ( random ) UID of size >= minimalSizeOfRandomPart consisting of\r\t\ta-z, A-Z, 0-9\r\r\t Starting letters are capitalized. \r\t TotalSize must be at least 1.\r\t Exactly 1 occurrence of $_ is guaranteed ( unless additionallyAllowed includes $_ ).\r\t The random part has even for small sizes good UID qualitites for many practical purposes.\r\t If only lower- or uppercase letters are demanded, simply convert the answer with\r\t say #asLowercase. The probability of a duplicate will rise only moderately ( see below ).\r\r\t Example: \r\t\tsize of random part = 10\r\t\tin n generated UIDs the chance p of having non-unique UIDs is\r\t\t\tn = 10000 ->  p < 1e-10\t\tif answer is reduced to lowerCase: p < 1.4 e-8\r\t\t\tn = 100000 -> p < 1e-8\r\t\tat the bottom is a snippet for your own calculations  \r\t\tNote: the calculated propabilites are theoretical,\r\t\t\tfor the actually used random generator they may be much worse\"\r\t| stream out sizeOfFirstPart index ascii ch skip array random |\r\ttotalSize > minimalSizeOfRandomPart ifFalse: [ self errorOutOfBounds ].\r\tstream := self readStream.\r\tout :=  (String new: totalSize) writeStream.\r\tindex := 0.\r\tskip := true.\r\tsizeOfFirstPart := totalSize - minimalSizeOfRandomPart - 1.\r\t[ stream atEnd or: [ index >= sizeOfFirstPart ] ] whileFalse: \r\t\t[ (((ascii := (ch := stream next) asciiValue) between: 65 and: 90) or: \r\t\t\t[ (ascii between: 97 and: 122) or: \r\t\t\t\t[ ch isDigit or: [ additionallyAllowed notNil and: [ additionallyAllowed includes: ch ] ] ] ]) \r\t\t\tifTrue: \r\t\t\t\t[ skip \r\t\t\t\t\tifTrue: [ out nextPut: ch asUppercase ]\r\t\t\t\t\tifFalse: [ out nextPut: ch ].\r\t\t\t\tindex := index + 1.\r\t\t\t\tskip := false ]\r\t\t\tifFalse: [ skip := true ] ].\r\tout nextPut: $_.\r\tarray := Array new: 62.\r\t1 \r\t\tto: 26\r\t\tdo: \r\t\t\t[ :i | \r\t\t\tarray \r\t\t\t\tat: i\r\t\t\t\tput: (i + 64) asCharacter.\r\t\t\tarray \r\t\t\t\tat: i + 26\r\t\t\t\tput: (i + 96) asCharacter ].\r\t53 \r\t\tto: 62\r\t\tdo: \r\t\t\t[ :i | \r\t\t\tarray \r\t\t\t\tat: i\r\t\t\t\tput: (i - 5) asCharacter ].\r\trandom := UUIDGenerator default randomGenerator.\r\ttotalSize - index - 1 timesRepeat: [ out nextPut: (array atRandom: random) ].\r\t^ out contents\r\r\t\"\tcalculation of probability p for failure of uniqueness in n UIDs\r\t\tNote: if answer will be converted to upper or lower case replace 62 with 36\r\t| n i p all |\r\tall := 62 raisedTo: sizeOfRandomPart.\r\ti := 1.\r\tp := 0.0 .\r\tn := 10000.\r\t[ i <= n ]\r\twhileTrue: [\r\t\tp := p + (( i - 1 ) / all ).\r\t\ti := i + 1 ].\r\tp   \r\r\tapproximation formula: n squared / ( 62.0 raisedTo: sizeOfRandomPart ) / 2 \r\t\"\r\r\t\"'Crop SketchMorphs and Grab Screen Rect to JPG' \r\t\t\tasAlphaNumeric: 31 extraChars: nil mergeUID: 10  \r\t \t\t\t'CropSketchMorphsAndG_iOw94jquN6'\r\t 'Monticello' \r\t\t\tasAlphaNumeric: 31 extraChars: nil mergeUID: 10    \r\t\t\t\t'Monticello_kp6aV2l0IZK9uBULGOeG' \r\t 'version-', ( '1.1.2' replaceAll: $. with: $- )\r\t\t\tasAlphaNumeric: 31 extraChars: #( $- ) mergeUID: 10    \r\t\t\t\t'Version-1-1-2_kuz2tMg2xX9iRLDVR'\""},{"name":"numArgs","linesOfCode":29,"sourceCode":"numArgs\r\t\"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector. It is intended mostly for the assistance of spelling correction.\"\r\r\t| firstChar numColons start ix |\r\tself size = 0 ifTrue: [ ^ -1 ].\r\tfirstChar := self at: 1.\r\t(firstChar isLetter or: [ firstChar = $_ ])\r\t\tifTrue: [ \"Fast reject if any chars are non-alphanumeric\r\t\tNOTE: fast only for Byte things - Broken for Wide\"\r\t\t\tself class isBytes\r\t\t\t\tifTrue: [ (self\r\t\t\t\t\t\tfindSubstring: '~'\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: 1\r\t\t\t\t\t\tmatchTable: Tokenish) > 0 ifTrue: [ ^ -1 ] ]\r\t\t\t\tifFalse: [ 2 to: self size do: [ :i | (self at: i) tokenish ifFalse: [ ^ -1 ] ] ].\r\t\t\t\"Fast colon count\"\r\t\t\tnumColons := 0.\r\t\t\tstart := 1.\r\t\t\t[ (ix := self indexOf: $: startingAt: start) > 0 ]\r\t\t\t\twhileTrue: [ (ix = start or: [ (self at: start) isDigit ]) ifTrue: [ ^ -1 ].\r\t\t\t\t\tnumColons := numColons + 1.\r\t\t\t\t\tstart := ix + 1 ].\r\t\t\tnumColons = 0 ifTrue: [ ^ 0 ].\r\t\t\t^ self last = $:\r\t\t\t\tifTrue: [ numColons ]\r\t\t\t\tifFalse: [ -1 ] ].\r\t\"Test case of binary selector, if self allSatisfy: #isSpecial (inlined for speed)\"\r\t1 to: self size do: [ :i | (self at: i) isSpecial ifFalse: [ ^ -1 ] ].\r\t^ 1"},{"name":"byteAt:","linesOfCode":2,"sourceCode":"byteAt: index\r\t^self subclassResponsibility"},{"name":"prefixMatchesRegex:","linesOfCode":6,"sourceCode":"prefixMatchesRegex: regexString\r\t\"Test if the receiver's prefix matches a regex.\t\r\tMay raise RxParser class>>regexErrorSignal or child signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegex matchesPrefix: self"},{"name":"padLeftTo:with:","linesOfCode":2,"sourceCode":"padLeftTo: length with: char\r\t^ (String new: (length - self size max: 0) withAll: char) , self."},{"name":"withSeparatorsCompacted","linesOfCode":19,"sourceCode":"withSeparatorsCompacted\r    \"Returns a copy of the receiver with each sequence of whitespace (separator) \r    characters replaced by a single space character\"\r    \"' test ' withSeparatorsCompacted >>> ' test '\"\r    \"' test  test' withSeparatorsCompacted >>> ' test test'\"\r    \"'test  test      ' withSeparatorsCompacted >>> 'test test '\"\r\r    self isEmpty ifTrue: [ ^ self ].\r    ^ self species new: self size streamContents: [:stream | \r        | lastBlank |\r        lastBlank := false.\r        self do: [ :eachChar | \r            lastBlank \r                ifTrue: [\r                    (lastBlank := eachChar isSeparator)\r                        ifFalse: [ stream nextPut: eachChar ] ] \r                ifFalse: [\r                    (lastBlank := eachChar isSeparator)\r                        ifTrue: [ stream nextPut: $  ]\r                        ifFalse: [ stream nextPut: eachChar ] ] ] ]"},{"name":"asHTMLString","linesOfCode":5,"sourceCode":"asHTMLString\r\t\"substitute the < & > into HTML compliant elements\"\r\t\"'<a>' asHTMLString\"\r\t^ self species new: self size streamContents: [ :s| \r\t\tself do: [:c | s nextPutAll: c asHTMLString ]]\r"},{"name":"removeFromMetacelloPackages:","linesOfCode":5,"sourceCode":"removeFromMetacelloPackages: aMetacelloPackagesSpec\r\r\taMetacelloPackagesSpec addMember: \r\t\t(aMetacelloPackagesSpec removeMember \r\t\t\tname: self;\r\t\t\tyourself)"},{"name":"setPackage:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setPackage: aString withInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setPackage: aString withString: self"},{"name":"copyReplaceAll:with:","linesOfCode":15,"sourceCode":"copyReplaceAll: oldSubstring with: newSubstring\r\t\"Answer a copy of the receiver in which all occurrences of oldSubstring have been replaced by newSubstring\"\r\t\"('ab cd ab ef ab' copyReplaceAll: 'ab' with: 'zk') >>> 'zk cd zk ef zk'\"\r    | idx |        \r    self = oldSubstring ifTrue: [ ^ newSubstring copy ].\r    oldSubstring isEmpty ifTrue: [ ^ self copy ].\r    idx := 1.\r    ^ self species new: self size streamContents: [ :stream | | foundIdx |\r        [ (foundIdx := self findString: oldSubstring startingAt: idx) isZero ] whileFalse: [ \r            stream \r                next: (foundIdx - idx) putAll: self startingAt: idx;\r                nextPutAll: newSubstring.\r            idx := foundIdx + oldSubstring size ].\r        idx <= self size ifTrue: [ \r            stream next: (self size - idx + 1) putAll: self startingAt: idx ] ]"},{"name":"endsWith:","linesOfCode":9,"sourceCode":"endsWith: suffix\r\t\"Answer whether the tail end of the receiver is the same as suffix.\r\tThe comparison is case-sensitive.\"\r \r\t\"('Elvis' endsWith: 'vis') >>> true\"\r\t\r\t| extra |\r\textra := self size - suffix size.\r\t^extra < 0 \r\t\tifTrue: [ false]\r\t   ifFalse: [ (self findString: suffix startingAt: extra + 1) > 0 ]"},{"name":"convertToWithConverter:","linesOfCode":7,"sourceCode":"convertToWithConverter: converter \r\tconverter\r\t\tifNil: [^ self].\r\t^ String new: self size streamContents: [:writeStream | \r\t\tconverter \r\t\t\tnextPutAll: self toStream: writeStream;\r\t\t\temitSequenceToResetStateIfNeededOn: writeStream]"},{"name":"trimLeft","linesOfCode":3,"sourceCode":"trimLeft\r\t\"Trim separators from the left side of the receiving string.\"\r\t\r\t^ self trimLeft: [ :char | char isSeparator ] "},{"name":"isValidLLVMSymbol","linesOfCode":8,"sourceCode":"isValidLLVMSymbol\r\tself isLLVMAnon ifTrue: [ ^ true ].\r\tself ifEmpty: [ ^ false ].\r\tself first isDigit ifTrue: [ ^ false ].\r\tself do: [ :c |\r\t\t(('._$' includes: c) or: [ c isAlphaNumeric ]) ifFalse: [ ^ false ].\r\t].\r\t^ true"},{"name":"findTokens:keep:","linesOfCode":14,"sourceCode":"findTokens: delimiters keep: keepers\r\t\"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)\"\r\r\t| tokens keyStart keyStop |\r\ttokens := OrderedCollection new.\r\tkeyStop := 1.\r\t[keyStop <= self size] whileTrue:\r\t\t[keyStart := self skipDelimiters: delimiters startingAt: keyStop.\r\t\tkeyStop to: keyStart-1 do: [:ii | \r\t\t\t(keepers includes: (self at: ii)) ifTrue: [\r\t\t\t\ttokens add: (self copyFrom: ii to: ii)]].\t\"Make this keeper be a token\"\r\t\tkeyStop := self findDelimiters: delimiters startingAt: keyStart.\r\t\tkeyStart < keyStop\r\t\t\tifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].\r\t^tokens"},{"name":"asSymbol","linesOfCode":4,"sourceCode":"asSymbol\r\t\"Answer the unique Symbol whose characters are the characters of the \r\tstring.\"\r\t^Symbol intern: self"},{"name":"asLLVMMetadataInContext:","linesOfCode":2,"sourceCode":"asLLVMMetadataInContext: aContext\r\t^ LLVMMDString new context: aContext; value: self; yourself"},{"name":"slvmUTF16EncodedSize","linesOfCode":2,"sourceCode":"slvmUTF16EncodedSize\r\t^ self slvmUTF16Encoded size"},{"name":"encodeDoublingQuoteOn:","linesOfCode":3,"sourceCode":"encodeDoublingQuoteOn: aStream\r\tself deprecated: 'Use #storeOn: instead' transformWith: '`@receiver encodeDoublingQuoteOn: `@argument' -> '`@receiver storeOn: `@argument'.\r\tself storeOn: aStream"},{"name":"correctAgainstDictionary:continuedFrom:","linesOfCode":7,"sourceCode":"correctAgainstDictionary: wordDict continuedFrom: oldCollection\r\t\"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary.\"\r\r\t^ wordDict \r\t\tifNil: [ self correctAgainstEnumerator: nil\r\t\t\t\t\tcontinuedFrom: oldCollection ]\r\t\tifNotNil: [ self correctAgainstEnumerator: [ :action | wordDict keysDo: action ]\r\t\t\t\t\tcontinuedFrom: oldCollection ]"},{"name":"storeOn:","linesOfCode":9,"sourceCode":"storeOn: aStream\r\t\"Print inside string quotes, doubling inbedded quotes.\"\r\r\t\"(String streamContents: [ :s | 'Foo''Bar' storeOn: s ]) >>> '''Foo''''Bar'''\"\r\r\t| x |\r\taStream nextPut: $'.\r\t1 to: self size do: [ :i | \r\t\taStream nextPut: (x := self at: i).\r\t\tx = $' ifTrue: [ aStream nextPut: x ] ].\r\taStream nextPut: $'"},{"name":"squeezeOutNumber","linesOfCode":6,"sourceCode":"squeezeOutNumber\r\t\"Try to find a number somewhere in this string, as explained in Number>readFrom:\r\t\r\tthis method returns the first number found\"\r\t\r\t\"'th is is29 a stRI4' squeezeOutNumber >>> 29\"\r\t\"'th is is2 9 a stRI4' squeezeOutNumber >>> 2\"\r\t\r\t^ Number squeezeNumberOutOfString: self"},{"name":"asZnCharacterEncoder","linesOfCode":4,"sourceCode":"asZnCharacterEncoder\r\t\"Return a ZnCharacterEncoder instance using the receiver as identifier\"\r\t\r\t\" 'UTF-8' asZnCharacterEncoder \"\r\t\r\t^ ZnCharacterEncoder newForEncoding: self"},{"name":"execute:against:","linesOfCode":2,"sourceCode":"execute: projectSpecBlock against: aScriptExecutor\r    aScriptExecutor executeString: self do: projectSpecBlock"},{"name":"metacelloSemanticStringLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloSemanticStringLessThanSelf: aString\r    ^ aString < self"},{"name":"setTimestampInMetacelloVersion:","linesOfCode":5,"sourceCode":"setTimestampInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setTimestamp: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"translateFrom:to:table:","linesOfCode":3,"sourceCode":"translateFrom: start  to: stop  table: table\r\t\"translate the characters in the string by the given table, in place\"\r\tself class translate: self from: start to: stop table: table"},{"name":"format:","linesOfCode":22,"sourceCode":"format: collection\r\t\"Format the receiver by interpolating elements from collection, as in the following examples:\" \r\t\"('Five is {1}.' format: { 1 + 4}) >>> 'Five is 5.'\"\r\t\"('Five is {five}.' format: (Dictionary with: #five -> 5)) >>>  'Five is 5.'\"\r\t\"('In {1} you can escape \\{ by prefixing it with \\\\' format: {'strings'}) >>> 'In strings you can escape { by prefixing it with \\' \"\r\t\"('In \\{1\\} you can escape \\{ by prefixing it with \\\\' format: {'strings'}) >>> 'In {1} you can escape { by prefixing it with \\' \"\r\r\t^ self species\r\t\tnew: self size\r\t\tstreamContents: [ :result | \r\t\t\t| stream |\r\t\t\tstream := self readStream.\r\t\t\t[ stream atEnd ]\r\t\t\t\twhileFalse: [ | currentChar |\r\t\t\t\t\t(currentChar := stream next) == ${\r\t\t\t\t\t\tifTrue: [ | expression index |\r\t\t\t\t\t\t\texpression := stream upTo: $}.\r\t\t\t\t\t\t\tindex := Integer readFrom: expression ifFail: [ expression ].\r\t\t\t\t\t\t\tresult nextPutAll: (collection at: index) asString ]\r\t\t\t\t\t\tifFalse: [ currentChar == $\\\r\t\t\t\t\t\t\t\tifTrue: [ stream atEnd\r\t\t\t\t\t\t\t\t\t\tifFalse: [ result nextPut: stream next ] ]\r\t\t\t\t\t\t\t\tifFalse: [ result nextPut: currentChar ] ] ] ]"},{"name":"asFileName","linesOfCode":7,"sourceCode":"asFileName\r\t\"Answer a String made up from the receiver that is an acceptable file \r\tname.\"\r\r\t| string checkedString |\r\tstring := FileSystem disk checkName: self fixErrors: true.\r\tcheckedString := FilePathEncoder encode: string.\r\t^ FilePathEncoder decode: checkedString"},{"name":"wbtSubstituteVariables:","linesOfCode":2,"sourceCode":"wbtSubstituteVariables: variables\r\t^ self wbtSubstituteVariablesWith: [ :varName | (variables at: varName ifAbsent: [ nil ]) asWBTVarSubstitution ]"},{"name":"flattenOn:","linesOfCode":2,"sourceCode":"flattenOn: aStream\r\t\taStream nextPut: self"},{"name":"asMetacelloVersionNumber","linesOfCode":2,"sourceCode":"asMetacelloVersionNumber\r\r\t^MetacelloVersionNumber fromString: self"},{"name":"asInteger","linesOfCode":8,"sourceCode":"asInteger \r\t\"Return the integer present in the receiver, or nil. In case of float, returns the integer part.\"\r\t\"'1' asInteger >>> 1\"\r\t\"'-1' asInteger >>> -1\"\r\t\"'10' asInteger >>> 10\"\r\t\"'a' asInteger >>> nil\"\r\t\"'1.234' asInteger >>> 1\"\r\t^self asSignedInteger\r"},{"name":"isOctetString","linesOfCode":8,"sourceCode":"isOctetString\r\t\"Answer whether the receiver can be represented as a byte string. \r\tThis is different from asking whether the receiver *is* a ByteString \r\t(i.e., #isByteString)\"\r\t1 to: self size do: [:pos |\r\t\t(self at: pos) asInteger >= 256 ifTrue: [^ false].\r\t].\r\t^ true.\r"},{"name":"=","linesOfCode":8,"sourceCode":"= aString \r\t\"Answer whether the receiver sorts equally as aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'abc' = 'def' >>> false\"\r\t\" 'abc' = 'abc' >>> true\"\r\t\" 'def' = 'abc' >>> false\"\r\t\r\t(aString isString and: [self size = aString size]) ifFalse: [^false].\r\t^ (self compare: self with: aString collated: AsciiOrder) = 2"},{"name":"displayProgressFrom:to:during:","linesOfCode":13,"sourceCode":"displayProgressFrom: minVal to: maxVal during: workBlock \r\t\"Display this string as a caption over a progress bar while workBlock is evaluated.\r\rEXAMPLE (Select next 6 lines and Do It)\r'Now here''s some real progress'\r\tdisplayProgressFrom: 0 to: 10\r\tduring: [:bar |\r\t1 to: 10 do: [:x | bar value: x.\r\t\t\t(Delay forMilliseconds: 500) wait]].\r\"\r\t^ UIManager default \r\t\tdisplayProgress: self \r\t\tfrom: minVal \r\t\tto: maxVal \r\t\tduring: workBlock"},{"name":"asClassVariable","linesOfCode":2,"sourceCode":"asClassVariable\r\t^ ClassVariable named: self"},{"name":"<","linesOfCode":7,"sourceCode":"< aString \r\t\"Answer whether the receiver sorts before aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'abc' < 'def' >>> true\"\r\t\" 'abc' < 'abc' >>> false\"\r\t\" 'def' < 'abc' >>> false\"\r\t\r\t\r\t^ (self compare: self with: aString collated: AsciiOrder) = 1"},{"name":"findString:","linesOfCode":5,"sourceCode":"findString: substring\r\t\"Answer the index of the first substring within the receiver. If the receiver does not contain substring, answer 0.\"\r\t\"('salkjsdlkgfee' findString: 'al') >>> 2\"\r\t\"('salkjsdlkgfeesd' findString: 'sd') >>> 6\"\r\t\r\t^self findString: substring startingAt: 1."},{"name":"initialIntegerOrNil","linesOfCode":16,"sourceCode":"initialIntegerOrNil\r\t\"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit\"\r\t\"'234Whoopie' initialIntegerOrNil >>> 234\"\r\t\"'wimpy' initialIntegerOrNil >>> nil\"\r\t\"'234' initialIntegerOrNil >>> 234\"\r\t\"'2N' initialIntegerOrNil >>> 2\"\r\t\"'2' initialIntegerOrNil >>> 2\"\r\t\"'  89Ten ' initialIntegerOrNil >>> nil\"\r\t\"'78 92' initialIntegerOrNil >>> 78\"\r\t\"'3.1415' initialIntegerOrNil >>> 3\"\r\t\r\t| firstNonDigit |\r\t(self size = 0 or: [ self first isDigit not ]) \r\t\tifTrue: [ ^ nil ].\r\tfirstNonDigit := (self findFirst: [ :m | m isDigit not ]).\r\tfirstNonDigit = 0 ifTrue: [ firstNonDigit := self size + 1 ].\r\t^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"},{"name":"padRightTo:with:","linesOfCode":2,"sourceCode":"padRightTo: length with: char\r\t^ self, (String new: (length - self size max: 0) withAll: char)"},{"name":"urlDecoded","linesOfCode":4,"sourceCode":"urlDecoded\r\t\"URL Decode the receiver and return the resulting String.\r\tThis is an encoding where characters that are illegal in a URL are escaped.\"\r\r    ^ ZnPercentEncoder new decode: self"},{"name":"allRegexMatches:","linesOfCode":2,"sourceCode":"allRegexMatches: rxString\r\r\t^rxString asRegex matchesIn: self"},{"name":"regex:matchesCollect:","linesOfCode":2,"sourceCode":"regex: rxString matchesCollect: aBlock\r\r\t^rxString asRegex matchesIn: self collect: aBlock"},{"name":"addToMetacelloRepositories:","linesOfCode":11,"sourceCode":"addToMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloRepositoriesSpec project repositorySpec)\r\t\t\tdescription: self;\r\t\t\tyourself.\r\taMetacelloRepositoriesSpec addMember: \r\t\t(aMetacelloRepositoriesSpec addMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"packageFileSpecFor:","linesOfCode":4,"sourceCode":"packageFileSpecFor: aMetacelloPackagesSpec\r\r\t^(aMetacelloPackagesSpec project packageSpec)\r\t\t\tfile: self;\r\t\t\tyourself"},{"name":"resolvePackageSpecsNamedForMetacelloMCVersion:visited:ifAbsent:","linesOfCode":4,"sourceCode":"resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock\r    ^ aMetacelloMCVersion\r        allPackagesForSpecs: {(aMetacelloMCVersion packageNamed: self ifAbsent: aBlock)}\r        visited: visited"},{"name":"asText","linesOfCode":3,"sourceCode":"asText\r\t\"Answer a Text whose string is the receiver.\"\r\r\t^Text fromString: self"},{"name":"caseSensitiveLessOrEqual:","linesOfCode":4,"sourceCode":"caseSensitiveLessOrEqual: aString \r\t\"Answer whether the receiver sorts before or equal to aString.\r\tThe collation order is case sensitive.\"\r\t^(self compare: aString caseSensitive: true) <= 2"},{"name":"trimLeft:","linesOfCode":3,"sourceCode":"trimLeft: aBlock\r\t\"Trim characters satisfying the condition given in aBlock from the left side of the receiving string.\"\r\t\r\t^ self trimLeft: aBlock right: [ :char | false ]"},{"name":"widthToDisplayInTree:","linesOfCode":2,"sourceCode":"widthToDisplayInTree: aTree\r\r\t^ aTree fontToUse widthOfStringOrText: self contents"},{"name":"addedToZnUrl:","linesOfCode":4,"sourceCode":"addedToZnUrl: url\r\t| segments |\r\tsegments := self findTokens: '/'.\r\t^ url withPathSegments: segments"},{"name":"convertToEncoding:","linesOfCode":2,"sourceCode":"convertToEncoding: encodingName\r\t^self convertToWithConverter: (TextConverter newForEncoding: encodingName)."},{"name":"setPostLoadDoItInMetacelloSpec:","linesOfCode":2,"sourceCode":"setPostLoadDoItInMetacelloSpec: aMetacelloSpec\r    self asSymbol setPostLoadDoItInMetacelloSpec: aMetacelloSpec"},{"name":"findLastOccurrenceOfString:startingAt:","linesOfCode":10,"sourceCode":"findLastOccurrenceOfString: substring startingAt: start \r\t\"Answer the index of the last occurrence of substring within the receiver, starting at start. If \r\tthe receiver does not contain substring, answer 0.  Case-sensitive match used.\"\r\r\t| last now |\r\tlast := self findString: substring startingAt: start.\r\tlast = 0 ifTrue: [^ 0].\r\t[last > 0] whileTrue:\r\t\t[now := last.\r\t\tlast := self findString: substring startingAt: last + 1].\r\r\t^ now\r"},{"name":"correctAgainst:","linesOfCode":6,"sourceCode":"correctAgainst: wordList\r\t\"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:\"\r\t| results |\r\tresults := self correctAgainst: wordList continuedFrom: nil.\r\tresults := self correctAgainst: nil continuedFrom: results.\r\t^ results"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"withoutTrailingDigits","linesOfCode":4,"sourceCode":"withoutTrailingDigits\r\t\"Answer the portion of the receiver that precedes any leading series of digits and separators.\r\tIf the receiver consists entirely of digits and separators, return an empty string\"\r\r\t^ self trimRight: [ :char | char isDigit or: [ char isSeparator ] ]"},{"name":"trimBoth:","linesOfCode":3,"sourceCode":"trimBoth: aBlock\r\t\"Trim characters satisfying the condition given in aBlock from both sides of the receiving string.\"\r\r\t^ self trimLeft: aBlock right: aBlock"},{"name":"metacelloSemanticIntegerLessThanSelf:","linesOfCode":3,"sourceCode":"metacelloSemanticIntegerLessThanSelf: anInteger\r    \"integer version components are always '>' string component\"\r\r    ^ true"},{"name":"metacelloVersionComponentLessThan:","linesOfCode":2,"sourceCode":"metacelloVersionComponentLessThan: aMetacelloVersonComponent\r\r\t^aMetacelloVersonComponent metacelloStringLessThanSelf: self"},{"name":"asClassIfAbsent:","linesOfCode":3,"sourceCode":"asClassIfAbsent: absentBlock\r\t\"returns a global class with my name\"\r\t^ self asClassInEnvironment: Smalltalk globals ifAbsent: absentBlock"},{"name":"withoutTrailingNewlines","linesOfCode":3,"sourceCode":"withoutTrailingNewlines\r\t\"Return a copy of the receiver with any combination of cr/lf characters at the end removed\"\r\r\t^ self trimRight: [ :char | char = Character cr or: [ char = Character lf ] ]"},{"name":"typeTable","linesOfCode":2,"sourceCode":"typeTable\r\t^ self class typeTable"},{"name":"includesSubstring:","linesOfCode":4,"sourceCode":"includesSubstring: substring\r\t\"Returns whether the receiver contains the argument.\"\r\t\"('abcdefgh' includesSubstring: 'de') >>> true\"\r\t\r\t^ substring isEmpty or: [ (self findString: substring startingAt: 1) > 0 ]"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString \r\r\t^ WideString from: self"},{"name":"trimLineSpaces","linesOfCode":7,"sourceCode":"trimLineSpaces\r\t\"Trim the spaces from the right side of each line. Useful for code\"\r\t\r\t^ self species streamContents: [ :str |\r\t\tself lines \r\t\t\tdo: [ :line | str nextPutAll: line trimRight]\r\t\t\tseparatedBy: [str cr]]\r\t\t\r"},{"name":"isValidSelector","linesOfCode":4,"sourceCode":"isValidSelector\r\t\"check I could be a valid selector (name of method). \r\t For checking if there is symbol like me used as a selector, see #isSelectorSymbol on Symbol\"\r\t^ RBScanner isSelector: self"},{"name":"slvmUTF32Encoded","linesOfCode":2,"sourceCode":"slvmUTF32Encoded\r\t^ self asWideString asArray collect: [ :each | each asInteger ]"},{"name":"displayAt:","linesOfCode":3,"sourceCode":"displayAt: aPoint \r\t\"Display the receiver as a DisplayText at aPoint on the display screen.\"\r\r\tself displayOn: Display at: aPoint"},{"name":"indexOfFirstUppercaseCharacter","linesOfCode":11,"sourceCode":"indexOfFirstUppercaseCharacter\r\t\"Returns the index of the first Uppercase character.\r\t'uouFauhZ ' indexOfFirstUppercaseCharacter2 -> 4\r\tNew implementation much faster than older one.\r\t\"\r\t| size |\r\tsize := self size.\r\t1 to: size do: [:i| \r\t\t(self at: i) isUppercase \r\t\t\tifTrue: [^ i ]].\r\t^ 0"},{"name":"expandMacrosWith:","linesOfCode":4,"sourceCode":"expandMacrosWith: anObject \r\t\"('Pharo is <1s>' expandMacrosWith: 'cool') >>> 'Pharo is cool'\"\r\t\"('Pharo is <1p>' expandMacrosWith: 'cool') >>> 'Pharo is ''cool'''\"\r\r\t^self expandMacrosWithArguments: (Array with: anObject)"},{"name":"asValidSelector","linesOfCode":25,"sourceCode":"asValidSelector\r\t\"Returns a symbol that is a valid selector by removing any space or forbidden characters\"\r\t\"'234znak ::x43 '') _ : 2' asValidSelector >>> #'v234znak:x43:v2'\"\r\t\"'234znak ::x43 ) :2' asValidSelector >>> #v234znak:x43:v2\"\r\t\r^(((\r\t$: join: (\t\r\t\t(\r\t\t\t$: split: (\r\t\t\t\tself select: [ :char |\r\t\t\t\t\t(char charCode < 128) and: [ \r\t\t\t\t\t\tchar isAlphaNumeric or: [ \r\t\t\t\t\t\t\tchar = $:\t\r\t\t\t\t\t\t]\t\r\t\t\t\t\t]\t\r\t\t\t\t]\r\t\t\t)\r\t\t)  \r\t\tselect: [ :split | split isNotEmpty ]\r\t\tthenCollect: [ :nonEmptyString |\r\t\t\tnonEmptyString first isLetter\r\t\t\t\tifTrue: [ nonEmptyString uncapitalized ]\r\t\t\t\tifFalse: [ 'v' , nonEmptyString ]\r\t\t]\r\t)\r) ifEmpty: [ 'v' ]), ((self isNotEmpty and: [ self last = $: ]) ifTrue: [ ':' ] ifFalse: [ #() ]) )asSymbol\r"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ self"},{"name":"asSpirVStringLiteral","linesOfCode":13,"sourceCode":"asSpirVStringLiteral\r\t| utf8 wordCount wordArray shift word wordIndex |\r\tutf8 := self asUTF8Bytes.\r\twordCount := utf8 size + 1 + 3 // 4.\r\twordArray := (1 to: wordCount) collect: [:i | 0 ].\r\t1 to: utf8 size do: [ :i |\r\t\tshift := (i - 1 \\\\ 4) * 8.\r\t\twordIndex := (i -1) // 4 + 1.\r\t\tword := wordArray at: wordIndex.\r\t\tword := word bitOr: ((utf8 at: i) bitShift: shift).\r\t\twordArray at: wordIndex put: word.\r\t].\r\t^ wordArray"},{"name":"setAuthorInMetacelloVersion:","linesOfCode":5,"sourceCode":"setAuthorInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setAuthor: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"llvmPrintEscapedStringOn:","linesOfCode":2,"sourceCode":"llvmPrintEscapedStringOn: aStream\r\t^ self llvmPrintEscapedStringOn: aStream addNull: false"},{"name":"expandMacrosWithArguments:","linesOfCode":69,"sourceCode":"expandMacrosWithArguments: anArray\r\t\"Interpret the receiver pattern (<1p>, <1s>, <t>...) with argument passed in anArray.\"\r\t\r\t\"<Np> writes the N-th argument using #printString, but without trancating it.\"\r\t\"('<1p>: <2p>' expandMacrosWith: 'Number' with: 5 with: nil) >>> '''Number'': 5'\"\r\t\r\t\"<Ns> writes the N-th argument, which should be a String, or a collection of printable objects.\r\tNote also important distinction for single-quotes inside the argument; with <p> they will be doubled.\"\r\t\"('<1s> vs <1p>' expandMacrosWith: 'it''em') >>> 'it''em vs ''it''''em'''\"\r\t\r\t\"Whitespace characters:\"\r\t\"'<t>' expandMacros >>> String tab\"\r\t\"'<r>' expandMacros >>> String cr\"\r\t\"'<n>' expandMacros >>> OSPlatform current lineEnding\"\r\t\"'<l>' expandMacros >>> String lf\"\r\t\r\t\"Writing '<' character:\r\tTo write '<', prepend it with a percent sign.\"\r\t\"'%<n>' expandMacros >>> '<n>'\"\r\t\r\t\"Ternary operator:\r\tAn if-else string can be written with <N?yes-string:no-string>.\r\tThe N-th argument must be a Boolean.\r\tYes-string cannot contain colon ':', as it terminates the yes-string.\r\tNo-string cannot contain closing angle bracket '>', as it terminates the no-string.\"\r\t\"('<1?success:error>' expandMacrosWith: true) >>> 'success'\"\r\t\"('<1?success:is error>' expandMacrosWith: false) >>> 'is error'\"\r\t\r\t| readStream char index |\r\t^ self species\r\t\tnew: self size\r\t\tstreamContents:\r\t\t\t[ :newStream | \r\t\t\treadStream := self readStream.\r\t\t\t[ readStream atEnd ]\r\t\t\t\twhileFalse:\r\t\t\t\t\t[ char := readStream next.\r\t\t\t\t\tchar == $<\r\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t[ | nextChar |\r\t\t\t\t\t\t\tnextChar := readStream next asUppercase.\r\t\t\t\t\t\t\tnextChar == $R\r\t\t\t\t\t\t\t\tifTrue: [ newStream cr ].\r\t\t\t\t\t\t\tnextChar == $L\r\t\t\t\t\t\t\t\tifTrue: [ newStream lf ].\r\t\t\t\t\t\t\tnextChar == $T\r\t\t\t\t\t\t\t\tifTrue: [ newStream tab ].\r\t\t\t\t\t\t\tnextChar == $N\r\t\t\t\t\t\t\t\tifTrue: [ newStream nextPutAll: OSPlatform current lineEnding ].\r\t\t\t\t\t\t\tnextChar isDigit\r\t\t\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t\t\t[ index := nextChar digitValue.\r\t\t\t\t\t\t\t\t\t[ readStream atEnd or: [ (nextChar := readStream next asUppercase) isDigit not ] ]\r\t\t\t\t\t\t\t\t\t\twhileFalse: [ index := index * 10 + nextChar digitValue ] ].\r\t\t\t\t\t\t\tnextChar == $?\r\t\t\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t\t\t[ | trueString falseString |\r\t\t\t\t\t\t\t\t\ttrueString := readStream upTo: $:.\r\t\t\t\t\t\t\t\t\tfalseString := readStream upTo: $>.\r\t\t\t\t\t\t\t\t\treadStream position: readStream position - 1.\r\t\t\t\t\t\t\t\t\tnewStream\r\t\t\t\t\t\t\t\t\t\tnextPutAll:\r\t\t\t\t\t\t\t\t\t\t\t((anArray at: index)\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ trueString ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ falseString ]) ].\r\t\t\t\t\t\t\tnextChar == $P\r\t\t\t\t\t\t\t\tifTrue: [ (anArray at: index) printOn: newStream  ].\r\t\t\t\t\t\t\tnextChar == $S\r\t\t\t\t\t\t\t\tifTrue: [ newStream nextPutAll: (anArray at: index) ].\r\t\t\t\t\t\t\treadStream skipTo: $> ]\r\t\t\t\t\t\tifFalse: [ newStream\r\t\t\t\t\t\t\t\tnextPut:\r\t\t\t\t\t\t\t\t\t(char == $%\r\t\t\t\t\t\t\t\t\t\tifTrue: [ readStream next ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ char ]) ] ] ]"},{"name":"expandMacrosWith:with:with:with:","linesOfCode":6,"sourceCode":"expandMacrosWith: anObject with: anotherObject with: thirdObject with: fourthObject \r\t^self expandMacrosWithArguments: (Array \r\t\t\t\twith: anObject\r\t\t\t\twith: anotherObject\r\t\t\t\twith: thirdObject\r\t\t\t\twith: fourthObject)"},{"name":"trim","linesOfCode":4,"sourceCode":"trim\r\t\"Trim separators from both sides of the receiving string.\"\r\t\"' this string will be trimmed   ' trim >>> 'this string will be trimmed'\"\r\t\r\t^ self trimBoth"},{"name":"withLineEndings:","linesOfCode":25,"sourceCode":"withLineEndings: lineEndingString\r\t\"Answer a new instance where all occurrences of CRLF, CR, and LF are substituted with the specified line ending string.\"\r\t\r\t^ self species streamContents: [ :out |\r\t\t| in c |\r\t\tin := self readStream.\r\t\t[ in atEnd ] whileFalse: [\r\t\t\tc := in next.\r\t\t\t\"CR\"\r\t\t\tc == Character cr ifTrue: [\r\t\t\t\tc := in peek.\r\t\t\t\t\"CR LF\"\r\t\t\t\tc == Character lf ifTrue: [\r\t\t\t\t\tin next.\r\t\t\t\t].\r\t\t\t\tout nextPutAll: lineEndingString\r\t\t\t] ifFalse: [\r\t\t\t\t\"LF\"\r\t\t\t\tc == Character lf ifTrue: [\r\t\t\t\t\tout nextPutAll: lineEndingString\r\t\t\t\t] ifFalse: [\r\t\t\t\t\tout nextPut: c\r\t\t\t\t]\r\t\t\t]\r\t\t]\r\t]\r"},{"name":"asCamelCase","linesOfCode":7,"sourceCode":"asCamelCase\r\t\"Convert to CamelCase, i.e, remove spaces, and convert starting lowercase to uppercase.\"\r   \"'A man, a plan, a canal, panama' asCamelCase >>> 'AMan,APlan,ACanal,Panama'\"\r \t\"'Here 123should % be 6 the name6 of the method' asCamelCase  >>> 'Here123should%Be6TheName6OfTheMethod'\"\r\t\t^ self species streamContents: [:stream |\r               self substrings do: [:sub |\r                       stream nextPutAll: sub capitalized]]"},{"name":"asUppercase","linesOfCode":3,"sourceCode":"asUppercase\r\t\"Answer a String made up from the receiver whose characters are all uppercase.\"\r\r\t^self copy asString translateToUppercase"},{"name":"beginsWithEmpty:caseSensitive:","linesOfCode":14,"sourceCode":"beginsWithEmpty: prefix caseSensitive: aBoolean \r\t\"Answer whether the receiver begins with the given prefix string. \r\tThe comparison is case-sensitive.\" \r\t| matchTable |\r\tprefix isEmpty ifTrue: [ ^ true ].\r\tself size < prefix size ifTrue: [ ^ false ].\r\tmatchTable := aBoolean \r\t\tifTrue: [ CaseSensitiveOrder ]\r\t\tifFalse: [ CaseInsensitiveOrder ].\r\t^ (self \r\t\tfindSubstring: prefix\r\t\tin: self\r\t\tstartingAt: 1\r\t\tmatchTable: matchTable) = 1"},{"name":"findString:startingAt:caseSensitive:","linesOfCode":36,"sourceCode":"findString: key startingAt: start caseSensitive: caseSensitive \r\t\"Answer the index in this String at which the substring key first occurs,\r\tat or beyond start. The match can be case-sensitive or not. If no match\r\tis found, zero will be returned.\"\r\t\r\t\"IMPLEMENTATION NOTE: do not use CaseSensitiveOrder because it is broken for WideString\r\tThis is a temporary work around until Wide CaseSensitiveOrder search is fixed\r\tCode should revert to:\r\tcaseSensitive\r\t\tifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]\r\t\tifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]\"\r\t\t\r\t^caseSensitive\r\t\tifTrue: [\r\t\t\t(self class isBytes and: [key class isBytes])\r\t\t\t\tifTrue: [self\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: CaseSensitiveOrder]\r\t\t\t\tifFalse: [WideString new\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: nil]]\r\t\tifFalse: [\r\t\t\t(self class isBytes and: [key class isBytes])\r\t\t\t\tifTrue: [self\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: CaseInsensitiveOrder]\r\t\t\t\tifFalse: [WideString new\r\t\t\t\t\t\tfindSubstring: key\r\t\t\t\t\t\tin: self\r\t\t\t\t\t\tstartingAt: start\r\t\t\t\t\t\tmatchTable: CaseInsensitiveOrder]]"},{"name":"repeat:","linesOfCode":8,"sourceCode":"repeat: aNumber\r\t\"Returns a new string concatenated by itself repeated n times\"\r\t\"('abc' repeat: 3) >>> 'abcabcabc'\"\r\r\taNumber < 0 ifTrue: [ self error: 'aNumber cannot be negative' ].\t\r\t^ self species \r\t\tnew: self size * aNumber \r\t\tstreamContents: [ :stringStream |\r\t\t\t1 to: aNumber do: [ :idx | stringStream nextPutAll: self ] ]"},{"name":"asNumber","linesOfCode":4,"sourceCode":"asNumber \r\t\"Answer the Number created by interpreting the receiver as the string \r\trepresentation of a number.\"\r\r\t^Number readFromString: self"},{"name":"asClass","linesOfCode":3,"sourceCode":"asClass\r\t\"returns a global class with my name\"\r\t^ self asClassInEnvironment: Smalltalk globals"},{"name":"matchesRegex:","linesOfCode":6,"sourceCode":"matchesRegex: regexString\r\t\"Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or\r\tchild signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegex matches: self"},{"name":"recordRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"recordRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doRecordRequiredFromArray: (Array with: self)."},{"name":"asLGitExternalString","linesOfCode":8,"sourceCode":"asLGitExternalString\r\t| data |\r\tdata := ExternalData\r\t\tfromHandle: (ExternalAddress allocate: self size + 1)\r\t\ttype: ExternalType char asPointerType.\r\tLibC memCopy: self to: data size: self size.\r\tdata getHandle byteAt: self size + 1 put: 0.\r\t^ data"},{"name":"skipDelimiters:startingAt:","linesOfCode":6,"sourceCode":"skipDelimiters: delimiters startingAt: start \r\t\"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string.\"\r\r\tstart to: self size do: [:i |\r\t\tdelimiters detect: [:delim | delim = (self at: i)]\r\t\t\t\tifNone: [^ i]].\r\t^ self size + 1"},{"name":"asPath","linesOfCode":8,"sourceCode":"asPath\r\t\"convert myself to a path\"\r\t\"Examples:\r\t\t'.' asPath\r\t\t'~/Desktop' asPath\r\t\t'/home/foo' asPath\r\t\t'../../foo.bar' asPath\"\r\t^ FileSystem disk resolve: self"},{"name":"setAuthorInMetacelloConfig:","linesOfCode":2,"sourceCode":"setAuthorInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setAuthorWithString: self"},{"name":"asDuration","linesOfCode":3,"sourceCode":"asDuration\r \t\"Convert from [-]D:HH:MM:SS[.S] format. What is between [] implies optional elements\"\r \r \t^ Duration fromString: self\r "},{"name":"lineNumber:","linesOfCode":7,"sourceCode":"lineNumber: anIndex\r\t\"Answer a string containing the characters in the given line number.\"\r\r\t| lineCount |\r\tlineCount := 0.\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\t(lineCount := lineCount + 1) = anIndex ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].\r\t^nil"},{"name":"howManyMatch:","linesOfCode":13,"sourceCode":"howManyMatch: string \r\t\"Count the number of characters in a substring that matches up in self and aString.\"\r\t\"('ab ab ac de' howManyMatch: 'ab') >>> 2\"\r\t\"('abab ac de' howManyMatch: 'abab') >>> 4\"\r\t\"('ab ab ac de' howManyMatch: 'a') >>> 1\"\r\t\"('ab ab ac de' howManyMatch: 'z') >>> 0\"\r\t\r\t| count shorterLength |\r\tcount := 0.\r\tshorterLength := self size min: string size.\r\t1 to: shorterLength do: [:index |\r\t\t(self at: index) = (string at: index )\r\t\t\tifTrue: [ count := count + 1 ]].\r\t^  count \r\t\r\t"},{"name":"loadRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"loadRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doLoadRequiredFromArray: (Array with: self)."},{"name":"asUrl","linesOfCode":2,"sourceCode":"asUrl\r\t^ self asZnUrl "},{"name":"asVmPathName","linesOfCode":6,"sourceCode":"asVmPathName\r\t\"This method returns self encoded in the encoding the system expects.\r\tWe default to utf8 as this is the most common encoding, but we should ask the system the current encoding instead.\r\t\r\tAlso, note the method name is wrong, this should be fixed\"\r\tself flag: #TODO.\r\t^ self utf8Encoded"},{"name":"substrings:","linesOfCode":18,"sourceCode":"substrings: separators\r\t\"Answer an array of non-empty substrings from the receiver separated by\r\tone or more characters from the 'separators' argument collection.\"\r\r\t| substrings substringStart |\r\tsubstrings := (Array new: 10) writeStream.\r\t1 to: self size do: [ :i | \r\t\t| nextChar |\r\t\tnextChar := self at: i.\r\t\t(separators includes: nextChar)\r\t\t\tifTrue: [\r\t\t\t\tsubstringStart\r\t\t\t\t\tifNotNil: [\r\t\t\t\t\t\tsubstrings nextPut: (self copyFrom: substringStart to: i - 1).\r\t\t\t\t\t\tsubstringStart := nil ] ]\r\t\t\tifFalse: [ substringStart ifNil: [ substringStart := i ] ] ].\r\tsubstringStart\r\t\tifNotNil: [ substrings nextPut: (self copyFrom: substringStart to: self size) ].\r\t^ substrings contents"},{"name":"mergeIntoMetacelloPackages:","linesOfCode":11,"sourceCode":"mergeIntoMetacelloPackages: aMetacelloPackagesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloPackagesSpec project packageSpec)\r\t\t\tfile: self;\r\t\t\tyourself.\r\taMetacelloPackagesSpec addMember: \r\t\t(aMetacelloPackagesSpec mergeMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"asSlot","linesOfCode":2,"sourceCode":"asSlot\r\t^ InstanceVariableSlot named: self"},{"name":"stringhash","linesOfCode":2,"sourceCode":"stringhash\r\r\t^ self hash.\r"},{"name":"setRequiresInMetacelloPackage:","linesOfCode":2,"sourceCode":"setRequiresInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setRequires: { self }."},{"name":"metacelloSemanticVersionComponentLessThan:","linesOfCode":2,"sourceCode":"metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent\r    ^ aMetacelloVersonComponent metacelloSemanticStringLessThanSelf: self"},{"name":"inspectionString","linesOfCode":5,"sourceCode":"inspectionString\r\t<inspectorPresentationOrder: -10 title: 'String'>\r\t\r\t^ SpTextPresenter new\r\t\ttext: (self truncateWithElipsisTo: 100000);\r\t\tyourself"},{"name":"convertFromWithConverter:","linesOfCode":10,"sourceCode":"convertFromWithConverter: converter\r\r\t| readStream c |\r\treadStream := self readStream.\r\t^ self species new: self size streamContents: [ :writeStream|\r\t\tconverter ifNil: [^ self].\r\t\t[readStream atEnd] whileFalse: [\r\t\t\tc := converter nextFromStream: readStream.\r\t\t\tc\r\t\t\t\tifNotNil: [writeStream nextPut: c] \r\t\t\t\tifNil: [^ writeStream contents]]].\r"},{"name":"findSubstringViaPrimitive:in:startingAt:matchTable:","linesOfCode":23,"sourceCode":"findSubstringViaPrimitive: key in: body startingAt: start matchTable: matchTable\r\t\"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.\r\r\tThe algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter.\"\r\t| index |\r\t<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>\r\t<var: #key declareC: 'unsigned char *key'>\r\t<var: #body declareC: 'unsigned char *body'>\r\t<var: #matchTable declareC: 'unsigned char *matchTable'>\r\r\tkey size = 0 ifTrue: [^ 0].\r\t(start max: 1) to: body size - key size + 1 do:\r\t\t[:startIndex |\r\t\tindex := 1.\r\t\t\t[(matchTable at: (body basicAt: startIndex+index-1) + 1)\r\t\t\t\t= (matchTable at: (key basicAt: index) + 1)]\r\t\t\t\twhileTrue:\r\t\t\t\t[index = key size ifTrue: [^ startIndex].\r\t\t\t\tindex := index+1]].\r\t^ 0\r\"\r' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1\r' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7\r' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0\r' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0\r' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7\r\""},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"slvmUTF8EncodedSize","linesOfCode":2,"sourceCode":"slvmUTF8EncodedSize\r\t^ self utf8Encoded size"},{"name":"asCStringForGDB","linesOfCode":4,"sourceCode":"asCStringForGDB\r\t^ ByteString streamContents: [ :out |\r\t\tself asCStringForGDBInto: out\r\t]"},{"name":"llvmPrintEscapedStringOn:addNull:","linesOfCode":11,"sourceCode":"llvmPrintEscapedStringOn: aStream addNull: addNull\r\taStream nextPut: $\".\r\tself do: [ :element |\r\t\t(Character space <= element and: [ element <= $~ and: [('\\\"' includes: element) not]]) ifTrue: [ \r\t\t\taStream nextPut: element\r\t\t] ifFalse: [\r\t\t\taStream nextPut: $\\; nextPutAll: (element asInteger printStringBase: 16 length: 2 padded: true)\r\t\t]\r\t].\r\t\r\taddNull ifTrue: [ aStream nextPutAll: '\\00' ].\r\taStream nextPut: $\".\r"},{"name":"asStringMorph","linesOfCode":4,"sourceCode":"asStringMorph \r\t\"Answer the receiver as a StringMorph\"\r\r\t^ StringMorph contents: self\r\r\"'bugs black blood' asStringMorph openInHand\""},{"name":"llvmPrintNameOn:","linesOfCode":6,"sourceCode":"llvmPrintNameOn: aStream\r\tself isValidLLVMSymbol ifTrue: [\r\t\taStream nextPutAll: self\r\t] ifFalse: [\r\t\tself llvmPrintEscapedStringOn: aStream\r\t]"},{"name":"asPhanideRegex","linesOfCode":2,"sourceCode":"asPhanideRegex\r\t^ (PhanideRegexParser parse: self) simplified"},{"name":"asHex","linesOfCode":5,"sourceCode":"asHex\r\t\"'A' asHex >>> '16r41'\"\r\t\"'AA' asHex >>> '16r4116r41'\"\r\t^ self species new: self size * 4 streamContents: [ :stream |\r\t\tself do: [ :ch | stream nextPutAll: ch hex ]]"},{"name":"leadingCharRunLengthAt:","linesOfCode":7,"sourceCode":"leadingCharRunLengthAt: index\r\r\t| leadingChar |\r\tleadingChar := (self at: index) leadingChar.\r\tindex to: self size do: [:i |\r\t\t(self at: i) leadingChar ~= leadingChar ifTrue: [^ i - index].\r\t].\r\t^ self size - index + 1.\r"},{"name":"startingAt:match:startingAt:","linesOfCode":43,"sourceCode":"startingAt: keyStart match: text startingAt: textStart\r\t\"Answer whether text matches the pattern in this string.\r\tMatching ignores upper/lower case differences.\r\tWhere this string contains #, text may contain any character.\r\tWhere this string contains *, text may contain any sequence of characters.\"\r\t\r\t| anyMatch matchStart matchEnd i matchStr j ii jj |\r\ti := keyStart.\r\tj := textStart.\r\t\r\t\"Process consecutive *s and #s at the beginning.\"\r\tanyMatch := false.\r\t[ i <= self size and: [\r\t\t(self at: i)\r\t\t\tcaseOf: {\r\t\t\t\t[ $* ] -> [ \r\t\t\t\t\tanyMatch := true.\r\t\t\t\t\ti := i + 1.\r\t\t\t\t\ttrue ].\r\t\t\t\t[ $# ] -> [\r\t\t\t\t\ti := i + 1.\r\t\t\t\t\tj := j + 1.\r\t\t\t\t\ttrue ] }\r\t\t\totherwise: [ false ] ] ] whileTrue.\r\ti > self size ifTrue: [\r\t\t^j - 1 = text size or: [ \"We reached the end by matching the character with a #.\"\r\t\t\tanyMatch and: [ j <= text size ] \"Or there was a * before the end.\" ] ].\r\tmatchStart := i.\r\r\t\"Now determine the match string\"\r\tmatchEnd := self size.\r\t(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue: [ matchEnd := ii-1 ].\r\t(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue: [ matchEnd := matchEnd min: ii-1 ].\r\tmatchStr := self copyFrom: matchStart to: matchEnd.\r\r\t\"Now look for the match string\"\r\t[jj := text findString: matchStr startingAt: j caseSensitive: false.\r\tanyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]\r\t\twhileTrue:\r\t\t[\"Found matchStr at jj.  See if the rest matches...\"\r\t\t(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:\r\t\t\t[^ true \"the rest matches -- success\"].\r\t\t\"The rest did not match.\"\r\t\tanyMatch ifFalse: [^ false].\r\t\t\"Preceded by * -- try for a later match\"\r\t\tj := j+1].\r\t^ false \"Failed to find the match string\""},{"name":"asString","linesOfCode":3,"sourceCode":"asString\r\t\"Answer this string.\"\r\r\t^ self\r"},{"name":"mbndLiteralTypeWithTarget:","linesOfCode":2,"sourceCode":"mbndLiteralTypeWithTarget: compilationTarget\r\t^ compilationTarget literalStringType"},{"name":"trimRight","linesOfCode":3,"sourceCode":"trimRight\r\t\"Trim separators from the right side of the receiving string.\"\r\t\r\t^ self trimRight: [ :char | char isSeparator ]"},{"name":"setBlessingInMetacelloVersion:","linesOfCode":5,"sourceCode":"setBlessingInMetacelloVersion: aMetacelloVersionSpec\r\r\taMetacelloVersionSpec setBlessing: \r\t\t(aMetacelloVersionSpec project valueHolderSpec\r\t\t\tvalue: self;\r\t\t\tyourself)"},{"name":"treeRenderSceneNodeWith:bounds:color:font:from:","linesOfCode":6,"sourceCode":"treeRenderSceneNodeWith: builder bounds: drawBounds color: drawColor font: aFont from: aMorph\r\r\t^ builder\r\t\tstring: self\r\t\tin: drawBounds \r\t\tfont: aMorph font\r\t\tcolor: drawColor"},{"name":"setTimestampInMetacelloConfig:","linesOfCode":2,"sourceCode":"setTimestampInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setTimestampWithString: self"},{"name":"writeLeadingCharRunsOn:","linesOfCode":7,"sourceCode":"writeLeadingCharRunsOn: stream\r\r\tself isEmpty ifTrue: [^ self].\r\r\tstream nextPut: $(.\r\tstream print: self size.\r\tstream skip: -1; nextPut: $).\r\tstream print: 0 \"was leading char\".\r\tstream skip: -1"},{"name":"numericSuffix","linesOfCode":4,"sourceCode":"numericSuffix\r\t\"'abc98' numericSuffix >>> 98\"\r\t\"'98abc' numericSuffix >>> 0\"\r\t^ self stemAndNumericSuffix last"},{"name":"wbtSubstituteVariablesWith:","linesOfCode":16,"sourceCode":"wbtSubstituteVariablesWith: aSubstitutionBlock\r\t| regex shouldContinue result |\r\tregex := '\\$\\(\\w*\\)' asRegex.\r\tshouldContinue := true.\r\tresult := self.\r\t[ shouldContinue ] whileTrue: [\r\t\tshouldContinue := false.\r\t\tresult := regex copy: result translatingMatchesUsing: [:varExpression |\r\t\t\t| rawVariableExpressionContent variableExpressionContentValue|\r\t\t\tshouldContinue := true.\r\t\t\trawVariableExpressionContent := (varExpression copyFrom: 3 to: varExpression size - 1).\r\t\t\tvariableExpressionContentValue := rawVariableExpressionContent wbtSubstituteVariablesWith: aSubstitutionBlock.\r\t\t\taSubstitutionBlock value: variableExpressionContentValue.\r\t\t]\r\t].\r\r\t^ result  "},{"name":"withAccentuatedCharacter:","linesOfCode":10,"sourceCode":"withAccentuatedCharacter: aKey\r\r\t| text index | \r\ttext := self asText.\r\taKey ifNil: [ ^ text ].\r\tindex := self asLowercase indexOf: aKey name asLowercase.\r\tindex isZero\r\t\tifTrue: [ ^ text ].\r\r\t^ text\r\t\taddAttribute: TextEmphasis underlined from: index to: index;\r\t\tyourself"},{"name":"asUncommentedCode","linesOfCode":19,"sourceCode":"asUncommentedCode\r\t\"this string reprensent a commented code, let's uncomment it\"\r\t\r\t^String streamContents:  [ :str |\r\t\t\r\t\t|doubleQuoteAlreadyFound|\r\t\tdoubleQuoteAlreadyFound := false.\r\t\t\r\t\tself withoutQuoting do: [ :char |\r\t\t\tchar = $\"\r\t\t\t\tifTrue: [ \r\t\t\t\t\tdoubleQuoteAlreadyFound \tifTrue: [ \r\t\t\t\t\t\t\tstr nextPut: $\" ].\r\t\t\t\t\tdoubleQuoteAlreadyFound := doubleQuoteAlreadyFound not.\r\t\t\t\t]\r\t\t\t\tifFalse: [ \r\t\t\t\t\tstr nextPut: char\r\t\t\t\t]\r\t\t ]\r\t]\r\r"},{"name":"metacelloIntegerLessThanSelf:","linesOfCode":3,"sourceCode":"metacelloIntegerLessThanSelf: anInteger\r\t\"integer version components are always '>' string component\"\r\r\t^false"},{"name":"asUTF8Bytes","linesOfCode":2,"sourceCode":"asUTF8Bytes\r\t^ ZnUTF8Encoder new encodeString: self"},{"name":"trimLeft:right:","linesOfCode":12,"sourceCode":"trimLeft: aLeftBlock right: aRightBlock\r\t\"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string.\"\r\r\t| left right |\r\tleft := 1.\r\tright := self size.\r\t\r\t[ left <= right and: [ aLeftBlock value: (self at: left) ] ]\r\t\twhileTrue: [ left := left + 1 ].\r\t\t\r\t[ left <= right and: [ aRightBlock value: (self at: right) ] ]\r\t\twhileTrue: [ right := right - 1 ].\r\t\t\r\t^ self copyFrom: left to: right"},{"name":"listRenderOn:atRow:bounds:color:backgroundColor:from:","linesOfCode":6,"sourceCode":"listRenderOn: aCanvas atRow: aRow bounds: bounds color: color backgroundColor: backgroundColor from: aMorph\r\r\taCanvas\r\t\tdrawString: self\r\t\tin: bounds\r\t\tfont: aMorph font\r\t\tcolor: color"},{"name":"romanNumber","linesOfCode":13,"sourceCode":"romanNumber\r\t| value v1 v2 |\r\tvalue := v1 := v2 := 0.\r\tself\r\t\treverseDo: [ :each | \r\t\t\teach = $-\r\t\t\t\tifTrue: [ ^ value negated ].\r\t\t\tv1 := #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).\r\t\t\tvalue := v1 >= v2\r\t\t\t\tifTrue: [ value + v1 ]\r\t\t\t\tifFalse: [ value - v1 ].\r\t\t\tv2 := v1 ].\r\t^ value"},{"name":"treeRenderOn:bounds:color:font:from:","linesOfCode":6,"sourceCode":"treeRenderOn: aCanvas bounds: drawBounds color: drawColor font: aFont from: aMorph\r\r\taCanvas\r\t\tdrawString: self\r\t\tin: drawBounds \r\t\tfont: aMorph font\r\t\tcolor: drawColor"},{"name":"asParser","linesOfCode":3,"sourceCode":"asParser\r\t\"Answer a parser that accepts the receiving string.\"\r\r\t^ PPLiteralSequenceParser on: self"},{"name":"asLowercase","linesOfCode":6,"sourceCode":"asLowercase\r\t\"Answer a String made up from the receiver whose characters are all lowercase.\"\r\t\"'PhaRo' asLowercase >>> 'pharo'\"\r\t\"'' asLowercase >>> ''\"\r\t\"' ' asLowercase >>> ' '\"\t\r\t^ self copy asString translateToLowercase"},{"name":"fetchRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doFetchRequiredFromArray: (Array with: self)."},{"name":"urlEncoded","linesOfCode":4,"sourceCode":"urlEncoded\r\t\"URL Encode the receiver and return the resulting String.\r\tThis is an encoding where characters that are illegal in a URL are escaped.\"\r\r    ^ ZnPercentEncoder new encode: self\r"},{"name":"base64Decoded","linesOfCode":7,"sourceCode":"base64Decoded\r\t\"Decode the receiver assuming it was encoded using Base64, returning a ByteArray.\r\tBase64 encoding is a technique to represent binary data as ASCII text.\r\tThe inverse operation is ByteArray>>#base64Encoded\"\r\t\r\t\"'AgMFBwsNERMXHR8lKSsvNTs9Q0dJT1NZYWVna21xf4OJi5WXnaOnrbO1v8HFx9Pf4+Xp7/H7' base64Decoded\"\r\t\"'SGVsbG8gV29ybGQh' base64Decoded utf8Decoded\"\r\t\r\t^ ZnBase64Encoder new decode: self"},{"name":"slvmUTF32EncodedSize","linesOfCode":2,"sourceCode":"slvmUTF32EncodedSize\r\t^ self slvmUTF32Encoded size"},{"name":"startsWithDigit","linesOfCode":7,"sourceCode":"startsWithDigit\r\t\"Answer whether the receiver's first character represents a digit\"\r\t\"'abc' startsWithDigit >>> false\"\r\t\"'0abc' startsWithDigit >>> true\"\r\t\"'1abc' startsWithDigit >>> true\"\r\t\"'11abc' startsWithDigit >>> true\"\r\t\r\t^ self size > 0 and: [self first isDigit]"},{"name":"indexOf:startingAt:","linesOfCode":6,"sourceCode":"indexOf: aCharacter startingAt: start\r\t\"Return the index of the argument in the receiver, only elements after the start of the element are considered zero if not present.\"\r\t\r\t\"('abcdf abcedf' indexOf: $a startingAt: 4) >>> 7\"\r\t\"('abddf bcdef' indexOf: $a startingAt: 100 ) >>> 0\"\r\t\r\t(aCharacter isCharacter) ifFalse: [^ 0].\r\t^ self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start"},{"name":"caseInsensitiveLessOrEqual:","linesOfCode":4,"sourceCode":"caseInsensitiveLessOrEqual: aString \r\t\"Answer whether the receiver sorts before or equal to aString.\r\tThe collation order is case insensitive.\"\r\t^(self compare: aString caseSensitive: false) <= 2"},{"name":"asPackageIfAbsent:","linesOfCode":2,"sourceCode":"asPackageIfAbsent: aBlock\r\t^ RPackageOrganizer default packageNamed: self ifAbsent: aBlock"},{"name":"matchesRegexIgnoringCase:","linesOfCode":6,"sourceCode":"matchesRegexIgnoringCase: regexString\r\t\"Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or\r\tchild signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegexIgnoringCase matches: self"},{"name":"withBlanksCondensed","linesOfCode":13,"sourceCode":"withBlanksCondensed\r\t\"Return a copy of the receiver with leading/trailing blanks (separators) removed\r\t and consecutive white spaces (separators) condensed to the first one.\"\r\r\t| trimmed lastBlank |\r\ttrimmed := self trimBoth.\r\t^ String streamContents: [ :stream | \r\t\t\tlastBlank := false.\r\t\t\ttrimmed\r\t\t\t\tdo: [ :eachChar | \r\t\t\t\t\t(eachChar isSeparator and: [ lastBlank ])\r\t\t\t\t\t\tifFalse: [ stream nextPut: eachChar ].\r\t\t\t\t\tlastBlank := eachChar isSeparator ] ]\r\r\t\" ' abc  d   ' withBlanksCondensed\""},{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self subclassResponsibility"},{"name":"copyReplaceAll:with:asTokens:","linesOfCode":26,"sourceCode":"copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens\r\t\"Answer a copy of the receiver in which all occurrences of oldSubstring have been replaced by newSubstring. ifTokens (valid for Strings only) specifies that the characters surrounding the replacement must not be alphanumeric (space). When ifTokens is set, it means that the replacement will not occur inside word.\"\r\r\t\"('test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true) >>> 'test longone string'\"\r\t\"('test te string' copyReplaceAll: 'te' with: 'longone' asTokens: false) >>> 'longonest longone string'\"\r\r\t| aString startSearch currentIndex endIndex |\r\r\taString := self.\r\tstartSearch := 1.\r\t[(currentIndex := aString indexOfSubCollection: oldSubstring startingAt: startSearch)\r\t\t\t > 0]\r\t\twhileTrue: \r\t\t[endIndex := currentIndex + oldSubstring size - 1.\r\t\t(ifTokens not\r\t\t\tor: [(currentIndex = 1\r\t\t\t\t\tor: [(aString at: currentIndex-1) isAlphaNumeric not])\r\t\t\t\tand: [endIndex = aString size\r\t\t\t\t\tor: [(aString at: endIndex+1) isAlphaNumeric not]]])\r\t\t\tifTrue: [aString := aString\r\t\t\t\t\tcopyReplaceFrom: currentIndex\r\t\t\t\t\tto: endIndex\r\t\t\t\t\twith: newSubstring.\r\t\t\t\tstartSearch := currentIndex + newSubstring size]\r\t\t\tifFalse: [\r\t\t\t\tifTokens \r\t\t\t\t\tifTrue: [startSearch := currentIndex + 1]\r\t\t\t\t\tifFalse: [startSearch := currentIndex + newSubstring size]]].\r\t^ aString\r\r"},{"name":"surroundedBy:","linesOfCode":8,"sourceCode":"surroundedBy: aString\r\t\"Answer the receiver with leading and trailing aString.\"\r\t\"('hello' surroundedBy: 'abd') >>> 'abdhelloabd'\"\r\t\"('hello' surroundedBy: ' abd ') >>> ' abd hello abd '\"\r\t\r\t^ self species streamContents: [ :s|\r\t\ts nextPutAll: aString.\r\t\ts nextPutAll: self.\r\t\ts nextPutAll: aString ]."},{"name":"withNoLineLongerThan:","linesOfCode":25,"sourceCode":"withNoLineLongerThan: aNumber\r\t\"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number\"\r\t(aNumber isNumber not or: [ aNumber < 1 ]) ifTrue: [self error: 'too narrow'].\r\t^self species\r\t\tnew: self size * (aNumber + 1) // aNumber \"provision for supplementary line breaks\"\r\t\tstreamContents: [ :stream |\r\t\t\tself lineIndicesDo: [ :start :endWithoutDelimiters :end |\r\t\t\t\t| pastEnd lineStart |\r\t\t\t\tpastEnd := endWithoutDelimiters + 1.\r\t\t\t\t\"eliminate spaces at beginning of line\"\r\t\t\t\tlineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [pastEnd]) min: pastEnd.\r\t\t\t\t[| lineStop lineEnd spacePosition |\r\t\t\t\tlineEnd := lineStop  := lineStart + aNumber min: pastEnd.\r\t\t\t\tspacePosition := lineStart.\r\t\t\t\t[spacePosition < lineStop] whileTrue: [\r\t\t\t\t\tspacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [pastEnd].\r\t\t\t\t\tspacePosition <= lineStop ifTrue: [lineEnd := spacePosition].\r\t\t\t\t].\r\t\t\t\t\"split before space or before lineStop if no space\"\r\t\t\t\tstream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).\r\t\t\t\t\"eliminate spaces at beginning of next line\"\r\t\t\t\tlineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd ifAbsent: [pastEnd].\r\t\t\t\tlineStart <= endWithoutDelimiters ]\r\t\t\t\t\twhileTrue: [stream cr].\r\t\t\t\tstream nextPutAll: (self copyFrom: pastEnd to: end) ] ]"},{"name":"asByteString","linesOfCode":4,"sourceCode":"asByteString\r\t\"Convert the receiver into a ByteString, if possible\"\r\t\"Do not raise an error if it's not possible, since my use case is usually one in which WideStrings may or may not have been mutated to something representable in a ByteString, and we mostly do this to save space if possible. If the percentage of such cases are small, it may be better to use isOctetString check first to avoid creating String instances\"\t\r\t^self asOctetString"},{"name":"printOn:","linesOfCode":3,"sourceCode":"printOn: aStream \r\t\"Print inside string quotes, doubling inbedded quotes.\"\r \r\tself storeOn: aStream"},{"name":"compare:with:collated:","linesOfCode":13,"sourceCode":"compare: string1 with: string2 collated: order\r\t\r\t\"'abc' = 'abc' asWideString >>> true\"\r\t\"'abc' asWideString = 'abc' >>> true\"\r\t\"(ByteArray with: 97 with: 0 with: 0 with: 0) asString ~= 'a000' asWideString >>> true\"\r\t\"('abc' sameAs: 'aBc' asWideString) >>> true\"\r\t\"('aBc' asWideString sameAs: 'abc') >>> true\"\r\t\"('a000' asWideString ~= (ByteArray with: 97 with: 0 with: 0 with: 0) asString) >>> true\"\r\t\"((ByteArray with: 97 with: 0 with: 0 with: 0) asString sameAs: 'Abcd' asWideString) >>> false\"\r\t\"('a000' asWideString sameAs: (ByteArray with: 97 with: 0 with: 0 with: 0) asString) >>> false\"\r\t\r\t(string1 isByteString and: [string2 isByteString]) ifTrue: [\r\t\t^ ByteString compare: string1 with: string2 collated: order].\r     \"Primitive does not fail properly right now\"\r\t^ String compare: string1 with: string2 collated: order"},{"name":"translateToUppercase","linesOfCode":3,"sourceCode":"translateToUppercase\r\t\"Translate all characters to lowercase, in place\"\r\r\tself translateWith: UppercasingTable"},{"name":"addToMetacelloPackages:","linesOfCode":11,"sourceCode":"addToMetacelloPackages: aMetacelloPackagesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloPackagesSpec project packageSpec)\r\t\t\tfile: self;\r\t\t\tyourself.\r\taMetacelloPackagesSpec addMember: \r\t\t(aMetacelloPackagesSpec addMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"compare:","linesOfCode":11,"sourceCode":"compare: aString \r\t\"Answer a comparison code telling how the receiver sorts relative to aString:\r\t\t1 - before\r\t\t2 - equal\r\t\t3 - after.\r\tThe collation sequence is ascii with case differences ignored.\r\tTo get the effect of a <= b, but ignoring case, use (a compare: b) <= 2.\"\r\t\"('aa' compare: 'ab') >>> 1\"\r\t\"('aa' compare: 'aa') >>> 2\"\r\t\"('ab' compare: 'aa') >>> 3\"\r\t\r\t^self compare: aString caseSensitive: false"},{"name":"isLiteral","linesOfCode":2,"sourceCode":"isLiteral\r\r\t^true"},{"name":"indexOfWideCharacterFrom:to:","linesOfCode":6,"sourceCode":"indexOfWideCharacterFrom: start to: end\r\t\"Return the index of the first wide character following anIndex\"\r\t\"Implementation note: inline #anySatisfy: here for efficiency reasons\"\r\t\r\tstart to: end do: [:ix | \r\t\t(self basicAt: ix) > 255 ifTrue: [ ^ix ]].\r\t^ 0"},{"name":"asFFILibrary","linesOfCode":2,"sourceCode":"asFFILibrary \r\t^ FFIUnknownLibrary name: self"},{"name":"threeWayCompareTo:","linesOfCode":8,"sourceCode":"threeWayCompareTo: aString\r\t\"Do a three-way comparison between the receiver and anotherObject, returning\r\t-1 if self < anotherObject\r\t0 if self = anotherObject\r\t1 if self > anotherObject\r\tThis assumes a total order in accordance with the mathematical law of trichotomy.\r\tSee also:  http://en.wikipedia.org/wiki/Three-way_comparison\"\r\r\t ^ (self compare: self with: aString collated: AsciiOrder) - 2"},{"name":"trimmed","linesOfCode":2,"sourceCode":"trimmed\r\t^ self trimBoth"},{"name":"setBlessingInMetacelloConfig:","linesOfCode":2,"sourceCode":"setBlessingInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setBlessingWithString: self"},{"name":"asInstanceSideBehaviorName","linesOfCode":2,"sourceCode":"asInstanceSideBehaviorName\r\r\t^ (self splitOn: Character space) first"},{"name":"withoutLeadingDigits","linesOfCode":4,"sourceCode":"withoutLeadingDigits\r\t\"Answer the portion of the receiver that follows any leading series of digits and separators.\r\tIf the receiver consists entirely of digits and separators, return an empty string\"\r\r\t^ self trimLeft: [ :char | char isDigit or: [ char isSeparator ] ]"},{"name":"asExternalTypeOn:","linesOfCode":2,"sourceCode":"asExternalTypeOn: generator\r\t^ generator resolveType: self"},{"name":"allRangesOfRegexMatches:","linesOfCode":2,"sourceCode":"allRangesOfRegexMatches: rxString\r\r\t^rxString asRegex matchingRangesIn: self"},{"name":"<=","linesOfCode":7,"sourceCode":"<= aString \r\t\"Answer whether the receiver sorts before or equal to aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'abc' <= 'def' >>> true\"\r\t\" 'abc' <= 'abc' >>> true\"\r\t\" 'def' <= 'abc' >>> false\"\r\t\r\t^ (self compare: self with: aString collated: AsciiOrder) <= 2"},{"name":"setIncludesInMetacelloPackage:","linesOfCode":2,"sourceCode":"setIncludesInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setIncludes: { self }."},{"name":"convertFromEncoding:","linesOfCode":2,"sourceCode":"convertFromEncoding: encodingName\r\t^self convertFromWithConverter: (TextConverter newForEncoding: encodingName)"},{"name":"wbtSolveLinkLibrariesInPackage:","linesOfCode":2,"sourceCode":"wbtSolveLinkLibrariesInPackage: targetPackage\r\t^ {targetPackage getMainTargetNamed: self ifAbsent: [ WBTImportedLibraryTarget new name: self ]}"},{"name":"llvmNameForHandle","linesOfCode":3,"sourceCode":"llvmNameForHandle\r\t(self allSatisfy: [ :each | each isDigit ]) ifTrue: [ ^ '' ].\r\t^ self"},{"name":"heightToDisplayInList:","linesOfCode":2,"sourceCode":"heightToDisplayInList: aList\r\r\t^ aList font height"},{"name":"withCRs","linesOfCode":5,"sourceCode":"withCRs\r\t\"Return a copy of the receiver in which backslash (\\) characters have been replaced with carriage returns. For example '-hello\\-hi' will be\r\t'-hello\r\t -hi'\"\r\r\t^ self collect: [ :c | c = $\\ ifTrue: [ Character cr ] ifFalse: [ c ]]."},{"name":"lineCount","linesOfCode":7,"sourceCode":"lineCount\r\t\"Answer the number of lines represented by the receiver, where every line delimiter CR, LF or CRLF pair adds one line.\"\r\r\t| lineCount |\r\tlineCount := 0.\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\tlineCount := lineCount + 1].\r\t^lineCount"},{"name":"match:","linesOfCode":21,"sourceCode":"match: text\r\t\"Answer whether text matches the pattern in this string.\r\tMatching ignores upper/lower case differences.\r\tWhere this string contains #, text may contain any character.\r\tWhere this string contains *, text may contain any sequence of characters.\"\r\t\r\t\"('*' match: 'zort') >>> true\"\r\t\"('*baz' match: 'mobaz') >>> true\"\r\t\"('*baz' match: 'mobazo') >>>false\"\r\t\"('*baz*' match: 'mobazo') >>> true\"\r\t\"('*baz*' match: 'mozo') >>> false\"\r\t\"('foo*' match: 'foozo') >>> true\"\r\t\"('foo*' match: 'bozo') >>> false\"\r\t\"('foo*baz' match: 'foo23baz') >>> true\"\r\t\"('foo*baz' match: 'foobaz') >>> true\"\r\t\"('foo*baz' match: 'foo23bazo') >>> false\"\r\t\"('foo' match: 'Foo') >>> true\"\r\t\"('foo*baz*zort' match: 'foobazort') >>> false\"\r\t\"('foo*baz*zort' match: 'foobazzort') >>> true\"\r\t\"('*foo#zort' match: 'afoo3zortthenfoo3zort') >>> true\"\r\t\"('*foo*zort' match: 'afoodezortorfoo3zort') >>> true\"\r\r\t^ self startingAt: 1 match: text startingAt: 1"},{"name":"compare:caseSensitive:","linesOfCode":9,"sourceCode":"compare: aString caseSensitive: aBool\r\t\"Answer a comparison code telling how the receiver sorts relative to aString:\r\t\t1 - before\r\t\t2 - equal\r\t\t3 - after.\r\t\"\r\t| map |\r\tmap := aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder].\r\t^self compare: self with: aString collated: map"},{"name":"alike:","linesOfCode":16,"sourceCode":"alike: aString \r\t\"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score (but see example with 7).  Case is ignored. This method is used to help find mistyped variable names in methods.\"\r\t\"('abc' alike: 'abc') >>> 7.\"\r\t\"('action' alike: 'actions') >>> 7.\"\r\t\"('action' alike: 'caption') >>> 5.\"\r\t\"('action' alike: 'name') >>> 0.\"\t\r\r\t| i j k minSize bonus |\r\tminSize := (j := self size) min: (k := aString size).\r\tbonus := (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].\r\ti := 1.\r\t[(i <= minSize) and: [((self at: i) asInteger bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]\r\t\twhileTrue: [ i := i + 1 ].\r\t[(j > 0) and: [(k > 0) and:\r\t\t[((self at: j) asInteger bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]\r\t\t\twhileTrue: [ j := j - 1.  k := k - 1. ].\r\t^ i - 1 + self size - j + bonus"},{"name":"gtInspectorTextIn:","linesOfCode":5,"sourceCode":"gtInspectorTextIn: composite\r\t<gtInspectorPresentationOrder: -10>\r\tcomposite text\r\t\ttitle: 'String';\r\t\tdisplay: [ self truncateWithElipsisTo: 100000 ]"},{"name":"asFileLocatorOrReference","linesOfCode":2,"sourceCode":"asFileLocatorOrReference\r\r\t^ FileLocator fromString: self ifNone: [ self asFileReference ]\r"},{"name":"isLLVMAnon","linesOfCode":2,"sourceCode":"isLLVMAnon\r\t^ self detect: [:c | c isDigit not] ifFound: [false] ifNone: [ true ]"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createObjectBytes: self asUTF8Bytes class: objectModel stringClass"},{"name":"displayOn:","linesOfCode":3,"sourceCode":"displayOn: aDisplayMedium\r\t\"Display the receiver on the given DisplayMedium.\"\r\r\tself displayOn: aDisplayMedium at: 0 @ 0"},{"name":"setProject:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setProject: aString withInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setProject: aString withString: self"},{"name":"findAnySubstring:startingAt:","linesOfCode":8,"sourceCode":"findAnySubstring: aCollection startingAt: start \r\t\"Answer the index where an element of aCollection begins. If none are found, answer size + 1. aCollection is an Array of Strings or Characters.\"\r\r\t^aCollection inject: 1 + self size into: [:min :searchTerm |\r\t\t| ind |\r\t\tind := searchTerm isCharacter \r\t\t\tifTrue: [self indexOf: searchTerm startingAt: start ifAbsent: [min]]\r\t\t\tifFalse: [self indexOfSubCollection: searchTerm startingAt: start ifAbsent: [min]].\r\t\tmin min: ind]"},{"name":"withInternalLineEndings","linesOfCode":3,"sourceCode":"withInternalLineEndings\r\t\"Answer a new instance where all occurrences of CRLF and LF are substituted with CR. Pharo internally uses CR for carriage return.\"\r\r\t^ self withLineEndings: String cr"},{"name":"findWordStart:startingAt:","linesOfCode":9,"sourceCode":"findWordStart: key startingAt: start\r\t| ind |\r\t\"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned.\"\r\r\tind := start.\r\t[ind := self findString: key startingAt: ind caseSensitive: false.\r\tind = 0 ifTrue: [^ 0].\t\"not found\"\r\tind = 1 ifTrue: [^ 1].\t\"First char is the start of a word\"\r\t(self at: ind-1) isSeparator] whileFalse: [ind := ind + 1].\r\t^ ind\t\"is a word start\""},{"name":"translatedTo:","linesOfCode":3,"sourceCode":"translatedTo: localeID \r\t\"answer the receiver translated to the given locale id\"\r\t^ NaturalLanguageTranslator translate: self toLocale: localeID"},{"name":"truncateTo:","linesOfCode":5,"sourceCode":"truncateTo: smallSize\r\t\"return myself or a copy shortened to smallSize.\"\r\r\t^ self size <= smallSize\r\t\tifTrue: [ self ]\r\t\tifFalse: [ self copyFrom: 1 to: smallSize ]"},{"name":"lineCorrespondingToIndex:","linesOfCode":5,"sourceCode":"lineCorrespondingToIndex: anIndex\r\t\"Answer a string containing the line at the given character position.\"\r\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\tanIndex <= end ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].\r\t^''"},{"name":"capitalized","linesOfCode":7,"sourceCode":"capitalized\r\t\"Return a copy with the first letter capitalized\"\r\t| cap |\r\tself isEmpty ifTrue: [ ^self copy ].\r\tcap := self copy.\r\tcap at: 1 put: (cap at: 1) asUppercase.\r\t^ cap"},{"name":"asBrick","linesOfCode":4,"sourceCode":"asBrick\r\r\t^ GLMLabelBrick new\r\t\ttext: self asString;\r\t\theight: [ :b | b approximateHeight ]"},{"name":"asClassInEnvironment:","linesOfCode":5,"sourceCode":"asClassInEnvironment: anEnvironment\r\t\"I return class named after myself from anEnvironment\"\r\t^ self \r\t\tasClassInEnvironment: anEnvironment \r\t\tifAbsent: [ NotFound signalFor: self in: anEnvironment ]"},{"name":"translateToLowercase","linesOfCode":3,"sourceCode":"translateToLowercase\r\t\"Translate all characters to lowercase, in place\"\r\r\tself translateWith: LowercasingTable"},{"name":"findString:startingAt:","linesOfCode":6,"sourceCode":"findString: substring startingAt: start \r\t\"Answer the index of the first substring within the receiver, starting at start. If the receiver does not contain substring, answer 0.\"\r\t\"('salkjsdlkgfee' findString: 'ee'startingAt: 3) >>> 12\"\r\t\"('salkjsdlkgfee' findString: 'al'startingAt: 3) >>> 0\"\r\t\"('salkjsdlkgfeeal' findString: 'al' startingAt: 1) >>> 2\"\r\t\r\t^self findString: substring startingAt: start caseSensitive: true"},{"name":"correctAgainst:continuedFrom:","linesOfCode":7,"sourceCode":"correctAgainst: wordList continuedFrom: oldCollection\r\t\"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList.\"\r\r\t^ wordList \r\t\tifNil: [ self correctAgainstEnumerator: nil\r\t\t\t\t\tcontinuedFrom: oldCollection ]\r\t\tifNotNil: [ self correctAgainstEnumerator: [ :action | wordList do: action without: nil]\r\t\t\t\t\tcontinuedFrom: oldCollection ]"},{"name":"expandMacrosWith:with:","linesOfCode":3,"sourceCode":"expandMacrosWith: anObject with: anotherObject \r\t^self \r\t\texpandMacrosWithArguments: (Array with: anObject with: anotherObject)"},{"name":"asTime","linesOfCode":3,"sourceCode":"asTime\r\t\"Many allowed forms, see Time>>readFrom:\"\r\r\t^ Time fromString: self."},{"name":"indexOf:","linesOfCode":9,"sourceCode":"indexOf: aCharacter\r\t\"Return the index starting at 1 of the argument in the receiver, zero if not present.\"\r\t\"('abcdf' indexOf: $a) >>> 1\"\r\t\"('abddf' indexOf: $k) >>> 0\"\r\t\r\taCharacter isCharacter ifFalse: [^ 0].\r\t^ self class\r\t\tindexOfAscii: aCharacter asciiValue\r\t\tinString: self\r\t\tstartingAt: 1.\r"},{"name":"lineNumberCorrespondingToIndex:","linesOfCode":8,"sourceCode":"lineNumberCorrespondingToIndex: anIndex\r\t\"Answer a lineNumber for the line at the given character position.\"\r\t|lineNumber|\r\t\r\tlineNumber := 0.\r\t\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\tlineNumber := lineNumber + 1.\r\t\tanIndex <= end ifTrue: [^lineNumber]].\r\t^lineNumber"},{"name":"metacelloStringLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloStringLessThanSelf: aString\r\r\t^aString < self"},{"name":">","linesOfCode":7,"sourceCode":"> aString \r\t\"Answer whether the receiver sorts after aString.\r\tThe collation order is simple ascii (with case differences).\"\r\t\" 'def' > 'abc' >>> true\"\r\t\" 'def' > 'def' >>> false\"\r\t\" 'abc' > 'def' >>> false\"\r\r\r\t^ (self compare: self with: aString collated: AsciiOrder) = 3"},{"name":"browseDirectory","linesOfCode":2,"sourceCode":"browseDirectory\r\t^ (PhideProject forDirectory: self) openBrowser"},{"name":"wbtSolveMainElementInPackage:","linesOfCode":2,"sourceCode":"wbtSolveMainElementInPackage: targetPackage\r\t^ targetPackage getMainTargetNamed: self ifAbsent: [ self error: 'Failed to solve' ]"},{"name":"copyWithRegex:matchesReplacedWith:","linesOfCode":3,"sourceCode":"copyWithRegex: rxString matchesReplacedWith: aString\r\r\t^rxString asRegex\r\t\tcopy: self replacingMatchesWith: aString"},{"name":"asSignedInteger","linesOfCode":9,"sourceCode":"asSignedInteger \r\t\"Returns the first signed integer it can find or nil.\"\r\r\t| start stream |\r\tstart := self findFirst: [:char | char isDigit].\r\tstart isZero ifTrue: [^ nil].\r\tstream := self readStream position: start - 1.\r\t((stream position ~= 0) and: [stream peekBack = $-])\r\t\tifTrue: [stream back].\r\t^ Integer readFrom: stream"},{"name":"prefixMatchesRegexIgnoringCase:","linesOfCode":6,"sourceCode":"prefixMatchesRegexIgnoringCase: regexString\r\t\"Test if the receiver's prefix matches a regex.\t\r\tMay raise RxParser class>>regexErrorSignal or child signals.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^regexString asRegexIgnoringCase matchesPrefix: self"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":7,"sourceCode":"indexOf: aCharacter startingAt: start ifAbsent: aBlock\r\t| ans |\r\taCharacter isCharacter ifFalse: [ ^ aBlock value ].\r\tans := self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start.\r\t^ ans = 0\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ ans ]"},{"name":"endOfParagraphBefore:","linesOfCode":7,"sourceCode":"endOfParagraphBefore: aNumber\r\t\"Return the index of the last Character cr before position aNumber, or zero if this is the first paragraph.\r\t'ddd' endOfParagraphBefore: 3\r\t'dd\r\td' endOfParagraphBefore: 4\r\t\"\r\t^ self lastIndexOf: Character cr startingAt: aNumber - 1 ifAbsent: [ 0 ]"},{"name":"asOctetString","linesOfCode":7,"sourceCode":"asOctetString\r\t\"Convert the receiver into an octet string, if possible\"\r\t\"(IE, I am a WideString containing only character with codePoints < 255, so all of them fit in a latin1-string).\"\r\t| string |\r\tstring := String new: self size.\r\t1 to: self size do: [:i | string at: i put: (self at: i)].\r\t^string"},{"name":"asPresenter","linesOfCode":4,"sourceCode":"asPresenter \r\r\t^ SpLabelPresenter new \r\t\tlabel: self;\r\t\tyourself"},{"name":"asFourCode","linesOfCode":15,"sourceCode":"asFourCode\r\t\"'abcd' asFourCode >>> -513645724\"\r\t\"'1111' asFourCode >>> 825307441\"\r\t\"'1234' asFourCode >>> 825373492\"\r\t| result |\r\tself size = 4 \r\t\tifFalse: [^self error: 'must be exactly four characters'].\r\t\t\r\tresult := self inject: 0 into: [:val :each | 256 * val + each asciiValue ].\r\t(result bitAnd: 16r80000000) = 0 \r\t\tifFalse: [ Error signal: 'cannot resolve fourcode' ].\r\t\t\r\t(result bitAnd: 16r40000000) = 0 \r\t\tifFalse: [ ^ result - 16r80000000 ].\r\t^ result\r"},{"name":"allRangesOfSubstring:","linesOfCode":11,"sourceCode":"allRangesOfSubstring: aSubstring\r\t\"('Ab cd ef Ab cd' allRangesOfSubstring: 'cd') >>> {(4 to: 5). (13 to: 14)}\"\r\t\"('Ab cd ef Ab cd' allRangesOfSubstring: 'zz') >>> #()\"\r\t\r\t^ Array streamContents: [:s | | start subSize |\r\t\tstart := 1.\r\t\tsubSize := aSubstring size.\r\t\t[start isZero]\r\t\t\twhileFalse: [ start := self findString: aSubstring startingAt: start.\r\t\t\t\tstart > 0 \r\t\t\t\t\tifTrue: [s nextPut: (start to: start + subSize - 1).\r\t\t\t\t\t\tstart := start + subSize]]]"},{"name":"truncateWithElipsisTo:","linesOfCode":8,"sourceCode":"truncateWithElipsisTo: maxLength\r\t\"Return myself or a copy suitably shortened but with elipsis added\"\r\r\t^ self size <= maxLength\r\t\tifTrue:\r\t\t\t[self]\r\t\tifFalse:\r\t\t\t[(self copyFrom: 1 to: (maxLength - 3)), '...']\r\r\r\t\"'truncateWithElipsisTo:' truncateWithElipsisTo: 20\""},{"name":"onlyLetters","linesOfCode":3,"sourceCode":"onlyLetters\r\t\"answer the receiver with only letters\"\r\t^ self select:[:each | each isLetter]"},{"name":"extractNumber","linesOfCode":2,"sourceCode":"extractNumber\r\t^ ('0', self select: [:ea | ea isDigit]) asNumber"},{"name":"withUnixLineEndings","linesOfCode":4,"sourceCode":"withUnixLineEndings\r\t\"Answer a new instance where all occurrences of CRLF and LF are substituted with LF.\"\r\t\"(('asa' , String cr , 'asa') withUnixLineEndings at: 4) >>> Character lf\"\r\r\t^ self withLineEndings: String lf"},{"name":"heightToDisplayInTree:","linesOfCode":2,"sourceCode":"heightToDisplayInTree: aTree\r\r\t^ aTree fontToUse height"},{"name":"asPParser","linesOfCode":3,"sourceCode":"asPParser\r\t\"Answer a parser that accepts the receiving string.\"\r\r\t^ PP2LiteralSequenceNode on: self"},{"name":"isAllDigits","linesOfCode":8,"sourceCode":"isAllDigits\r\t\"Return whether the receiver is composed entirely of digits and has at least one digit\"\r\t\"'2345' isAllDigits >>> true\"\r\t\"'0002345' isAllDigits >>> true\"\r\t\"'2345.88' isAllDigits >>> false\"\r\t\r\tself do: [:c | c isDigit ifFalse: [^ false]].\r\tself ifEmpty: [^false].\r\t^ true"},{"name":"asPackage","linesOfCode":2,"sourceCode":"asPackage\r\t^ self asPackageIfAbsent: [ NotFound new messageText: 'There is no package named ', self; object: self; signal ] "},{"name":"asUnsignedInteger","linesOfCode":7,"sourceCode":"asUnsignedInteger\r\t\"Returns the first integer it can find or nil.\"\r\t| start stream |\r\tstart := self findFirst: [ :char | char isDigit ].\r\tstart isZero ifTrue: [ ^ nil ].\r\tstream := self readStream position: start - 1.\r\t^ Integer readFrom: stream"},{"name":"findTokens:escapedBy:","linesOfCode":50,"sourceCode":"findTokens: delimiters escapedBy: quoteDelimiters \r\t\"Answer a collection of Strings separated by the delimiters, where  \r\tdelimiters is a Character or collection of characters. Two delimiters in a  \r\trow produce an empty string (compare this to #findTokens, which  \r\ttreats sequential delimiters as one).  \r\t \r\tThe characters in quoteDelimiters are treated as quote characters, such  \r\tthat any delimiter within a pair of matching quoteDelimiter characters  \r\tis treated literally, rather than as a delimiter.  \r\t \r\tThe quoteDelimiter characters may be escaped within a quoted string.  \r\tTwo sequential quote characters within a quoted string are treated as  \r\ta single character.  \r\t \r\tThis method is useful for parsing comma separated variable strings for  \r\tspreadsheet import and export.\"\r\t| tokens rs activeEscapeCharacter ts char token delimiterChars quoteChars |\r\tdelimiterChars := (delimiters \r\t\tifNil: [ '' ]\r\t\tifNotNil: [ delimiters ]) asString.\r\tquoteChars := (quoteDelimiters \r\t\tifNil: [ '' ]\r\t\tifNotNil: [ quoteDelimiters ]) asString.\r\ttokens := OrderedCollection new.\r\trs := self readStream.\r\tactiveEscapeCharacter := nil.\r\tts := String new writeStream.\r\t[ rs atEnd ] whileFalse: \r\t\t[ char := rs next.\r\t\tactiveEscapeCharacter \r\t\t\tifNil: \r\t\t\t\t[ (quoteChars includes: char) \r\t\t\t\t\tifTrue: [ activeEscapeCharacter := char ]\r\t\t\t\t\tifFalse: \r\t\t\t\t\t\t[ (delimiterChars includes: char) \r\t\t\t\t\t\t\tifTrue: \r\t\t\t\t\t\t\t\t[ token := ts contents.\r\t\t\t\t\t\t\t\ttokens add: token.\r\t\t\t\t\t\t\t\tts := String new writeStream ]\r\t\t\t\t\t\t\tifFalse: [ ts nextPut: char ] ] ]\r\t\t\tifNotNil: \r\t\t\t\t[ char == activeEscapeCharacter \r\t\t\t\t\tifTrue: \r\t\t\t\t\t\t[ rs peek == activeEscapeCharacter \r\t\t\t\t\t\t\tifTrue: [ ts nextPut: rs next ]\r\t\t\t\t\t\t\tifFalse: [ activeEscapeCharacter := nil ] ]\r\t\t\t\t\tifFalse: [ ts nextPut: char ] ] ].\r\ttoken := ts contents.\r\t(tokens isEmpty and: [ token isEmpty ]) ifFalse: [ tokens add: token ].\r\t^ tokens"},{"name":"asResolvedBy:","linesOfCode":2,"sourceCode":"asResolvedBy: aFileSystem\r\t^ aFileSystem resolveString: self"},{"name":"stonContainSubObjects","linesOfCode":2,"sourceCode":"stonContainSubObjects \r\t^ false"},{"name":"charactersExactlyMatching:","linesOfCode":11,"sourceCode":"charactersExactlyMatching: aString\r\t\"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly.\"\r\t\"('s' charactersExactlyMatching: 'abc') >>> 0\"\r\t\"('fear is the little death that the.' charactersExactlyMatching: 'the') >>> 0\"\r\t\"('fear is the little death that the.' charactersExactlyMatching: 'fear is') >>> 7\"\r\t\r\t| count |\r\tcount := self size min: aString size.\r\t1 to: count do: [:i | \r\t\t(self at: i) = (aString at: i) ifFalse: [\r\t\t\t^ i - 1]].\r\t^ count"},{"name":"asSlotCollection","linesOfCode":6,"sourceCode":"asSlotCollection\r\t\"Parse as slots. Use space, tab and cr as separators\r\tExample: \r\t  'a b' asSlotCollection --> {a => Slot. b => Slot}\r\t\"\r\t\r\t^(self substrings: Character separators) collect: [ :substring | substring asSymbol asSlot ]"},{"name":"sameAs:","linesOfCode":4,"sourceCode":"sameAs: aString \r\t\"Answer whether the receiver sorts equal to aString. The \r\tcollation sequence is ascii with case differences ignored.\"\r\t^(self compare: aString caseSensitive: false) = 2"},{"name":"asZnUrl","linesOfCode":2,"sourceCode":"asZnUrl\r\t^ ZnUrl fromString: self"},{"name":"asColor","linesOfCode":2,"sourceCode":"asColor\r\t^ Color fromHexString: self"},{"name":"includesSubstring:caseSensitive:","linesOfCode":7,"sourceCode":"includesSubstring: aString caseSensitive: caseSensitive\r\t\"Returns whether the receiver contains the argument.\"\r\t\"('abcdefgh' includesSubstring: 'de' caseSensitive: false) >>> true\"\r\t\"('abcdefgh' includesSubstring: 'DE' caseSensitive: false) >>> true\"\r\t\"('abcDefgh' includesSubstring: 'De' caseSensitive: true) >>> true\"\r\t\"('abcDefgh' includesSubstring: 'DE' caseSensitive: true) >>> false\"\r\t\r\t^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0"},{"name":"keywords","linesOfCode":20,"sourceCode":"keywords\r\t\"Answer an array of the keywords that compose the receiver.\"\r\t| keywords |\r\tkeywords := Array streamContents:\r\t\t[:kwds | | char kwd | kwd := (String new: 16) writeStream.\r\t\t1 to: self size do:\r\t\t\t[:i |\r\t\t\tkwd nextPut: (char := self at: i).\r\t\t\tchar = $: ifTrue: \r\t\t\t\t\t[kwds nextPut: kwd contents.\r\t\t\t\t\tkwd reset]].\r\t\t(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].\r\t(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:\r\t\t[\"Has an initial keyword, as in #:if:then:else:\"\r\t\tkeywords := keywords allButFirst].\r\t(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:\r\t\t[\"Has a final keyword, as in #nextPut::andCR\"\r\t\tkeywords := keywords copyReplaceFrom: keywords size - 1\r\t\t\t\t\t\t\t\tto: keywords size with: {':' , keywords last}].\r\t^ keywords"},{"name":"setPreLoadDoItInMetacelloSpec:","linesOfCode":2,"sourceCode":"setPreLoadDoItInMetacelloSpec: aMetacelloSpec\r    self asSymbol setPreLoadDoItInMetacelloSpec: aMetacelloSpec"},{"name":"llvmPrintSpecializedMetadataValueOn:","linesOfCode":2,"sourceCode":"llvmPrintSpecializedMetadataValueOn: aStream\r\tself llvmPrintEscapedStringOn: aStream"},{"name":"isByteString","linesOfCode":3,"sourceCode":"isByteString\r\t\"Answer whether the receiver is a ByteString\"\r\t^false"},{"name":"string","linesOfCode":2,"sourceCode":"string\r\t^self"},{"name":"asClassInEnvironment:ifAbsent:","linesOfCode":9,"sourceCode":"asClassInEnvironment: anEnvironment ifAbsent: absentBlock\r\t^  anEnvironment \r\t\t\tat: self asSymbol \r\t\t\tifPresent: [ :aClass| \r\t\t\t\tself \r\t\t\t\t\tassert: aClass isBehavior \r\t\t\t\t\tdescription: [ self printString, ' is not a Class but an instance of a ', aClass class name ].\r\t\t\t\taClass ]\r\t\t\tifAbsent: absentBlock\r\t"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeString: self"},{"name":"asWBTVarSubstitution","linesOfCode":2,"sourceCode":"asWBTVarSubstitution\r\t^ self"},{"name":"asWin32WideString","linesOfCode":2,"sourceCode":"asWin32WideString\r\r\t^ Win32WideString fromString: self"},{"name":"asAlien","linesOfCode":4,"sourceCode":"asAlien\r\t| bs |\r\t^(Alien newC: (bs := self byteSize) + 1)\r\t\treplaceFrom: 1 to: bs with: self startingAt: 1"},{"name":"setDescriptionInMetacelloConfig:","linesOfCode":2,"sourceCode":"setDescriptionInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setDescriptionWithString: self"},{"name":"asRegexIgnoringCase","linesOfCode":8,"sourceCode":"asRegexIgnoringCase\r\t\"Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal\r\tor RxParser>>compilationErrorSignal.\r\tThis is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.\r\tRefer to `documentation' protocol of RxParser class for details.\"\r\r\t^RxParser preferredMatcherClass\r\t\tfor: (RxParser new parse: self)\r\t\tignoreCase: true"},{"name":"endsWithDigit","linesOfCode":6,"sourceCode":"endsWithDigit\r\t\"Answer whether the receiver's final character represents a digit.\"\r\t\"'foo10' endsWithDigit >>> true\"\r\t\"'foo10foo' endsWithDigit >>> false\"\r\t\"'foo1' endsWithDigit >>> true\"\r\t\r\t^ self notEmpty and: [self last isDigit]"},{"name":"linesDo:","linesOfCode":4,"sourceCode":"linesDo: aBlock\r\t\"Execute aBlock with each line in this string. The terminating line delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock\"\r\r\tself lineIndicesDo: [:start :endWithoutDelimiters :end |\r\t\taBlock value: (self copyFrom: start to: endWithoutDelimiters)]"},{"name":"join:","linesOfCode":7,"sourceCode":"join: aCollection\r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\"('*' join: #('WWWWW' 'W  EW' 'zzzz')) >>> 'WWWWW*W  EW*zzzz'\"\r\t\r\t^ self species new: (aCollection size * self size) streamContents: [:stream | \r\t\t\taCollection\r\t\t\t\tdo: [:each | stream nextPutAll: each asString] \r\t\t\t\tseparatedBy: [stream nextPutAll: self]]"},{"name":"isLiteralSymbol","linesOfCode":32,"sourceCode":"isLiteralSymbol\r\t\"Test whether a symbol can be stored as # followed by its characters.  \r\tSymbols created internally with asSymbol may not have this property, \r\te.g. '3' asSymbol.\"\r\r\t| i ascii type next last |\r\tself flag: 'reuse a parser for this'.\r\t\r\ti := self size.\r\ti = 0 ifTrue: [^ false].\r\r\t\"TypeTable should have been origined at 0 rather than 1 ...\"\r\tascii := (self at: 1) asciiValue.\r\ttype := self typeTable at: ascii ifAbsent: [^false].\r\ttype == #xLetter ifTrue: [\r\t\tnext := last := nil.\r\t\t[i > 1]\r\t\t\t\twhileTrue: \r\t\t\t\t\t[ascii := (self at: i) asciiValue.\r\t\t\t\t\ttype := self typeTable at: ascii ifAbsent: [^false].\r\t\t\t\t\t(type == #xLetter or: [type == #xDigit or: [type == #xColon\r\t\t\t\t\t\t\tand: [\r\t\t\t\t\t\t\t\tnext == nil\r\t\t\t\t\t\t\t\t\tifTrue: [last := #xColon. true] \r\t\t\t\t\t\t\t\t\tifFalse: [last == #xColon and: [next ~~ #xDigit and: [next ~~ #xColon]]]]]])\r\t\t\t\t\t\tifFalse: [^ false].\r\t\t\t\t\tnext := type.\r\t\t\t\t\ti := i - 1].\r\t\t\t^ true].\t\r\ttype == #xBinary ifTrue: [^i = 1]. \"Here we could extend to\r\t\t^(2 to: i) allSatisfy: [:j |\r\t\t\tascii := (self at: j) asciiValue.\r\t\t\t(self typeTable at: ascii ifAbsent: []) == #xBinary]\"\r\ttype == #verticalBar ifTrue: [^i = 1].\r\t^false"},{"name":"isString","linesOfCode":2,"sourceCode":"isString\r\t^ true"},{"name":"utf8Encoded","linesOfCode":5,"sourceCode":"utf8Encoded\r\t\"Produce a ByteArray encoding the receiver using UTF-8,\r\tthe recommended encoding for Strings, unless you know what you are doing.\"\r\t\r\t\" 'Les lves franais' utf8Encoded \"\r\t\r\t^ self encodeWith: ZnCharacterEncoder utf8"},{"name":"indexOfSubCollection:startingAt:ifAbsent:","linesOfCode":5,"sourceCode":"indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock\r\t| index |\r\tindex := self findString: sub startingAt: start.\r\tindex = 0 ifTrue: [^ exceptionBlock value].\r\t^ index"},{"name":"padRightTo:","linesOfCode":2,"sourceCode":"padRightTo: length\r\t^ self padRightTo: length with: Character space"},{"name":"asByteArray","linesOfCode":6,"sourceCode":"asByteArray\r\t\"Convert to a ByteArray with the ascii values of the string.\"\r\t\"'a' asByteArray >>> #[97]\"\r\t\"'A' asByteArray >>> #[65]\"\r\t\"'ABA' asByteArray >>> #[65 66 65]\"\r\tself subclassResponsibility "},{"name":"findBetweenSubstrings:","linesOfCode":11,"sourceCode":"findBetweenSubstrings: delimiters\r\t\"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation.\"\r\r\t| tokens keyStart keyStop |\r\ttokens := OrderedCollection new.\r\tkeyStop := 1.\r\t[keyStop <= self size] whileTrue:\r\t\t[keyStart := self skipAnySubstring: delimiters startingAt: keyStop.\r\t\tkeyStop := self findAnySubstring: delimiters startingAt: keyStart.\r\t\tkeyStart < keyStop\r\t\t\tifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].\r\t^tokens"},{"name":"indexOfSubCollection:","linesOfCode":6,"sourceCode":"indexOfSubCollection: sub \r\t\"\"\r\r\t^ self\r\t\tindexOfSubCollection: sub\r\t\tstartingAt: 1\r\t\tifAbsent: [0]"},{"name":"lines","linesOfCode":4,"sourceCode":"lines\r    \"Answer an array of lines composing this receiver without the line ending delimiters\"\r    ^Array new: (self size // 60 max: 16)\r            streamContents: [:lines | self linesDo: [:aLine | lines nextPut: aLine]]"},{"name":"setImportInVersionSpec:","linesOfCode":2,"sourceCode":"setImportInVersionSpec: aMetacelloVersionSpec\r  aMetacelloVersionSpec setImport: {self}"},{"name":"packToArity:","linesOfCode":4,"sourceCode":"packToArity: arity\r\t\"WARNING: Here applies the same rules as in ByteArray>>#rollToArity:, check there!\"\r\tarity = 1 ifTrue: [ ^ self ].\r\tself error: 'Use ExternalAddress instead!'"},{"name":"asCStringForGDBInto:","linesOfCode":16,"sourceCode":"asCStringForGDBInto: out\r\t| utf8String |\r\tutf8String := self utf8Encoded.\r\tout nextPut: $\".\r\tutf8String do: [ :char |\r\t\t(\" \" 32 <= char and: [ char <= 126 ]) ifTrue: [\r\t\t\t('\"\\' includes: char asCharacter) ifTrue: [\r\t\t\t\tout nextPut: $\\; nextPut: char asCharacter\r\t\t\t] ifFalse: [ \r\t\t\t\tout nextPut: char asCharacter\r\t\t\t].\r\t\t] ifFalse: [\r\t\t\tout nextPutAll: '\\x'; nextPutAll: (char printStringBase: 16 length: 2 padded: true) asLowercase\r\t\t]\r\t].\r\tout nextPut: $\".\r"},{"name":"findSubstring:in:startingAt:matchTable:","linesOfCode":31,"sourceCode":"findSubstring: key in: body startingAt: start matchTable: matchTable\r\t\"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.\"\r\t| index c1 c2 |\r\tmatchTable == nil ifTrue: [\r\t\tkey size = 0 ifTrue: [^ 0].\r\t\tstart to: body size - key size + 1 do:\r\t\t\t[:startIndex |\r\t\t\tindex := 1.\r\t\t\t\t[(body at: startIndex+index-1)\r\t\t\t\t\t= (key at: index)]\r\t\t\t\t\twhileTrue:\r\t\t\t\t\t[index = key size ifTrue: [^ startIndex].\r\t\t\t\t\tindex := index+1]].\r\t\t^ 0\r\t].\r\r\tkey size = 0 ifTrue: [^ 0].\r\tstart to: body size - key size + 1 do:\r\t\t[:startIndex |\r\t\tindex := 1.\r\t\t[c1 := body at: startIndex+index-1.\r\t\tc2 := key at: index.\r\t\t((c1 leadingChar = 0 and: [ c1 asciiValue < matchTable size ]) \r\t\t\tifTrue: [ matchTable at: c1 asciiValue + 1 ]\r\t\t\tifFalse: [ c1 asciiValue + 1 ]) = \r\t\t\t((c2 leadingChar = 0 and: [ c2 asciiValue < matchTable size ])\r\t\t\t\tifTrue: [ matchTable at: c2 asciiValue + 1 ]\r\t\t\t\tifFalse: [c2 asciiValue + 1 ]) ]\r\t\t\twhileTrue:\r\t\t\t\t[index = key size ifTrue: [^ startIndex].\r\t\t\t\tindex := index+1]].\r\t^ 0"},{"name":"displayOn:at:","linesOfCode":3,"sourceCode":"displayOn: aDisplayMedium at: aPoint \r\t\"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text.\"\r\r\tself displayOn: aDisplayMedium at: aPoint textColor: Color black"},{"name":"asEmailHeaderString","linesOfCode":2,"sourceCode":"asEmailHeaderString\r\t^ self"},{"name":"gtDisplayOn:","linesOfCode":2,"sourceCode":"gtDisplayOn: aStream\r\tself printOn: aStream."},{"name":"correctAgainstEnumerator:continuedFrom:","linesOfCode":24,"sourceCode":"correctAgainstEnumerator: wordBlock continuedFrom: oldCollection\r\r\t\"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it.\"\r\r\t| choices results maxChoices scoreMin |\r\r\tscoreMin := self size // 2 min: 3.\r\tmaxChoices := 10.\r\toldCollection\r\t\tifNil: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]\r\t\tifNotNil: [ choices := oldCollection ].\r\twordBlock\r\t\tifNil: [ results := OrderedCollection new.\r\t\t\t1 to: ( maxChoices min: choices size ) do: [ :i | results add: ( choices at: i ) key ]\r\t\t\t]\r\t\tifNotNil: [ wordBlock\r\t\t\t\tvalue: [ :word | \r\t\t\t\t\t| score |\r\r\t\t\t\t\t( score := self alike: word ) >= scoreMin\r\t\t\t\t\t\tifTrue: [ choices add: ( Association key: word value: score ).\r\t\t\t\t\t\t\tchoices size >= maxChoices\r\t\t\t\t\t\t\t\tifTrue: [ scoreMin := ( choices at: maxChoices ) value ]\r\t\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\tresults := choices\r\t\t\t].\r\t^ results"},{"name":"asMIMEType","linesOfCode":2,"sourceCode":"asMIMEType\r\t^ self asZnMimeType"},{"name":"hash","linesOfCode":6,"sourceCode":"hash\r\t\"#hash is implemented, because #= is implemented\"\r\t\"ar 4/10/2005: I had to change this to use ByteString hash as initial \r\thash in order to avoid having to rehash everything and yet compute\r\tthe same hash for ByteString and WideString.\"\r\t^ self class stringHash: self initialHash: ByteString hash"},{"name":"decodeQuotedPrintable","linesOfCode":4,"sourceCode":"decodeQuotedPrintable\r\t\"Assume receiver is in MIME 'quoted-printable' encoding, and decode it.\"\r  \r\t^QuotedPrintableMimeConverter mimeDecode: self as: self class"},{"name":"translated","linesOfCode":3,"sourceCode":"translated\r\"answer the receiver translated to the default language\"\r\t^ NaturalLanguageTranslator translate: self\r"},{"name":"mergeIntoMetacelloRepositories:","linesOfCode":11,"sourceCode":"mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\t| spec |\r\tspec := \r\t\t(aMetacelloRepositoriesSpec project repositorySpec)\r\t\t\tdescription: self;\r\t\t\tyourself.\r\taMetacelloRepositoriesSpec addMember: \r\t\t(aMetacelloRepositoriesSpec mergeMember \r\t\t\tname: spec name;\r\t\t\tspec: spec;\r\t\t\tyourself)"},{"name":"slvmUTF16Encoded","linesOfCode":17,"sourceCode":"slvmUTF16Encoded\r\t^ Array streamContents: [ :out |\r\t\tself do: [ :each |\r\t\t\t| codePoint highBits lowBits |\r\t\t\tcodePoint := each asInteger.\r\t\t\tcodePoint <= 16rffff ifTrue: [ \r\t\t\t\tout nextPut: codePoint\r\t\t\t] ifFalse: [\r\t\t\t\t\"https://en.wikipedia.org/wiki/UTF-16\"\r\t\t\t\tcodePoint := codePoint - 16r10000.\r\t\t\t\thighBits := (codePoint >> 10) & 16r3FF.\r\t\t\t\tout nextPut: 16rD800 + highBits.\r\r\t\t\t\tlowBits := codePoint & 16r3FF.\r\t\t\t\tout nextPut: 16rDC00 + lowBits.\r\t\t\t]\r\t\t]\r\t]"},{"name":"padLeftTo:","linesOfCode":2,"sourceCode":"padLeftTo: length\r\t^ self padLeftTo: length with: Character space"},{"name":"copyWithRegex:matchesTranslatedUsing:","linesOfCode":3,"sourceCode":"copyWithRegex: rxString matchesTranslatedUsing: aBlock\r\r\t^rxString asRegex\r\t\tcopy: self translatingMatchesUsing: aBlock"},{"name":"isAllAlphaNumerics","linesOfCode":9,"sourceCode":"isAllAlphaNumerics\r\t\"Returns whether the receiver is composed entirely of alphanumerics (i.e., letters or digits).\"\r\t\"'3.123' isAllAlphaNumerics >>> false\"\r\t\"'a3123abc' isAllAlphaNumerics >>> true\"\r\t\"'3123' isAllAlphaNumerics >>> true\"\r\t\"'3,123' isAllAlphaNumerics >>> false\"\r\t\"'a''b' isAllAlphaNumerics >>> false\"\r\t\r\tself do: [:c | c isAlphaNumeric ifFalse: [^ false]].\r\t^ true"},{"name":"localizedForPresenter:","linesOfCode":3,"sourceCode":"localizedForPresenter: aPresenter\r\r\t\"This message serves for the string modification for the purpose of a given Spec presenter. It may, for example, convert it to a presenter's locale. The implementation here (in the String) serves as fallback for regular strings.\"\r\r\t^ self"},{"name":"asPluralBasedOn:","linesOfCode":6,"sourceCode":"asPluralBasedOn: aNumberOrCollection\r\t\"Append an 's' to this string based on whether aNumberOrCollection is 1 or of size 1.\"\r\r\t^ (aNumberOrCollection = 1 or:\r\t\t[aNumberOrCollection isCollection and: [aNumberOrCollection size = 1]])\r\t\t\tifTrue: [self]\r\t\t\tifFalse: [self, 's']\r"},{"name":"asMetacelloSemanticVersionNumber","linesOfCode":2,"sourceCode":"asMetacelloSemanticVersionNumber\r    ^ MetacelloSemanticVersionNumber fromString: self"},{"name":"asComment","linesOfCode":25,"sourceCode":"asComment\r\t\"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled\"\r\r\t^String streamContents:  [ :str |\r\t\t| quoteCount first |\r\r\t\tstr nextPut: $\".\r\t\r\t\tquoteCount := 0.\r\t\tfirst := true.\r\t\tself do: [ :char |\r\t\t\tchar = $\"\r\t\t\t\tifTrue: [\r\t\t\t\t\tfirst ifFalse: [\r\t\t\t\t\t\tstr nextPut: char.\r\t\t\t\t\t\tquoteCount := quoteCount + 1 ] ]\r\t\t\t\tifFalse: [\r\t\t\t\t\tquoteCount odd ifTrue: [\r\t\t\t\t\t\t\"add a quote to even the number of quotes in a row\"\r\t\t\t\t\t\tstr nextPut: $\" ].\r\t\t\t\t\tquoteCount := 0.\r\t\t\t\t\tstr nextPut: char ].\r\t\t\tfirst := false ]. \r\r\t\tquoteCount odd ifTrue: [\r\t\t\t\"check at the end\"\r\t\t\tstr nextPut: $\". ].\r\r\t\tstr nextPut: $\".\r\t]\r\t"},{"name":"asDate","linesOfCode":3,"sourceCode":"asDate\r\t\"Many allowed forms, see Date>>#readFrom:\"\r\r\t^ Date fromString: self"},{"name":"isAllSeparators","linesOfCode":6,"sourceCode":"isAllSeparators\r\t\"Returns whether the receiver is composed entirely of separators i.e., a space, tab, lf, cr, and newPage\"\r\t\"(Character space asString, Character space asString) isAllSeparators >>> true\"\r\t\"(Character space asString, 'a') isAllSeparators >>> false\"\r\tself do: [ :c | c isSeparator ifFalse: [ ^false ] ].\r\t^true"},{"name":"lastSpacePosition","linesOfCode":10,"sourceCode":"lastSpacePosition\r\t\"Answer the character position of the final space or other separator character in the receiver, and 0 if none\"\r\t\"'fred the bear' lastSpacePosition >>> 9\"\r\t\"'ziggie' lastSpacePosition >>> 0\"\r\t\"'elvis ' lastSpacePosition >>> 6\"\r\t\"'elvis  ' lastSpacePosition >>> 7\"\r\t\"'' lastSpacePosition >>> 0\"\r\r\tself size to: 1 by: -1 do:\r\t\t[:i | ((self at: i) isSeparator) ifTrue: [^ i]].\r\t^ 0\r"},{"name":"translateWith:","linesOfCode":3,"sourceCode":"translateWith: table\r\t\"translate the characters in the string by the given table, in place\"\r\t^ self translateFrom: 1 to: self size table: table"},{"name":"encompassParagraph:","linesOfCode":8,"sourceCode":"encompassParagraph: anInterval\r\t\"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.\r\tAnswer starts at the position following a cr (or eventually 1) and ends at a cr (or eventually at self size).\r\tSee also #encompassLine:\"\r\t| left right |\r\tleft := (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.\r\tright := (self indexOf: Character cr startingAt: (anInterval last max: anInterval first) ifAbsent: [self size]).\r\t^left to: right"},{"name":"isWideString","linesOfCode":3,"sourceCode":"isWideString\r\t\"Answer whether the receiver is a WideString\"\r\t^false"},{"name":"setLoadsInMetacelloProject:","linesOfCode":2,"sourceCode":"setLoadsInMetacelloProject: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setLoads: { self }."},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeString: self"},{"name":"asWDCShaderCode","linesOfCode":2,"sourceCode":"asWDCShaderCode\r\t^ self utf8Encoded"},{"name":"encodeWith:","linesOfCode":5,"sourceCode":"encodeWith: encoding\r\t\"Produce a ByteArray that encodes the receiver, using a specified encoding.\r\tEncoding is either a ZnCharacterEncoder instance or an identifier for one.\"\r\t\r\t\" 'Les lves franais' encodeWith: #utf8 \"\r\t\r\t^ encoding asZnCharacterEncoder encodeString: self"},{"name":"asWBTEscapedVarSubstitution","linesOfCode":18,"sourceCode":"asWBTEscapedVarSubstitution\r\tSmalltalk platform isWindows ifTrue: [ \r\t\t^ (self includes: Character space)\r\t\t\tifTrue: [ '\"' , self , '\"' ]\r\t\t\tifFalse: [ self ]\r\t].\r\t(self includesAnyOf: ' \"\\') ifFalse: [ ^ self ].\r\t^ ByteString streamContents: [ :out |\r\t\tout nextPut: $\".\r\t\tself do: [ :each |\r\t\t\t('\"\\' includes: each) ifTrue: [ \r\t\t\t\tout nextPut: $\\.\r\t\t\t].\r\t\t\r\t\t\tout nextPut: each\r\t\t].\r\t\tout nextPut: $\".\r\t].\r"},{"name":"findIn:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findIn: body startingAt: start matchTable: matchTable\r\t\r\t^ self findSubstringViaPrimitive: self in: body startingAt: start matchTable: matchTable"}],"meta":{"name":"String class","instanceVariables":[],"methods":[{"name":"lf","linesOfCode":3,"sourceCode":"lf\r\t\"Answer a string containing a single carriage return character.\"\r\r\t^ self with: Character lf"},{"name":"new:","linesOfCode":5,"sourceCode":"new: sizeRequested\r\t\"Return a new instance with the number of indexable variables specified by the argument.\"\r\r\t^ self == String\r\t\tifTrue: [ ByteString new: sizeRequested ]\r\t\tifFalse: [ self basicNew: sizeRequested ]"},{"name":"findFirstInString:inCharacterSet:startingAt:","linesOfCode":8,"sourceCode":"findFirstInString: aString inCharacterSet: aCharacterSet startingAt: start \r\t\"Trivial, non-primitive version\"\r\t\r\tstart\r\t\tto: aString size\r\t\tdo: [:i | (aCharacterSet\r\t\t\t\t\tincludes: (aString at: i))\r\t\t\t\tifTrue: [^ i]].\r\t^ 0"},{"name":"cr","linesOfCode":3,"sourceCode":"cr\r\t\"Answer a string containing a single carriage return character.\"\r\r\t^ self with: Character cr\r"},{"name":"newTokenish","linesOfCode":4,"sourceCode":"newTokenish\r\t\"a table for testing tokenish (for fast numArgs)\"\r\t^ String withAll: (Character allByteCharacters \r\t\tcollect: [:c | c tokenish ifTrue: [ c ] ifFalse: [ $~ ]])"},{"name":"crlfcrlf","linesOfCode":2,"sourceCode":"crlfcrlf\r\t^self crlf , self crlf.\r"},{"name":"newUppercasingTable","linesOfCode":3,"sourceCode":"newUppercasingTable\r\t\"a table for translating to upper case\"\r\t^ String withAll: (Character allByteCharacters collect: [:c | c asUppercase])"},{"name":"systemIconName","linesOfCode":2,"sourceCode":"systemIconName\r\r\t^ #stringIcon"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeStringInspector"},{"name":"settingInputWidgetForNode:","linesOfCode":2,"sourceCode":"settingInputWidgetForNode: aSettingNode\r\t^ aSettingNode inputWidgetForString"},{"name":"loremIpsum:","linesOfCode":21,"sourceCode":"loremIpsum: size\r\t\"Return a mostly random multi-paragraph filler string of the specified size.\r\tThe result is pure ASCII, uses CR for newlines and ends with a dot and newline.\"\r\t\r\t\"self loremIpsum: 2048\"\r\t\r\t| words out |\r\twords := (self loremIpsum findTokens: ' ,.') collect: [:each | each asLowercase].\r\t(out := LimitedWriteStream on: (self new: size))\r\t\tlimit: size - 2;\r\t\tlimitBlock: [\r\t\t\t^ out originalContents \r\t\t\t\tat: size - 1 put: $.; \r\t\t\t\tat: size put: Character cr; \r\t\t\t\tyourself ].\r\t[ \r\t\tout << self loremIpsum; cr; cr.\r\t\t5 atRandom timesRepeat: [\r\t\t\t15 atRandom timesRepeat: [\r\t \t\t\tout << words atRandom capitalized.\r\t\t\t\t20 atRandom timesRepeat: [ out space; << words atRandom ].\r\t\t\t\tout nextPut: $.; space ].\r\t\t\tout cr; cr ] ] repeat"},{"name":"expandMacro:argument:withExpansions:","linesOfCode":6,"sourceCode":"expandMacro: macroType argument: argument withExpansions: expansions \r\tmacroType = $s ifTrue: [^expansions at: argument].\r\tmacroType = $p ifTrue: [^(expansions at: argument) printString].\r\tmacroType = $n ifTrue: [^String cr].\r\tmacroType = $t ifTrue: [^String tab].\r\tself error: 'unknown expansion type'"},{"name":"indexOfAscii:inString:startingAt:","linesOfCode":4,"sourceCode":"indexOfAscii: anInteger inString: aString startingAt: start\t\r\tstart to: aString size do: [ :index |\r\t\t(aString basicAt: index) = anInteger ifTrue: [ ^index ] ].\r\t^0\r\r"},{"name":"newCaseSensitiveOrder","linesOfCode":15,"sourceCode":"newCaseSensitiveOrder\r\t\"Case-sensitive compare sorts space, digits, letters, all the rest...\"\r\t\r\t| newTab order |\r\tnewTab := ByteArray new: 256 withAll: 255.\r\torder := -1.\r\t' 0123456789' do:  \"0..10\"\r\t\t[:c | newTab at: c asciiValue + 1 put: (order := order+1)].\r\t($a to: $z) do:     \"11-64\"\r\t\t[:c | newTab  at: c asUppercase asciiValue + 1 put: (order := order+1).\r\t\tnewTab  at: c asciiValue + 1 put: (order := order+1)].\r\t1 to: newTab  size do:\r\t\t[:i | (newTab  at: i) = 255 ifTrue:\r\t\t\t[newTab  at: i put: (order := order+1)]].\r\torder = 255 ifFalse: [self error: 'order problem'].\r\t^ newTab "},{"name":"findFirstInString:inSet:startingAt:","linesOfCode":13,"sourceCode":"findFirstInString: aString inSet: inclusionMap startingAt: start\r\t\"Trivial, non-primitive version\"\r\t\r\t| i stringSize ascii more |\r\tinclusionMap size ~= 256 ifTrue: [^ 0].\r\tstringSize := aString size.\r\tmore := true.\r\ti := start - 1.\r\t[more and: [(i := i + 1) <= stringSize]] whileTrue: [\r\t\tascii := (aString basicAt: i).\r\t\tmore := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].\r\t].\r\r\ti > stringSize ifTrue: [^ 0].\r\t^ i"},{"name":"fromString:","linesOfCode":3,"sourceCode":"fromString: aString \r\t\"Answer an instance of me that is a copy of the argument, aString.\"\r\t\r\t^ aString copyFrom: 1 to: aString size"},{"name":"newCSLineEnders","linesOfCode":3,"sourceCode":"newCSLineEnders\r\t\"CR and LF--characters that terminate a line\"\r\t^ CharacterSet crlf"},{"name":"canonicalArgumentName","linesOfCode":2,"sourceCode":"canonicalArgumentName\r\r\t^ 'aString'"},{"name":"fromByteArray:","linesOfCode":2,"sourceCode":"fromByteArray: aByteArray\r\r\t^ aByteArray asString\r"},{"name":"newCaseInsensitiveOrder","linesOfCode":10,"sourceCode":"newCaseInsensitiveOrder\r\t\"map char and char asLower (Lowercase Latin1 stays in the Latin1 range, uppercase not.)\"\r\t| newCollection |\r\tnewCollection := AsciiOrder copy.\r    (0 to: 255) do:[ :v |\r            | char lower |\r            char := v asCharacter.\r            lower := char asLowercase.\r            newCollection at: lower asciiValue + 1 put: (newCollection at: char asciiValue + 1) ].\r\t^ newCollection "},{"name":"readFrom:","linesOfCode":18,"sourceCode":"readFrom: inStream\r\t\"Answer an instance of me that is determined by reading the stream, \r\tinStream. Embedded double quotes become the quote Character.\"\r\r\t| char done |\r\t^ self streamContents: [ :outStream | \r\t\t\"go to first quote\"\r\t\tinStream skipTo: $'.\r\t\tdone := false.\r\t\t[ done or: [ inStream atEnd ] ]\r\t\t\twhileFalse: [ \r\t\t\t\tchar := inStream next.\r\t\t\t\tchar = $'\r\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\tchar := inStream next.\r\t\t\t\t\t\tchar = $'\r\t\t\t\t\t\t\tifTrue: [ outStream nextPut: char ]\r\t\t\t\t\t\t\tifFalse: [ done := true ] ]\r\t\t\t\t\tifFalse: [ outStream nextPut: char ] ] ]"},{"name":"translate:from:to:table:","linesOfCode":7,"sourceCode":"translate: aString from: start  to: stop  table: table\r\t\"Trivial, non-primitive version\"\r\t| char |\r\tstart to: stop do: [:i |\r\t\t(char := aString basicAt: i) < 256 ifTrue: [\r\t\t\taString at: i put: (table at: char+1)].\r\t]\r"},{"name":"newAsciiOrder","linesOfCode":2,"sourceCode":"newAsciiOrder\r\t^ (0 to: 255) as: ByteArray"},{"name":"value:","linesOfCode":2,"sourceCode":"value: anInteger\r\r\t^ self with: (Character value: anInteger)\r"},{"name":"compare:with:collated:","linesOfCode":32,"sourceCode":"compare: string1 with: string2 collated: order\r\t\"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array.\"\r\r\t| len1 len2 c1 c2 |\r\torder\r\t\tifNil: [ len1 := string1 size.\r\t\t\tlen2 := string2 size.\r\t\t\t1 to: (len1 min: len2) do: [ :i | \r\t\t\t\tc1 := string1 basicAt: i.\r\t\t\t\tc2 := string2 basicAt: i.\r\t\t\t\tc1 = c2\r\t\t\t\t\tifFalse: [ ^ c1 < c2\r\t\t\t\t\t\t\tifTrue: [ 1 ]\r\t\t\t\t\t\t\tifFalse: [ 3 ] ] ].\r\t\t\tlen1 = len2 ifTrue: [ ^ 2 ].\r\t\t\t^ len1 < len2\r\t\t\t\tifTrue: [ 1 ]\r\t\t\t\tifFalse: [ 3 ] ].\r\tlen1 := string1 size.\r\tlen2 := string2 size.\r\t1 to: (len1 min: len2) do: [ :i | \r\t\tc1 := string1 basicAt: i.\r\t\tc2 := string2 basicAt: i.\r\t\tc1 < 256 ifTrue: [ c1 := order at: c1 + 1 ].\r\t\tc2 < 256 ifTrue: [ c2 := order at: c2 + 1 ].\r\t\tc1 = c2\r\t\t\tifFalse: [ ^ c1 < c2\r\t\t\t\t\tifTrue: [ 1 ]\r\t\t\t\t\tifFalse: [ 3 ] ] ].\r\tlen1 = len2 ifTrue: [ ^ 2 ].\r\t^ len1 < len2\r\t\tifTrue: [ 1 ]\r\t\tifFalse: [ 3 ]"},{"name":"initialize","linesOfCode":12,"sourceCode":"initialize   \r\t\r\tself initializeTypeTable.\r\t\r\tAsciiOrder := self newAsciiOrder.\r\tCaseInsensitiveOrder := self newCaseInsensitiveOrder.\r\tCaseSensitiveOrder := self newCaseSensitiveOrder.\r\tLowercasingTable := self newLowercasingTable.\r\tUppercasingTable := self newUppercasingTable.\r\tTokenish := self newTokenish.\r\tCSLineEnders := self newCSLineEnders.\r\r \t\"separators and non-separators\"\r\tCSSeparators := CharacterSet separators.\r\tCSNonSeparators := CSSeparators complement."},{"name":"newLowercasingTable","linesOfCode":3,"sourceCode":"newLowercasingTable\r\t\"a table for translating to lower case\"\r\t^ String withAll: (Character allByteCharacters collect: [:c | c asLowercase])"},{"name":"tab","linesOfCode":3,"sourceCode":"tab\r\t\"Answer a string containing a single tab character.\"\r\r\t^ self with: Character tab\r"},{"name":"with:","linesOfCode":7,"sourceCode":"with: aCharacter\r\t| newCollection |\r\tnewCollection := aCharacter asInteger < 256\r\t\tifTrue:[ ByteString new: 1]\r\t\tifFalse:[ WideString new: 1].\r\tnewCollection at: 1 put: aCharacter.\r\t^newCollection"},{"name":"initializeTypeTable","linesOfCode":27,"sourceCode":"initializeTypeTable\r\r\t| newTable |\r\tnewTable := Array new: 256 withAll: #xBinary. \"default\"\r\tnewTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. \"tab lf ff cr space\"\r\tnewTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.\r\r\t1 to: 255\r\t\tdo: [:index |\r\t\t\t(Character value: index) isLetter\r\t\t\t\tifTrue: [newTable at: index put: #xLetter]].\r\r\tnewTable at: 30 put: #doIt.\r\tnewTable at: $\" asciiValue put: #xDoubleQuote.\r\tnewTable at: $# asciiValue put: #xLitQuote.\r\tnewTable at: $$ asciiValue put: #xDollar.\r\tnewTable at: $' asciiValue put: #xSingleQuote.\r\tnewTable at: $: asciiValue put: #xColon.\r\tnewTable at: $( asciiValue put: #leftParenthesis.\r\tnewTable at: $) asciiValue put: #rightParenthesis.\r\tnewTable at: $. asciiValue put: #period.\r\tnewTable at: $; asciiValue put: #semicolon.\r\tnewTable at: $[ asciiValue put: #leftBracket.\r\tnewTable at: $] asciiValue put: #rightBracket.\r\tnewTable at: ${ asciiValue put: #leftBrace.\r\tnewTable at: $} asciiValue put: #rightBrace.\r\tnewTable at: $^ asciiValue put: #upArrow.\r\tnewTable at: $_ asciiValue put: #xLetter. \"by default, do not accept _ as assignement\"\r\tnewTable at: $| asciiValue put: #verticalBar.\r\tTypeTable := newTable\r"},{"name":"stringHash:initialHash:","linesOfCode":11,"sourceCode":"stringHash: aString initialHash: speciesHash\r\t| stringSize hash low |\r\tstringSize := aString size.\r\thash := speciesHash bitAnd: 16rFFFFFFF.\r\t1 to: stringSize do: [:pos |\r\t\thash := hash + (aString basicAt: pos).\r\t\t\"Begin hashMultiply\"\r\t\tlow := hash bitAnd: 16383.\r\t\thash := (16r260D * low + ((16r260D * (hash // 16384) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.\r\t].\r\t^ hash\r"},{"name":"asExternalTypeOn:","linesOfCode":2,"sourceCode":"asExternalTypeOn: generator \r\t^ generator resolveType: #FFIExternalString"},{"name":"space","linesOfCode":3,"sourceCode":"space\r\t\"Answer a string containing a single space character.\"\r\r\t^ self with: Character space\r"},{"name":"loremIpsum","linesOfCode":4,"sourceCode":"loremIpsum\r\t\"Return a constant string with one paragraph of text, the famous Lorem ipsum filler text.\r\tThe result is pure ASCII (Latin words) and contains no newlines.\"\r\t\r\t^ 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'"},{"name":"crlf","linesOfCode":3,"sourceCode":"crlf\r\t\"Answer a string containing a carriage return and a linefeed.\"\r\r\t^ self with: Character cr with: Character lf\r"},{"name":"typeTable","linesOfCode":3,"sourceCode":"typeTable\r\tTypeTable ifNil: [self initializeTypeTable].\r\t^ TypeTable"},{"name":"empty","linesOfCode":3,"sourceCode":"empty\r\t\"A canonicalized empty String instance.\"\r\t^ ''"}],"meta":null}},{"name":"WideString","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\r\t^ self size * 4.\r"},{"name":"asByteArray","linesOfCode":10,"sourceCode":"asByteArray \r\t\"Convert to a ByteArray with the ascii values of the string.\"\r\t\"'a' asByteArray >>> #[97]\"\r\t\"'A' asByteArray >>> #[65]\"\r\t\"'ABA' asByteArray >>> #[65 66 65]\"\r\t| b |\r\tb := ByteArray new: self byteSize.\r\t1 to: self size * 4 do: [:i |\r\t\tb at: i put: (self byteAt: i)].\r\t^ b"},{"name":"byteAt:","linesOfCode":5,"sourceCode":"byteAt: index\r\r\t| d r |\r\td := (index + 3) // 4.\r\tr := (index - 1) \\\\ 4 + 1.\r\t^ (self wordAt: d) byteAt: ((4 - r) + 1).\r"},{"name":"wordAt:","linesOfCode":3,"sourceCode":"wordAt: index\r\t<primitive: 60>\r\t^ (self basicAt: index).\r"},{"name":"wordAt:put:","linesOfCode":3,"sourceCode":"wordAt: index put: anInteger\r\t<primitive: 61>\r\tself basicAt: index put: anInteger.\r"},{"name":"asFourCode","linesOfCode":9,"sourceCode":"asFourCode\r\r\t| result |\r\tself size = 1 ifFalse: [^ Error signal: 'must be exactly four octets' ].\r\tresult := self basicAt: 1.\r\t(result bitAnd: 16r80000000) = 0 \r\t\tifFalse: [ Error signal: 'cannot resolve fourcode' ].\r\t(result bitAnd: 16r40000000) = 0 \r\t\tifFalse: [ ^ result - 16r80000000 ].\r\t^ result\r"},{"name":"includesUnifiedCharacter","linesOfCode":2,"sourceCode":"includesUnifiedCharacter\r\r\t^ self isUnicodeStringWithCJK\r"},{"name":"isUnicodeStringWithCJK","linesOfCode":2,"sourceCode":"isUnicodeStringWithCJK\r\r\t^self anySatisfy: [:char | Unicode isUnifiedKanji: char charCode]\r\t"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":6,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\r\t<primitive: 105>\r\treplacement class == String ifTrue: [\r\t\t^ self replaceFrom: start to: stop with: (replacement asWideString) startingAt: repStart.\r\t]. \r\r\t^ super replaceFrom: start to: stop with: replacement startingAt: repStart.\r"},{"name":"asUppercase","linesOfCode":4,"sourceCode":"asUppercase\r\t\"Answer a copy of self with all characters in an upper case.\r\tThis might be a difficult task, ask Unicode.\"\r\t\r\t^ Unicode toUppercaseString: self"},{"name":"asLowercase","linesOfCode":4,"sourceCode":"asLowercase\r\t\"Answer a copy of self with all characters in a lower case.\r\tThis might be a difficult task, ask Unicode.\"\r\t\r\t^ Unicode toLowercaseString: self"},{"name":"mutateJISX0208StringToUnicode","linesOfCode":9,"sourceCode":"mutateJISX0208StringToUnicode\r\r\t| c |\r\t1 to: self size do: [:i |\r\t\tc := self at: i.\r\t\t(c leadingChar = JISX0208 leadingChar or: [\r\t\t\tc leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [\r\t\t\tself basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.\r\t\t]\r\t].\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":8,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a wide char string, I know that we have to scan multi-byte characters and handle encodings etc\"\r\t| charSet |\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\tcharSet := self encodedCharSetAt: startIndex.\r\t^charSet scanMultibyteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX font: aFont\t"},{"name":"copyFrom:to:","linesOfCode":5,"sourceCode":"copyFrom: start to: stop\r\r\t| n |\r\tn := super copyFrom: start to: stop.\r\tn isOctetString ifTrue: [^ n asOctetString].\r\t^ n.\r"},{"name":"at:","linesOfCode":10,"sourceCode":"at: index\r\t\"Answer the Character stored in the field of the receiver indexed by the\r\t argument.  Primitive.  Fail if the index argument is not an Integer or is out\r\t of bounds.  Essential.  See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 63>\r\t^index isInteger\r\t\tifTrue:\r\t\t\t[self errorSubscriptBounds: index]\r\t\tifFalse:\r\t\t\t[self errorNonIntegerIndex]"},{"name":"isWideString","linesOfCode":3,"sourceCode":"isWideString\r\t\"Answer whether the receiver is a WideString\"\r\t^true"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString \r\r\t^ self."},{"name":"byteAt:put:","linesOfCode":8,"sourceCode":"byteAt: index put: aByte\r\r\t| d r w |\r\td := (index + 3) // 4.\r\tr := (index - 1) \\\\ 4 + 1.\r\tw := (self wordAt: d) bitAnd: ((16rFF<<((4 - r)*8)) bitInvert32).\r\tw := w + (aByte<<((4 - r)*8)).\r\tself basicAt: d put: w.\r\t^ aByte.\r"},{"name":"at:put:","linesOfCode":15,"sourceCode":"at: index put: aCharacter\r\t\"Store the Character into the field of the receiver indicated by the index.\r\t Primitive.  Fail if the index is not an Integer or is out of bounds, or if the\r\t argument is not a Character.  Essential.  See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 64>\r\taCharacter isCharacter\r\t\tifTrue:\r\t\t\t[index isInteger\r\t\t\t\tifTrue: [ ( index between: 1 and: self size )\r\t\t\t\t\tifFalse: [ ^ self errorSubscriptBounds: index ] ]\r\t\t\t\tifFalse: [ ^ self errorNonIntegerIndex ]]\r\t\tifFalse:\r\t\t\t[ ^ self errorImproperStore ].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #at:put: index: index value: aCharacter ]."},{"name":"findIn:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findIn: body startingAt: start matchTable: matchTable\r\t\r\t^ self findSubstring: self in: body startingAt: start matchTable: matchTable"}],"meta":{"name":"WideString class","instanceVariables":[],"methods":[{"name":"from:","linesOfCode":7,"sourceCode":"from: aString \r\r\t| newString |\r\t(aString isMemberOf: self)\r\t\tifTrue: [^ aString copy].\r\tnewString := self new: aString size.\r\t1 to: aString size do: [:index | newString basicAt: index put: (aString basicAt: index)].\r\t^ newString\r"},{"name":"fromString:","linesOfCode":11,"sourceCode":"fromString: aString \r\t\"Answer an instance of me that is a copy of the argument, aString.\"\r\r\t| inst |\r\t(aString isMemberOf: self) ifTrue: [\r\t\t^ aString copy.\r\t].\r\tinst := self new: aString size.\r\t1 to: aString size do: [:pos |\r\t\tinst basicAt: pos put: (aString basicAt: pos).\r\t].\r\t^ inst.\r"},{"name":"fromByteArray:","linesOfCode":12,"sourceCode":"fromByteArray: aByteArray \r\r\t| inst |\r\taByteArray size \\\\ 4 = 0 ifFalse: [^ ByteString fromByteArray: aByteArray ].\r\tinst := self new: aByteArray size // 4.\r\t4 to: aByteArray size by: 4 do: [:i |\r\t\tinst basicAt: i // 4\r\t\t\tput: ((aByteArray at: i - 3) << 24) + \r\t\t\t\t((aByteArray at: i - 2) << 16) +\r\t\t\t\t ((aByteArray at: i - 1) << 8) +\r\t\t\t\t(aByteArray at: i)\r\t].\r\r\t^ inst\r"},{"name":"newFromStream:","linesOfCode":10,"sourceCode":"newFromStream: s\r\t\"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk.\"\r\t| len |\r\r\ts next = 16r80 ifTrue:\r\t\t[\"A compressed format.  Could copy what BitMap does, or use a \r\t\tspecial sound compression format.  Callers normally compress their own way.\"\r\t\t^ self error: 'not implemented'].\r\ts skip: -1.\r\tlen := s nextInt32.\r\t^ s nextWordsInto: (self basicNew: len)"}],"meta":null}},{"name":"ManifestCollectionsStrings","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsStrings class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'System-Support' )"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Streams' #'Collections-Weak' #'Collections-Native' #'Collections-Support' #Kernel #'Collections-Sequenceable' #'Multilingual-Encodings' #'Collections-Abstract')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Strings'"}],"meta":null}},{"name":"Symbol","instanceVariables":[],"methods":[{"name":"at:put:","linesOfCode":3,"sourceCode":"at: anInteger put: anObject \r\t\"You cannot modify the receiver.\"\r\r\tself errorNoModification"},{"name":"isSymbol","linesOfCode":2,"sourceCode":"isSymbol\r\t^ true "},{"name":"isSelectorSymbol","linesOfCode":2,"sourceCode":"isSelectorSymbol\r\t^ (self class selectorTable like: self) notNil"},{"name":"isTestSelector","linesOfCode":3,"sourceCode":"isTestSelector\r\r\t^ self isUnary and: [ \r\t\t  (self beginsWith: 'test') or: [ self beginsWith: 'should' ] ]"},{"name":"rsValue:","linesOfCode":2,"sourceCode":"rsValue: anObject \r\t^ anObject perform: self"},{"name":"asParser","linesOfCode":3,"sourceCode":"asParser\r\t\"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser.\"\r\r\t^ PPPredicateObjectParser perform: self"},{"name":"includesKey:","linesOfCode":2,"sourceCode":"includesKey: sym\r\t^self == sym."},{"name":"errorNoModification","linesOfCode":2,"sourceCode":"errorNoModification\r\r\tself error: 'symbols can not be modified.'"},{"name":"isInfix","linesOfCode":3,"sourceCode":"isInfix\r\t\"Answer whether the receiver is an infix message selector.\"\r\r\t^ self precedence = 2"},{"name":"stonOn:","linesOfCode":2,"sourceCode":"stonOn: stonWriter\r\tstonWriter writeSymbol: self"},{"name":"asPParser","linesOfCode":3,"sourceCode":"asPParser\r\t\"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser.\"\r\r\t^ PP2NodeFactory instance perform: self"},{"name":"asAnnouncement","linesOfCode":2,"sourceCode":"asAnnouncement\r\r\t^ self"},{"name":"shallowCopy","linesOfCode":2,"sourceCode":"shallowCopy\r\t\"Answer with the receiver, because Symbols are unique.\""},{"name":"gtInspectorImplementorsIn:","linesOfCode":7,"sourceCode":"gtInspectorImplementorsIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\tcomposite list \r\t\ttitle: 'Implementors';\r\t\tdisplay: [ self systemNavigation allImplementorsOf: self ];\r\t\tformat: #name;\r\t\tshowOnly: 30"},{"name":"=","linesOfCode":6,"sourceCode":"= aSymbol\r\t\"Compare the receiver and aSymbol.\" \r\tself == aSymbol ifTrue: [^ true].\r\tself class == aSymbol class ifTrue: [^ false].\r\t\"Use String comparison otherwise\"\r\t^ super = aSymbol"},{"name":"asMetacelloAttributePath","linesOfCode":2,"sourceCode":"asMetacelloAttributePath\r    ^ MetacelloMethodSectionPath with: {self}"},{"name":"noiseValueAt:withAmplitude:withTilingPeriod:","linesOfCode":2,"sourceCode":"noiseValueAt: coord withAmplitude: amplitude withTilingPeriod: tilingPeriod\r\t^ (coord perform: self with: tilingPeriod) * amplitude"},{"name":"isKeyword","linesOfCode":3,"sourceCode":"isKeyword\r\t\"Answer whether the receiver is a message keyword.\"\r\r\t^ self precedence = 3"},{"name":"isMbndAnonymousSymbol","linesOfCode":2,"sourceCode":"isMbndAnonymousSymbol\r\t^ self = #_"},{"name":"flushCache","linesOfCode":3,"sourceCode":"flushCache\r\t\"Tell the virtual machine to remove all entries with this symbol as a selector from its method lookup caches, if it has any.  This \tmust be done whenever a method is added, redefined or removed, so that message lookups reflect the revised organization.  c.f. \tBehavior>>flushCache & CompiledMethod>>flushCache.  Essential. See MethodDictionary class comment.\"\r\r\t<primitive: 119>\r"},{"name":"brickValue:","linesOfCode":2,"sourceCode":"brickValue: aBrick\r\r\t^ self cull: aBrick"},{"name":"isDoIt","linesOfCode":2,"sourceCode":"isDoIt\r\r\t^ (self == #DoIt) or: [self == #DoItIn:]."},{"name":"rwValue:","linesOfCode":2,"sourceCode":"rwValue: anObject \r\t^ anObject perform: self"},{"name":"setPostLoadDoItInMetacelloSpec:","linesOfCode":8,"sourceCode":"setPostLoadDoItInMetacelloSpec: aMetacelloSpec\r    self precedence == 0\r        ifTrue: [ self error: 'Invalid selector' ].\r    aMetacelloSpec\r        setPostLoadDoIt:\r            (aMetacelloSpec project valueHolderSpec\r                value: self;\r                yourself)"},{"name":"setPreLoadDoItInMetacelloSpec:","linesOfCode":8,"sourceCode":"setPreLoadDoItInMetacelloSpec: aMetacelloSpec\r    self precedence == 0\r        ifTrue: [ self error: 'Invalid selector' ].\r    aMetacelloSpec\r        setPreLoadDoIt:\r            (aMetacelloSpec project valueHolderSpec\r                value: self;\r                yourself)"},{"name":"identifiesClapParameter:","linesOfCode":2,"sourceCode":"identifiesClapParameter: aClapParameter\r\t^ self = aClapParameter identifier"},{"name":"gtInspectorSendersIn:","linesOfCode":7,"sourceCode":"gtInspectorSendersIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\tcomposite list \r\t\ttitle: 'Senders';\r\t\tdisplay: [ self systemNavigation allSendersOf: self ];\r\t\tformat: #name;\r\t\tshowOnly: 30 "},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":2,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart\r\r\tself errorNoModification"},{"name":"=>","linesOfCode":5,"sourceCode":"=> aVariable\r\t\"If the slot we give as argument is not present in the image, we create an UndefinedSlot with the AST of the slot definition\"\r\r\t^ aVariable \r\t\tifNil: [ UndefinedSlot named: self ast: thisContext sender sourceNodeExecuted]\r\t\tifNotNil: [ aVariable named: self ]"},{"name":"asGlamourOriginIdentifier","linesOfCode":2,"sourceCode":"asGlamourOriginIdentifier\r\t^ GLMPortIdentifier defaultOriginOf: self"},{"name":"collatedBy:","linesOfCode":4,"sourceCode":"collatedBy: aSortFunction\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated iusing aSortFunction.\"\r\t\"(#('abc' 'de' 'fghi') sorted: (#size collatedBy: [:e|e bitAnd: 1]) , #size) >>> #( 'de' 'fghi' 'abc')\"\r\r\t^PropertySortFunction property: self collatedWith: aSortFunction asSortFunction"},{"name":"brickValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"brickValue: anObject withEnoughArguments: aCollection\r\r\t^ anObject perform: self withEnoughArguments: aCollection"},{"name":"uncapitalized","linesOfCode":3,"sourceCode":"uncapitalized\r\t\"Answer an object like the receiver but with first character downshifted if necessary\"\r\r\t^ self asString uncapitalized asSymbol"},{"name":"asTestSelector","linesOfCode":10,"sourceCode":"asTestSelector\r\r\t\"Converts a method selector into a test selector in form of #testOriginalSelector\"\r\r\t\"#+ asTestSelector >>> #testPlus\"\r\t\"#+-<> asTestSelector >>>  #testPlusMinusLessThanGreaterThan\"\r\t\"#message asTestSelector  >>> #testMessage\"\r\t\"#mySelector asTestSelector >>> #testMySelector\"\r\t\"#at:putNext: asTestSelector >>> #testAtPutNext\"\r\r\tself isBinary ifTrue: [ \r\t\t^ (#test, (self flatCollect: [ :each | (((Character specialCharacterNames at: each) copyReplaceAll: '-' with: ' ') substrings collect: #capitalized) joinUsing: ''])) asSymbol ].\r\t\r\t^ (#test, (((self copyReplaceAll: ':' with: ' ') substrings collect: #capitalized) joinUsing: '')) asSymbol"},{"name":"handlesAnnouncement:","linesOfCode":7,"sourceCode":"handlesAnnouncement: anAnnouncement \r\t\"Anything else than the announcement identifier (in the case of symbol i.e. #foo for ... on: #foo send: #bar to: nil) will not \r\tbe handled.\"\r\t\r\t\"Announcer new \r\t\ton: #FOO send: #bar to: nil;\r\t\tannounce: #FOO should raise DNU bar\"\r\t\r\t^ anAnnouncement == self"},{"name":"senders","linesOfCode":2,"sourceCode":"senders\r\t^ SystemNavigation default allSendersOf: self"},{"name":"cull:","linesOfCode":2,"sourceCode":"cull: anObject \r\t^anObject perform: self."},{"name":"separateKeywords","linesOfCode":11,"sourceCode":"separateKeywords\r\t\"#'foo:zork:' separateKeywords -> 'foo:  zork:'\"\r\r\tself isKeyword\r\t\tifFalse: [ ^ self ].\r\t^ String streamContents: [ :stream | \r\t\t\t(self findTokens: $:) \r\t\t\t\tdo: [ :each | \r\t\t\t\t\tstream\r\t\t\t\t\t\tnextPutAll: each;\r\t\t\t\t\t\tnextPut: $: ]\r\t\t\t\tseparatedBy: [ stream nextPutAll: '  ' ] ]"},{"name":"phlowValue:value:","linesOfCode":2,"sourceCode":"phlowValue: anObject value: otherObject\r\r\t^ anObject perform: self withEnoughArguments: { otherObject }"},{"name":",","linesOfCode":5,"sourceCode":", otherSymbolOrString\r\t\"Concatenate the receiver with otherSymbolOrString and return the result.\r\tOverwritten to always return Symbol results,\r\twhether the argument is a Symbol or a String\"\r\t\r\t^ (super , otherSymbolOrString) asSymbol"},{"name":"prepareForDelivery","linesOfCode":2,"sourceCode":"prepareForDelivery\r\t\"somehow symbol can be announcemnt\""},{"name":"phlowValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"phlowValue: anObject withEnoughArguments: aCollection\r\r\t^ anObject perform: self withEnoughArguments: aCollection"},{"name":"precedence","linesOfCode":8,"sourceCode":"precedence\r\t\"Answer the receiver's precedence, assuming it is a valid Smalltalk\r\tmessage selector or 0 otherwise.  The numbers are 1 for unary,\r\t2 for binary and 3 for keyword selectors.\"\r\r\tself size = 0 ifTrue: [^ 0].\r\t(self first isLetter or: [ self first = $_ ]) ifFalse: [^ 2].\r\tself last = $: ifTrue: [^ 3].\r\t^ 1"},{"name":"asGlamourTargetIdentifier","linesOfCode":2,"sourceCode":"asGlamourTargetIdentifier\r\t^ GLMPortIdentifier defaultTargetOf: self"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createSymbolObjectInstance: self"},{"name":"mbndLiteralTypeWithTarget:","linesOfCode":2,"sourceCode":"mbndLiteralTypeWithTarget: compilationTarget\r\t^ compilationTarget literalSymbolType"},{"name":"isUnary","linesOfCode":3,"sourceCode":"isUnary\r\t\"Answer whether the receiver is an unary message selector.\"\r\r\t^ self precedence = 1"},{"name":"setForDo:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: {self} do: aBlock"},{"name":"copy","linesOfCode":2,"sourceCode":"copy\r\t\"Answer with the receiver, because Symbols are unique.\""},{"name":"sorted:","linesOfCode":3,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then <= is used for comparison. We convert the symbol to an array because symbols can't be changed.\"\r\t\r\t^self asArray sort: aSortBlockOrNil"},{"name":"asMutator","linesOfCode":10,"sourceCode":"asMutator\r\t\"Return a setter message from a getter message.\r\tReturn self if it is already a setter. \r\tPay attention the implementation should be improved to return valid selector.\"\r\t\r\t\"#name asMutator >>> #name:\"\r\t\"#name: asMutator >>> #name:\"\r\r\t\"#_ asMutator >>> #_:\"\r\t\"#foo:: asMutator >>> #'foo::'\"\r\t\r\tself endsWithAColon ifTrue:[ ^ self ].\r\t^ (self copyWith: $:) asSymbol"},{"name":"asSortFunction","linesOfCode":4,"sourceCode":"asSortFunction\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method.\"\r\t\"(#('abc' 'de' 'fghi') sorted: #size ascending) >>> #('de' 'abc' 'fghi')\"\r\r\t^PropertySortFunction property: self"},{"name":"glamourValueWithArgs:","linesOfCode":4,"sourceCode":"glamourValueWithArgs: anArray \r\t \r\tanArray size < 1 ifTrue: [^nil]. \r\t^anArray first perform: self"},{"name":"capitalized","linesOfCode":2,"sourceCode":"capitalized\r\t^ self asString capitalized asSymbol"},{"name":"isBinary","linesOfCode":3,"sourceCode":"isBinary\r\t\"Answer whether the receiver is a binary message selector.\"\r\r\t^ self precedence = 2"},{"name":"value:","linesOfCode":2,"sourceCode":"value: anObject \r\t^anObject perform: self."},{"name":"setForVersion:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForVersion: aString withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: {self} version: aString"},{"name":"asMetacelloAttributeList","linesOfCode":2,"sourceCode":"asMetacelloAttributeList\r    ^ {self}"},{"name":"numArgs:","linesOfCode":14,"sourceCode":"numArgs: n\r\t\"Answer a string that can be used as a selector with n arguments.\r\t TODO: need to be extended to support shrinking and for selectors like #+ \" \r\r\t| selector numArgs offs |\r\t\r\tselector := self.\r\t(numArgs := selector numArgs) >= n \r\t\tifTrue: [ ^ self ].\r\t\r\t^ self class new: 16 streamContents: [ :stream|\r\t\tstream nextPutAll: self.\r\t\t(numArgs = 0) \r\t\t\tifTrue: [ stream nextPut: $:. offs := 0] \r\t\t\tifFalse: [ offs := 1 ].\r\t\t2 to: n - numArgs + offs do: [:i | \r\t\t\tstream nextPutAll: 'with:' ]].\r\t\r"},{"name":"asString","linesOfCode":6,"sourceCode":"asString \r\t\"Refer to the comment in String|asString.\"\r\t| newString |\r\tnewString := self species new: self size.\r\tnewString replaceFrom: 1 to: newString size with: self startingAt: 1.\r\t^newString"},{"name":"asSymbol","linesOfCode":2,"sourceCode":"asSymbol \r\t\"Refer to the comment in String|asSymbol.\""},{"name":"asMethodPreamble","linesOfCode":14,"sourceCode":"asMethodPreamble\r\tself numArgs = 0\r\t\tifTrue: [ ^ self asString ].\r\t^ String\r\t\tstreamContents: [ :str | \r\t\t\t| keywords |\r\t\t\tkeywords := self keywords.\r\t\t\tkeywords\r\t\t\t\tdoWithIndex: [ :each :index | \r\t\t\t\t\tstr\r\t\t\t\t\t\tnextPutAll: each;\r\t\t\t\t\t\tnextPutAll: ' var';\r\t\t\t\t\t\tnextPutAll: index asString.\r\t\t\t\t\tindex = keywords size ifFalse: [ str space ] ] ]"},{"name":"descending","linesOfCode":4,"sourceCode":"descending\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in descending order using the <=> method.\"\r\t\"(#('abc' 'de' 'fghi') sorted: #size descending) >>> #('fghi' 'abc' 'de')\"\r\r\t^self asSortFunction reversed"},{"name":"storeOn:","linesOfCode":5,"sourceCode":"storeOn: aStream \r\r\taStream nextPut: $#.\r\t(self isLiteralSymbol)\r\t\tifTrue: [aStream nextPutAll: self]\r\t\tifFalse: [super storeOn: aStream]"},{"name":"phlowValue:","linesOfCode":2,"sourceCode":"phlowValue: anObject\r\r\t^ self cull: anObject"},{"name":"asIcon","linesOfCode":4,"sourceCode":"asIcon\r\tself deprecated: 'Do not use #foo asIcon but self iconNamed: #foo' \r\t\ttransformWith: '`@rec asIcon'  -> 'self iconNamed: `@rec'.\r\t^ Smalltalk ui icons iconNamed: self"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeSymbol: self"},{"name":"noiseValueAt:withAmplitude:","linesOfCode":2,"sourceCode":"noiseValueAt: coord withAmplitude: amplitude\r\t^ (coord perform: self) * amplitude"},{"name":"ascending","linesOfCode":4,"sourceCode":"ascending\r\t\"Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method.\"\r\t\"(#('abc' 'de' 'fghi') sorted: #size ascending) >>> #('de' 'abc' 'fghi')\"\r\r\t^self asSortFunction "},{"name":"asClapIdentifier","linesOfCode":2,"sourceCode":"asClapIdentifier\r\t^ self"},{"name":"isOrientedFill","linesOfCode":3,"sourceCode":"isOrientedFill\r\t\"Needs to be implemented here because symbols can occupy 'color' slots of morphs.\"\r\r\t^ false"},{"name":"implementors","linesOfCode":2,"sourceCode":"implementors\r\t^SystemNavigation new allImplementorsOf: self"},{"name":"string:","linesOfCode":3,"sourceCode":"string: aString\r\r\t1 to: aString size do: [:j | super at: j put: (aString at: j)].\r\t^self  "},{"name":"veryDeepCopyWith:","linesOfCode":2,"sourceCode":"veryDeepCopyWith: deepCopier\r\t\"Return self.  I am immutable in the Morphic world.  Do not record me.\""}],"meta":{"name":"Symbol class","instanceVariables":[],"methods":[{"name":"selectorsContaining:","linesOfCode":26,"sourceCode":"selectorsContaining: aString\r\t\"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter.\"\r\r\t| size selectorList ascii |\r\r\tselectorList := OrderedCollection new.\r\t(size := aString size) = 0 ifTrue: [^selectorList].\r\r\taString size = 1 ifTrue:\r\t\t[\r\t\t\tascii := aString first asciiValue.\r\t\t\tascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]\r\t\t].\r\r\t(aString first isAlphaNumeric) ifFalse:\r\t\t[\r\t\t\taString size = 2 ifTrue: \r\t\t\t\t[Symbol hasInterned: aString ifTrue:\r\t\t\t\t\t[:s | selectorList add: s]].\r\t\t\t^selectorList\r\t\t].\r\r\tselectorList := selectorList copyFrom: 2 to: selectorList size.\r\r\tself allSymbolTablesDo: [:each |\r\t\teach size >= size ifTrue:\r\t\t\t[(each findSubstring: aString in: each startingAt: 1 \r\t\t\t\tmatchTable: CaseInsensitiveOrder) > 0\r\t\t\t\t\t\tifTrue: [selectorList add: each]]].\r\r\t^selectorList reject: [:each | \"reject non-selectors, but keep ones that begin with an uppercase\"\r\t\teach numArgs < 0 and: [each asString uncapitalized numArgs < 0]].\r\r\"Symbol selectorsContaining: 'scon'\""},{"name":"new:","linesOfCode":2,"sourceCode":"new: aSize\r\r\tself shouldNotImplement ."},{"name":"new:streamContents:","linesOfCode":2,"sourceCode":"new: size streamContents: aBlock\r\t^ (super new: size streamContents: aBlock) asSymbol"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ String"},{"name":"thatStarts:skipping:","linesOfCode":25,"sourceCode":"thatStarts: leadingCharacters skipping: skipSym\r\t\"Answer a selector symbol that starts with leadingCharacters.\r\tSymbols beginning with a lower-case letter handled directly here.\r\tIgnore case after first char.\r\tIf skipSym is not nil, it is a previous answer; start searching after it.\r\tIf no symbols are found, answer nil.\r\tUsed by Alt-q (Command-q) routines\"\r\r\t| size firstMatch key |\r\r\tsize := leadingCharacters size.\r\tsize = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].\r\r\tfirstMatch := leadingCharacters at: 1.\r\tsize > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].\r\r\tself allSymbolTablesDo: [:each |\r\t\t\teach size >= size ifTrue:\r\t\t\t\t[\r\t\t\t\t\t((each at: 1) == firstMatch and:\r\t\t\t\t\t\t[key == nil or:\r\t\t\t\t\t\t\t[(each findString: key startingAt: 2 caseSensitive: false) = 2]])\r\t\t\t\t\t\t\t\tifTrue: [^each]\r\t\t\t\t]\r\t\t] after: skipSym.\r\r\t^nil\r\r\"Symbol thatStarts: 'sf' skipping: nil\"\r\"Symbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:\"\r\"Symbol thatStarts: 'candidate' skipping: nil\"\r"},{"name":"rehash","linesOfCode":6,"sourceCode":"rehash\r   \"Symbol rehash\"\r\t\"Rebuild the hash table, reclaiming unreferenced Symbols.\"\r\r\tSymbolTable := WeakSet withAll: self allSubInstances.\r\tNewSymbols := WeakSet new.\r\tself rebuildSelectorTable."},{"name":"forbiddenSelectorsForMethodFinder","linesOfCode":2,"sourceCode":"forbiddenSelectorsForMethodFinder\r\r\t^ #(string: privateAt:put:)"},{"name":"findInterned:","linesOfCode":3,"sourceCode":"findInterned: aString\r\r\tself hasInterned:aString ifTrue:[:symbol| ^symbol].\r\t^nil."},{"name":"allSymbols","linesOfCode":7,"sourceCode":"allSymbols\r\t\"Answer all interned symbols\"\r\t^Array streamContents:[:s|\r\t\ts nextPutAll: NewSymbols.\r\t\ts nextPutAll: OneCharacterSymbols.\r\t\ts nextPutAll: SymbolTable.\r\t].\r"},{"name":"initSelectorTable","linesOfCode":2,"sourceCode":"initSelectorTable\r\t^ SelectorTable := WeakSet new"},{"name":"hasInterned:ifTrue:","linesOfCode":8,"sourceCode":"hasInterned: aString ifTrue: symBlock\r\t\"Answer with false if aString hasnt been interned (into a Symbol),  \r\totherwise supply the symbol to symBlock and return true.\"\r\r\t^ (self lookup: aString)\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :symbol | \r\t\t\tsymBlock value: symbol.\r\t\t\ttrue ]"},{"name":"possibleSelectorsFor:","linesOfCode":23,"sourceCode":"possibleSelectorsFor: misspelled \r\t\"Answer an ordered collection of possible corrections\r\tfor the misspelled selector in order of likelyhood\"\r\r\t| numArgs candidates lookupString best binary short long first |\r\tlookupString := misspelled asLowercase. \"correct uppercase selectors to lowercase\"\r\tnumArgs := lookupString numArgs.\r\t(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].\r\tfirst := lookupString first.\r\tshort := lookupString size - (lookupString size // 4 max: 3) max: 2.\r\tlong := lookupString size + (lookupString size // 4 max: 3).\r\r\t\"First assemble candidates for detailed scoring\"\r\tcandidates := OrderedCollection new.\r\tself allSymbolTablesDo: [:s | | ss | (((ss := s size) >= short\t\"not too short\"\r\t\t\tand: [ss <= long\t\t\t\"not too long\"\r\t\t\t\t\tor: [(s at: 1) = first]])\t\"well, any length OK if starts w/same letter\"\r\t\t\tand: [s numArgs = numArgs])\t\"and numArgs is the same\"\r\t\t\tifTrue: [candidates add: s]].\r\r\t\"Then further prune these by correctAgainst:\"\r\tbest := lookupString correctAgainst: candidates.\r\t((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [\r\t\tbinary := misspelled, ':'.\t\t\"try for missing colon\"\r\t\tSymbol hasInterned: binary ifTrue: [:him | best addFirst: him]].\r\t^ best"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r\t^ (aCollection as: String) asSymbol\r\r\"\tSymbol newFrom: {$P. $e. $n}\r\t{$P. $e. $n} as: Symbol\r\""},{"name":"allSymbolTablesDo:after:","linesOfCode":3,"sourceCode":"allSymbolTablesDo: aBlock after: aSymbol\r\r\tNewSymbols do: aBlock after: aSymbol.\r\tSymbolTable do: aBlock after: aSymbol."},{"name":"withAll:","linesOfCode":2,"sourceCode":"withAll: aCollection\r\t^ self newFrom: aCollection"},{"name":"shutDown:","linesOfCode":3,"sourceCode":"shutDown: aboutToQuit\r\r\tSymbolTable addAll: NewSymbols.\r\tNewSymbols := WeakSet new.\r"},{"name":"internSelector:","linesOfCode":5,"sourceCode":"internSelector: aStringOrSymbol\r\t| selector |\r\tselector := (self selectorTable like: aStringOrSymbol)\r\t\tifNil: [ self selectorTable add: aStringOrSymbol asSymbol ].\r\t^ selector"},{"name":"readFrom:","linesOfCode":4,"sourceCode":"readFrom: strm  \r\t\"Symbol readFromString: '#abc'\"\r\r\tstrm peek = $# ifFalse: [self error: 'Symbols must be introduced by #'].\r    \t^ strm contents parseLiterals first.\r "},{"name":"cleanUp","linesOfCode":4,"sourceCode":"cleanUp\r\t\"Flush caches\"\r\r\tself compactSymbolTable.\r\tself rebuildSelectorTable"},{"name":"selectorTable","linesOfCode":2,"sourceCode":"selectorTable\r\t^SelectorTable ifNil: [self initSelectorTable]"},{"name":"findInternedSelector:","linesOfCode":8,"sourceCode":"findInternedSelector: aString\r\t| symbol |\r\tsymbol := self findInterned: aString.\r\t\"if it isn't found or not a SelectorSymbol - return nil\"\r\t(symbol isNil or: [ symbol isSelectorSymbol not ])\r\t\tifTrue: [ ^ nil ].\r\t\"otherwise, return this symbol\"\r\t^ symbol"},{"name":"selectorThatStartsCaseSensitive:skipping:","linesOfCode":17,"sourceCode":"selectorThatStartsCaseSensitive: leadingCharacters skipping: skipSym\r\t\"Same as thatStartsCaseSensitive:skipping: but on the SelectorTable only\"\r\t| size firstMatch key |\r\r\tsize := leadingCharacters size.\r\tsize = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].\r\tfirstMatch := leadingCharacters at: 1.\r\tsize > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].\r\tself selectorTable do: [:each |\r\t\t\t(each notNil and: [each size >= size]) ifTrue:\r\t\t\t\t[\r\t\t\t\t\t((each at: 1) == firstMatch and:\r\t\t\t\t\t\t[key == nil or:\r\t\t\t\t\t\t\t[(each findString: key startingAt: 2 caseSensitive: true) = 2]])\r\t\t\t\t\t\t\t\tifTrue: [^each]\r\t\t\t\t]\r\t\t] after: skipSym.\r\r\t^nil\r"},{"name":"allSymbolTablesDo:","linesOfCode":3,"sourceCode":"allSymbolTablesDo: aBlock\r\r\tNewSymbols do: aBlock.\r\tSymbolTable do: aBlock."},{"name":"compactSymbolTable","linesOfCode":7,"sourceCode":"compactSymbolTable\r\t\"Reduce the size of the symbol table so that it holds all existing symbols + 25% (changed from 1000 since sets like to have 25% free and the extra space would grow back in a hurry)\"\r\r\t| oldSize |\r\r\tSmalltalk garbageCollect.\r\toldSize := SymbolTable array size.\r\tSymbolTable growTo: SymbolTable size * 4 // 3 + 100.\r\t^oldSize printString,'  ',(oldSize - SymbolTable array size) printString, ' slot(s) reclaimed'"},{"name":"initialize","linesOfCode":6,"sourceCode":"initialize\r\tSymbol rehash.\r\tOneCharacterSymbols := nil.\r\tOneCharacterSymbols := (1 to: 256) collect: [ :i | (i - 1) asCharacter asSymbol].\r\r\tSessionManager default\r\t\tregisterSystemClassNamed: #Symbol"},{"name":"thatStartsCaseSensitive:skipping:","linesOfCode":17,"sourceCode":"thatStartsCaseSensitive: leadingCharacters skipping: skipSym\r\t\"Same as thatStarts:skipping: but caseSensitive\"\r\t| size firstMatch key |\r\r\tsize := leadingCharacters size.\r\tsize = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].\r\tfirstMatch := leadingCharacters at: 1.\r\tsize > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].\r\tself allSymbolTablesDo: [:each |\r\t\t\teach size >= size ifTrue:\r\t\t\t\t[\r\t\t\t\t\t((each at: 1) == firstMatch and:\r\t\t\t\t\t\t[key == nil or:\r\t\t\t\t\t\t\t[(each findString: key startingAt: 2 caseSensitive: true) = 2]])\r\t\t\t\t\t\t\t\tifTrue: [^each]\r\t\t\t\t]\r\t\t] after: skipSym.\r\r\t^nil\r"},{"name":"with:","linesOfCode":2,"sourceCode":"with: aCharacter\r\t^self newFrom: aCharacter asOrderedCollection"},{"name":"internCharacter:","linesOfCode":4,"sourceCode":"internCharacter: aCharacter\r\taCharacter asciiValue > 256 ifTrue:[^self intern: aCharacter asString].\r\tOneCharacterSymbols ifNil: [^self intern: aCharacter asString].\r\t^OneCharacterSymbols at: aCharacter asciiValue + 1\r"},{"name":"intern:","linesOfCode":12,"sourceCode":"intern: aStringOrSymbol \r\r\t^(self lookup: aStringOrSymbol) ifNil:[\r\t\t| aClass aSymbol |\r\t\taStringOrSymbol isSymbol ifTrue:[\r\t\t\taSymbol := aStringOrSymbol.\r\t\t] ifFalse:[\r\t\t\taClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[WideSymbol].\r\t\t\taSymbol := aClass basicNew: aStringOrSymbol size.\r\t\t\taSymbol string: aStringOrSymbol.\r\t\t].\r\t\tNewSymbols add: aSymbol.\r\t\taSymbol]."},{"name":"rebuildSelectorTable","linesOfCode":7,"sourceCode":"rebuildSelectorTable\r\tself initSelectorTable.\r\tCompiledMethod\r\t\tallInstancesDo: [ :method | \r\t\t\t| selector |\r\t\t\tselector := method selector.\r\t\t\tselector ifNotNil: [ SelectorTable add: selector ] ]"},{"name":"lookup:","linesOfCode":4,"sourceCode":"lookup: aStringOrSymbol\r\r\t^(SymbolTable like: aStringOrSymbol) ifNil: [\r\t\tNewSymbols like: aStringOrSymbol\r\t]"}],"meta":null}},{"name":"WideSymbol","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\r\t^ self size * 4.\r"},{"name":"byteAt:","linesOfCode":5,"sourceCode":"byteAt: index\r\r\t| d r |\r\td := (index + 3) // 4.\r\tr := (index - 1) \\\\ 4 + 1.\r\t^ (self wordAt: d) byteAt: ((4 - r) + 1).\r"},{"name":"wordAt:","linesOfCode":3,"sourceCode":"wordAt: index\r\t<primitive: 60>\r\t^ (self basicAt: index).\r"},{"name":"wordAt:put:","linesOfCode":2,"sourceCode":"wordAt: index put: anInteger\r\t^ self modificationForbiddenFor: #wordAt:put: index: index value: anInteger "},{"name":"mutateJISX0208StringToUnicode","linesOfCode":9,"sourceCode":"mutateJISX0208StringToUnicode\r\r\t| c |\r\t1 to: self size do: [:i |\r\t\tc := self at: i.\r\t\t(c leadingChar = JISX0208 leadingChar or: [\r\t\t\tc leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [\r\t\t\tself basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.\r\t\t]\r\t].\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":8,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a wide char string, I know that we have to scan multi-byte characters and handle encodings etc\"\r\t| charSet |\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\tcharSet := self encodedCharSetAt: startIndex.\r\t^charSet scanMultibyteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX font: aFont\t"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index \r\t\"Answer the Character stored in the field of the receiver indexed by the argument.\"\r\t^ Character value: (self wordAt: index).\r"},{"name":"isWideString","linesOfCode":3,"sourceCode":"isWideString\r\t\"Answer whether the receiver is a WideString\"\r\t^true"},{"name":"species","linesOfCode":3,"sourceCode":"species\r\t\"Answer the preferred class for reconstructing the receiver.\"\r\t^WideString\r"},{"name":"asWideString","linesOfCode":2,"sourceCode":"asWideString \r\r\t^ self."},{"name":"string:","linesOfCode":4,"sourceCode":"string: aString\r\t1 to: aString size do: [:j | \r\t\tself privateAt: j put: (aString at: j) asInteger].\r\t^ self"},{"name":"byteAt:put:","linesOfCode":2,"sourceCode":"byteAt: index put: aByte\r\t^ self modificationForbiddenFor: #byteAt:put: index: index value: aByte"},{"name":"privateAt:put:","linesOfCode":12,"sourceCode":"privateAt: index put: aCharacter\r\t\"Primitive. Store the Character in the field of the receiver indicated by\r\tthe index. Fail if the index is not an Integer or is out of bounds, or if\r\tthe argument is not a Character. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 61>\r\tindex isInteger\r\t\tifTrue: [ (index between: 1 and: self size)\r\t\t\tifFalse: [ ^ self errorSubscriptBounds: index] ]\r\t\tifFalse: [^ self errorNonIntegerIndex].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #privateAt:put: index: index value: aCharacter ].\r"},{"name":"findIn:startingAt:matchTable:","linesOfCode":2,"sourceCode":"findIn: body startingAt: start matchTable: matchTable\r\t\r\t^ self findSubstring: self in: body startingAt: start matchTable: matchTable"}],"meta":{"name":"WideSymbol class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ByteSymbol","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self size"},{"name":"asByteArray","linesOfCode":6,"sourceCode":"asByteArray\r\t| ba sz |\r\tsz := self byteSize.\r\tba := ByteArray new: sz.\r\tba replaceFrom: 1 to: sz with: self startingAt: 1.\r\t^ba"},{"name":"asOctetString","linesOfCode":2,"sourceCode":"asOctetString\r\t^ self"},{"name":"byteAt:","linesOfCode":3,"sourceCode":"byteAt: index\r\t<primitive: 60>\r\t^(self at: index) asciiValue"},{"name":"serializeOn:","linesOfCode":2,"sourceCode":"serializeOn: anEncoder\r\r\tanEncoder encodeString: self"},{"name":"indexOfAnyOf:startingAt:","linesOfCode":3,"sourceCode":"indexOfAnyOf: aCollection startingAt: start\r\t\"Use double dispatching for speed\"\r\t^aCollection findFirstInByteString: self startingAt: start"},{"name":"isByteString","linesOfCode":3,"sourceCode":"isByteString\r\t\"Answer whether the receiver is a ByteString\"\r\t^true"},{"name":"findSubstring:in:startingAt:matchTable:","linesOfCode":4,"sourceCode":"findSubstring: key in: body startingAt: start matchTable: matchTable\r\t\"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.\"\r\t<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>\r\t^super findSubstring: key in: body startingAt: start matchTable: matchTable"},{"name":"isOctetString","linesOfCode":5,"sourceCode":"isOctetString\r\t\"Answer whether the receiver can be represented as a byte string. \r\tThis is different from asking whether the receiver *is* a ByteString \r\t(i.e., #isByteString)\"\r\t^ true.\r"},{"name":"scanCharactersFrom:to:with:rightX:font:","linesOfCode":6,"sourceCode":"scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX  font: aFont\r\t\"NB: strongly consider getting almost all these parameters from the scanner\"\r\t\"Since I'm a byte char string, I know that we have to scan single-byte characters and don't have to handle encodings etc\"\r\tstartIndex > stopIndex\r\t\tifTrue: [^aCharacterScanner handleEndOfRunAt: stopIndex].\r\t^aFont scanByteCharactersFrom: startIndex to: stopIndex in: self with: aCharacterScanner rightX: rightX"},{"name":"beginsWith:","linesOfCode":14,"sourceCode":"beginsWith: prefix\r\t\"Answer whether the receiver begins with the given prefix string.\r\tThe comparison is case-sensitive.\"\r\r\t\"IMPLEMENTATION NOTE:\r\tfollowing algorithm is optimized in primitive only in case self and prefix are bytes like.\r\tOtherwise, if self is wide, then super outperforms,\r\tOtherwise, if prefix is wide, primitive is not correct\"\r\r\t\"(#pharo beginsWith: #pharoProject) >>> false\"\r\t\"(#pharo beginsWith: #phuro) >>> false\"\r\t\"(#pharo beginsWith: #pha) >>> true\"\r\t\r\tprefix class isBytes ifFalse: [^super beginsWith: prefix].\r\t\r\tself size < prefix size ifTrue: [^ false].\r\t^ (self findSubstring: prefix in: self startingAt: 1\r\t\t\tmatchTable: CaseSensitiveOrder) = 1"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitHookPrimitive: self"},{"name":"at:","linesOfCode":6,"sourceCode":"at: index \r\t\"Primitive. Answer the Character stored in the field of the receiver\r\tindexed by the argument. Fail if the index argument is not an Integer or\r\tis out of bounds. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 63>\r\t^ Character value: (super at: index)"},{"name":"asKmCategoryIn:","linesOfCode":2,"sourceCode":"asKmCategoryIn: aKmRepository\r\t^aKmRepository categoryForName: self"},{"name":"tfPointerAddress","linesOfCode":3,"sourceCode":"tfPointerAddress\r\r\tself pinInMemory.\r\t^ PointerUtils oopForObject: self\r"},{"name":"species","linesOfCode":3,"sourceCode":"species\r\t\"Answer the preferred class for reconstructing the receiver.\"\r\t^ByteString\r"},{"name":"string:","linesOfCode":4,"sourceCode":"string: aString\r\t1 to: aString size do: [:j | \r\t\tself privateAt: j put: (aString at: j)].\r\t^self"},{"name":"indexOfAnyOf:startingAt:ifAbsent:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection startingAt: start ifAbsent: aBlock\r\t\"Use double dispatching for speed\"\r\t| index |\r\t^(index := aCollection findFirstInByteString: self startingAt: start) = 0\r\t\tifTrue: [aBlock value]\r\t\tifFalse: [index]"},{"name":"byteAt:put:","linesOfCode":3,"sourceCode":"byteAt: anInteger put: anObject \r\t\"You cannot modify the receiver.\"\r\t^ self modificationForbiddenFor: #byteAt:put: index: anInteger value: anObject"},{"name":"privateAt:put:","linesOfCode":14,"sourceCode":"privateAt: index put: aCharacter\r\t\"Primitive. Store the Character in the field of the receiver indicated by\r\tthe index. Fail if the index is not an Integer or is out of bounds, or if\r\tthe argument is not a Character. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 64>\r\taCharacter isCharacter \r\t\tifFalse:[^self errorImproperStore].\r\tindex isInteger\r\t\tifTrue: [ (index between: 1 and: self size)\r\t\t\t\tifFalse: [ self errorSubscriptBounds: index] ]\r\t\tifFalse: [self errorNonIntegerIndex].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #privateAt:put: index: index value: aCharacter ].\r"},{"name":"hasWideCharacterFrom:to:","linesOfCode":3,"sourceCode":"hasWideCharacterFrom: start to: stop\r\t\"Always false because I only contains byte characters\"\r\t^false"}],"meta":{"name":"ByteSymbol class","instanceVariables":[],"methods":[{"name":"stringHash:initialHash:","linesOfCode":2,"sourceCode":"stringHash: aString initialHash: speciesHash\r\t^ByteString stringHash: aString initialHash: speciesHash"},{"name":"materializeFrom:","linesOfCode":2,"sourceCode":"materializeFrom: aDecoder\r\r\t^ aDecoder nextEncodedString asSymbol"},{"name":"findFirstInString:inSet:startingAt:","linesOfCode":2,"sourceCode":"findFirstInString: aString inSet: inclusionMap startingAt: start\r\t^ByteString findFirstInString: aString  inSet: inclusionMap startingAt: start"},{"name":"indexOfAscii:inString:startingAt:","linesOfCode":2,"sourceCode":"indexOfAscii: anInteger inString: aString startingAt: start\r\t^ByteString indexOfAscii: anInteger inString: aString startingAt: start"},{"name":"translate:from:to:table:","linesOfCode":2,"sourceCode":"translate: aString from: start  to: stop  table: table\r\t^ByteString translate: aString from: start  to: stop  table: table"}],"meta":null}}]},{"name":"Collections-Weak","classes":[{"name":"WeakArray","instanceVariables":[],"methods":[],"meta":{"name":"WeakArray class","instanceVariables":[],"methods":[{"name":"doOldFinalization","linesOfCode":7,"sourceCode":"doOldFinalization\r\t\"Process the weak registries, in the old finalization style.  Hopefully this will\r\t eventually go away when all clients have adopted the new finalization scheme.\"\r\tFinalizationLock critical: [\r\t\t\tFinalizationDependents do: \t[:weakDependent |\r\t\t\t\tweakDependent ifNotNil: [\r\t\t\t\t\t[ weakDependent finalizeValues ] on: Exception fork: [:ex | ex pass ] ]]]."},{"name":"finalizationProcess","linesOfCode":19,"sourceCode":"finalizationProcess\r\t\"The finalization process arranges to send mourn to each element of the VM's finalization queue,\r\t which is accessed via primitiveFetchMourner.  The VM signals FinalizationSemaphore whenever\r\t the queue is non-empty.  This process loops, waiting on the semaphore, fetches the first element\r\t of the queue and then spawns a process at a higher priority to acually send the mourn messages.\r\t If an error occurs in the higher priority mourn loop process then this process will simply spawn\r\t another process, hence ensuring that errors in finalization methods don't break finalization.\r\r\t In addition this process also runs the old finalization scheme, supporting clients of the older,\r\t WeakRegistry based scheme.  Hopefully this will go away when all cleints have moved over.\"\r\t| throttle firstMourner |\r\tthrottle := Semaphore new.\r\t[true] whileTrue: [FinalizationSemaphore wait; initSignals.\r\t \"Support the old scheme until things have changed over...\"\r\t self doOldFinalization.\r\t [firstMourner := self primitiveFetchMourner.\r\t  firstMourner notNil] whileTrue:\r\t\t[[throttle signal.\r\t\t  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1.\r\t\t throttle wait]]"},{"name":"restartFinalizationProcess","linesOfCode":11,"sourceCode":"restartFinalizationProcess\r\t\"kill any old process, just in case\"\r\tFinalizationProcess\r\t\tifNotNil: [FinalizationProcess terminate.\r\t\t\tFinalizationProcess := nil].\r\r\tFinalizationSemaphore := Smalltalk specialObjectsArray at: 42.\r\tFinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].\r\tFinalizationLock := Semaphore forMutualExclusion.\r\t\r\tFinalizationProcess := [self finalizationProcess]\r\t\tforkAt: Processor userInterruptPriority.\r\tFinalizationProcess name: 'WeakArray Finalization Process'."},{"name":"addWeakDependent:","linesOfCode":18,"sourceCode":"addWeakDependent: anObject\r\t\r\tFinalizationLock critical:[ | index finished weakDependent |\r\t\tfinished := false.\r\t\tindex := 0.\r\t\t[index := index + 1.\r\t\tfinished not and:[index <= FinalizationDependents size]] whileTrue:[\r\t\t\tweakDependent := FinalizationDependents at: index.\r\t\t\tweakDependent ifNil: [\r\t\t\t\tFinalizationDependents at: index put: anObject.\r\t\t\t\tfinished := true.\r\t\t\t].\r\t\t].\r\t\tfinished ifFalse:[\r\t\t\t\"Grow linearly\"\r\t\t\tFinalizationDependents := FinalizationDependents, (WeakArray new: 10).\r\t\t\tFinalizationDependents at: index put: anObject.\r\t\t].\r\t] ifError: [:err | err signal]."},{"name":"hasWeakDependent:","linesOfCode":2,"sourceCode":"hasWeakDependent: anObject\r\t^FinalizationDependents includes: anObject"},{"name":"initialize","linesOfCode":9,"sourceCode":"initialize\r\t\"Do we need to initialize specialObjectsArray?\"\r\tSmalltalk specialObjectsArray size < 42 \r\t\tifTrue: [Smalltalk recreateSpecialObjectsArray].\r\r\tSessionManager default\r\t\tregisterSystemClassNamed: self name.\r\r\tFinalizationSemaphore := Smalltalk specialObjectsArray at: 42.\r\tFinalizationLock := Semaphore forMutualExclusion.\r\tFinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10]."},{"name":"pvtCreateTemporaryObjectIn:","linesOfCode":3,"sourceCode":"pvtCreateTemporaryObjectIn: tempObject\r\t\"We have to create the temporary object in a separate stack frame\"\r\ttempObject at: 1 put: Object new"},{"name":"runningFinalizationProcess","linesOfCode":3,"sourceCode":"runningFinalizationProcess\r\t\"Answer the FinalizationProcess I am running, if any\"\r\t^FinalizationProcess"},{"name":"startUp:","linesOfCode":3,"sourceCode":"startUp: resuming\r\tresuming ifFalse: [ ^self ].\r\tself restartFinalizationProcess."},{"name":"removeWeakDependent:","linesOfCode":8,"sourceCode":"removeWeakDependent: anObject\r\tFinalizationLock critical:[\r\t\t1 to: FinalizationDependents size do:[:i|\r\t\t\t((FinalizationDependents at: i) == anObject) ifTrue:[\r\t\t\t\tFinalizationDependents at: i put: nil.\r\t\t\t].\r\t\t].\r\t] ifError: [:err | err signal]."},{"name":"mournLoopWith:","linesOfCode":10,"sourceCode":"mournLoopWith: firstMourner\r\t\"Send mourn to all the objects available in the mourn queue, starting\r\t with firstMourner which the sender has already extraced for us.  If\r\t an error occurs here, it will break this loop but the sender will spawn\r\t another mournLoopWith: so that finalization is not broken by errors in\r\t individual cases.\"\r\t| mourner |\r\tmourner := firstMourner.\r\t[mourner mourn.\r\t (mourner := self primitiveFetchMourner) notNil] whileTrue"},{"name":"primitiveFetchMourner","linesOfCode":9,"sourceCode":"primitiveFetchMourner\r\t\"Answer the next mourner in the VM's queue of objects to be finalized.\r\t The queue contains weak arrays and ephemerons.  If the primitive is\r\t not implemented, raise an error telling people to upgrade the VM.  If\r\t implemented, the primitive fails if the queue is empty, with the error\r\t code #'not found'. Primitive.  Essential.\"\r\r\t<primitive: 172 error: ec>\r\tec ifNil: [^self error: 'The primitiveFetchMourner primitive is missing.\\Please upgrade your virtual machine to one that has the primitive.' withCRs].\r\t^nil"}],"meta":null}},{"name":"WeakIdentityKeyDictionary","instanceVariables":[],"methods":[{"name":"compare:to:","linesOfCode":2,"sourceCode":"compare: object1 to: object2\r\t^ object1 == object2"},{"name":"startIndexFor:","linesOfCode":3,"sourceCode":"startIndexFor: anObject\r\t\"Return the index at which the scan for anObject should start.\"\r\t\r\t^(anObject identityHash \\\\ array size) + 1"},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"valuesDo:","linesOfCode":14,"sourceCode":"valuesDo: aBlock \r\t\"See comments in Dictionary>>valuesDo:.  The code keeps the key so it's\r\tnot collected during the evaluation of aBlock\"\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: array size do:\r\t\t[ :eachIndex | \r\t\t\t| eachAssociation eachKey |\r\t\t\teachAssociation := array at: eachIndex.\r\t\t\tnil == eachAssociation ifFalse:\r\t\t\t\t[\r\t\t\t\t\teachKey := eachAssociation key.\r\t\t\t\t\tnil == eachKey ifFalse: [ aBlock value: eachAssociation value ]\r\t\t\t\t]\r\t\t]"}],"meta":{"name":"WeakIdentityKeyDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakIdentityValueDictionary","instanceVariables":[],"methods":[{"name":"keyAtValue:ifAbsent:","linesOfCode":6,"sourceCode":"keyAtValue: value ifAbsent: exceptionBlock\r\t\"Answer the key that is the external name for the argument, value. If \r\tthere is none, answer the result of evaluating exceptionBlock.\"\r \r\tself associationsDo: \r\t\t[:association | value == association value ifTrue: [^ association key]].\r\t^ exceptionBlock value"},{"name":"scanFor:","linesOfCode":14,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t| finish start element |\r\tfinish := array size.\r\tstart := (anObject identityHash \\\\ finish) + 1.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [element key == anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"}],"meta":{"name":"WeakIdentityValueDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakIdentitySet","instanceVariables":[],"methods":[{"name":"scanFor:","linesOfCode":10,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either flag (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := anObject identityHash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element enclosedElement == anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"scanForEmptySlotFor:","linesOfCode":9,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by flag or a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey identityHash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element == nil ]) ifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"}],"meta":{"name":"WeakIdentitySet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakValueDictionary","instanceVariables":[],"methods":[{"name":"size","linesOfCode":5,"sourceCode":"size\r\t| count |\r\tcount := 0.\r\tself valuesDo: [ :each | count := count + 1 ].\r\t^ count"},{"name":"clyIncludesCleanedKey:","linesOfCode":3,"sourceCode":"clyIncludesCleanedKey: key\r\t\"Answer whether the receiver has a key which value was collected as garbage\"\r\t\r\t^ (array at: (self scanFor: key)) value == nil"},{"name":"valuesDo:","linesOfCode":7,"sourceCode":"valuesDo: aBlock\r\t\"See comments in Dictionary>>valuesDo:.  The code keeps\r\ta reference to the value to facilitate debugging\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\t1 to: array size do: [ :eachIndex | \r\t\t(array at: eachIndex) value\r\t\t\tifNotNil: [ :assocValue | aBlock value: assocValue enclosedElement ] ]"},{"name":"includesKey:","linesOfCode":5,"sourceCode":"includesKey: key\r\t\"Answer whether the receiver has a key equal to the argument and also that the value associated to this key was not garbage collected.\"\r\r\t^ (array at: (self scanFor: key))\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :value | value value isNotNil ]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation\r\tself at: anAssociation key put: anAssociation value.\r\t^ anAssociation"},{"name":"rehash","linesOfCode":5,"sourceCode":"rehash\r\t| newSelf |\r\tnewSelf := self species new: self size.\r\tarray do: [ :each | each value ifNotNil: [ :asso | newSelf noCheckAdd: each ] ].\r\tarray := newSelf array"},{"name":"associationsDo:","linesOfCode":4,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value associations).\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\tarray do: [ :each | each value ifNotNil: [ :value | aBlock value: each key -> value enclosedElement ] ]"},{"name":"associationAt:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifAbsent: aBlock\r\t\"Answer the association with the given key.\r\tIf the key is not found, return the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key))\r\t\tifNil: [ aBlock value ]\r\t\tifNotNil: [ :assoc | assoc key -> assoc value enclosedElement ]"},{"name":"at:ifPresent:ifAbsentOrNil:","linesOfCode":8,"sourceCode":"at: key ifPresent: presentBlock ifAbsentOrNil: absentBlock\r\r\t^ self \r\t\tat: key\r\t\tifPresent: [:valueOrNil | \r\t\t\tvalueOrNil\r\t\t\t\tifNotNil: presentBlock\r\t\t\t\tifNil: absentBlock ]\r\t\tifAbsent: absentBlock"},{"name":"clyCleanGarbage","linesOfCode":9,"sourceCode":"clyCleanGarbage\r\r\t| firstFound |\r\tarray withIndexDo: [:ass :index | \r\t\t(ass notNil and: [ass value isNil]) ifTrue: [ \r\t\t\tarray at: index put: nil.\r\t\t\ttally := tally - 1.\r\t\t\tfirstFound ifNil: [firstFound := index]]].\r\t\r\tfirstFound ifNotNil: [ \r\t\tself fixCollisionsFrom: firstFound]"},{"name":"at:ifPresent:","linesOfCode":6,"sourceCode":"at: key ifPresent: aBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the given block optionally with the value associated\r\twith the key.\r\tOtherwise, answer nil.\"\r\r\t^ (array at: (self findElementOrNil: key)) value ifNotNil: [ :value | aBlock cull: value enclosedElement ]"},{"name":"privateAssociations","linesOfCode":3,"sourceCode":"privateAssociations\r\t\"I am a method used for test to return the WeakValueAssociations instead of Associations.\"\r\r\t^ array select: [ :each | each value isNotNil ]"},{"name":"at:ifAbsent:","linesOfCode":6,"sourceCode":"at: key ifAbsent: aBlock\r\t\"Answer the value associated with the key or, if key isn't found,\r\tanswer the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key)) value\r\t\t\tifNil: aBlock\r\t\t\tifNotNil: [ :value | value enclosedElement ]"},{"name":"at:put:","linesOfCode":9,"sourceCode":"at: key put: anObject\r\t\"Set the value at key to be anObject.  If key is not found, create a new\r\tentry for key and set is value to anObject. Answer anObject.\"\r\r\t| index |\r\tindex := self findElementOrNil: key.\r\t(array at: index)\r\t\tifNil: [ self atNewIndex: index put: (WeakValueAssociation key: key value: anObject asCollectionElement) ]\r\t\tifNotNil: [ :element | element value: anObject asCollectionElement ].\r\t^ anObject"}],"meta":{"name":"WeakValueDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakKeyToCollectionDictionary","instanceVariables":[],"methods":[{"name":"noCheckAddForRehash:","linesOfCode":8,"sourceCode":"noCheckAddForRehash: anAssociation\r\t| cleanedValue |\r\tanAssociation key ifNil:[^self].\r\tcleanedValue := anAssociation value copyWithout: nil.\r\tcleanedValue notEmpty ifTrue:[\r\t\tanAssociation value: cleanedValue.\r\t\tsuper noCheckAddForRehash: anAssociation.\r\t]."},{"name":"finalizeValues","linesOfCode":2,"sourceCode":"finalizeValues \r\tself rehash"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":14,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\ttally := 0.\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :association |\r\t\t\tassociation key ifNotNil: [ :key | \"Don't let the key go away\"\r\t\t\t\t| cleanedValue |\r\t\t\t\t(cleanedValue := association value copyWithout: nil) isEmpty \r\t\t\t\t\tifFalse: [\r\t\t\t\t\t\tassociation value: cleanedValue.\r\t\t\t\t\t\tarray\r\t\t\t\t\t\t\tat: (self scanForEmptySlotFor: key)\r\t\t\t\t\t\t\tput: association.\r\t\t\t\t\t\ttally := tally + 1 ] ] ] ]"}],"meta":{"name":"WeakKeyToCollectionDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakOrderedCollection","instanceVariables":[],"methods":[],"meta":{"name":"WeakOrderedCollection class","instanceVariables":[],"methods":[{"name":"arrayType","linesOfCode":2,"sourceCode":"arrayType\r\t^ WeakArray"}],"meta":null}},{"name":"WeakRegistry","instanceVariables":[{"name":"list"},{"name":"valueDictionary"},{"name":"sema"}],"methods":[{"name":"protected:","linesOfCode":5,"sourceCode":"protected: aBlock\r\t\"Execute aBlock protected by the accessLock\"\r\r\t^ sema\r\t\tcritical: aBlock\r\t\tifError: [ :err | err signal ]"},{"name":"removeAll","linesOfCode":6,"sourceCode":"removeAll\r\t\"See super\"\r\t\r\tself protected:[\r\t\tvalueDictionary removeAll.\r\t\tlist swapWithNil. \"prune finalization list as well\"\r\t]"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ self protected: [ valueDictionary slowSize ]"},{"name":"finalizeValues","linesOfCode":24,"sourceCode":"finalizeValues\r\t\"Finalize any values, which happen to stocked in our list, due to some weak references become garbage\"\r\t\r\t| finalizer |\r\r\t\"Do the old way, if VM don't supports us\"\r\tWeakFinalizationList hasNewFinalization ifFalse: [ | finalizers |\r\t\tfinalizers := OrderedCollection new.\r\t\tself protected: [ \r\t\t\tvalueDictionary expiredValuesDo: [:finItem |\r\t\t\t\tfinalizers add: finItem\r\t\t\t\t].\r\t\t ].\r\t\tfinalizers do: [:each | [each finalizeValues] on: Exception fork: [:ex | ex pass ] ].\r\t\t^ self ].\r\r\tself protected: [ finalizer := list swapWithNil ].\r\r\t\"We don't need to protect a following loop from concurrent access,\r\tbecause at the moment we're finalizing values, \r\tonly we can access this list of finalizers, because valueDictionary already see them\r\tas an unused slots, because they're associated with key == nil\"\r\t\r\t[ finalizer notNil ] whileTrue: [\r\t\t| next |\r\t\tnext := finalizer next.\r\t\t[ finalizer finalizeValues] on: Exception fork: [:ex | ex pass ].\r\t\tfinalizer := next\r\t]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anObject\r\t\"Add anObject to the receiver. Store the object as well as the associated executor.\"\r\t\r\t^self add: anObject executor: anObject executor"},{"name":"initialize","linesOfCode":6,"sourceCode":"initialize\r\tsuper initialize.\r\tvalueDictionary := WeakIdentityKeyDictionary new.\r\tlist := WeakFinalizationList new.\r\tsema := Semaphore forMutualExclusion.\r\tself installFinalizer"},{"name":"keys","linesOfCode":2,"sourceCode":"keys\r\r\t^self protected: [ valueDictionary keys ]\r"},{"name":"printElementsOn:","linesOfCode":3,"sourceCode":"printElementsOn: aStream\r\tsema ifNil: [ ^super printElementsOn: aStream ].\r\taStream nextPutAll: '(<this WeakRegistry is locked>)'"},{"name":"add:executor:","linesOfCode":12,"sourceCode":"add: anObject executor: anExecutor\r\t\"With new finalization, we can simply override associations with key == nil in valueDictionary \"\r\tself protected: [ | finItem |\r\t\tfinItem := valueDictionary at: anObject ifAbsent: [\r\t\t\tWeakFinalizationList hasNewFinalization ifTrue: [\r\t\t\t\tvalueDictionary overridingAt: anObject put: (WeakFinalizerItem new list: list object: anObject) ]\r\t\t\tifFalse: [\r\t\t\t\tvalueDictionary at: anObject put: (WeakFinalizerItem new list: list object: anObject) \r\t\t\t\t]\r\t\t].\r\t\tfinItem add: anExecutor ].\r\t^ anObject\r"},{"name":"postCopy","linesOfCode":12,"sourceCode":"postCopy\r\t\"should we prohibit any attempts to copy receiver?\"\r\tself protected: [ | oldDict |\r\t\tsema := Semaphore forMutualExclusion.\r\t\toldDict := valueDictionary.\r\t\tlist := WeakFinalizationList new.\r\t\tvalueDictionary := WeakIdentityKeyDictionary new.\r\t\tself installFinalizer.\r\t\r\t\toldDict keysAndValuesDo: [:key :value |\r\t\t\tvalueDictionary at: key put: (value copyWithList: list)\r\t\t].\r\t]"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock\r\t^self protected: [\r\t\tvalueDictionary keysDo: aBlock\r\t]\r"},{"name":"installFinalizer","linesOfCode":4,"sourceCode":"installFinalizer\r\t\"Do nothing, pharo does not supports it right now\r\t  valueDictionary finalizer: #finalizeValues\r\t\""},{"name":"species","linesOfCode":2,"sourceCode":"species\r\t^Set"},{"name":"remove:ifAbsent:","linesOfCode":5,"sourceCode":"remove: oldObject ifAbsent: exceptionBlock\r\t\"Remove oldObject as one of the receiver's elements.\"\r\t\r\toldObject ifNil: [ ^nil ].\r\t^(self protected: [ valueDictionary removeKey: oldObject ifAbsent: nil ])\r\t\tifNil: [ exceptionBlock value ]"}],"meta":{"name":"WeakRegistry class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: n\r\t^ self new"},{"name":"default","linesOfCode":2,"sourceCode":"default\r\t^Default ifNil: [ Default := self new ]"},{"name":"new","linesOfCode":5,"sourceCode":"new\r\t| registry |\r\tregistry := super new.\r\tWeakArray addWeakDependent: registry.\r\t^registry\r"}],"meta":null}},{"name":"WeakKeyDictionary","instanceVariables":[{"name":"expired"},{"name":"finalizer"}],"methods":[{"name":"allAssociationsDo:","linesOfCode":6,"sourceCode":"allAssociationsDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations). This includes associations with nil keys, except for\r\tthe expired ones.\"\r\r\tsuper associationsDo: [:association | \r\t\tassociation expired ifFalse:[aBlock value: association]]."},{"name":"grow","linesOfCode":3,"sourceCode":"grow\r\tsuper grow.\r\texpired := 0."},{"name":"expiredValuesDo:","linesOfCode":10,"sourceCode":"expiredValuesDo: aBlock\r\t\"Clear all associations with nil keys\"\r\t1 to: array size do:[:i | | assoc |\r\t\tassoc := array at: i.\r\t\t(assoc notNil and: [ assoc key isNil and: [assoc expired not ]])\r\t\tifTrue: [ \r\t\t\taBlock value: assoc value.\r\t\t\tassoc expire.\r\t\t\texpired := expired + 1.\r\t\t\ttally := tally - 1.\t]]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation\r\tself at: anAssociation key put: anAssociation value.\r\t^ anAssociation"},{"name":"rehash","linesOfCode":4,"sourceCode":"rehash\r\t\"Rehash the receiver.\"\r\tsuper rehash.\r\texpired := 0."},{"name":"associationsDo:","linesOfCode":7,"sourceCode":"associationsDo: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).\"\r\r\t\r\r\tsuper associationsDo: [:association | | key | \r\t\t\"Hold onto the key so it won't be collected while the block is evaluated.\"\r\t\tkey := association key.\r\t\tkey ifNotNil:[aBlock value: association]]."},{"name":"overridingAt:put:","linesOfCode":19,"sourceCode":"overridingAt: key put: anObject\r\r\t\"Set the value at key to be anObject.  If key is not found, create a new\r\tentry for key and set is value to anObject. Answer anObject.\r\tMay override an association with key == nil\"\r\r\t| index element |\r\r\tkey ifNil: [ ^ anObject ].\r\tindex := self scanForKeyOrNil: key.\t\"There should always be room.\"\r\tindex = 0\r\t\tifTrue: [ self error: 'No space left in dictionary' ].\r\r\telement := array at: index.\r\telement == nil\r\t\tifTrue: [ self atNewIndex: index put: ( WeakKeyAssociation key: key value: anObject ) ]\r\t\tifFalse: [ element expired\r\t\t\t\tifTrue: [ tally := tally + 1 ].\r\t\t\telement key: key.\r\t\t\telement value: anObject.\r\t\t\tself fullCheck\r\t\t\t].\r\t^ anObject"},{"name":"scanFor:","linesOfCode":15,"sourceCode":"scanFor: anObject\r\t\"mvl 10/21/2007: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForEmpty: must be changed in the receiver as well.\"\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. Expired associations are ignored, since callers take non-nil slots as a successful search. Subclasses should override startIndexFor: and compare:to: if they have a different semantics for matching elements.\"\r\t| element start finish |\r\tfinish := array size.\r\tstart := self startIndexFor: anObject.\r\t\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [self compare: element key to: anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [self compare: element key to: anObject])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"scanForKeyOrNil:","linesOfCode":14,"sourceCode":"scanForKeyOrNil: anObject\r\t\"Same as scanFor: , but treats association with key == nil as empty slot\"\r\t\r\t| element start finish |\r\tfinish := array size.\r\tstart := self startIndexFor: anObject.\r\t\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil or: [ element key isNil or: [self compare: element key to: anObject]])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil or: [ element key isNil or: [self compare: element key to: anObject]])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"valueAtNewKey:put:atIndex:declareFrom:","linesOfCode":2,"sourceCode":"valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary \r\tself shouldNotImplement."},{"name":"valuesDo:","linesOfCode":9,"sourceCode":"valuesDo: aBlock\r\t\"See comments in Dictionary>>valuesDo:\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\t1 to: array size do: [ :eachIndex | \r\t\t(array at: eachIndex) ifNotNil: [ :eachAssociation | \r\t\t\t| eachKey |\r\t\t\t\"The code keeps the key so it's not collected during the evaluation of aBlock\"\r\t\t\teachKey := eachAssociation key.\r\t\t\taBlock value: eachAssociation value ] ]"},{"name":"postCopy","linesOfCode":9,"sourceCode":"postCopy\r\t\"Must copy the associations, or later store will affect both the\roriginal and the copy\"\r\r\tarray := array\r\t\tcollect: [ :assoc | \r\t\t\tassoc\r\t\t\t\tifNotNil: [ assoc expired\r\t\t\t\t\t\tifTrue: [ WeakKeyAssociation expired ]\r\t\t\t\t\t\tifFalse: [ WeakKeyAssociation key: assoc key value: assoc value ] ] ]"},{"name":"isHealthy","linesOfCode":14,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in the receiver,\r\tanswer true if everything ok, false otherwise\r\t\r\tWeakKeyDictionary allInstances select: [:dict |\r\t\tdict isHealthy not ]\r\tDictionary allSubInstances select: [:dict |\r\t\tdict isHealthy not ]\r\t\"\r\tarray withIndexDo: [:elem :i |\r\t\t(elem notNil and: [elem key notNil ])\r\t\t\t\tifTrue:  [(self scanFor: elem key) == i ifFalse: [ ^ false ]\r\t\t\t]\r\t].\r\t^ true"},{"name":"fullCheck","linesOfCode":8,"sourceCode":"fullCheck\r\t\"Inlined super fullCheck, since the correct + X value for rehash check depends on its implementation\"\r\t\"Keep array at least 1/4 free for decent hash behavior\"\r\tarray size - tally < (array size // 4 max: 1)\r\t\tifTrue: [self grow].\r\t\"Make sure we never have so many expired entries that adding might fail\"\r\t4 * expired + 4 > array size \r\t\tifTrue: [self rehash]."},{"name":"removeKey:ifAbsent:","linesOfCode":14,"sourceCode":"removeKey: key ifAbsent: aBlock\r\t\"Remove key (and its associated value) from the receiver. If key is not in \r\tthe receiver, answer the result of evaluating aBlock. Otherwise, answer \r\tthe value externally named by key.\"\r\r\t| index result assoc |\r\tindex := self findElementOrNil: key.\r\tassoc := array at: index.\r\t(assoc == nil or: [assoc key isNil]) ifTrue: [ ^ aBlock value ].\r\tassoc key: nil.\r\tresult := assoc value.\r\tassoc expire.\r\texpired := expired + 1.\r\ttally := tally - 1.\r\t^result"},{"name":"startIndexFor:","linesOfCode":3,"sourceCode":"startIndexFor: anObject\r\t\"Return the index at which the scan for anObject should start.\"\r\t\r\t^(anObject hash \\\\ array size) + 1"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":12,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\ttally := 0.\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :association |\r\t\t\tassociation key \r\t\t\t\tifNil: [ finalizer ifNotNil: [ finalizer value: association value ] ]\r\t\t\t\tifNotNil: [ :key | \"Don't let the key go away\"\r\t\t\t\t\tarray\r\t\t\t\t\t\tat: (self scanForEmptySlotFor: key)\r\t\t\t\t\t\tput: association.\r\t\t\t\t\ttally := tally + 1 ] ] ]"},{"name":"finalizeValues:","linesOfCode":9,"sourceCode":"finalizeValues: finiObjects\r\t\"Clear all associations with key == nil and value is in finiObjects.\"\r\tarray do:[:assoc|\r\t\t(assoc notNil and:[finiObjects includes: assoc value]) ifTrue:[\r\t\t\tassoc expire.\r\t\t\texpired := expired + 1.\r\t\t\ttally := tally - 1.\r\t\t].\r\t].\r"},{"name":"noCheckAddForRehash:","linesOfCode":2,"sourceCode":"noCheckAddForRehash: anAssociation\r\t^self noCheckAdd: anAssociation"},{"name":"finalizeValues","linesOfCode":13,"sourceCode":"finalizeValues\r\t\"Clear all associations with nil keys.\r\tAvoid using block closures, so it won't produce many garbage \r\t(since pushing closure as argument requires creating its preinitialized copy)\"\r\t1 to: array size do:[:i | | assoc |\r\t\tassoc := array at: i.\r\t\tassoc ifNotNil:[\r\t\t\tassoc expire ifTrue:[\r\t\t\t\texpired := expired + 1.\r\t\t\t\ttally := tally - 1.\r\t\t\t].\r\t\t].\r\t].\r"},{"name":"initialize:","linesOfCode":3,"sourceCode":"initialize: n\r\texpired := 0.\r\t^super initialize: n"},{"name":"noCheckAdd:","linesOfCode":18,"sourceCode":"noCheckAdd: anAssociation\r\t\"Add anAssociation to the receiver. Discard expired associations. Put nil keys at the beginning.\"\r\t\r\t| key |\r\t\r\tkey := anAssociation key. \"Hold on to the key during this method\"\r\r\tanAssociation expired ifFalse:[\r\t\tkey ifNotNil:[\r\t\t\tsuper noCheckAdd: anAssociation\r\t\t] ifNil: [\r\t\t\t1 to: array size do:[:n|\r\t\t\t\t(array at: n) ifNil:[\r\t\t\t\t\tarray at: n put: anAssociation. \r\t\t\t\t\ttally := tally + 1.\r\t\t\t\t\t^self\r\t\t\t\t].\r\t\t\t].\r\t\t\tself error: 'could not find an empty slot.'\r\t\t].\r\t]."},{"name":"slowSize","linesOfCode":11,"sourceCode":"slowSize\r\t\"Careful! Answer the maximum amount\r\tof elements in the receiver, not the\r\texact amount\"\r\r\t| count |\r\tcount := 0.\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject expired ifFalse: [\r\t\t\t\tcount := count + 1 ] ] ].\r\t^count"},{"name":"fixCollisionsFrom:","linesOfCode":3,"sourceCode":"fixCollisionsFrom: oldIndex\r\t\"This is an internal method that should not be needed in WeakKeyDictionary\"\r\tself shouldNotImplement."},{"name":"scanForEmpty:","linesOfCode":35,"sourceCode":"scanForEmpty: anObject\r\t\"Scan the key array for the first slot containing either a nil or an expired association (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found.\"\r\t| element start finish firstNil |\r\tfinish := array size.\r\tstart := self startIndexFor: anObject.\r\tfirstNil := nil.\r\t\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == nil \r\t\t\t\t\t\tor: [self compare: element key to: anObject])\r\t\t\tifTrue: [\r\t\t\t\t\"If we found no match, and have an expired slot, use that one.\"\r\t\t\t\t(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].\r\t\t\t\t^ index \r\t\t\t].\r\t\t\t\"If this slot is expired, and we haven't seen an earlier expired slot, record it\"\r\t\t\t(element notNil \r\t\t\t\tand: [element expired \r\t\t\t\t\t\tand: [firstNil isNil]]) ifTrue: [firstNil := index].\r\t\t].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == nil \r\t\t\t\t\tor: [self compare: element key to: anObject])\r\t\t\tifTrue: [\r\t\t\t\t(element isNil and: [firstNil notNil]) ifTrue:[^firstNil].\r\t\t\t\t^ index \r\t\t\t].\r\t\t\t(element notNil \r\t\t\t\tand: [element expired \r\t\t\t\t\t\tand: [firstNil isNil]]) ifTrue: [firstNil := index].\r\t\t].\r\r\t\"If there is no empty slot, but an expired one, return it.\"\t\r\tfirstNil notNil ifTrue:[^firstNil].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"at:put:","linesOfCode":18,"sourceCode":"at: key put: anObject\r\r\t\"Set the value at key to be anObject.  If key is not found, create a new\r\tentry for key and set is value to anObject. Answer anObject.\"\r\r\t| index element |\r\r\tkey ifNil: [ ^ anObject ].\r\tindex := self scanForEmpty: key.\t\"There should always be room.\"\r\tindex = 0\r\t\tifTrue: [ self error: 'No space left in dictionary' ].\r\r\telement := array at: index.\r\telement == nil\r\t\tifTrue: [ self atNewIndex: index put: ( WeakKeyAssociation key: key value: anObject ) ]\r\t\tifFalse: [ element expired\r\t\t\t\tifTrue: [ tally := tally + 1 ].\r\t\t\telement key: key.\r\t\t\telement value: anObject.\r\t\t\tself fullCheck\r\t\t\t].\r\t^ anObject"},{"name":"compare:to:","linesOfCode":2,"sourceCode":"compare: object1 to: object2\r\t^object1 = object2"}],"meta":{"name":"WeakKeyDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WeakSet","instanceVariables":[{"name":"flag"}],"methods":[{"name":"growTo:","linesOfCode":6,"sourceCode":"growTo: anInteger\r\t\"Grow the elements array and reinsert the old elements\"\r\r\t| oldElements |\r\toldElements := array.\r\tarray := WeakArray new: anInteger withAll: flag.\r\tself noCheckNoGrowFillFrom: oldElements"},{"name":"scanForLoadedSymbol:","linesOfCode":14,"sourceCode":"scanForLoadedSymbol: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements\"\r\r\t| element start finish |\r\r\tstart := (anObject hash \\\\ array size) + 1.\r\tfinish := array size.\r\r\t\"Search from (hash mod size) to the end.\"\r\tstart to: finish do:\r\t\t[:index | ((element := array at: index) == flag or: [element asString = anObject asString])\r\t\t\tifTrue: [^ index ]].\r\r\t\"Search from 1 to where we started.\"\r\t1 to: start-1 do:\r\t\t[:index | ((element := array at: index) == flag or: [element asString = anObject asString])\r\t\t\tifTrue: [^ index ]].\r\r\t^ 0  \"No match AND no empty slot\""},{"name":"grow","linesOfCode":9,"sourceCode":"grow\r\t\"Grow the elements array if needed.\r\tSince WeakSets just nil their slots, alot of the occupied (in the eyes of the set) slots are usually \tempty. Doubling size if unneeded can lead to BAD performance, therefore we see if reassigning \tthe <live> elements to a Set of similiar size leads to a sufficiently (50% used here) empty set first.\r\tand reinsert the old elements\"\r\r\t| oldTally |\r\toldTally := tally.\r\tself growTo: array size.\r\toldTally >> 1 < tally\r\t\tifTrue: [ self growTo: (HashTableSizes atLeast: 2 * array size) ]"},{"name":"scanFor:","linesOfCode":10,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either flag (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\r\t| index start |\r\tindex := start := anObject hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element enclosedElement = anObject ])\r\t\t\tifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"anyOne","linesOfCode":7,"sourceCode":"anyOne\r\t\"First we will try to return any real object which is not garbage collected. It will skip all slots with flag. In case when everything is garbage collected we will return nil. WeakSet is not empty in this case (isEmpty will return false). So we should not signal any error\"\r\t| result |\r\tresult := super anyOne.\r\t^result == self \r\t\tifTrue: [ nil ] \r\t\tifFalse: [ result ]"},{"name":"add:","linesOfCode":8,"sourceCode":"add: newObject\r\t\"Include newObject as one of the receiver's elements, but only if\r\tnot already present. Answer newObject\"\r\r\t| index element |\r\tindex := self scanFor: newObject.\r\t((element := array at: index) == flag or: [ element == nil ])\r\t\tifTrue: [self atNewIndex: index put: newObject asCollectionElement].\r\t^newObject"},{"name":"includes:","linesOfCode":4,"sourceCode":"includes: anObject \r\t\r\t^(array at: (self scanFor: anObject))\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :object | object ~~ flag ]"},{"name":"initialize:","linesOfCode":6,"sourceCode":"initialize: n\r\t\"Initialize array to an array size of n\"\r\r\tflag := Object new.\r\tarray := WeakArray new: n.\r\tarray atAllPut: flag.\r\ttally := 0"},{"name":"printElementsOn:","linesOfCode":7,"sourceCode":"printElementsOn: aStream\r\t| oldPos |\r\taStream nextPut: $(.\r\toldPos := aStream position.\r\tself do: [:element | aStream print: element; space].\r\taStream position > oldPos ifTrue: [aStream skip: -1 \"remove the extra space\"].\r\taStream nextPut: $)"},{"name":"do:after:","linesOfCode":10,"sourceCode":"do: aBlock after: anElement\r\r\t| startIndex |\r\ttally = 0 ifTrue: [ ^self ].\r\tstartIndex := anElement\r\t\tifNil: [ 0 ]\r\t\tifNotNil: [ self scanFor: anElement ].\r\tstartIndex + 1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [\r\t\t\t\taBlock value: object enclosedElement] ] ]"},{"name":"like:ifAbsent:","linesOfCode":7,"sourceCode":"like: anObject ifAbsent: aBlock\r\t\"Answer an object in the receiver that is equal to anObject,\r\tor evaluate the block if not found. Relies heavily on hash properties\"\r\r\t| element |\r\t^ ((element := array at: (self scanFor: anObject)) == flag or: [ element == nil ])\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ element enclosedElement ]"},{"name":"collect:","linesOfCode":9,"sourceCode":"collect: aBlock\r\r\t| newSet |\r\tnewSet := self species new: self size.\r\ttally = 0 ifTrue: [ ^newSet ].\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [\r\t\t\t\tnewSet add: (aBlock value: object enclosedElement) ] ] ].\r\t^newSet"},{"name":"rehash","linesOfCode":2,"sourceCode":"rehash\r\tself growTo: array size"},{"name":"fixCollisionsFrom:","linesOfCode":17,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by flag.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one.\"\r\r\t| element index |\r\tindex := start.\r\t[ (element := array at: (index := index \\\\ array size + 1)) == flag ] whileFalse: [\r\t\telement \r\t\t\tifNil: [ \"This object is gone\"\r\t\t\t\tarray at: index put: flag.\r\t\t\t\ttally := tally - 1 ]\r\t\t\tifNotNil: [\r\t\t\t\t| newIndex |\r\t\t\t\t(newIndex := self scanFor: element enclosedElement) = index ifFalse: [\r\t\t\t\t\tarray \r\t\t\t\t\t\tat: newIndex put: element;\r\t\t\t\t\t\tat: index put: flag ] ] ]\r"},{"name":"slowSize","linesOfCode":11,"sourceCode":"slowSize\r\t\"Careful! Answer the maximum amount\r\tof elements in the receiver, not the\r\texact amount\"\r\r\t| count |\r\tcount := 0.\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [\r\t\t\t\tcount := count + 1 ] ] ].\r\t^count"},{"name":"asArray","linesOfCode":5,"sourceCode":"asArray\r\r\t| newArray |\r\t\r\tnewArray := OrderedCollection new.\r\t\r\tself do: [:each | newArray add: each].\r\t\r\t^ newArray asArray"},{"name":"postCopy","linesOfCode":6,"sourceCode":"postCopy\r\t| oldFlag |\r\tsuper postCopy.\r\toldFlag := flag.\r\tflag := Object new.\r\tarray replaceAll: oldFlag with: flag."},{"name":"isHealthy","linesOfCode":11,"sourceCode":"isHealthy\r\t\"Test that object hashes match their positions stored in set's array,\r\tanswer true if everything ok, false otherwise\r\t\r\tWeakSet allSubInstances select: [:badSet |\r\t\tbadSet isHealthy not ]\r\t\"\r\tarray withIndexDo: [ :element :index |\r\t\t(element isNotNil and: [ element ~~ flag ]) ifTrue: [\r\t\t\t(self scanFor: element) == index\r\t\t\t\tifFalse: [ ^ false ]]].\r\t^ true"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock\r\r\ttally = 0 ifTrue: [ ^self ].\r\t1 to: array size do: [ :index |\r\t\t(array at: index) ifNotNil: [ :object |\r\t\t\tobject  == flag ifFalse: [\r\t\t\t\taBlock value: object enclosedElement] ] ]"},{"name":"like:","linesOfCode":6,"sourceCode":"like: anObject\r\t\"Answer an object in the receiver that is equal to anObject,\r\tnil if no such object is found. Relies heavily on hash properties\"\r\r\t| element |\r\t^(element  := array at: (self scanFor: anObject)) == flag\r\t\tifFalse: [ element enclosedElement]"},{"name":"remove:ifAbsent:","linesOfCode":8,"sourceCode":"remove: oldObject ifAbsent: aBlock\r\r\t| index |\r\tindex := self scanFor: oldObject.\r\t(array at: index) == flag ifTrue: [ ^ aBlock value ].\r\tarray at: index put: flag.\r\ttally := tally - 1.\r\tself fixCollisionsFrom: index.\r\t^oldObject"},{"name":"scanForEmptySlotFor:","linesOfCode":9,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by flag or a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey hash \\\\ array size + 1.\r\t[ \r\t\t| element |\r\t\t((element := array at: index) == flag or: [ element == nil ]) ifTrue: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":10,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\r\ttally := 0.\r\t1 to: anArray size do: [ :index |\r\t\t(anArray at: index) ifNotNil: [ :object |\r\t\t\tobject == flag ifFalse: [ \r\t\t\t\tarray\r\t\t\t\t\tat: (self scanForEmptySlotFor: object enclosedElement)\r\t\t\t\t\tput: object.\r\t\t\t\ttally := tally + 1 ] ] ]"}],"meta":{"name":"WeakSet class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ManifestCollectionsWeak","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsWeak class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'System-Support' #'Collections-Streams')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'System-Finalization' #'Collections-Support' #'Collections-Sequenceable' #'Collections-Unordered' #'Collections-Abstract' #Kernel)"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Weak'"}],"meta":null}}]},{"name":"Collections-Abstract","classes":[{"name":"HashedCollection","instanceVariables":[{"name":"tally"},{"name":"array"}],"methods":[{"name":"growTo:","linesOfCode":6,"sourceCode":"growTo: anInteger\r\t\"Grow the elements array and reinsert the old elements\"\r\t\r\t| oldElements |\r\toldElements := array.\r\tarray := Array new: anInteger.\r\tself noCheckNoGrowFillFrom: oldElements"},{"name":"grow","linesOfCode":10,"sourceCode":"grow\r\t\"Grow the elements array and reinsert the old elements\"\r\r\t| oldElements |\r\toldElements := array.\r\tarray := Array new: (HashTableSizes atLeast: oldElements size * 2).\r\ttally := 0.\r\toldElements\r\t\tdo:\r\t\t\t[ :each | \r\t\t\teach ifNotNil: [ self noCheckAdd: each ] ]"},{"name":"scanFor:","linesOfCode":3,"sourceCode":"scanFor: anObject\r\t\"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\tself subclassResponsibility"},{"name":"rehash","linesOfCode":2,"sourceCode":"rehash\r\tself growTo: self capacity"},{"name":"add:withOccurrences:","linesOfCode":5,"sourceCode":"add: newObject withOccurrences: anInteger\r\t\"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject.\"\r\t\r\tanInteger < 1 ifTrue: [ ^newObject ].\r\t\"I can only store an object once.\"\r\t^ self add: newObject"},{"name":"union:","linesOfCode":3,"sourceCode":"union: aCollection\r\t\"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all.\"\r\r\t^ self copy addAll: aCollection; yourself"},{"name":"atNewIndex:put:","linesOfCode":4,"sourceCode":"atNewIndex: index put: anObject\r\tarray at: index put: anObject.\r\ttally := tally + 1.\r\tself fullCheck"},{"name":"growSize","linesOfCode":3,"sourceCode":"growSize\r\t\"Answer what my next higher table size should be\"\r\r\t^HashTableSizes atLeast: self capacity * 3 // 2 + 2\r\t"},{"name":"comeFullyUpOnReload:","linesOfCode":4,"sourceCode":"comeFullyUpOnReload: smartRefStream\r\t\"Symbols have new hashes in this image.\"\r\r\tself  compact.\r\t\"^ self\"\r"},{"name":"fullCheck","linesOfCode":4,"sourceCode":"fullCheck\r\t\"Keep array at least 1/4 free for decent hash behavior\"\r\tarray size - tally < (array size // 4 max: 1)\r\t\tifTrue: [self grow]"},{"name":"compact","linesOfCode":5,"sourceCode":"compact\r\t\"Reduce the size of array so that the load factor will be ~75%.\"\r\t\r\t| newCapacity |\r\tnewCapacity := HashTableSizes atLeast: tally * 4 // 3.\r\tself growTo: newCapacity"},{"name":"scanForEmptySlotFor:","linesOfCode":8,"sourceCode":"scanForEmptySlotFor: aKey\r\t\"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements.\"\r\t\r\t| index start |\r\tindex := start := aKey hash \\\\ array size + 1.\r\t[ \r\t\t(array at: index) ifNil: [ ^index ].\r\t\t(index := index \\\\ array size + 1) = start ] whileFalse.\r\tself errorNoFreeSpace"},{"name":"metaLinkOptions","linesOfCode":5,"sourceCode":"metaLinkOptions\r\t^{\r\t#findElementOrNil: -> #( + optionCompileOnLinkInstallation).\r\t#metaLinkOptions -> #( + optionCompileOnLinkInstallation)\r\t}"},{"name":"noCheckNoGrowFillFrom:","linesOfCode":3,"sourceCode":"noCheckNoGrowFillFrom: anArray\r\t\"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require.\"\r\t\r\tself subclassResponsibility"},{"name":"removeAll","linesOfCode":4,"sourceCode":"removeAll\r\t\"remove all elements from this collection.\r\tPreserve the capacity\"\r\t\r\tself initialize: self capacity"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ tally"},{"name":"initialize:","linesOfCode":4,"sourceCode":"initialize: n\r\t\"Initialize array to an array size of n\"\r\tarray := Array new: n.\r\ttally := 0"},{"name":"capacity","linesOfCode":3,"sourceCode":"capacity\r\t\"Answer the current capacity of the receiver.\"\r\r\t^ array size"},{"name":"errorNoFreeSpace","linesOfCode":2,"sourceCode":"errorNoFreeSpace\r\r\tself error: 'There is no free space in this collection!'"},{"name":"noCheckAdd:","linesOfCode":2,"sourceCode":"noCheckAdd: anObject\r\r    self subclassResponsibility"},{"name":"array","linesOfCode":2,"sourceCode":"array\r\t^ array"},{"name":"fixCollisionsFrom:","linesOfCode":5,"sourceCode":"fixCollisionsFrom: start\r\t\"The element at start has been removed and replaced by nil.\r\tThis method moves forward from there, relocating any entries\r\tthat had been placed below due to collisions with this one.\"\r\t\r\tself subclassResponsibility"},{"name":"findElementOrNil:","linesOfCode":9,"sourceCode":"findElementOrNil: anObject\r\t\"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found.\"\r\r\t| index |\r\r\tindex := self scanFor: anObject.\r\tindex > 0 ifTrue: [^index].\r\r\t\"Bad scene.  Neither have we found a matching element\r\tnor even an empty slot.  No hashed set is ever supposed to get\r\tcompletely full.\"\r\tself error: 'There is no free space in this set!'."},{"name":"fuelAfterMaterialization","linesOfCode":2,"sourceCode":"fuelAfterMaterialization\r\r\tself rehash"},{"name":"veryDeepCopyWith:","linesOfCode":6,"sourceCode":"veryDeepCopyWith: deepCopier\r\t| copyOfSelf|\r\tcopyOfSelf := super veryDeepCopyWith: deepCopier.\r\t\"force Sets and Dictionaries to rehash\"\r\tcopyOfSelf rehash.\r\t\t^ copyOfSelf"}],"meta":{"name":"HashedCollection class","instanceVariables":[],"methods":[{"name":"cleanUp:","linesOfCode":3,"sourceCode":"cleanUp: aggressive\r\t\"Rehash all instances when cleaning aggressively\"\r\r\taggressive ifTrue: [self compactAll].\r"},{"name":"new:","linesOfCode":3,"sourceCode":"new: nElements\r\t\"Create a Set large enough to hold nElements without growing\"\r\t^ self basicNew initialize: (self sizeFor: nElements)"},{"name":"compactAll","linesOfCode":4,"sourceCode":"compactAll\r\t\"HashedCollection compactAll\"\t\r\t\t\r\tself allSubclassesDo: #compactAllInstances"},{"name":"rehashAllInstances","linesOfCode":3,"sourceCode":"rehashAllInstances\r\t\"Do not use #allInstancesDo: because rehash may create new instances.\"\r\t\r\tself allInstances do: [ :each | each rehash ]"},{"name":"compactAllInstances","linesOfCode":3,"sourceCode":"compactAllInstances\r\t\"Do not use #allInstancesDo: because rehash may create new instances.\"\r\t\r\tself allInstances do: [ :each | each compact ]"},{"name":"sizeFor:","linesOfCode":4,"sourceCode":"sizeFor: nElements\r\t\"Large enough size to hold nElements with some slop (see fullCheck)\"\r\t\r\tnElements < 4 ifTrue: [ ^5 ].\r\t^ HashTableSizes atLeast: nElements +1 * 4 // 3"},{"name":"new","linesOfCode":4,"sourceCode":"new\r\t^ self basicNew\r\t\tinitialize: 5;\r\t\tyourself"},{"name":"rehashAll","linesOfCode":4,"sourceCode":"rehashAll\r\t\"HashedCollection rehashAll\"\t\r\t\t\r\tself allSubclassesDo: #rehashAllInstances"},{"name":"newFrom:","linesOfCode":3,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\t^self subclassResponsibility"},{"name":"empty","linesOfCode":4,"sourceCode":"empty\r\t^ self basicNew\r\t\tinitialize: 1;\r\t\tyourself"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #HashedCollection"}],"meta":null}},{"name":"ManifestCollectionsAbstract","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsAbstract class","instanceVariables":[],"methods":[{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Regex-Core' #'Collections-Strings' #'Collections-Streams' #'Collections-Support' #'Collections-Unordered' #Kernel #'Collections-Sequenceable' #'Collections-Native')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Abstract'"}],"meta":null}},{"name":"Behavior class","instanceVariables":[],"methods":[{"name":"initialize","linesOfCode":16,"sourceCode":"initialize\r\t\"Behavior initialize\"\r\t\"Never called for real\"\r\tObsoleteSubclasses\r\t\tifNil: [ self initializeObsoleteSubclasses ]\r\t\tifNotNil: [ | newDict | \r\t\t\tnewDict := WeakKeyToCollectionDictionary newFrom: ObsoleteSubclasses.\r\t\t\tnewDict rehash.\r\t\t\tObsoleteSubclasses := newDict ].\r\t\t\r\tClassProperties\r\t\tifNil: [ self initializeClassProperties ]\r\t\tifNotNil: [ | newDict | \r\t\t\tnewDict := WeakIdentityKeyDictionary newFrom: ClassProperties.\r\t\t\tnewDict rehash.\r\t\t\tClassProperties := newDict ]"},{"name":"flushObsoleteSubclasses","linesOfCode":3,"sourceCode":"flushObsoleteSubclasses\r\t\"Behavior flushObsoleteSubclasses\"\r\tObsoleteSubclasses finalizeValues."},{"name":"sortBlock","linesOfCode":2,"sourceCode":"sortBlock\r\t^ [ :a :b | a name <= b name ]"},{"name":"initializeClassProperties","linesOfCode":2,"sourceCode":"initializeClassProperties\r\tClassProperties := WeakIdentityKeyDictionary new."},{"name":"initializeObsoleteSubclasses","linesOfCode":2,"sourceCode":"initializeObsoleteSubclasses\r\tObsoleteSubclasses := WeakKeyToCollectionDictionary new."},{"name":"cleanUp","linesOfCode":3,"sourceCode":"cleanUp\r\t\"Flush the obsolete subclasses.\"\r\r\tself flushObsoleteSubclasses"}],"meta":null},{"name":"NotFound","instanceVariables":[{"name":"object"}],"methods":[{"name":"collection","linesOfCode":3,"sourceCode":"collection\r\t\"Return the collection where something is not found in\"\r\t\r\t^ self signaler"},{"name":"messageText","linesOfCode":3,"sourceCode":"messageText\r\t\"Overwritten to initialiaze the message text to a standard text if it has not yet been set\"\r\t\r\t^ messageText ifNil: [ messageText := self standardMessageText ]"},{"name":"object","linesOfCode":3,"sourceCode":"object\r\t\"Return the object that was not found\"\r\t\r\t^ object"},{"name":"object:","linesOfCode":3,"sourceCode":"object: anObject\r\t\"Set the object that was not found\"\r\t\r\tobject := anObject"},{"name":"standardMessageText","linesOfCode":6,"sourceCode":"standardMessageText\r\t\"Generate a standard textual description\"\r\t\r\t^ String streamContents: [ :stream |\r\t\tstream print: self object.\r\t\tstream << ' not found in '.\r\t\tstream print: self collection class ]"},{"name":"collection:","linesOfCode":3,"sourceCode":"collection: aCollection\r\t\"Set the collection where something is not found in\"\r\t\r\tself signaler: aCollection"}],"meta":{"name":"NotFound class","instanceVariables":[],"methods":[{"name":"signalFor:in:","linesOfCode":6,"sourceCode":"signalFor: anObject in: aCollection\r\t\"Create and signal a NotFound exception for anObject in aCollection.\"\r\r\t^ self new\r\t\tobject: anObject;\r\t\tcollection: aCollection;\r\t\tsignal"},{"name":"signalFor:","linesOfCode":5,"sourceCode":"signalFor: anObject\r\t\"Create and signal a NotFound exception for anObject in the default receiver.\"\r\t\r\t^ self new\r\t\tobject: anObject;\r\t\tsignal"}],"meta":null}},{"name":"Collection","instanceVariables":[],"methods":[{"name":"copyWith:","linesOfCode":6,"sourceCode":"copyWith: newElement\r\t\"Answer a new collection with newElement added (as last\r\telement if sequenceable).\"\r\r\t^ self copy\r\t\tadd: newElement;\r\t\tyourself"},{"name":"reject:thenCollect:","linesOfCode":3,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self reject: rejectBlock) collect: collectBlock"},{"name":"stonOn:","linesOfCode":6,"sourceCode":"stonOn: stonWriter\r\t\"For collections we chose to write a list of elements as delivered by #do:\r\tThis is not the best or most correct solution for all subclasses though,\r\tso some will revert to standard object behavior or chose another solution\"\r\t\r\tstonWriter writeObject: self do: [\r\t\tstonWriter encodeList: self ]\r"},{"name":"collect:thenDo:","linesOfCode":4,"sourceCode":"collect: collectBlock thenDo: doBlock \r\t\"Utility method to improve readability.\"\r\t\r\t^ self do: [ :each|\r\t\tdoBlock value: (collectBlock value: each)]"},{"name":"flatCollect:","linesOfCode":7,"sourceCode":"flatCollect: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t\"( #((3 4) (1 2)) flatCollect: [:each | each ] )>>> #(3 4 1 2)\"\r\t\"( #(3 4 1 2) flatCollect: [:each | { each } ] ) >>> #(3 4 1 2)\"\r\t\r\t^ self flatCollect: aBlock as: self species"},{"name":"cos","linesOfCode":2,"sourceCode":"cos\r\t^self collect: [:each | each cos]"},{"name":"removeFromMetacelloRepositories:","linesOfCode":2,"sourceCode":"removeFromMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each removeFromMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"asCharacterSet","linesOfCode":4,"sourceCode":"asCharacterSet\r\t\"Answer a CharacterSet whose elements are the unique elements of the receiver.\r\tThe reciever should only contain characters.\"\r\r\t^ CharacterSet newFrom: self"},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: aCollection \r\t\"Include all the elements of aCollection as the receiver's elements. Answer \r\taCollection. Actually, any object responding to #do: can be used as argument.\"\r\r\taCollection do: [:each | self add: each].\r\t^ aCollection"},{"name":"removeAllFoundIn:","linesOfCode":6,"sourceCode":"removeAllFoundIn: aCollection \r\t\"Remove each element of aCollection which is present in the receiver \r\tfrom the receiver. Answer aCollection. No error is raised if an element\r\tisn't found. ArrayedCollections cannot respond to this message.\"\r\r\taCollection do: [:each | self remove: each ifAbsent: []].\r\t^ aCollection"},{"name":"-","linesOfCode":2,"sourceCode":"- arg\r\r\t^ arg adaptToCollection: self andSend: #-"},{"name":"asDraggableMorph","linesOfCode":5,"sourceCode":"asDraggableMorph\r\t^ (String streamContents: [ :s| \r\t\tself \r\t\t\tdo: [ :each | s print: each ]\r\t\t\tseparatedBy: [ s space ]]) asStringMorph"},{"name":"gtDebuggerSUnitPrint","linesOfCode":3,"sourceCode":"gtDebuggerSUnitPrint\r\r\t^ String streamContents: [ :s | \r\t\t  self asStringOn: s delimiter: String cr ]"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\r\tself subclassResponsibility"},{"name":"raisedTo:","linesOfCode":2,"sourceCode":"raisedTo: arg\r\r\t^ arg adaptToCollection: self andSend: #raisedTo:"},{"name":"asOrderedCollection","linesOfCode":7,"sourceCode":"asOrderedCollection\r\t\"Answer an OrderedCollection whose elements are the elements of the\r\treceiver. The order in which elements are added depends on the order\r\tin which the receiver enumerates its elements. In the case of unordered\r\tcollections, the ordering is not necessarily the same for multiple \r\trequests for the conversion.\"\r\r\t^ self as: OrderedCollection"},{"name":"sum","linesOfCode":11,"sourceCode":"sum\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t| sum sample |\r\t\r\tself emptyCheck.\r\tsample := self anyOne.\r\tsum := self inject: sample into: [:accum :each | accum + each].\r\t^ sum - sample"},{"name":"gtInspectorInterestingObject","linesOfCode":4,"sourceCode":"gtInspectorInterestingObject\r\t^ self size = 1\r\t\tifTrue: [ self anyOne ]\r\t\tifFalse: [ self ]"},{"name":"copyWithoutDuplicates","linesOfCode":6,"sourceCode":"copyWithoutDuplicates\r\t\"Answer a copy of the receiver without any duplicated elements\"\r\t\"(#(2 3 4 4  5 6) copyWithoutDuplicates)  >>> #(2 3 4 5 6)\"\r\t\"(#('do' 'la' 'si' 'do' 'la') copyWithoutDuplicates) >>> #('la' 'do' 'si')\"\r\t\"(#(#do #la #si #do #la) copyWithoutDuplicates) >>> #(#la #do #si)\"\r\t^ self asSet asArray"},{"name":"//","linesOfCode":2,"sourceCode":"// arg\r\r\t^ arg adaptToCollection: self andSend: #//"},{"name":"copyWithout:","linesOfCode":6,"sourceCode":"copyWithout: oldElement \r\t\"Answer a copy of the receiver that does not contain any\r\telements equal to oldElement.\"\r\t\"('fred the bear' copyWithout: $e) >>> 'frd th bar'\"\r\t\"(#(2 3 4 5 5 6) copyWithout: 5) >>> #(2 3 4 6)\"\r\t\r\t\r\t^ self reject: [:each | each = oldElement]"},{"name":"floor","linesOfCode":2,"sourceCode":"floor\r\t^ self collect: [:a | a floor]"},{"name":"negated","linesOfCode":4,"sourceCode":"negated\r\t\"Negated value of all elements in the collection\"\r\t\"#(1 2 3) negated >>> #(-1 -2 -3)\"\r\t^ self collect: [:a | a negated]"},{"name":"do:separatedBy:","linesOfCode":12,"sourceCode":"do: elementBlock separatedBy: separatorBlock\r\t\"Evaluate the elementBlock for all elements in the receiver,\r\tand evaluate the separatorBlock between.\"\r\t\"(String streamContents: [:s | #(1 2 3) do: [:each | s << each asString] separatedBy: [s << ', ']]) >>> '1, 2, 3'\"\r\r\t| beforeFirst | \r\tbeforeFirst := true.\r\tself do:\r\t\t[:each |\r\t\tbeforeFirst\r\t\t\tifTrue: [beforeFirst := false]\r\t\t\tifFalse: [separatorBlock value].\r\t\telementBlock value: each]"},{"name":"reject:thenDo:","linesOfCode":6,"sourceCode":"reject: rejectBlock thenDo: doBlock \r\t\"Utility method to improve readability.\r\tDo not create the intermediate collection.\"\r\t\r\tself do: [ :each |\r\t\t(rejectBlock value: each)\r\t\t\tifFalse: [ doBlock value: each ] ]."},{"name":"collect:thenSelect:","linesOfCode":3,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self collect: collectBlock) select: selectBlock"},{"name":"asStringOn:delimiter:","linesOfCode":6,"sourceCode":"asStringOn: aStream delimiter: delimString\r\t\"Print elements on a stream separated\r\twith a delimiter String like: 'a, b, c'\r\tUses #asString instead of #print:.\"\r\r\tself do: [:elem | aStream nextPutAll: elem asString]\r\t\tseparatedBy: [aStream nextPutAll: delimString]"},{"name":"errorSizeMismatch","linesOfCode":3,"sourceCode":"errorSizeMismatch\r\t\"Signal a SizeMismatch exception\"\r\r\tSizeMismatch signal"},{"name":"asStringOn:delimiter:last:","linesOfCode":14,"sourceCode":"asStringOn: aStream delimiter: delimString last: lastDelimString\r\t\"Print elements on a stream separated\r\twith a delimiter between all the elements and with\r\ta special one before the last like: 'a, b and c'.\r\tUses #asString instead of #print:\r\r\tNote: Feel free to improve the code to detect the last element.\"\r\r\t| n sz |\r\tn := 1.\r\tsz := self size.\r\tself do: [:elem |\r\t\tn := n + 1.\r\t\taStream nextPutAll: elem asString]\r\tseparatedBy: [\r\t\taStream nextPutAll: (n = sz ifTrue: [lastDelimString] ifFalse: [delimString])]"},{"name":"addIfNotPresent:ifPresentDo:","linesOfCode":7,"sourceCode":"addIfNotPresent: anObject ifPresentDo: aBlock\r\t\"Include anObject as one of the receiver's elements and then value aBlock, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t(self includes: anObject) \r\t\tifFalse: [ self add: anObject ]\r\t\tifTrue: [ aBlock value ].\r\t^ anObject"},{"name":"averageIfEmpty:","linesOfCode":5,"sourceCode":"averageIfEmpty: aBlock \r\t\"This method return the average of the collection if it is not empty. In the other case,\r\tit return the value of the block. It means the user the user of this method decide of the return value. #() averageIfEmpty: [ 0 ]\"\r\tself ifEmpty: [ ^ aBlock value ].\r\t^ self average"},{"name":"difference:","linesOfCode":9,"sourceCode":"difference: aCollection\r\t\"Answer the set theoretic difference of two collections. Pay attention that the difference is not commutative, hence the order is important.\"\r\r\t\"(#(a b c d e f) difference:  #(a b z k))>>> #(#f #d #e #c)\"\r\r\t\"(#(a b z k) difference: #(a b c d e f)) >>> #(#k #z)\"\r\r\t| set |\r\tset := self asSet\r\t\tremoveAllFoundIn: aCollection;\r\t\tyourself.\r\t^ self species withAll: set asArray"},{"name":"adaptToCollection:andSend:","linesOfCode":7,"sourceCode":"adaptToCollection: rcvr andSend: selector\r\t\"If I am involved in arithmetic with another Collection, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t(rcvr isSequenceable and: [ self isSequenceable ]) ifFalse:\r\t\t[self error: 'Only sequenceable collections may be combined arithmetically'].\r\t^ rcvr with: self collect:\r\t\t[:rcvrElement :myElement | rcvrElement perform: selector with: myElement]"},{"name":"includesAny:","linesOfCode":4,"sourceCode":"includesAny: aCollection \r\t\"Answer whether any element of aCollection is one of the receiver's elements.\"\r\taCollection do: [:elem | (self includes: elem) ifTrue: [^ true]].\r\t^ false"},{"name":"inspectionItems:","linesOfCode":15,"sourceCode":"inspectionItems: aBuilder\r\t<inspectorPresentationOrder: 0 title: 'Items'> \r\t\r\t^ aBuilder newTable\t\t\r\t\taddColumn: (SpIndexTableColumn new \r\t\t\ttitle: 'Index';\r\t\t\tsortFunction: #yourself ascending;\r\t\t\tbeNotExpandable;\r\t\t\tyourself);\r\t\taddColumn: (SpStringTableColumn new  \r\t\t\ttitle: 'Value'; \r\t\t\tevaluated: [ :each | StObjectPrinter asTruncatedTextFrom: each ];\r\t\t\tsortFunction: #printString ascending;\r\t\t\tyourself);\r\t\titems: self asOrderedCollection;\r\t\tyourself"},{"name":"flattened","linesOfCode":5,"sourceCode":"flattened\r\t\"Flattens a collection of collections (no matter how many levels of collections exist). Strings are considered atoms and, as such, won't be flattened\"\r\t\"( #(1 #(2 3) #(4 #(5))) flattened ) >>> #(1 2 3 4 5)\" \r\t\"( #('string1' #('string2' 'string3')) flattened ) >>> #('string1' 'string2' 'string3')\"\r\t\r\t^ Array streamContents: [ :stream | self flattenOn: stream]."},{"name":"max","linesOfCode":6,"sourceCode":"max\r\t\"Return the maximum value of the collection\r\t\r\tExample of use:\r\t#(1 5 10 -4) max >>> 10\r\t\"\r\t^ self inject: self anyOne into: [:max :each | max max: each]"},{"name":"detect:ifNone:","linesOfCode":5,"sourceCode":"detect: aBlock ifNone: exceptionBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tAnswer the first element for which aBlock evaluates to true. If none  \r\tevaluate to true, then evaluate the argument, exceptionBlock.\"\r\r\t^ self detect: aBlock ifFound: [ :element | element ] ifNone: exceptionBlock"},{"name":"asCommaString","linesOfCode":5,"sourceCode":"asCommaString\r    \"Return collection printed as 'a, b, c' \"\r    \"#( 'a' 'b' 'c') asCommaString >>> 'a, b, c'\"\r    \r    ^String streamContents: [:s | self asStringOn: s delimiter: ', ']"},{"name":"remove:ifAbsent:","linesOfCode":7,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\t\"Remove oldObject from the receiver's elements. If several of the \r\telements are equal to oldObject, only one is removed. If no element is \r\tequal to oldObject, answer the result of evaluating anExceptionBlock. \r\tOtherwise, answer the argument, oldObject. ArrayedCollections cannot \r\trespond to this message.\"\r\r\tself subclassResponsibility"},{"name":"errorEmptyCollection","linesOfCode":3,"sourceCode":"errorEmptyCollection\r\t\"Signal a CollectionIsEmpty exception\"\r\r\tCollectionIsEmpty signalWith: self"},{"name":"removeFromMetacelloPackages:","linesOfCode":2,"sourceCode":"removeFromMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each removeFromMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"min","linesOfCode":2,"sourceCode":"min\r\t^ self inject: self anyOne into: [:min :each | min min: each]"},{"name":"asGCoordinates","linesOfCode":2,"sourceCode":"asGCoordinates\r\t^ GCoordinates withCollection: self"},{"name":"tan","linesOfCode":2,"sourceCode":"tan\r\t^self collect: [:each | each tan]"},{"name":"gtCollectionSizeThreshold","linesOfCode":4,"sourceCode":"gtCollectionSizeThreshold\r\t\"Return the maximum collection size that GT supports while showing all elements.\r\tWhen this threshold is reached, we no longer show certain views that would take too much resources.\"\r\r\t^ 16rFFFF \"65535\""},{"name":"gather:","linesOfCode":3,"sourceCode":"gather: aBlock\r\t\"This method is kept for compatibility reasons, use flatCollect: instead.\"\r\t\r\t^ self flatCollect: aBlock."},{"name":"sign","linesOfCode":5,"sourceCode":"sign\r\t\"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.\"\r\t\"5 sign >>> 1\"\r\t\"-3 sign >>> -1\"\r\t^self collect: [:each | each sign]"},{"name":"printOn:delimiter:","linesOfCode":5,"sourceCode":"printOn: aStream delimiter: delimString\r\t\"Print elements on a stream separated\r\twith a delimiter String like: 'a, b, c' \"\r\r\tself do: [:elem | aStream print: elem] separatedBy: [aStream nextPutAll: delimString]\r\t\t"},{"name":"isCollection","linesOfCode":3,"sourceCode":"isCollection\r\t\"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:\"\r\t^true"},{"name":"storeOn:","linesOfCode":16,"sourceCode":"storeOn: aStream \r\t\"Refer to the comment in Object|storeOn:.\"\r\r\t| noneYet |\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new)'.\r\tnoneYet := true.\r\tself do: \r\t\t[:each | \r\t\tnoneYet\r\t\t\tifTrue: [noneYet := false]\r\t\t\tifFalse: [aStream nextPut: $;].\r\t\taStream nextPutAll: ' add: '.\r\t\taStream store: each].\r\tnoneYet ifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"execute:against:","linesOfCode":2,"sourceCode":"execute: projectSpecBlock against: aScriptExecutor\r    aScriptExecutor executeCollection: self do: projectSpecBlock"},{"name":"select:","linesOfCode":9,"sourceCode":"select: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. Collect into a new collection like the receiver, only those elements for which aBlock evaluates to true. Answer the new collection.\"\r\t\"(#(1 2 3 4 5) select: #even) >>> #(2 4)\"\r\t\r\t| newCollection |\r\tnewCollection := self copyEmpty.\r\tself do: [ :each | \r\t\t(aBlock value: each) \r\t\t\tifTrue: [ newCollection add: each ]].\r\t^newCollection"},{"name":"do:without:","linesOfCode":4,"sourceCode":"do: aBlock without: anItem \r\t\"Enumerate all elements in the receiver. \r\tExecute aBlock for those elements that are not equal to the given item\"\r\r\t^ self do: [:each | anItem = each ifFalse: [aBlock value: each]]"},{"name":"arcTan","linesOfCode":2,"sourceCode":"arcTan\r\t^self collect: [:each | each arcTan]"},{"name":"detectSum:","linesOfCode":9,"sourceCode":"detectSum: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tReturn the sum of the answers.\"\r\t| sum |\r\tself deprecated: 'Use #sum: instead'.\r\tsum := 0.\r\tself do: [:each | \r\t\tsum := (aBlock value: each) + sum].  \r\t^ sum"},{"name":"sqrt","linesOfCode":2,"sourceCode":"sqrt\r\t^ self collect: [:each | each sqrt]"},{"name":"printElementsOn:","linesOfCode":6,"sourceCode":"printElementsOn: aStream\r\t\"The original code used #skip:, but some streams do not support that,\r\t and we don't really need it.\"\r\r\taStream nextPut: $(.\r\tself do: [:element | aStream print: element] separatedBy: [aStream space].\r\taStream nextPut: $)"},{"name":"printOn:delimiter:last:","linesOfCode":15,"sourceCode":"printOn: aStream delimiter: delimString last: lastDelimString\r\t\"Print elements on a stream separated\r\twith a delimiter between all the elements and with\r\ta special one before the last like: 'a, b and c'\r\r\tNote: Feel free to improve the code to detect the last element.\"\r\r\t| n sz |\r\tn := 1.\r\tsz := self size.\r\tself do: [:elem |\r\t\tn := n + 1.\r\t\taStream print: elem]\r\tseparatedBy: [\r\t\tn = sz\r\t\t\tifTrue: [aStream print: lastDelimString]\r\t\t\tifFalse: [aStream print: delimString]]"},{"name":"flatCollectAsSet:","linesOfCode":5,"sourceCode":"flatCollectAsSet: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t^ self flatCollect: aBlock as: Set"},{"name":"flattenOn:","linesOfCode":2,"sourceCode":"flattenOn: aStream\r\r\tself do: [ :each | each flattenOn: aStream ]"},{"name":"includesAllOf:","linesOfCode":5,"sourceCode":"includesAllOf: aCollection \r\r\tself\r\t\tdeprecated: 'Please use #includesAll: instead'\r\t\ttransformWith: '`@receiver includesAllOf: `@statements' -> '`@receiver includesAll: `@statements'.\r\t\r\t^ self includesAll: aCollection"},{"name":"asSet","linesOfCode":3,"sourceCode":"asSet\r\t\"Answer a Set whose elements are the unique elements of the receiver.\"\r\r\t^ Set withAll: self"},{"name":"addToMetacelloRepositories:","linesOfCode":2,"sourceCode":"addToMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each addToMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"resolvePackageSpecsNamedForMetacelloMCVersion:visited:ifAbsent:","linesOfCode":4,"sourceCode":"resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock\r    ^ aMetacelloMCVersion\r        allPackagesForSpecs: (self collect: [ :ea | aMetacelloMCVersion packageNamed: ea ifAbsent: aBlock ])\r        visited: visited"},{"name":"copyEmpty","linesOfCode":2,"sourceCode":"copyEmpty\r\t^ self species new"},{"name":"sumNumbers","linesOfCode":9,"sourceCode":"sumNumbers\r\t\"This is implemented using a variant of the normal inject:into: pattern\r\tthat is specific to handling numbers. The receiver should include only numbers.\r\t\r\tDifferent from the sum implementation, the default value is zero. While sum is \r\tmore general, sumNumbers is meant to support the most often encountered use case of\r\tdealing with numbers.\"\r\r\t^ self \r\t\tinject: 0 \r\t\tinto: [ :sum :each |  sum + each ]"},{"name":"ifNotEmpty:ifEmpty:","linesOfCode":6,"sourceCode":"ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock\r\t\"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise\r\t If the notEmptyBlock has an argument, eval with the receiver as its argument\"\r\r\t^ self isEmpty\r\t\tifTrue: [ emptyBlock value ]\r\t\tifFalse: [ notEmptyBlock cull: self ]"},{"name":"size","linesOfCode":6,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | tally := tally + 1].\r\t^ tally"},{"name":"addedToZnUrl:","linesOfCode":2,"sourceCode":"addedToZnUrl: url \r\t^ url withPathSegments: self"},{"name":"ln","linesOfCode":2,"sourceCode":"ln\r\t^self collect: [:each | each ln]"},{"name":"asOrderedDictionary","linesOfCode":2,"sourceCode":"asOrderedDictionary\r\r\t^ self as: OrderedDictionary"},{"name":"inject:into:","linesOfCode":7,"sourceCode":"inject: thisValue into: binaryBlock \r\t\"Accumulate a running value associated with evaluating the argument, binaryBlock, with the current value of the argument, thisValue, and the receiver as block arguments.\"\r\t\r\t\"( #(1 2 3) inject: 0 into: [ :sum :each | sum + each ] ) >>> 6\"\r\r\t| nextValue |\r\tnextValue := thisValue.\r\tself do: [:each | nextValue := binaryBlock value: nextValue value: each].\r\t^nextValue"},{"name":"capacity","linesOfCode":3,"sourceCode":"capacity\r\t\"Answer the current capacity of the receiver.\"\r\r\t^ self size"},{"name":"squared","linesOfCode":2,"sourceCode":"squared\r\t^ self collect: [:each | each * each]"},{"name":"reduce:","linesOfCode":6,"sourceCode":"reduce: aBlock\r\t\"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified.\"\r\t\"( #(1 2 3) asSet reduce: [ :a :b | a + b ] ) >>> 1 + 2 + 3\"\r\t\"( #(1 2 3 4 5) asSet reduce: [ :a :b :c | a + b + c ] ) >>> 1 + 2 + 3 + 4 + 5\"\r\t\t\r\t^self asOrderedCollection reduce: aBlock"},{"name":"removeAll:","linesOfCode":7,"sourceCode":"removeAll: aCollection \r\t\"Remove each element of aCollection from the receiver. If successful for \r\teach, answer aCollection. Otherwise create an error notification.\r\tArrayedCollections cannot respond to this message.\"\r\r\taCollection == self ifTrue: [^self removeAll].\r\taCollection do: [:each | self remove: each].\r\t^ aCollection"},{"name":"gtInspectorItemsIn:","linesOfCode":18,"sourceCode":"gtInspectorItemsIn: composite\r\t<gtInspectorPresentationOrder: 0>\r\t^ composite fastList\r\t\ttitle: 'Items';\r\t\tdisplay: [ \"The FastTable renderer needs to access elements by index so we transform\r\t\t\tthe collection to an OrderedCollection. Subclasses can override the #display\r\t\t\tblock to provide a different behaviour. The previous renderer had this behaviour\r\t\t\timplemented in the renderer.\" self asOrderedCollection ];\r\t\tbeMultiple;\r\t\tformat: [ :each | GTObjectPrinter asTruncatedTextFrom: each ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\t\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult\r\t\t\t\tifNotNil: [ result size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] ] ]"},{"name":"doWithIndex:","linesOfCode":6,"sourceCode":"doWithIndex: elementAndIndexBlock\r\t\"Use the new version with consistent naming\r\t\r\tExample of use:\r\t(#('hello' 'world' 'bonjour') doWithIndex: [ :element :index |  ])\r\t\"\r\r\t^ self withIndexDo: elementAndIndexBlock"},{"name":"collectAll:","linesOfCode":8,"sourceCode":"collectAll: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect all the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself do: [:each | newCollection addAll: (aBlock value: each)].\r\t^ newCollection"},{"name":"atRandom","linesOfCode":11,"sourceCode":"atRandom\r\t\"Answer a random element of the receiver.  Uses a shared random \r\tnumber generator owned by class Collection.  If you use this a lot, \r\tdefine your own instance of Random and use #atRandom:.  Causes \r\tan error if self has no elements.\"\r\r\t^ self atRandom: SharedRandom globalGenerator.\r\r\"Examples:\r\t#('one' 'or' 'the' 'other') atRandom\r\t(1 to: 10) atRandom\r\t'Just pick one of these letters at random' atRandom\r\t#(3 7 4 9 21) asSet atRandom\t\t(just to show it also works for Sets)\r\""},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted\"\r\t\r\t^self asArray sorted"},{"name":"detect:ifFound:","linesOfCode":14,"sourceCode":"detect: aBlock ifFound: foundBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tIf some element evaluates aBlock to true, then cull this element into \r\tfoundBlock. \r\tIf no element matches the criteria then do nothing.\r\tAlways returns self to avoid misuse and a potential isNil check on the sender.\"\r\t\"(#(1 2) detect: [ :each | each even ] ifFound: [ ^'yay!' ]) >>> 'yay'\"\r\t\"(#(1 3) detect: [ :each | each even ] ifFound: [ ^'yay!' ]) >>> #(1 3)\"\r\r\tself\r\t\tdetect: aBlock\r\t\tifFound: foundBlock\r\t\tifNone: [ \r\t\t\t\"Do nothing on purpose\"\r\t\t\t ]"},{"name":"rounded","linesOfCode":2,"sourceCode":"rounded\r\t^ self collect: [:a | a rounded]"},{"name":"anyOne","linesOfCode":8,"sourceCode":"anyOne\r\t\"Answer a representative sample of the receiver. It raises an error when the collection is empty. This method can be helpful when needing to preinfer the nature of the contents of semi-homogeneous collections.\"\r\t\"#(1 2 3) anyOne >>> 1\"\r\t\"\r\t([#() anyOne] on: SubscriptOutOfBounds do: [ :ex | 'whatever' ]) >>> 'whatever'\r\t\"\r\t\r\tself emptyCheck.\r\tself do: [:each | ^ each]"},{"name":"add:","linesOfCode":4,"sourceCode":"add: newObject \r\t\"Include newObject as one of the receiver's elements. Answer newObject. \r\tArrayedCollections cannot respond to this message.\"\r\r\tself subclassResponsibility"},{"name":",","linesOfCode":4,"sourceCode":", aCollection\r\t\"Concatenate the receiver with the argument.\"\r\t\"#(1 2 3) , #(4 5 6) >>> #(1 2 3 4 5 6)\"\r\t\r\t^self copy addAll: aCollection; yourself"},{"name":"stdev","linesOfCode":9,"sourceCode":"stdev\r\t| avg sample sum |\r\t\"In statistics, the standard deviation is a measure that is used to quantify the amount of variation or dispersion of a set of data values.\r\tFor details about implementation see comment in self sum.\"\r\tavg := self average.\r\tsample := self anyOne.\r\tsum := self inject: sample into: [ :accum :each | accum + (each - avg) squared ].\r\tsum := sum - sample.\r\t^ (sum / (self size - 1)) sqrt"},{"name":"asSortedCollection:","linesOfCode":7,"sourceCode":"asSortedCollection: aSortBlock \r\t\"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is defined by the argument, aSortBlock. Note that it is better to use #sorted: if you don't really need a SortedCollection, but a sorted collection!!\"\r\r\t| aSortedCollection |\r\taSortedCollection := SortedCollection new: self size.\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"detect:ifFound:ifNone:","linesOfCode":10,"sourceCode":"detect: aBlock ifFound: foundBlock ifNone: exceptionBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tIf some element evaluates aBlock to true, then cull this element into \r\tfoundBlock and answer the result of this evaluation. \r\tIf none evaluate to true, then evaluate exceptionBlock.\"\r\r\tself\r\t\tdo: [ :each | \r\t\t\t(aBlock value: each)\r\t\t\t\tifTrue: [ ^ foundBlock cull: each ] ].\r\t^ exceptionBlock value\t"},{"name":"recordRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"recordRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doRecordRequiredFromArray: self."},{"name":"sin","linesOfCode":2,"sourceCode":"sin\r\t^self collect: [:each | each sin]"},{"name":"notEmpty","linesOfCode":4,"sourceCode":"notEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\t\"use isNotEmpty for consistency with isEmpty\"\r\r\t^ self isEmpty not"},{"name":"mergeIntoMetacelloPackages:","linesOfCode":2,"sourceCode":"mergeIntoMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each mergeIntoMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"loadRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"loadRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doLoadRequiredFromArray: self."},{"name":"allSatisfy:","linesOfCode":8,"sourceCode":"allSatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver.\r\tIf aBlock returns false for any element return false.\r\tOtherwise return true.\"\r\t\"#(1 2) allSatisfy: [ :each | each even ] >>> false\"\r\t\"#(2 4) allSatisfy: [ :each | each even ] >>> true\"\r\r\tself do: [:each | (aBlock value: each) ifFalse: [^ false]].\r\t^ true"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self asArray"},{"name":"removeAll","linesOfCode":7,"sourceCode":"removeAll\r\t\"Remove each element from the receiver and leave it empty.\r\tArrayedCollections cannot respond to this message.\r\tThere are two good reasons why a subclass should override this message:\r\t1) the subclass does not support being modified while being iterated\r\t2) the subclass provides a much faster way than iterating through each element\"\r\r\tself do: [:each | self remove: each]."},{"name":"setRequiresInMetacelloPackage:","linesOfCode":2,"sourceCode":"setRequiresInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setRequires: self asArray."},{"name":"sumNumbers:","linesOfCode":10,"sourceCode":"sumNumbers: aBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern\r\tthat is specific to handling numbers. aBlock is expected to return a number\r\tfor every element in the collection.\r\t\r\tDifferent from the sum: implementation, the default value is zero. While sum: is \r\tmore general, sumNumbers: is meant to support the most often encountered use case of\r\tdealing with numbers.\"\r\r\t^ self \r\t\tinject: 0 \r\t\tinto: [ :sum :each |  sum + (aBlock value: each) ]"},{"name":"do:displayingProgress:every:","linesOfCode":33,"sourceCode":"do: aBlock displayingProgress: aStringOrBlock every: msecs\r\t\"Enumerate aBlock displaying progress information.\r \t If the argument is a string, use a static label for the process.\r\t If the argument is a block, evaluate it with the element to retrieve the label.\r \t The msecs argument ensures that updates happen at most every msecs.\r       Example:\r               Smalltalk allClasses\r                       do:[:aClass| (Delay forMilliseconds: 1) wait]\r                       displayingProgress:[:aClass| 'Processing ', aClass name]\r                       every: 0.\"\r\r\t| size labelBlock count oldLabel lastUpdate |\r\tself isEmpty ifTrue: [ ^ self ].\r\toldLabel := nil.\r\tcount := lastUpdate := 0.\r\tsize := self size.\r\t'' displayProgressFrom: 0 to: size during: [:bar |\r\t\tlabelBlock := aStringOrBlock isString\r\t\t\tifTrue: [\r\t\t\t\tbar label: aStringOrBlock.\r\t\t\t\t[ :dummyItem | aStringOrBlock] ]\r\t\t\tifFalse: [ aStringOrBlock ].\r\r\t\tself do: [ :each | | newLabel |\r\t\t\t\"Special handling for first and last element\"\r\t\t\t(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) \r\t\t\t\tifTrue: [ \r\t\t\t\t\tbar current: count.\r\t\t\t\t\toldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) \r\t\t\t\t\t\tifFalse: [\r\t\t\t\t\t\t\tbar label: newLabel.\r\t\t\t\t\t\t\toldLabel := newLabel ].\r\t\t\t\tlastUpdate := Time millisecondClockValue ].\r\t\t\taBlock value: each.\r\t\t\tcount := count + 1 ] ]"},{"name":"contents","linesOfCode":2,"sourceCode":"contents\r\t^ self"},{"name":"addIfNotPresent:","linesOfCode":5,"sourceCode":"addIfNotPresent: anObject\r\t\"Include anObject as one of the receiver's elements, but only if there\r\tis no such element already. Anwser anObject.\"\r\r\t(self includes: anObject) ifFalse: [self add: anObject].\r\t^ anObject"},{"name":"asSequenceParser","linesOfCode":2,"sourceCode":"asSequenceParser\r\t^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])"},{"name":"fold:","linesOfCode":4,"sourceCode":"fold: binaryBlock\r\t\"Evaluate the block with the first two elements of the receiver, then with the result of the first evaluation and the next element, and so on.  Answer the result of the final evaluation. If the receiver is empty, raise an error. If the receiver has a single element, answer that element.\"\r\t\"( #('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b] ) >>> 'if it is to be it is up to me'\"\r\r\t^self reduce: binaryBlock"},{"name":"roundTo:","linesOfCode":2,"sourceCode":"roundTo: quantum\r\t^self collect: [ :ea | ea roundTo: quantum ]"},{"name":"asChoiceParser","linesOfCode":2,"sourceCode":"asChoiceParser\r\t^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])"},{"name":"anySatisfy:","linesOfCode":8,"sourceCode":"anySatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver.\r\tIf aBlock returns true for any element return true.\r\tOtherwise return false.\"\r\t\"#(1 3) anySatisfy: [ :each | each even ] >>> false\"\r\t\"#(1 2) anySatisfy: [ :each | each even ] >>> true\"\r\r\tself do: [:each | (aBlock value: each) ifTrue: [^ true]].\r\t^ false"},{"name":"selectEveryFirst","linesOfCode":5,"sourceCode":"selectEveryFirst\r\t\"#(1 2 3 4) selectEveryFirst asArray \r\t>>> #(1 3)\r\t\"\r\t^ self selectEvery: [ :i | (i+1 \\\\ 2) = 0 ]"},{"name":"findFirstInByteString:startingAt:","linesOfCode":8,"sourceCode":"findFirstInByteString: aByteString startingAt: start\r\t\"Find the index of first character starting at start in aByteString that is included in the receiver.\r\tDefault is to use a naive algorithm.\r\tSubclasses might want to implement a more efficient scheme\"\r\r\tstart to: aByteString size do:\r\t\t[:index |\r\t\t(self includes: (aByteString at: index)) ifTrue: [^ index]].\r\t^ 0"},{"name":"isEmpty","linesOfCode":3,"sourceCode":"isEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\r\t^self size = 0"},{"name":"asParser","linesOfCode":12,"sourceCode":"asParser    \r\t\"Create a range of characters between start and stop.\"\r\r\t(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ \r\t\t| charSet |\r\t\tcharSet := PPCharSetPredicate on: [ :char | self includes: char ] .\r     \t^ PPPredicateObjectParser on: charSet message: 'One of these charactes expected: ', self printString.\r\t].\r\r\r\t^ super asParser\r\t\"\r\t\t($a to:$f) asParser parse:'a'\r\t\t($a to:$f) asParser parse:'g'\r\t\"\r"},{"name":"arcSin","linesOfCode":2,"sourceCode":"arcSin\r\t^self collect: [:each | each arcSin]"},{"name":"emptyCheck","linesOfCode":2,"sourceCode":"emptyCheck\r\r\tself isEmpty ifTrue: [self errorEmptyCollection]"},{"name":"occurrencesOf:","linesOfCode":6,"sourceCode":"occurrencesOf: anObject \r\t\"Answer how many of the receiver's elements are equal to anObject.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | anObject = each ifTrue: [tally := tally + 1]].\r\t^tally"},{"name":"union:","linesOfCode":6,"sourceCode":"union: aCollection\r\t\"Answer the set theoretic union of two collections.\"\r\t\"(#(1 2 3) union: #(4 5 6 2)) >>> #(1 2 3 4 5 6)\"\r\t\r\t| set |\r\tset := self asSet addAll: aCollection; yourself.\r\t^ self species withAll: set asArray"},{"name":"unzip","linesOfCode":18,"sourceCode":"unzip\r\t\"Given a collection returns in one pass two collections containing each odd and even elements in respective subcollections\"\r\t\"\r\t#(1 2 3 4) unzip first asArray \r\t>>> #(1 3)\r\t#(1 2 3 4) unzip second asArray \r\t>>> #(2 4)\r\t\"\r\t\r\t| odd even s |\r\ts := self size // 2.\r\todd := OrderedCollection new: s.\r\teven := OrderedCollection new: s.\r\t1 \r\t\tto: self size \r\t\tdo: [ :i | (i \\\\ 2) = 0\t\r\t\t\t\t\t\tifTrue: [ even add: (self at: i) ]\r\t\t\t\t\t\tifFalse: [ odd add: (self at: i) ] ].\r\t^ { odd . even }"},{"name":"fetchRequiredForMetacelloMCVersion:","linesOfCode":2,"sourceCode":"fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion\r\r\t^aMetacelloMCVersion doFetchRequiredFromArray: self."},{"name":"collect:as:","linesOfCode":4,"sourceCode":"collect: aBlock as: aClass\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into an instance of aClass. Answer the resulting collection.\"\r\r\t^(aClass new: self size) fillFrom: self with: aBlock"},{"name":"asMetacelloAttributePath","linesOfCode":2,"sourceCode":"asMetacelloAttributePath\r    ^ MetacelloMethodSectionPath withAll: self"},{"name":"reject:","linesOfCode":4,"sourceCode":"reject: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. Collect into a new collection like the receiver only those elements for which aBlock evaluates to false. Answer the new collection.\"\r\t\"#(1 2 3 4 5) reject: #even >>>  #(1 3 5)\"\r\r\t^ self select: [ :element | (aBlock value: element) == false ]"},{"name":"|","linesOfCode":4,"sourceCode":"| aCollection\r\t\"Return all the elements that appear in self or in aCollection\"\r\t\"'abc' | 'cbe' >>> 'bcea'\"\r\t\r\t^ self union: aCollection"},{"name":"degreeCos","linesOfCode":2,"sourceCode":"degreeCos\r\t^self collect: [:each | each degreeCos]"},{"name":"noneSatisfy:","linesOfCode":4,"sourceCode":"noneSatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver. If aBlock returns false for all elements return true. Otherwise return false\"\r\r\tself do: [:item | (aBlock value: item) ifTrue: [^ false]].\r\t^ true"},{"name":"addToMetacelloPackages:","linesOfCode":2,"sourceCode":"addToMetacelloPackages: aMetacelloPackagesSpec\r\r\tself do: [:each | each addToMetacelloPackages: aMetacelloPackagesSpec ]"},{"name":"asDictionary","linesOfCode":2,"sourceCode":"asDictionary\r\r\t^ self as: Dictionary"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream \r\t\"Append a sequence of characters that identify the receiver to aStream.\"\r\r\tself printNameOn: aStream.\r\tself printElementsOn: aStream"},{"name":"nodesDo:","linesOfCode":2,"sourceCode":"nodesDo: aBlock\r\tself do: aBlock"},{"name":"fillFrom:with:","linesOfCode":5,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollections's elements as the argument.  \r\tCollect the resulting values into self. Answer self.\"\r\r\taCollection do: [ :each |\r\t\tself add: (aBlock value: each) ]"},{"name":"isNotEmpty","linesOfCode":7,"sourceCode":"isNotEmpty\r\t\"Answer whether the receiver contains any elements.\r\t\r\tExample of use:\r\t\r\t#() isNotEmpty >>> false\r\t#(1 2 3) isNotEmpty >>> true\r\t\"\r\r\t^ self isEmpty not"},{"name":"setIncludesInMetacelloPackage:","linesOfCode":2,"sourceCode":"setIncludesInMetacelloPackage: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setIncludes: self asArray."},{"name":"asGVector","linesOfCode":2,"sourceCode":"asGVector\r\t^ GVector withCollection: self"},{"name":"asCommaStringAnd","linesOfCode":4,"sourceCode":"asCommaStringAnd\r\t\"Return collection printed as 'a, b and c' \"\r\t\"#( 'a' 'b' 'c') asCommaStringAnd >>> 'a, b and c'\"\r\r\t^String streamContents: [:s | self asStringOn: s delimiter: ', ' last: ' and ']"},{"name":"printNameOn:","linesOfCode":2,"sourceCode":"printNameOn: aStream\r\tsuper printOn: aStream"},{"name":"includesAll:","linesOfCode":4,"sourceCode":"includesAll: aCollection \r\t\"Answer whether all the elements of aCollection are in the receiver.\"\r\taCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].\r\t^ true"},{"name":"arcCos","linesOfCode":2,"sourceCode":"arcCos\r\t^self collect: [:each | each arcCos]"},{"name":"select:thenCollect:","linesOfCode":3,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self select: selectBlock) collect: collectBlock"},{"name":"&","linesOfCode":3,"sourceCode":"& aCollection\r\t\"#(1 2 3 4) & #(1 2 4 6 7) >>> #(1 2 4)\"\r\t\r\t^ self intersection: aCollection"},{"name":"detectMin:","linesOfCode":21,"sourceCode":"detectMin: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the element for which aBlock evaluates to the lowest number.\r\tIf collection empty, return nil.\r\t\r\tExample of use:\r\t({ 2@3 . -4@6 . 10@ -3 } detectMin: [ :p | p x ]) >>> (-4@6)\r\t({ 2@3 . -4@6 . 10@ -3 } detectMin: [ :p | p y ]) >>> (10@ -3)\r\t\"\r\r\t| minElement minValue |\r\tself do: [:each | | val | \r\t\tminValue == nil\r\t\t\tifFalse: [\r\t\t\t\t(val := aBlock value: each) < minValue ifTrue: [\r\t\t\t\t\tminElement := each.\r\t\t\t\t\tminValue := val]]\r\t\t\tifTrue: [\"first element\"\r\t\t\t\tminElement := each.\r\t\t\t\tminValue := aBlock value: each].\r\t\t\t\t\"Note that there is no way to get the first element that works \r\t\t\t\tfor all kinds of Collections.  Must test every one.\"].\r\t^ minElement"},{"name":"selectEvery:","linesOfCode":7,"sourceCode":"selectEvery: aBlock\r\t\"Select elements of the receiver whose index satisfy the argument. Look at selectEveryFirst and selectEverySecond for examples.\"\r\t\r\t| res |\r\tres := OrderedCollection new.\r\t1 to: self size do: [ :i | (aBlock value: i) \r\t\t\t\t\t\t\t\t\t\t\tifTrue: [res add: (self at: i) ]].\r\t^ res"},{"name":"sum:ifEmpty:","linesOfCode":14,"sourceCode":"sum: aBlock ifEmpty: anEmptySumBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t| sum sample |\r\t\r\t^ self\r\t\tifNotEmpty: [ \r\t\t\tsample := aBlock value: self anyOne.\r\t\t\tsum := self inject: sample into: [ :previousValue :each |\r\t\t\t\tpreviousValue + (aBlock value: each) ].\r\t\t\tsum - sample ]\r\t\tifEmpty: anEmptySumBlock."},{"name":"range","linesOfCode":4,"sourceCode":"range\r\t\"returns the difference between the max and min element, their positions notwithstanding\"\r\t\"#( 1 51 10 ) range >>> 50\"\r\t^ self max - self min"},{"name":"associationsDo:","linesOfCode":5,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value \r\tassociations).  If any non-association is within, the error is not caught now,\r\tbut later, when a key or value message is sent to it.\"\r\r\tself do: aBlock"},{"name":"gtInspectorHash","linesOfCode":2,"sourceCode":"gtInspectorHash\r\r\t^ super gtInspectorHash bitXor: self size hash"},{"name":"flatCollect:as:","linesOfCode":8,"sourceCode":"flatCollect: aBlock as: aCollectionClass\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\r\t| col |\r\tcol := OrderedCollection new: self size.\r\tself do: [ :each | col addAll: (aBlock value: each) ].\r\t^ aCollectionClass withAll: col "},{"name":"remove:","linesOfCode":5,"sourceCode":"remove: oldObject \r\t\"Remove oldObject from the receiver's elements. Answer oldObject \r\tunless no element is equal to oldObject, in which case, raise an error.\r\tArrayedCollections cannot respond to this message.\"\r\r\t^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]"},{"name":"asBag","linesOfCode":3,"sourceCode":"asBag\r\t\"Answer a Bag whose elements are the elements of the receiver.\"\r\r\t^ Bag withAll: self"},{"name":"do:displayingProgress:","linesOfCode":12,"sourceCode":"do: aBlock displayingProgress: aStringOrBlock\r\t\"Enumerate aBlock displaying progress information. \r \t If the argument is a string, use a static label for the process. \r\t If the argument is a block, evaluate it with the element to retrieve the label.\r\t\r\t\tSmalltalk allClasses \r\t\t\tdo:[:aClass| (Delay forMilliseconds: 1) wait]\r\t\t\tdisplayingProgress: 'Processing...'.\r\t\tSmalltalk allClasses \r\t\t\tdo:[:aClass| (Delay forMilliseconds: 1) wait]\r\t\t\tdisplayingProgress:[:aClass| 'Processing ', aClass name].\r\t\"\r\t^self do: aBlock displayingProgress: aStringOrBlock every: 20"},{"name":"/","linesOfCode":2,"sourceCode":"/ arg\r\r\t^ arg adaptToCollection: self andSend: #/"},{"name":"gtIterator","linesOfCode":2,"sourceCode":"gtIterator\r\t^ [ :filter | self do: filter ] gtIterator"},{"name":"asShortcut","linesOfCode":2,"sourceCode":"asShortcut\r\t^ self asKeyCombination"},{"name":"asRWElementList","linesOfCode":2,"sourceCode":"asRWElementList\r\t^ RWElementList withAll: self"},{"name":"ifNotEmpty:","linesOfCode":6,"sourceCode":"ifNotEmpty: aBlock\r\t\"Evaluate the given block with the receiver as argument, answering its value\r    unless the receiver is empty, in which case answer the receiver.\"\r\r\t^ self isEmpty\r\t\tifTrue: [ self ]\r\t\tifFalse: [ aBlock cull: self ]"},{"name":"ifEmpty:","linesOfCode":6,"sourceCode":"ifEmpty: aBlock\r\t\"Evaluate the given block, answering its value if the receiver is empty, otherwise answer the receiver.\"\r\r\t\"Note that the fact that this method returns its receiver in case the receiver is not empty allows one to write expressions like the following ones: self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified'])\"\r\r\t^ self isEmpty\r\t\tifTrue: [ aBlock value ]\r\t\tifFalse: [ self ]"},{"name":"adaptToNumber:andSend:","linesOfCode":4,"sourceCode":"adaptToNumber: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a scalar, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t^ self collect: [:element | rcvr perform: selector with: element]"},{"name":"collect:into:","linesOfCode":4,"sourceCode":"collect: aBlock into: aCollection\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into aCollection. Answer aCollection.\"\r\r\t^aCollection fillFrom: self with: aBlock"},{"name":"ceiling","linesOfCode":2,"sourceCode":"ceiling\r\t^ self collect: [:a | a ceiling]"},{"name":"asSortedCollection","linesOfCode":3,"sourceCode":"asSortedCollection\r\t\"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is the default less than or equal. Note that you should use #sorted: if you don't really need a SortedCollection, but a sorted collection.\"\r\r\t^ self as: SortedCollection"},{"name":"collect:thenReject:","linesOfCode":3,"sourceCode":"collect: collectBlock thenReject: selectBlock\r\t\"Utility method to improve readability.\"\r\r\t^ (self collect: collectBlock) reject: selectBlock"},{"name":"count:","linesOfCode":8,"sourceCode":"count: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tAnswer the number of elements that answered true.\"\r\t\"#(1 2 3 4) count: [ :each | each even ] >>> true\"\r\r\t| sum |\r\tsum := 0.\r\tself do: [:each | (aBlock value: each) ifTrue: [sum := sum + 1]].\r\t^ sum"},{"name":"\\\\","linesOfCode":2,"sourceCode":"\\\\ arg\r\r\t^ arg adaptToCollection: self andSend: #\\\\"},{"name":"asKeyCombination","linesOfCode":6,"sourceCode":"asKeyCombination\r\t| shortcut |\r\tself size = 1 ifTrue: [ ^self first asKeyCombination ].\r\r\tshortcut := KMKeyCombinationSequence new.\r\tself do: [ :each | shortcut addShortcut: each asKeyCombination ].\r\t^shortcut."},{"name":"copyWithoutAll:","linesOfCode":4,"sourceCode":"copyWithoutAll: aCollection\r\t\"Answer a copy of the receiver that does not contain any elements \r\tequal to those in aCollection.\"\r\r\t^ self reject: [:each | aCollection includes: each]"},{"name":"exp","linesOfCode":2,"sourceCode":"exp\r\t^self collect: [:each | each exp]"},{"name":"sum:","linesOfCode":7,"sourceCode":"sum: aBlock\r\t\"This is implemented using a variant of the normal inject:into: pattern. \r\tThe reason for this is that it is not known whether we're in the normal \r\tnumber line, i.e. whether 0 is a good initial value for the sum. \r\tConsider a collection of measurement objects, 0 would be the unitless \r\tvalue and would not be appropriate to add with the unit-ed objects.\"\r\t^ self sum: aBlock ifEmpty: [ 0 ]"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t^ self anySatisfy: [:each | each = anObject]"},{"name":"intersection:","linesOfCode":6,"sourceCode":"intersection: aCollection\r\t\"Answer the set theoretic intersection of two collections.\"\r\r\t\"(#(1 2 3 4) intersection: #(3 4 5)) >>> #(3 4)\"\r\r\t\"(#(1 2 3 4) intersection: #()) >>> #()\"\r\r\t\"(#() intersection: #(1 2 3 4)) >>> #()\"\r\r\t^ self species withAll: (self asSet intersection: aCollection) asArray"},{"name":"collect:","linesOfCode":8,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| newCollection |\r\tnewCollection := self species new.\r\tself do: [:each | newCollection add: (aBlock value: each)].\r\t^ newCollection"},{"name":"removeAllSuchThat:","linesOfCode":5,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Evaluate aBlock for each element and remove all that elements from\r\tthe receiver for that aBlock evaluates to true.  Use a copy to enumerate \r\tcollections whose order changes when an element is removed (i.e. Sets).\"\r\r\tself copy do: [:each | (aBlock value: each) ifTrue: [self remove: each]]"},{"name":"asArray","linesOfCode":10,"sourceCode":"asArray\r\t\"Answer an Array whose elements are the elements of the receiver.\r\tImplementation note: Cannot use ''Array withAll: self'' as that only\r\tworks for SequenceableCollections which support the replacement \r\tprimitive.\"\r\r\t| newArray index |\r\tnewArray := Array new: self size.\r\tindex := 0.\r\tself do: [:each | newArray at: (index := index + 1) put: each].\r\t^ newArray"},{"name":"groupedBy:","linesOfCode":13,"sourceCode":"groupedBy: aBlock\r\t\"Answer a dictionary whose keys are the result of evaluating aBlock for all my elements, and the value for each key is the selection of my elements that evaluated to that key. Uses species.\r\t\r\tExample of use:\r\t(#(1 2 3 4 5) groupedBy: [ :v | v odd ]) asString >>> 'an OrderedDictionary(true->#(1 3 5) false->#(2 4))'\r\t\"\r\t\r\t\r\t\r\t| groups |\r\tgroups := OrderedDictionary new.\r\tself do: [ :each |\r\t\t(groups at: (aBlock value: each) ifAbsentPut: [ OrderedCollection new ]) add: each ].\r\tself species ~~ OrderedCollection ifTrue: [\r\t\tgroups associationsDo: [ :association |\r\t\t\tassociation value: (self species withAll: association value) ]].\r\t^ groups\r"},{"name":"ifEmpty:ifNotEmpty:","linesOfCode":6,"sourceCode":"ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock\r\t\"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise\"\r\t\"If the notEmptyBlock has an argument, eval with the receiver as its argument\"\r\r\t^ self isEmpty\r\t\tifTrue: [ emptyBlock value ]\r\t\tifFalse: [ notEmptyBlock cull: self ]"},{"name":"spotterItemsFor:","linesOfCode":14,"sourceCode":"spotterItemsFor: aStep\r\t<spotterOrder: 10>\r\t| processor |\r\t(self isEmpty or: [ self size > self gtCollectionSizeThreshold ]) ifTrue: [ ^ self ].\r\tprocessor := aStep previousProcessorFrom: self.\r\t^ aStep listProcessor\r\t\ttitle: processor title;\r\t\tcandidatesLimit: 100;\r\t\titems: [ self collect: [ :each | each asSpotterCandidateLink value] as: OrderedCollection ];\r\t\titemName: processor itemName;\r\t\titemIcon: processor itemIcon;\r\t\tactLogic: processor actLogic; \r\t\tfilter: processor filter gtListFilter;\r\t\twantsToDisplayOnEmptyQuery: true"},{"name":"select:thenDo:","linesOfCode":7,"sourceCode":"select: selectBlock thenDo: doBlock\r    \"Utility method to improve readability.\r\tDo not create the intermediate collection.\"\r\r    self do: [: each |\r        ( selectBlock value: each ) \r\t\t\tifTrue: [ doBlock value: each ]\r    ]."},{"name":"selectEverySecond","linesOfCode":5,"sourceCode":"selectEverySecond\r\t\"#(1 2 3 4) selectEverySecond asArray \r\t>>> #(2 4)\r\t\"\r\t^ self selectEvery: [ :i | i \\\\ 2 = 0 ]"},{"name":"asGPoint","linesOfCode":2,"sourceCode":"asGPoint\r\t^ GPoint withCollection: self"},{"name":"degreeSin","linesOfCode":2,"sourceCode":"degreeSin\r\t^self collect: [:each | each degreeSin]"},{"name":"isEmptyOrNil","linesOfCode":3,"sourceCode":"isEmptyOrNil\r\t\"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil\"\r\r\t^ self isEmpty"},{"name":"maxValue:","linesOfCode":2,"sourceCode":"maxValue: aBlock\r\t^ self inject: (aBlock value: self anyOne) into: [ :max :each | max max: (aBlock value: each) ]"},{"name":"atRandom:","linesOfCode":9,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver. Uses aGenerator which\rshould be kept by the user in a variable and used every time. Use\rthis instead of #atRandom for better uniformity of random numbers because \r\tonly you use the generator. Causes an error if self has no elements.\"\r\t| rand |\r\r\tself emptyCheck.\r\trand := aGenerator nextInteger: self size.\r\tself withIndexDo: [:each :index | index = rand ifTrue: [^each]]"},{"name":"identityIncludes:","linesOfCode":4,"sourceCode":"identityIncludes: anObject \r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\tself do: [:each | anObject == each ifTrue: [^true]].\r\t^false"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeList: self"},{"name":"asWBTVarSubstitution","linesOfCode":8,"sourceCode":"asWBTVarSubstitution\r\tself ifEmpty: [ ^ '' ].\r\t\r\t^ ByteString streamContents: [ :out |\r\t\tself doWithIndex: [ :each :index |\r\t\t\tindex > 1 ifTrue: [ out space ].\r\t\t\tout nextPutAll: each asWBTVarSubstitution\r\t\t]\r\t]"},{"name":"copyWithDependent:","linesOfCode":4,"sourceCode":"copyWithDependent: newElement\r\t\"Answer a new collection with newElement added (as last\r\telement if sequenceable).\"\r\t^self copyWith: newElement"},{"name":"withIndexDo:","linesOfCode":6,"sourceCode":"withIndexDo: elementAndIndexBlock\r\t\"Just like do: except that the iteration index supplies the second argument to the block\"\r\t\"Support collection enumeration with a counter, even though not ordered\"\r\t| index |\r\tindex := 0.\r\tself do: [:item | elementAndIndexBlock value: item value: (index := index+1)]"},{"name":"addAssignToFloatArray:","linesOfCode":3,"sourceCode":"addAssignToFloatArray: aFloatArray\r\t1 to: aFloatArray size do: [ :i | aFloatArray at: i put: (aFloatArray at: i) + (self at: i) ].\r\t^ aFloatArray"},{"name":"truncated","linesOfCode":2,"sourceCode":"truncated\r\t^ self collect: [:a | a truncated]"},{"name":"setImportInVersionSpec:","linesOfCode":2,"sourceCode":"setImportInVersionSpec: aMetacelloVersionSpec\r  aMetacelloVersionSpec setImport: self asArray"},{"name":"asByteArray","linesOfCode":10,"sourceCode":"asByteArray\r\t\"Answer a ByteArray whose elements are the elements of the receiver.\r\tImplementation note: Cannot use ''ByteArray withAll: self'' as that only\r\tworks for SequenceableCollections which support the replacement \r\tprimitive.\"\r\r\t| array index |\r\tarray := ByteArray new: self size.\r\tindex := 0.\r\tself do: [:each | array at: (index := index + 1) put: each].\r\t^ array"},{"name":"write:","linesOfCode":6,"sourceCode":"write: anObject\r\r\tself\r\t\tdeprecated: 'Please use #add: instead'\r\t\ttransformWith: '`@receiver write: `@statements1' \r\t\t\t\t\t\t-> '`@receiver add: `@statements1'.\r\t^ self add: anObject"},{"name":"add:withOccurrences:","linesOfCode":4,"sourceCode":"add: newObject withOccurrences: anInteger\r\t\"Add newObject anInteger times to the receiver. Answer newObject.\"\r\r\tanInteger timesRepeat: [self add: newObject].\r\t^ newObject"},{"name":"contains:","linesOfCode":3,"sourceCode":"contains: aBlock\r\t\"For compatibility, please use #anySatisfy: instead!\"\r\t^self anySatisfy: aBlock"},{"name":"*","linesOfCode":2,"sourceCode":"* arg\r\r\t^ arg adaptToCollection: self andSend: #*"},{"name":"log","linesOfCode":2,"sourceCode":"log\r\t^ self collect: [:each | each log]"},{"name":"setForDo:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForDo: aBlock withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: self do: aBlock"},{"name":"asEmailHeaderString","linesOfCode":5,"sourceCode":"asEmailHeaderString\r\r\t^ String streamContents: [ :str | \r\t\t\tself\r\t\t\t\tdo: [ :e | str nextPutAll: e asEmailHeaderString ]\r\t\t\t\tseparatedBy: [ str nextPutAll: ', ' ] ]"},{"name":"gtDisplayOn:","linesOfCode":11,"sourceCode":"gtDisplayOn: stream\r\tself printNameOn: stream.\r\tstream\r\t\tspace;\r\t\tnextPut: $[;\r\t\tprint: self size;\r\t\tnextPutAll: (' item' asPluralBasedOn: self size);\r\t\tnextPut: $];\r\t\tspace.\r\tself size <= self gtCollectionSizeThreshold \r\t\tifTrue: [ self printElementsOn: stream ]"},{"name":"adaptToPoint:andSend:","linesOfCode":4,"sourceCode":"adaptToPoint: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a scalar, return a Collection of\r\tthe results of each element combined with the scalar in that expression.\"\r\r\t^ self collect: [:element | rcvr perform: selector with: element]"},{"name":"sorted:","linesOfCode":6,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\r\t^self asArray sort: aSortBlockOrNil"},{"name":"groupedBy:having:","linesOfCode":5,"sourceCode":"groupedBy: aBlock having: aSelectionBlock\r\t\"Like in SQL operation - Split the recievers contents into collections of \r\telements for which keyBlock returns the same results, and return those \r\tcollections allowed by selectBlock.\"\r\t^ (self groupedBy: aBlock) select: aSelectionBlock\r"},{"name":"hash","linesOfCode":9,"sourceCode":"hash\r\t\"Answer an integer hash value for the receiver such that,\r\t  -- the hash value of an unchanged object is constant over time, and\r\t  -- two equal objects have equal hash values\"\r\r\t| hash |\r\r\thash := self species hash.\r\tself size <= 10 ifTrue:\r\t\t[self do: [:elem | hash := hash bitXor: elem hash]].\r\t^hash bitXor: self size hash"},{"name":"reciprocal","linesOfCode":4,"sourceCode":"reciprocal\r\t\"Return the reciever full of reciprocated elements\"\r\t\"#(1 11 0.5) reciprocal >>> {1 . 1/11 . 2.0}\"\r\t^ self collect: [:a | a reciprocal]"},{"name":"mergeIntoMetacelloRepositories:","linesOfCode":2,"sourceCode":"mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec\r\r\tself do: [:each | each mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec ]"},{"name":"detect:","linesOfCode":5,"sourceCode":"detect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the first element for which aBlock evaluates to true.\"\r\t\"(#(1 2 3 4) detect: [ :each | each even ]) >>> 2\"\r\r\t^ self detect: aBlock ifNone: [self errorNotFound: aBlock]"},{"name":"isSequenceable","linesOfCode":2,"sourceCode":"isSequenceable\r\t^ false"},{"name":"errorNotFound:","linesOfCode":3,"sourceCode":"errorNotFound: anObject\r\t\"Raise a NotFound exception.\"\r\r\tNotFound signalFor: anObject"},{"name":"average","linesOfCode":7,"sourceCode":"average\r\t\"Calculate the average of a collection, return a CollectionIsEmpty exception if the collection is empty. Look averageIfEmpty: aBlock\"\r\t\r\t\" #(2 6 7) average   \r\t>>> 5 \"\r\t\r\t\" #(3 5 7 7) average \r\t>>> (11/2) \"\r\r\t^ self sum / self size"},{"name":"+","linesOfCode":2,"sourceCode":"+ arg\r\r\t^ arg adaptToCollection: self andSend: #+"},{"name":"abs","linesOfCode":3,"sourceCode":"abs\r\t\"Absolute value of all elements in the collection\"\r\t^ self collect: [:a | a abs]"},{"name":"includesSubstringAnywhere:","linesOfCode":12,"sourceCode":"includesSubstringAnywhere: testString\r\t\"Answer whether the receiver includes, anywhere in its nested structure, a string that has testString as a substring\"\r\tself do:\r\t\t[:element |\r\t\t\t(element isString)\r\t\t\t\tifTrue:\r\t\t\t\t\t[(element includesSubstring: testString) ifTrue: [^ true]].\r\t\t\t(element isCollection)\r\t\t\t\tifTrue:\r\t\t\t\t\t[(element includesSubstringAnywhere: testString) ifTrue: [^ true]]].\r\t^ false\r\r\"#(first (second third) ((allSentMessages ('Elvis' includes:)))) includesSubstringAnywhere:  'lvi'\""},{"name":"\\","linesOfCode":4,"sourceCode":"\\ aCollection\r\t\"Return all the elements in self that are not in aCollection\"\r\t\"'abc' \\ 'cbe' >>> 'a'.\"\r\t\r\t^ self difference: aCollection"},{"name":"setForVersion:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setForVersion: aString withInMetacelloConfig: aMetacelloConstructore\r    aMetacelloConstructore setFor: self version: aString"},{"name":"asMetacelloAttributeList","linesOfCode":2,"sourceCode":"asMetacelloAttributeList\r    ^ self"},{"name":"detectMax:","linesOfCode":17,"sourceCode":"detectMax: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument. \r\tAnswer the element for which aBlock evaluates to the highest magnitude.\r\tIf collection empty, return nil.  This method might also be called elect:.\"\r\r\t| maxElement maxValue |\r\tself do: [:each | | val | \r\t\tmaxValue == nil\r\t\t\tifFalse: [\r\t\t\t\t(val := aBlock value: each) > maxValue ifTrue: [\r\t\t\t\t\tmaxElement := each.\r\t\t\t\t\tmaxValue := val]]\r\t\t\tifTrue: [\"first element\"\r\t\t\t\tmaxElement := each.\r\t\t\t\tmaxValue := aBlock value: each].\r\t\t\t\t\"Note that there is no way to get the first element that works \r\t\t\t\tfor all kinds of Collections.  Must test every one.\"].\r\t^ maxElement"},{"name":"median","linesOfCode":8,"sourceCode":"median\r\t\"Return the middle element, or as close as we can get.\r\t\r\tExample of use:\r\t{1 . 2 . 3 . 4 . 5} median >>> 3\r\t{1 . 2 . 4 . 5} median >>> 3\r\t{1 . 2 . 5 . 5} median >>> (7/2)\r\t\"\r\t\r\t^ self asSortedCollection median"},{"name":"--","linesOfCode":2,"sourceCode":"-- other\r\t^ self , other"},{"name":"setLoadsInMetacelloProject:","linesOfCode":2,"sourceCode":"setLoadsInMetacelloProject: aMetacelloPackageSpec\r\r\taMetacelloPackageSpec setLoads: self asArray."},{"name":"includesAnyOf:","linesOfCode":3,"sourceCode":"includesAnyOf: aCollection \r\t\r\tself flag: 'use includesAny: instead'.\r\t\r\t^ self includesAny: aCollection.\r\t"},{"name":"asIdentitySet","linesOfCode":2,"sourceCode":"asIdentitySet\r\t^(IdentitySet new: self size) addAll: self; yourself"}],"meta":{"name":"Collection class","instanceVariables":[],"methods":[{"name":"with:with:with:with:with:with:","linesOfCode":10,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject\r\t\"Answer an instance of me, containing the six arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tadd: fifthObject;\r\t\tadd: sixthObject;\r\t\tyourself"},{"name":"with:with:with:with:","linesOfCode":8,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject \r\t\"Answer an instance of me, containing the four arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tyourself"},{"name":"fromSton:","linesOfCode":9,"sourceCode":"fromSton: stonReader\r\t\"For collections we chose to instanciate based a list of elements using #add:\r\tThis is not the best or most correct solution for all subclasses though,\r\tso some will revert to standard object behavior or chose another solution.\"\r\t\r\t| collection |\r\tcollection := self new.\r\tstonReader parseListDo: [ :each |\r\t\tcollection add: each ].\r\t^ collection"},{"name":"systemIconName","linesOfCode":2,"sourceCode":"systemIconName\r\r\t^ #collectionIcon"},{"name":"with:","linesOfCode":5,"sourceCode":"with: anObject \r\t\"Answer an instance of me containing anObject.\"\r\r\t^ self empty\r\t\tadd: anObject;\r\t\tyourself"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #Collection"},{"name":"with:with:with:with:with:","linesOfCode":9,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject\r\t\"Answer an instance of me, containing the five arguments as the elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tadd: fourthObject;\r\t\tadd: fifthObject;\r\t\tyourself"},{"name":"with:with:with:","linesOfCode":7,"sourceCode":"with: firstObject with: secondObject with: thirdObject \r\t\"Answer an instance of me containing the three arguments as elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tadd: thirdObject;\r\t\tyourself"},{"name":"with:with:","linesOfCode":6,"sourceCode":"with: firstObject with: secondObject \r\t\"Answer an instance of me containing the two arguments as elements.\"\r\r\t^ self new\r\t\tadd: firstObject;\r\t\tadd: secondObject;\r\t\tyourself"},{"name":"canonicalArgumentName","linesOfCode":2,"sourceCode":"canonicalArgumentName\r\r\t^ 'aCollection'."},{"name":"approvedSelectorsForMethodFinder","linesOfCode":2,"sourceCode":"approvedSelectorsForMethodFinder\r\r\t ^ self selectors"},{"name":"withAll:","linesOfCode":5,"sourceCode":"withAll: aCollection\r\t\"Create a new collection containing all the elements from aCollection.\"\r\r\t^ (self new: aCollection size)\r\t\taddAll: aCollection;\r\t\tyourself"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ self new"}],"meta":null}},{"name":"SequenceableCollection","instanceVariables":[],"methods":[{"name":"copyWith:","linesOfCode":12,"sourceCode":"copyWith: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver and has \r\tnewElement at the last element.\"\r\r\t| newIC |\r\tnewIC := self species new: self size + 1.\r\tnewIC \r\t\treplaceFrom: 1\r\t\tto: self size\r\t\twith: self\r\t\tstartingAt: 1.\r\tnewIC at: newIC size put: newElement.\r\t^newIC"},{"name":"at:incrementBy:","linesOfCode":4,"sourceCode":"at: index incrementBy: value\r\t\"(#(1 2 3 4) at: 3 incrementBy: 2) >>> 5\"\r\t\"(#(1 2 3 4) at: 2 incrementBy: 2) >>> 4\"\r\t\r\t^self at: index put: (self at: index) + value"},{"name":"copyReplaceFrom:to:with:","linesOfCode":29,"sourceCode":"copyReplaceFrom: start to: stop with: replacementCollection \r\t\"Answer a copy of the receiver satisfying the following conditions: If \r\tstop is less than start, then this is an insertion; stop should be exactly \r\tstart-1, start = 1 means insert before the first character, start = size+1 \r\tmeans append after last character. Otherwise, this is a replacement; start \r\tand stop have to be within the receiver's bounds.\"\r\r\t| newSequenceableCollection newSize endReplacement |\r\tnewSize := self size - (stop - start + 1) + replacementCollection size.\r\tendReplacement := start - 1 + replacementCollection size.\r\tnewSequenceableCollection := self species new: newSize.\r\tstart > 1 ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: 1\r\t\t\tto: start - 1\r\t\t\twith: self\r\t\t\tstartingAt: 1].\r\tstart <= endReplacement ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: start\r\t\t\tto: endReplacement\r\t\t\twith: replacementCollection\r\t\t\tstartingAt: 1].\r\tendReplacement < newSize ifTrue:[\r\t\tnewSequenceableCollection\r\t\t\treplaceFrom: endReplacement + 1\r\t\t\tto: newSize\r\t\t\twith: self\r\t\t\tstartingAt: stop + 1].\r\t^newSequenceableCollection"},{"name":"reject:thenCollect:","linesOfCode":8,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Optimized version of Collection>>#reject:thenCollect:\"\r\t\r\t\"(#(1 2 3 4) reject: [:each | each = 3 ] thenCollect: [:each | each + 10 ]) >>> #(11 12 14)\"\r\t\r\t| each |\r\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(rejectBlock value: (each := self at: index))\r\t\t\t\tifFalse: [ stream nextPut: (collectBlock value: each) ]]]"},{"name":"seventh","linesOfCode":5,"sourceCode":"seventh\r\t\"Answer the seventh element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) seventh >>> #g\"\r\r\t^ self at: 7"},{"name":"stonOn:","linesOfCode":6,"sourceCode":"stonOn: stonWriter\r\t\"Instances of STON listClass will be encoded directly, without a class tag.\r\tOther (sub)classes will be encoded with a class tag and will use a list representation. \"\r\r\tself class == STON listClass\r\t\tifTrue: [ stonWriter writeList: self ]\r\t\tifFalse: [ super stonOn: stonWriter ]"},{"name":"asFloatArray","linesOfCode":7,"sourceCode":"asFloatArray\r\t\"Answer a FloatArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| floatArray |\r\tfloatArray := FloatArray new: self size.\r\t1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].\r\t^floatArray"},{"name":"flatCollect:","linesOfCode":12,"sourceCode":"flatCollect: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. optimized version for Sequencable Collection and subclasses\r\timplementing #writeStream\"\r\r\t\"(#( (2 -3) (4 -5) #(-6)) flatCollect: [ :e | e abs  ]) >>> #(2 3 4 5 6)\"\r\r\t\"(#( (2 -3) #((4 -5)) #(-6)) flatCollect: [ :e | e abs  ]) >>> #(2 3 #(4 5) 6)\"\r\r\tself isEmpty\r\t\tifTrue: [ ^ self copy ].\r\t^self species \r\t\tnew: 0\r\t\tstreamContents: [ :stream | self do: [ :each | stream nextPutAll: (aBlock value: each) ] ]"},{"name":"splitOn:do:","linesOfCode":4,"sourceCode":"splitOn: splitter do: aBlock\r\t\"Perform an action specified as aBlock to each of the elements of the receiver that have been split using the splitter argument. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\t\"(String streamContents: [:s | 'Pharo is cool' splitOn: Character space do: [:each | s << each ]])>>>'Pharoiscool'\"\r\t\r\t^ splitter split: self do: aBlock"},{"name":"replaceAll:with:","linesOfCode":15,"sourceCode":"replaceAll: oldObject with: newObject \r\t\"Replace all occurrences of oldObject with newObject\"\r\t\"(#(a b a d a) replaceAll: #a with: #e) >>> #(e b e d e)\"\r\t\r\t| index |\r\tindex := self\r\t\t\t\tindexOf: oldObject\r\t\t\t\tstartingAt: 1\r\t\t\t\tifAbsent: [0].\r\t[index = 0]\r\t\twhileFalse: \r\t\t\t[self at: index put: newObject.\r\t\t\tindex := self\r\t\t\t\t\t\tindexOf: oldObject\r\t\t\t\t\t\tstartingAt: index + 1\r\t\t\t\t\t\tifAbsent: [0]]"},{"name":"asGPUFloat32x2Array","linesOfCode":2,"sourceCode":"asGPUFloat32x2Array\r\t^ self asGPUArrayOfType: #Float32x2"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock \r\t\"Refer to the comment in Collection|do:.\"\r\t1 to: self size do:\r\t\t[:index | aBlock value: (self at: index)]"},{"name":"before:","linesOfCode":7,"sourceCode":"before: target\r\t\"Answer the receiver's element immediately before target. Raise an\r\terror if target is not an element of the receiver, or if there are no \r\telements before it (i.e. it is the first element).\"\r\t\"(#(11 22 33) before: 22) >>> 11\"\r\t\"(#(11 22 33) before: 33) >>> 22\"\r\r\t^ self before: target ifAbsent: [self errorNotFound: target]"},{"name":"allPairsDo:","linesOfCode":5,"sourceCode":"allPairsDo: aBinaryBlock\r\t\"Iterate over all the pairs of the receiver and apply the binaryBlock\r\tto each pair. \"\r\r\t\"(Array streamContents: [ :stream | #(0 1 2 3) allPairsDo: [ :first :second | stream nextPut: { first . second } ] ]) >>> #(#(0 0) #(0 1) #(0 2) #(0 3) #(1 0) #(1 1) #(1 2) #(1 3) #(2 0) #(2 1) #(2 2) #(2 3) #(3 0) #(3 1) #(3 2) #(3 3))\"\r\r\tself do: [ :first | self do: [ :second | aBinaryBlock value: first value: second ] ]"},{"name":"combinations:atATimeDo:","linesOfCode":10,"sourceCode":"combinations: kk atATimeDo: aBlock\r\t\"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations.\"\r\r\t\"(Array streamContents: [:stream | 'abcde' combinations: 3 atATimeDo: [:each | stream nextPut: each copy]]) >>> #(#($a $b $c) #($a $b $d) #($a $b $e) #($a $c $d) #($a $c $e) #($a $d $e) #($b $c $d) #($b $c $e) #($b $d $e) #($c $d $e))\"\r\r\t| aCollection |\r\taCollection := Array new: kk.\r\tself\r\t\tcombinationsAt: 1\r\t\tin: aCollection\r\t\tafter: 0\r\t\tdo: aBlock"},{"name":"putOn:","linesOfCode":5,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream by iterating over its elements.\r\tIn general we assume aStream accepts the receiver's elements as element type.\r\tReturn self.\"\r\r\tself do: [ :each | each putOn: aStream ]"},{"name":"allButFirst","linesOfCode":5,"sourceCode":"allButFirst\r\t\"Answer a copy of the receiver containing all but the first\r\telement. Raise an error if there are not enough elements.\"\t\r\t\"#(a b c) allButFirst >>> #(b c)\"\r\r\t^ self allButFirst: 1"},{"name":"split:indicesDo:","linesOfCode":15,"sourceCode":"split: aSequenceableCollection indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of aSequenceableCollection that have been identified by taking the receiver as a splitter.\"\r\t\"('||' split: 'foo||bar||2')>>>#('foo' 'bar' '2') asOrderedCollection\"\r\t\"(String streamContents: [:s | '||' split: 'foo||bar||2' indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:3 s:6 e:8 s:11 e:11 '\"\r\t\r\t| position oldPosition |\r\tposition := 1.\r\toldPosition := position.\r\tposition := aSequenceableCollection indexOfSubCollection: self startingAt: position.\r\t\r\t[ position > 0 ] whileTrue: [\r\t\taBlock value: oldPosition value: position - 1.\r\t\tposition := position + self size.\r\t\toldPosition := position.\r\t\tposition := aSequenceableCollection indexOfSubCollection: self startingAt: position.\r\t].\r\r\taBlock value: oldPosition value: aSequenceableCollection size.\r\r"},{"name":"reverseDo:","linesOfCode":7,"sourceCode":"reverseDo: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument, \r\tstarting with the last element and taking each in sequence up to the \r\tfirst. For SequenceableCollections, this is the reverse of the enumeration \r\tfor do:.\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) reverseDo: [:each | stream nextPut: each + 10]]) >>> #(13 12 11)\"\r\r\tself size to: 1 by: -1 do: [:index | aBlock value: (self at: index)]"},{"name":"asGroup","linesOfCode":2,"sourceCode":"asGroup\r\t^ (RSGroup new: self size) addAll: self; yourself"},{"name":"bind:","linesOfCode":5,"sourceCode":"bind: aBlock \r\r\t\"Extract items from the receiver and use them as arguments of aBlock. Signal an error\r\t(ArgumentsCountMismatch) when the arguments count of aBlock does not match the receiver size.\" \r\t\r\t\"(#(1 2 3) bind: [ :first :second :third | first + second + third ]) >>> 6\"\r\r\t^ aBlock valueWithArguments: self"},{"name":"joinUsing:last:","linesOfCode":8,"sourceCode":"joinUsing: joiner last: last \r\t\"Append the elements of the receiver separating them with the joiner argument and handle the last elment separation using the last argument.\"\r\t\r\t\"(#(1 2 3 4) joinUsing: ', ' last: ' and ') >>> '1, 2, 3 and 4'\"\r\t\r\t(self size = 0) ifTrue: [  ^ '' ].\r\t(self size = 1) ifTrue: [  ^ self first asString ].\r\t^ last join: (Array\r\t\t\t\twith: (joiner join: self allButLast)\r\t\t\t\twith: self last)"},{"name":"asPetitStream","linesOfCode":2,"sourceCode":"asPetitStream\r\t^ PPStream on: self"},{"name":"isSortedBy:","linesOfCode":15,"sourceCode":"isSortedBy: aBlock\r\t\"Return true if the receiver is sorted by the given criterion.\"\r\t\"(#(1 2 3) isSortedBy: [:a :b | a <= b ]) >>> true\"\r\t\"(#(1 2 3) isSortedBy: [:a :b | a >= b ]) >>> false\"\r\t\"(#(xa xc xz xb xy) isSortedBy: #last ascending) >>> false\"\r\t\"(#(xa xb xc xy xz) isSortedBy: #last ascending) >>> true\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\t(aBlock value: lastElm value: elm) ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"isSorted","linesOfCode":14,"sourceCode":"isSorted\r\t\"Return true if the receiver is sorted by the given criterion.\r\tOptimization for isSortedBy: [:a :b | a <= b].\"\r\t\"#(1 2 3) isSorted >>> true\"\r\t\"#(1 2 3 0) isSorted >>> false\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\tlastElm <= elm ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"asDastrelCollectionWithContext","linesOfCode":2,"sourceCode":"asDastrelCollectionWithContext\r\t^ DASLCollectionWithContext new collection: self"},{"name":"do:separatedBy:","linesOfCode":8,"sourceCode":"do: elementBlock separatedBy: separatorBlock\r\t\"Evaluate the elementBlock for all elements in the receiver,\r\tand evaluate the separatorBlock between.\"\r\t\r\t\"(Array streamContents: ([:stream | #(1 2 3) do: [:each | stream nextPut: (each + 10)] separatedBy: [ stream nextPut: 0 ]])) >>> #(11 0 12 0 13)\"\r\r\t1 to: self size do:\r\t\t[:index |\r\t\tindex = 1 ifFalse: [separatorBlock value].\r\t\telementBlock value: (self at: index)]"},{"name":"reject:thenDo:","linesOfCode":7,"sourceCode":"reject: rejectBlock thenDo: aBlock\r\t\"Refer to the comment in Collection>>#reject:thenDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) reject: [:each | each = 3 ] thenDo: [:each | stream nextPut: each + 10]]) >>> #(11 12 14)\"\r\t\r\t|  each |\r\t\r\t1 to: self size do: [ :index |\r\t\t(rejectBlock value: (each := self at: index))\r\t\t\tifFalse: [ aBlock value: each ]]."},{"name":"collect:thenSelect:","linesOfCode":9,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Optimized version of Collection>>#collect:thenSelect:\"\r\t\r\t\"(#(1 2 3) collect: [:each | each + 10 ] thenSelect: [:each | each even]) >>> #(12)\"\r\t\r\t| each |\r\t\r\t^  self class new: self size streamContents: [ :stream |\r\t\t1 to: self size do: [:index |\r\t\t\teach := collectBlock value: (self at: index).\r\t\t\t(selectBlock value: each)\r\t\t\t\tifTrue: [ stream nextPut: each ]]]"},{"name":"paddedWith:do:","linesOfCode":10,"sourceCode":"paddedWith: otherCollection do: twoArgBlock \r\t\"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection.\r\tMissing elements from either will be passed as nil.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) paddedWith: #(40 50 60) do: [:first :second | stream nextPut: (first + second)]]) >>> #(50 70 90) \"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) paddedWith: #(40 50) do: [:a :b | stream nextPut: {a. b} ]]) >>> #(#(10 40) #(20 50) #(30 nil)) \"\r\r\t\"(Array streamContents: [:stream | #(10 20) paddedWith: #(40 50 60) do: [:a :b | stream nextPut: {a. b} ]]) >>> #(#(10 40) #(20 50) #(nil 60))\"\r\t\t\r\t1 to: (self size max: otherCollection size) do:\r\t\t[:index | twoArgBlock value: (self at: index ifAbsent: [])\r\t\t\t\tvalue: (otherCollection at: index ifAbsent: [])]"},{"name":"collectWithIndex:","linesOfCode":3,"sourceCode":"collectWithIndex: elementAndIndexBlock\r\t\"Use the new version with consistent naming\"\r\t^ self withIndexCollect: elementAndIndexBlock"},{"name":"swap:with:","linesOfCode":7,"sourceCode":"swap: oneIndex with: anotherIndex \r\t\"Move the element at oneIndex to anotherIndex, and vice-versa.\"\r\t\"(#(a b c d e) swap: 5 with: 1) >>> #(e b c d a)\"\r\r\t| element |\r\telement := self at: oneIndex.\r\tself at: oneIndex put: (self at: anotherIndex).\r\tself at: anotherIndex put: element"},{"name":"difference:","linesOfCode":3,"sourceCode":"difference: aCollection\r\t\"Answer the difference of two sequences preserving order and collection type.\"\r\t^ self reject: [:each | aCollection includes: each]"},{"name":"runningMax:","linesOfCode":4,"sourceCode":"runningMax: aSubsetSize\r\t\"Running max. See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningMax: 3) >>> {2 . 2 . 3 . 3}\"\r\r\t^ self running: [ :subset | subset max ] of: aSubsetSize"},{"name":"beginsWith:","linesOfCode":9,"sourceCode":"beginsWith: aSequenceableCollection\r\t\"Answer true if the receiver starts with the argument collection\"\r\t\r\t\"#(1 2 3 4 5) beginsWith: #() >>> false\"\r\t\"#(1 2 3) beginsWith: #(1 2 3 4 5) >>> false\"\r\t\"#(1 2 3 4 5) beginsWith: #(0 1 2) >>> false\"\r\t\"#(1 2 3 4 5) beginsWith: #(1 2 3) >>> true\"\r\t\r\t(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].\r\taSequenceableCollection withIndexDo: [:each :index | (self at: index) ~= each ifTrue: [^false]].\r\t^true"},{"name":"findBinary:","linesOfCode":9,"sourceCode":"findBinary: aBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, raise an error.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ]) >>> 11 \"\r\r\t^ self findBinary: aBlock do: [ :found | found ] ifNone: [ self errorNotFound: aBlock ]"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: oldObject ifAbsent: anExceptionBlock \r\t\"SequencableCollections cannot implement removing.\"\r\r\tself shouldNotImplement"},{"name":"indexOfAnyOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"indexOfAnyOf: aCollection startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of any element included in aCollection after start within the receiver.\r\tIf the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.\r\tNote: it is user responsibility to provide aCollection that behaves relatevily fast when asked for includes: (like a Set)\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 2 ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 4 ifAbsent: 7) >>> 7\"\r\r\tstart to: self size do:\r\t\t[:index |\r\t\t(aCollection includes: (self at: index)) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"asGPUFloat32x3Array","linesOfCode":2,"sourceCode":"asGPUFloat32x3Array\r\t^ self asGPUArrayOfType: #Float32x3"},{"name":"asGPUArrayOfType:","linesOfCode":2,"sourceCode":"asGPUArrayOfType: type\r\t^ SGPUCompilationEnvironment current constructArrayOfType: type with: self"},{"name":"groupsOf:atATimeDo:","linesOfCode":17,"sourceCode":"groupsOf: n atATimeDo: aBlock \r\t\"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.\r\tAllows use of a flattened \r\tarray for things that naturally group into groups of n.\r\tIf aBlock has a single argument, pass it an array of n items,\r\totherwise, pass the items as separate arguments.\r\tSee also pairsDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40 50) groupsOf: 2 atATimeDo:  [:first :second | stream nextPut: (first + second)]]) >>> #(30 70)\"\r\t\r\t| passArray |\r\tpassArray := (aBlock numArgs = 1).\r\tn\r\t\tto: self size\r\t\tby: n\r\t\tdo: [:index | | args | \r\t\t\targs := (self copyFrom: index - n + 1 to: index) asArray.\r\t\t\tpassArray ifTrue: [ aBlock value: args ]\r\t\t\t\tifFalse: [ aBlock valueWithArguments: args ]]."},{"name":"overlappingPairsWithIndexDo:","linesOfCode":5,"sourceCode":"overlappingPairsWithIndexDo: aBlock \r\t\"Emit overlapping pairs of my elements into aBlock, along with an index.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40) overlappingPairsWithIndexDo: [:first :second :index| stream nextPut: (first + second + index)]]) >>> #(31 52 73)\"\r\r\t1 to: self size - 1\r\t\tdo: [:i | aBlock value: (self at: i) value: (self at: i + 1) value: i ]"},{"name":"atPin:","linesOfCode":9,"sourceCode":"atPin: index \r\t\"Return the index'th element of me if possible.\r\tReturn the first or last element if index is out of bounds.\"\r\t\"(#(w x y z) atPin: 2) >>> #x\"\r\t\"(#(w x y z) atPin: 4) >>> #z\"\r\t\"(#(w x y z) atPin: 8) >>> #z\"\r\r\tindex < 1 ifTrue: [^ self first].\r\tindex > self size ifTrue: [^ self last].\r\t^ self at: index"},{"name":"max:","linesOfCode":11,"sourceCode":"max: aBlock\r\t| max |\r\tself ifEmpty: [ ^ nil ].\r\tmax := aBlock value: self first.\r\tself\r\t\tallButFirstDo:\r\t\t\t[ :each | \r\t\t\t| value |\r\t\t\tvalue := aBlock value: each.\r\t\t\tmax := max max: value ].\r\t^ max"},{"name":"asGPUFloat64x4Array","linesOfCode":2,"sourceCode":"asGPUFloat64x4Array\r\t^ self asGPUArrayOfType: #Float64x4"},{"name":"indexOfAnyOf:startingAt:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection startingAt: start\r\t\"Answer the index of the first occurrence of any element included in aCollection after start within the receiver.\r\tIf the receiver does not contain anElement, answer zero, which is an invalid index.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 2) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) startingAt: 4) >>> 0\"\r\r\t^self indexOfAnyOf: aCollection startingAt: start ifAbsent: [0]"},{"name":"first:","linesOfCode":5,"sourceCode":"first: n\r\t\"Answer the first n elements of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"(#(a b c d e f g h ) first: 3) >>> #(a b c)\"\r\r\t^ self copyFrom: 1 to: n"},{"name":"copyReplaceAll:with:","linesOfCode":15,"sourceCode":"copyReplaceAll: oldSubCollection with: newCollection\r\t\"Answer a copy of the receiver in which all occurrences of\r\toldSubCollection have been replaced by newCollection \"\r\r\t| aString startSearch currentIndex endIndex |\r\t\r\taString := self.\r\tstartSearch := 1.\r\t[(currentIndex := aString indexOfSubCollection: oldSubCollection startingAt: startSearch) > 0]\r\t\twhileTrue: [\r\t\t\tendIndex := currentIndex + oldSubCollection size - 1.\r\t\t\taString := aString\r\t\t\t\t\tcopyReplaceFrom: currentIndex\r\t\t\t\t\tto: endIndex\r\t\t\t\t\twith: newCollection.\r\t\t\t\tstartSearch := currentIndex + newCollection size].\r\r\t^ aString"},{"name":"endsWith:","linesOfCode":7,"sourceCode":"endsWith: aSequenceableCollection\r\t\"Answer true if the receiver ends with the argument collection\"\r\t\r\t| start |\r\t(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].\r\tstart := self size - aSequenceableCollection size.\r\taSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].\r\t^true"},{"name":"permutationsStartingAt:do:","linesOfCode":9,"sourceCode":"permutationsStartingAt: anInteger do: aBlock\r\tanInteger > self size\r\t\tifTrue: [ ^ self ].\r\tanInteger = self size\r\t\tifTrue: [ ^ aBlock value: self ].\r\tanInteger to: self size do: [ :i | \r\t\tself swap: anInteger with: i.\r\t\tself permutationsStartingAt: anInteger + 1 do: aBlock.\r\t\tself swap: anInteger with: i ]"},{"name":"asPointArray","linesOfCode":7,"sourceCode":"asPointArray\r\t\"Answer an PointArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| pointArray |\r\tpointArray := PointArray new: self size.\r\t1 to: self size do:[:i| pointArray at: i put: (self at: i)].\r\t^pointArray"},{"name":"mergeSortFrom:to:src:dst:by:","linesOfCode":9,"sourceCode":"mergeSortFrom: first to: last src: src dst: dst by: aBlock\r\t\"Private. Split the range to be sorted in half, sort each half, and \r\tmerge the two half-ranges into dst.\"\r\r\t| middle |\r\tfirst = last ifTrue: [^ self].\r\tmiddle := (first + last) // 2.\r\tself mergeSortFrom: first to: middle src: dst dst: src by: aBlock.\r\tself mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.\r\tsrc mergeFirst: first middle: middle last: last into: dst by: aBlock"},{"name":"asDigitsToPower:do:","linesOfCode":8,"sourceCode":"asDigitsToPower: anInteger do: aBlock\r\t\"Repeatedly value aBlock with a single Array.  Adjust the collection\r\tso that aBlock is presented all (self size raisedTo: anInteger) possible \r\tcombinations of the receiver's elements taken as digits of an anInteger long number.\"\r\r\t\"(Array streamContents: [:stream | (0 to: 1) asDigitsToPower: 4 do: [:each | stream nextPut: each copy]]) >>> #((0 0 0 0) (0 0 0 1) (0 0 1 0) (0 0 1 1) (0 1 0 0) (0 1 0 1) (0 1 1 0) (0 1 1 1) (1 0 0 0) (1 0 0 1) (1 0 1 0) (1 0 1 1) (1 1 1 0) (1 1 1 1))\"\r\r\t| aCollection |\r\taCollection := Array new: anInteger.\r\tself asDigitsAt: 1 in: aCollection do: aBlock"},{"name":"select:","linesOfCode":8,"sourceCode":"select: aBlock \r\t\"Optimized version of Collection>>#select:\"\r\t\r\t\"(#(1 2 3 4) select: [:each | each > 2 ]) >>> #(3 4)\"\r\t\r\t| each |\r\t^ self species new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(aBlock value: (each := self at: index))\r\t\t\t\tifTrue: [ stream nextPut: each ]]]"},{"name":"do:without:","linesOfCode":7,"sourceCode":"do: aBlock without: anItem\r\t\"Enumerate all elements in the receiver.\r\tExecute aBlock for those elements that are not equal to the given item\"\r\t\"Refer to the comment in Collection|do:.\"\r\t\r\t\"(Array streamContents: ([:stream | #(1 2 3) do: [:each | stream nextPut: (each + 10)] without: 2])) >>> #(11 13)\"\r\t\r\t1 to: self size do:\r\t\t[:index | anItem = (self at: index) ifFalse:[aBlock value: (self at: index)]]"},{"name":"allButLast","linesOfCode":5,"sourceCode":"allButLast\r\t\"Answer a copy of the receiver containing all but the last\r\telement. Raise an error if there are not enough elements.\"\r\t\"#(a b c d) allButLast >>> #(a b c)\"\r\r\t^ self allButLast: 1"},{"name":"after:","linesOfCode":5,"sourceCode":"after: target\r\t\"Answer the element after target.  Raise an error if target is not\r\tin the receiver, or if there are no elements after it.\"\r\t\"(#(a b c d) after: #b) >>> #c\"\r\r\t^ self after: target ifAbsent: [self errorNotFound: target]"},{"name":"reduceRight:","linesOfCode":17,"sourceCode":"reduceRight: aBlock\r\t\"Fold the result of the receiver from right to left into aBlock. The argument aBlock must take two or more arguments.\"\r\r\t\"(#(1 2 3) reduceRight: [ :a :b | a - b ]) >>> (1 - (2 - 3))\"\r\t\"(#(1 2 3) reduceRight: [ :a :b | a - b ]) >>> 2\"\r\t\"(#(1 + 3 - 5) reduceRight: [ :a :op :b | a perform: op with: b ]) >>> (1 + (3 - 5))\"\r\t\"(#(1 + 3 - 5) reduceRight: [ :a :op :b | a perform: op with: b ]) >>> -1\"\r\r\t| arguments |\r\tself emptyCheck.\r\targuments := Array new: aBlock argumentCount.\r\t(arguments size = 0 or: [ (self size + 1) \\\\ (arguments size - 1) > 0 ])\r\t\tifTrue: [ self error: 'Collection size and block argument count do not match.' ].\r\targuments at: arguments size put: self last.\r\tself size - arguments size + 1 to: 1 by: 1 - arguments size do: [ :index |\r\t\targuments\r\t\t\treplaceFrom: 1 to: aBlock argumentCount - 1 with: self startingAt: index;\r\t\t\tat: arguments size put: (aBlock valueWithArguments: arguments) ].\r\t^ arguments last"},{"name":"lastIndexOf:ifAbsent:","linesOfCode":7,"sourceCode":"lastIndexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOf: #a ifAbsent: 7) >>> 5\"\r\t\"(#(a b a d e) lastIndexOf: #c ifAbsent: 7) >>> 7\"\r\t\r\t^self lastIndexOf: anElement startingAt: self size ifAbsent: exceptionBlock"},{"name":"=","linesOfCode":8,"sourceCode":"= otherCollection \r\t\"Answer true if the receiver is equivalent to the otherCollection.\r\tFirst test for identity, then rule out different species and sizes of\r\tcollections. As a last resort, examine each element of the receiver\r\tand the otherCollection.\"\r\r\tself == otherCollection ifTrue: [^ true].\r\tself species == otherCollection species ifFalse: [^ false].\r\t^ self hasEqualElements: otherCollection"},{"name":"allButLastDo:","linesOfCode":5,"sourceCode":"allButLastDo: block\r\r\t\"Executes aBlock on each of the receiver's elements except for the last one\"\r\r\t\"(Array streamContents: [:stream | #(1 2 3) allButLastDo: [:each | stream nextPut: (each + 10)]]) >>> #(11 12)\"\r\r\t1 to: self size - 1 do:\r\t\t[:index | block value: (self at: index)]"},{"name":"atAll:","linesOfCode":10,"sourceCode":"atAll: indexArray\r\t\"Answer a new collection like the receiver which contains all elements\r\tof the receiver at the indices of indexArray.\"\r\t\"(#('one' 'two' 'three' 'four') atAll: #(3 2 4)) >>> #('three' 'two' 'four')\"\r\r\t| newCollection |\r\tnewCollection := self species ofSize: indexArray size.\r\t1 to: indexArray size do:\r\t\t[:index |\r\t\tnewCollection at: index put: (self at: (indexArray at: index))].\r\t^ newCollection"},{"name":"from:to:do:","linesOfCode":4,"sourceCode":"from: start to: stop do: aBlock\r\t\"Evaluate aBlock for all elements between start and stop (inclusive).\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30 40) from: 2 to: 3 do: [:each | stream nextPut: each]]) >>> #(20 30)\"\r\r\tstart to: stop do: [:index | aBlock value: (self at: index)]"},{"name":"runningMin:","linesOfCode":4,"sourceCode":"runningMin: aSubsetSize\r\t\"Running min. See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningMin: 3) >>> {1 . 1 . 2 . 2}\"\r\r\t^ self running: [ :subset | subset min ] of: aSubsetSize"},{"name":"beginsWithAnyOf:","linesOfCode":3,"sourceCode":"beginsWithAnyOf: aCollection\r\t\"Return true if the receiver starts with any of the elements in aCollection.\"\r\t^aCollection anySatisfy:[:prefix| self beginsWith: prefix]"},{"name":"asStringWithCr","linesOfCode":12,"sourceCode":"asStringWithCr\r\t\"Convert to a string with returns between items.  Elements are\rusually strings.\r\t Useful for labels for PopUpMenus.\"\r\t| labelStream |\r\tlabelStream := (String new: 200) writeStream.\r\tself do: [:each |\r\t\teach isString\r\t\t\tifTrue: [labelStream nextPutAll: each; cr]\r\t\t\tifFalse: [each printOn: labelStream. labelStream cr]].\r\tself size > 0 ifTrue: [labelStream skip: -1].\r\t^ labelStream contents"},{"name":"copyEmpty","linesOfCode":2,"sourceCode":"copyEmpty\r\t^ self species new: 0"},{"name":"readStreamDo:","linesOfCode":4,"sourceCode":"readStreamDo: aBlock\r\t\"Evaluates the argument with the read stream of the collection. Answers the result.\"\r\t\r\t\"#(3 4 5) readStreamDo: [ :stream | stream contents ] >>> #(3 4 5)\"\r\r\t^ aBlock value: self readStream"},{"name":"with:collect:","linesOfCode":12,"sourceCode":"with: otherCollection collect: twoArgBlock \r\t\"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection.\"\r\t\r\t\"(#(1 2 3) with: #(4 5 6) collect: [:a :b | a + b]) >>> #(5 7 9)\"\r\t\r\t| result |\r\totherCollection size = self size ifFalse: [self errorSizeMismatch].\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result at: index put:\r\t\t(twoArgBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: (otherCollection at: index))].\r\t^ result"},{"name":"groupsOf:","linesOfCode":12,"sourceCode":"groupsOf: n\r\t| groups pos |\r\r\tpos := 0.\r\tgroups := OrderedCollection new.\r\t(n to: self size by: n) do: [ :index | \r\t\t\t| args |\r\t\t\targs := self copyFrom: index - n + 1 to: index.\r\t\t\tgroups add: args.\r\t\t\tpos := pos + n ].\r\tpos < self size ifTrue: [ \r\t\tgroups add: (self copyFrom: pos + 1 to: self size) ].\r\t^ groups"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"#(a b c d e) size >>> 5\"\r\t\"#(x y z) size >>> 3\"\r\t\r\t^ self subclassResponsibility"},{"name":"collect:from:to:","linesOfCode":9,"sourceCode":"collect: aBlock from: firstIndex to: lastIndex\r\t\"Refer to the comment in Collection|collect:.\"\r\t\r\t\"(#(1 2 3 4) collect: [:each | each  + 10] from: 2 to: 3) >>> #(12 13) \"\r\r\t| size result j |\r\tsize := lastIndex - firstIndex + 1.\r\tresult := self species new: size.\r\tj := firstIndex.\r\t1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j := j + 1].\r\t^ result"},{"name":"indexOfAnyOf:ifAbsent:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of any element included in aCollection within the receiver.\r\tIf the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c) ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y z) ifAbsent: 7) >>> 7\"\r\r\t^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: exceptionBlock"},{"name":"overlappingPairsCollect:","linesOfCode":8,"sourceCode":"overlappingPairsCollect: aBlock \r\r\t\"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements.\"\r\t\r\t\"(#(1 2 3 4) overlappingPairsCollect: [:first :second| first + second]) >>> #(3 5 7)\"\r\t\r\t| retval |\r\tretval := self species ofSize: self size - 1.\r\t1 to: self size - 1\r\t\tdo: [:i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].\r\t^retval"},{"name":"asIntegerArray","linesOfCode":7,"sourceCode":"asIntegerArray\r\t\"Answer an IntegerArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| intArray |\r\tintArray := IntegerArray new: self size.\r\t1 to: self size do:[:i| intArray at: i put: (self at: i)].\r\t^intArray"},{"name":"first","linesOfCode":4,"sourceCode":"first\r\t\"Answer the first element of the receiver\"\r\t\"#(a b c d e f g h ) first >>> #a\"\r\r\t^ self at: 1"},{"name":"mergeFirst:middle:last:into:by:","linesOfCode":21,"sourceCode":"mergeFirst: first middle: middle last: last into: dst by: aBlock\r\t\"Private. Merge the sorted ranges [first..middle] and [middle+1..last] \r\tof the receiver into the range [first..last] of dst.\"\r\r\t| i1 i2 val1 val2 out |\r\ti1 := first.\r\ti2 := middle + 1.\r\tval1 := self at: i1.\r\tval2 := self at: i2.\r\tout := first - 1.  \"will be pre-incremented\"\r\r\t\"select 'lower' half of the elements based on comparator\"\r\t[(i1 <= middle) and: [i2 <= last]] whileTrue:\r\t\t[(aBlock value: val1 value: val2)\r\t\t\tifTrue: [dst at: (out := out + 1) put: val1.\r\t\t\t\t\tval1 := self at: (i1 := i1 + 1)]\r\t\t\tifFalse: [dst at: (out := out + 1) put: val2.\r\t\t\t\t\ti2 := i2 + 1.\r\t\t\t\t\ti2 <= last ifTrue: [val2 := self at: i2]]].\r\r\t\"copy the remaining elements\"\r\ti1 <= middle\r\t\tifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]\r\t\tifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]"},{"name":"permutationsDo:","linesOfCode":5,"sourceCode":"permutationsDo: aBlock\r\t\"Repeatly value aBlock with a single copy of the receiver. Reorder the copy\r\tso that aBlock is presented all (self size factorial) possible permutations.\"\r\r\t\"(Array streamContents: [:stream | (1 to: 3) permutationsDo: [:each | stream nextPut: each copy]]) >>> #(#(1 2 3) #(1 3 2) #(2 1 3) #(2 3 1) #(3 2 1) #(3 1 2))\"\r\r\tself shallowCopy permutationsStartingAt: 1 do: aBlock"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":10,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"This destructively replaces elements from start to stop in the receiver \r\tstarting at index, repStart, in the sequenceable collection, \r\treplacementCollection. Answer the receiver. No range checks are \r\tperformed.\"\r\r\t| index repOff |\r\trepOff := repStart - start.\r\tindex := start - 1.\r\t[(index := index + 1) <= stop]\r\t\twhileTrue: [self at: index put: (replacement at: repOff + index)]"},{"name":"reduce:","linesOfCode":7,"sourceCode":"reduce: aBlock\r\t\"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified.\"\r\r\t\"(#(1 2 3) reduce: [ :a :b | a + b ]) >>> 6\" \"1 + 2 + 3\"\r\t\"(#(1 2 3) reduce: [ :a :b | a + b ]) >>> (1 + 2 + 3)\"\r\r\t\"(#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]) >>> 15\"\r\t\"(#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]) >>> (1 + 2 + 3 + 4 + 5)\"\r\r\t^ self reduceLeft: aBlock"},{"name":"atLast:","linesOfCode":6,"sourceCode":"atLast: indexFromEnd\r\t\"Return element at indexFromEnd from the last position.\r\t atLast: 1, returns the last element\"\r\t\"(#(x y z) atLast: 1) >>> #z\"\r\t\"(#(x y z) atLast: 2) >>> #y\"\r\r\t^ self atLast: indexFromEnd ifAbsent: [self error: 'index out of range']"},{"name":"rsSwapElement:withElement:","linesOfCode":6,"sourceCode":"rsSwapElement: u withElement: v\r\t| index1 index2 |\r\tindex1 := self indexOf: u.\r\tindex2 := self indexOf: v.\r\tself at: index2 put: u.\r\tself at: index1 put: v."},{"name":"gtInspectorItemsIn:","linesOfCode":21,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self ];\r\t\tbeMultiple;\r\t\tenableElementIndex;\r\t\twantsAutomaticRefresh: true;\r\t\tcolumn: 'Index' evaluated: [ :value :idex | idex asString ] width: 50;\r\t\tcolumn: 'Item' evaluated: [ :value | GTObjectPrinter asTruncatedTextFrom: value ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult ifNotNil: [ \r\t\t\t\tresult isCollection ifTrue: [ \r\t\t\t\t\tresult size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] \r\t\t\t\t] ifFalse: [ result ]\r\t\t\t]\r\t\t]"},{"name":"fasterDifferencePreservingOrder:","linesOfCode":8,"sourceCode":"fasterDifferencePreservingOrder: aCollection\r\t\" this implementation does not preserve the original species of self ! it serves ONE specific use case only \"\r\t| newCollection |\r\tnewCollection := OrderedCollection new: self size.\r\tself do: [ :each | \r\t\t(aCollection includes: each) \r\t\t\tifFalse: [ newCollection add: each ] ].\r\t^ newCollection"},{"name":"detectIndex:","linesOfCode":5,"sourceCode":"detectIndex: aBlock\r\r\t\"Return index of first element that satisfies aBlock.\r\tIf no matching element is found, raise an error.\"\r\t\r\t\"(#(1 5 10) detectIndex: [ :each | each > 3 ]) >>> 2\"\r\r\t^ self detectIndex: aBlock ifNone: [ self errorNotFound: aBlock ] "},{"name":"piecesCutWhere:do:","linesOfCode":17,"sourceCode":"piecesCutWhere: binaryBlock do: pieceBlock\r\t\"Evaluate pieceBlock with substrings of the receiver derived from cutting the receiver at points where binaryBlock answers true for adjacent elements.\"\r\t\r\t\"(Array streamContents: [:stream |  #(1 2 3 1 6 1 2 3 4) piecesCutWhere: [ :a :b | a = 1 and: [ b = 2]] do: [:each | stream nextPut: each size]]) >>> #(1 5 3)\"\r\r\t| size lastCut this next |\r\t(size := self size) <= 1 ifTrue:\r\t\t [size = 1 ifTrue: [pieceBlock value: self].\r\t\t^self].\r\tlastCut := 1.\r\tthis := self at: 1.\r\t2 to: size do:\r\t\t[:i|\r\t\tnext := self at: i.\r\t\t(binaryBlock value: this value: next) ifTrue:\r\t\t\t[pieceBlock value: (self copyFrom: lastCut to: i - 1).\r\t\t\tlastCut := i].\r\t\tthis := next].\r\tpieceBlock value: (self copyFrom: lastCut to: size)"},{"name":"sorted","linesOfCode":6,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted in ascending order using the #'<=' operator.\"\r\t\"#(8 5 3 9) sorted >>> #(3 5 8 9)\"\r\t\"#(a b z d) sorted >>> #(a b d z)\"\r\t\r\t^self sorted: [ :a :b| a <= b ]"},{"name":"lastIndexOfAnyOf:startingAt:ifAbsent:","linesOfCode":9,"sourceCode":"lastIndexOfAnyOf: aCollection startingAt: lastIndex ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOfAnyOf: #(a b) startingAt: 1 ifAbsent: 7) >>> 1\"\r\r\tlastIndex to: 1 by: -1 do:\r\t\t[:index |\r\t\t(aCollection includes: (self at: index)) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"reverse","linesOfCode":3,"sourceCode":"reverse\r\t\"Answer a copy of the receiver with element order reversed, as expected by ANSI.\"\r\r\t^ self reversed"},{"name":"sort","linesOfCode":5,"sourceCode":"sort\r\t\"Sort this collection into ascending order using the '<=' operator.\"\r\t\"#(8 5 3 9) sort >>> #(3 5 8 9)\"\r\t\"#(a b z d) sort >>> #(a b d z)\"\r\t\r\tself sort: [:a :b | a <= b]"},{"name":"atWrap:","linesOfCode":8,"sourceCode":"atWrap: index\r\r    \"Answer the index'th element of the receiver.  If index is out of bounds,\r    let it wrap around from the end to the beginning until it is in bounds.\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 2) >>> 22\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 4) >>> 11\"\r    \"(#(11 22 33) asOrderedCollection atWrap: 5) >>> 22\"\r    \r    ^ self at: index - 1 \\\\ self size + 1"},{"name":"findBinary:do:ifNone:","linesOfCode":24,"sourceCode":"findBinary: aBlock do: actionBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf found, evaluate actionBlock with the found element as argument\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements or nil as arguments.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 11\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 12 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(11 15)'\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 0.5 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(nil 1)'\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 25 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(23 nil)'\"\r\r\t^ self\r\t\tfindBinaryIndex: aBlock\r\t\tdo: [ :foundIndex | actionBlock value: (self at: foundIndex) ]\r\t\tifNone: [ :prevIndex :nextIndex | \r\t\t\texceptionBlock\r\t\t\t\tcull:\r\t\t\t\t\t(prevIndex > 0\r\t\t\t\t\t\tifTrue: [ self at: prevIndex ])\r\t\t\t\tcull:\r\t\t\t\t\t(nextIndex <= self size\r\t\t\t\t\t\tifTrue: [ self at: nextIndex ]) ]"},{"name":"joinUsing:","linesOfCode":3,"sourceCode":"joinUsing: joiner\r\t\"Append the elements of the receiver separating them with the joiner - character, string or sequenceable collection. Return collection of the same collection class as 'joiner', or a String\"\r\t^ joiner join: self"},{"name":"piecesCutWhere:","linesOfCode":10,"sourceCode":"piecesCutWhere: binaryBlock\r\t\"Answer substrings of the receiver derived from cutting the receiver at points where binaryBlock answers true for adjacent elements.\"\r\t\"( #(1 2 3 1 6 1 2 3 4) piecesCutWhere: [ :a :b | a = 1 and: [ b = 2]]) asArray >>> #(#(1) #(2 3 1 6 1) #(2 3 4))\"\r\t| pieces |\r\tpieces := OrderedCollection new.\r\tself \r\t\tpiecesCutWhere: binaryBlock\r\t\tdo: [ :piece | pieces add: piece ].\r\t^pieces\r\r   \"'Now is the time for all good people to come to the aid of the cause of world peace.  It is just fine, even desirable, to love your country, if that means wanting it to play a beneficial role in the course of world events and be the best possible example of a good society.  But if it means wanting dominion over the rest of the world, it is not love but defensiveness or self-glorification, and will lead only to oblivion.'  piecesCutWhere: [:a :b| a = $. and: [b isSeparator]]\""},{"name":"anyOne","linesOfCode":7,"sourceCode":"anyOne\r\t\"Answer a representative sample of the receiver. It raises an error when the collection is empty. This method can be helpful when needing to preinfer the nature of the contents of semi-homogeneous collections.\"\r\t\"#(1 2 3) anyOne >>> 1\"\r\t\"\r\t([#() anyOne] on: SubscriptOutOfBounds do: [ :ex | 'whatever' ]) >>> 'whatever'\r\t\"\r\t^ self first"},{"name":",","linesOfCode":7,"sourceCode":", otherCollection \r\t\"Concatenate two Strings or Collections.\"\r\t\"#(2 4 6 8) , #(who do we appreciate) >>> #(2 4 6 8 who do we appreciate)\"\r\t\"((2989 storeStringBase: 16) copyFrom: 4 to: 6) , ' boy!' >>> 'BAD boys!'\"\r\t\r\t^ self copyReplaceFrom: self size + 1\r\t\t  to: self size\r\t\t  with: otherCollection\r"},{"name":"copyUpTo:","linesOfCode":4,"sourceCode":"copyUpTo: anElement \r\t\"Answer all elements up to but not including anObject. If there\r\tis no such object, answer a copy of the receiver.\"\r\r\t^ self first: (self indexOf: anElement ifAbsent: [^ self copy]) - 1"},{"name":"asPetit2Stream","linesOfCode":3,"sourceCode":"asPetit2Stream\r\t^ PP2Stream on: self\r\t\"^ PP2BufferStream on: (ReadStream on: self)\""},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"atWrap:put:","linesOfCode":8,"sourceCode":"atWrap: index put: value\r\t\"Store value into the index'th element of the receiver.  If index is out\r\tof bounds, let it wrap around from the end to the beginning until it \r\tis in bounds. Answer value.\"\r\t\"(#(11 22 33) asOrderedCollection atWrap: 2 put: 0; yourself) >>> #(11 0 33)\"\r   \"(#(11 22 33) asOrderedCollection atWrap: 4 put: 0; yourself) >>> #(0 22 33)\"\r   \"(#(11 22 33) asOrderedCollection atWrap: 6 put: 0; yourself) >>> #(11 22 0)\"\r\r\t^ self at: index  - 1 \\\\ self size + 1 put: value"},{"name":"asGPUFloat32x4Array","linesOfCode":2,"sourceCode":"asGPUFloat32x4Array\r\t^ self asGPUArrayOfType: #Float32x4"},{"name":"replace:","linesOfCode":6,"sourceCode":"replace: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into self.\"\r\t\r\t\"(#(1 2 3 4) replace: [:each | each + 1 ]) >>> #(2 3 4 5)\"\r\r\t1 to: self size do: [ :index |\r\t\tself at: index put: (aBlock value: (self at: index)) ]"},{"name":"sortedAs:","linesOfCode":20,"sourceCode":"sortedAs: aSortBlockOrSymbol\r\t\"Answer a SortedCollection whose elements are the elements of the \r\treceiver. The sort order is defined by the argument, aSortBlock.\"\r\r\t| aSortedCollection aSortBlock |\r\taSortedCollection := SortedCollection new: self size.\r\taSortBlock := \r\t\taSortBlockOrSymbol isSymbol \r\t\t\tifTrue: [ [:a :b | |t1 t2|\r\t\t\t\t\t\t\tt1 := (a perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\tt2 := (b perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\t((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])\r\t\t\t\t\t\t\t\tifTrue: [ t1 ]\r\t\t\t\t\t\t\t\tifFalse: [ t1 < t2 ] ] ]\r\t\t\tifFalse: [ \r\t\t\t\t(aSortBlockOrSymbol numArgs = 1)\r\t\t\t\t\tifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) < (aSortBlockOrSymbol value: v2) ] ]\r\t\t\t\t\tifFalse: [ aSortBlockOrSymbol ] ].\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"asWordArray","linesOfCode":7,"sourceCode":"asWordArray\r\t\"Answer a WordArray whose elements are the elements of the receiver, in \r\tthe same order.\"\r\r\t| wordArray |\r\twordArray := WordArray new: self size.\r\t1 to: self size do:[:i| wordArray at: i put: (self at: i)].\r\t^wordArray"},{"name":"lastIndexOf:","linesOfCode":6,"sourceCode":"lastIndexOf: anElement\r\t\"Answer the index of the last occurrence of anElement within the \r\treceiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b a d a) lastIndexOf: #a) >>> 5\"\r\t\"(#(a b a d e) lastIndexOf: #a) >>> 3\"\r\r\t^ self lastIndexOf: anElement startingAt: self size ifAbsent: [0]"},{"name":"asDigitsAt:in:do:","linesOfCode":7,"sourceCode":"asDigitsAt: anInteger in: aCollection do: aBlock\r\tself\r\t\tdo: [ :each | \r\t\t\taCollection at: anInteger put: each.\r\t\t\tanInteger = aCollection size\r\t\t\t\tifTrue: [ aBlock value: aCollection ]\r\t\t\t\tifFalse: [ self asDigitsAt: anInteger + 1 in: aCollection do: aBlock ] ]"},{"name":"readStream","linesOfCode":2,"sourceCode":"readStream\r\t^ ReadStream on: self"},{"name":"allButFirstDo:","linesOfCode":5,"sourceCode":"allButFirstDo: aBlock\r\r\t\"Executes aBlock on each of the receiver's elements except for the first one\"\r\r\t\"(Array streamContents: [:stream | #(1 2 3) allButFirstDo: [:each | stream nextPut: (each + 10)]]) >>> #(12 13)\"\r\r\t2 to: self size do:\r\t\t[:index | aBlock value: (self at: index)]"},{"name":"lastIndexOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock\r\t\"Answer the index of the last occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the\r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b a d a) lastIndexOf: #a startingAt: 1 ifAbsent: 7) >>> 1\"\r\t\"(#(e b a d e) lastIndexOf: #a startingAt: 4 ifAbsent: 7) >>> 3\"\r\r\tlastIndex to: 1 by: -1 do:\r\t\t[:index |\r\t\t(self at: index) = anElement ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"overlappingPairsDo:","linesOfCode":5,"sourceCode":"overlappingPairsDo: aBlock \r\r\t\"Emit overlapping pairs of my elements into aBlock\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) overlappingPairsDo: [:first :second| stream nextPut: (first + second)]]) >>> #(3 5 7)\"\r\r\t1 to: self size - 1\r\t\tdo: [:i | aBlock value: (self at: i) value: (self at: i + 1)]"},{"name":"second","linesOfCode":5,"sourceCode":"second\r\t\"Answer the second element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) second >>> #b\"\r\r\t^ self at: 2"},{"name":"ninth","linesOfCode":5,"sourceCode":"ninth\r\t\"Answer the ninth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) ninth >>> #i\"\r\r\t^ self at: 9"},{"name":"@","linesOfCode":2,"sourceCode":"@ aCollection \r\t^ self with: aCollection collect: [:a :b | a @ b]"},{"name":"writeStreamDo:","linesOfCode":4,"sourceCode":"writeStreamDo: aBlock\r\t\"Evaluates the argument with the write stream of the collection. Answers the result.\"\r\t\r\t\"(#() writeStreamDo: [ :stream | stream nextPut: '4'; space; nextPutAll: '34'. stream contents ]) >>> {'4'. Character space. $3. $4}\"\r\r\t^ aBlock value: self writeStream"},{"name":"copyWithoutFirst","linesOfCode":4,"sourceCode":"copyWithoutFirst\r\t\"Deprecatd. Return a copy of the receiver which doesn't include\r\tthe first element.\"\r\r\t^ self allButFirst"},{"name":"findBinaryIndex:do:ifNone:","linesOfCode":27,"sourceCode":"findBinaryIndex: aBlock do: actionBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf found, evaluate actionBlock with the index as argument\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the indexes of the 'bounding' elements as arguments.\r\tWarning: Might give invalid indexes, see examples below\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 5\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 12 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(5 6)'\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 0.5 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ', {a. b} printString ]) >>> 'between: #(0 1)'\"\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] do: [ :found | found ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(7 8)' \"\r\t\t\t\r\t| index low high test |\r\tlow := 1.\r\thigh := self size.\r\t[ index := high + low // 2.\r\t  low > high ] whileFalse: [\r\t\ttest := aBlock value: (self at: index).\r\t\ttest = 0 \r\t\t\tifTrue: [ ^ actionBlock value: index ]\r\t\t\tifFalse: [ test > 0\r\t\t\t\tifTrue: [ low := index + 1 ]\r\t\t\t\tifFalse: [ high := index - 1 ] ] ].\r\t^ exceptionBlock cull: high cull: low"},{"name":"combinations","linesOfCode":7,"sourceCode":"combinations\r\t\"Return all the combinations of elements of the receiver. Note that combinations does not include the empty element contrary to the mathematical definition of combinations.\"\r\r\t\"#(1 2 3 4) combinations >>> #(#(1) #(2) #(3) #(4) #(1 2) #(1 3) #(1 4) #(2 3) #(2 4) #(3 4) #(1 2 3) #(1 2 4) #(1 3 4) #(2 3 4) #(1 2 3 4))\"\r\r\t^ Array\r\t\tstreamContents: [ :stream | \r\t\t\t1 to: self size do:\r\t\t\t\t[ :take | self combinations: take atATimeDo: [ :combination | stream nextPut: combination copy ] ] ]"},{"name":"with:do:","linesOfCode":8,"sourceCode":"with: otherCollection do: twoArgBlock \r\t\"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection.\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) with: #(4 5 6) do: [:a :b | stream nextPut: (a + b)]]) >>> #(5 7 9)\"\r\t\r\totherCollection size = self size ifFalse: [self errorSizeMismatch].\r\t1 to: self size do:\r\t\t[:index |\r\t\ttwoArgBlock value: (self at: index)\r\t\t\t\tvalue: (otherCollection at: index)]"},{"name":"shuffle","linesOfCode":4,"sourceCode":"shuffle\r\t\"Modify the receiver but with its elements in random positions.\r\tThis method use Random class as random generator\"\r\t\r\t^ self shuffleBy: Random new"},{"name":"findBinaryIndex:","linesOfCode":12,"sourceCode":"findBinaryIndex: aBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, raise an error.\"\r\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ]) >>> 5\"\r\r\t^ self\r\t\tfindBinaryIndex: aBlock\r\t\tdo: [ :found | found ]\r\t\tifNone: [ self errorNotFound: aBlock ]"},{"name":"findBinary:ifNone:","linesOfCode":15,"sourceCode":"findBinary: aBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements as optional arguments.\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 24 - arg ] ifNone: ['Not found']) >>> 'Not found'\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 24 - arg ] ifNone: [:a :b | 'over ', a printString]) >>> 'over 23'\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinary: [ :arg | 25 - arg ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(23 nil)'\"\r\t\r\t^ self \r\t\tfindBinary: aBlock \r\t\tdo: [ :found | found ] \r\t\tifNone: exceptionBlock"},{"name":"reject:","linesOfCode":8,"sourceCode":"reject: rejectBlock \r\t\"Optimized version of Collection>>#reject:\"\r\t\r\t\"#(1 2 3 4) reject: [:each | each = 3 ] >>> #(1 2 4)\"\r\t\r\t| each |\r\t\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(rejectBlock value: (each := self at: index))\r\t\t\t\tifFalse: [ stream nextPut: each ]]]"},{"name":"indexOf:startingAt:","linesOfCode":5,"sourceCode":"indexOf: anElement startingAt: start\r       \"Answer the index of the first occurrence of anElement after start within the receiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b c d e) indexOf: #c startingAt: 2) >>> 3\" \r\t\"(#(a b c d e) indexOf: #c startingAt: 4) >>> 0\"\r\r\t^self indexOf: anElement startingAt: start ifAbsent: 0"},{"name":"withIndexCollect:","linesOfCode":11,"sourceCode":"withIndexCollect: elementAndIndexBlock \r\t\"Just like with:collect: except that the iteration index supplies the second argument to the block.\"\r\t\r\t\"(#(10 20 30) withIndexCollect: [:each :index | each + (index * 2)]) >>> #(12 24 36)\"\r\t\r\t| result |\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result at: index put:\r\t\t(elementAndIndexBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: index)].\r\t^ result"},{"name":"nextToLast","linesOfCode":3,"sourceCode":"nextToLast\r\t\"(#(1 2 3 4) nextToLast) >>> 3\"\r\t^self at: self size - 1"},{"name":"withIndexSelect:","linesOfCode":10,"sourceCode":"withIndexSelect: elementAndIndexBlock\r\t\"select elements from the receiver that the block evaluates true with the element and its index.\"\r\r\t\"(#('We' 'love' 'pharo!') withIndexSelect: [:value :index | value size - 1 <= index]) >>> #('We')\"\r\r\t^ self class\r\t\tnew: self size\r\t\tstreamContents: [ :stream | \r\t\t\t1 to: self size do: [ :index | \r\t\t\t\t| each |\r\t\t\t\t(elementAndIndexBlock value: (each := self at: index) value: index)\r\t\t\t\t\tifTrue: [ stream nextPut: each ] ] ]"},{"name":"writeStream","linesOfCode":2,"sourceCode":"writeStream\r\t^ WriteStream on: self"},{"name":"endsWithAnyOf:","linesOfCode":3,"sourceCode":"endsWithAnyOf: aCollection\r\t\"Return true if the receiver ends with any of the elements in aCollection.\"\r\t^aCollection anySatisfy:[:suffix| self endsWith: suffix]"},{"name":"findFirst:","linesOfCode":10,"sourceCode":"findFirst: aBlock\r\t\"Return the index of my first element for which aBlock evaluates as true.\r\tIf no matching element is found, return 0\"\r\t\r\t\"(#(1 5 10) findFirst: [ :each | each > 3 ]) >>> 2\"\r\t\"(#(1 5 10) findFirst: [ :each | each > 15 ]) >>> 0\"\r\r\t| index |\r\tindex := 0.\r\t[(index := index + 1) <= self size] whileTrue:\r\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\r\t^ 0"},{"name":"reversed","linesOfCode":9,"sourceCode":"reversed\r\t\"Answer a copy of the receiver with element order reversed.\"\r\t\"Example: 'frog' reversed\"\r\r\t| n result src |\r\tn := self size.\r\tresult := self species new: n.\r\tsrc := n + 1.\r\t1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].\r\t^ result\r"},{"name":"indexOfSubCollection:startingAt:","linesOfCode":11,"sourceCode":"indexOfSubCollection: aSubCollection startingAt: anIndex \r\t\"Answer the index of the receiver's first element, such that that element \r\tequals the first element of aSubCollection, and the next elements equal \r\tthe rest of the elements of aSubCollection. Begin the search at element \r\tanIndex of the receiver. If no such match is found, answer 0.\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 2) >>> 3\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 4) >>> 0\"\r\r\t^self\r\t\tindexOfSubCollection: aSubCollection\r\t\tstartingAt: anIndex\r\t\tifAbsent: [0]"},{"name":"copyAfter:","linesOfCode":5,"sourceCode":"copyAfter: anElement\r\t\"Answer a copy of the receiver from after the first occurrence\r\tof anElement up to the end. If no such element exists, answer \r\tan empty copy.\"\r\r\t^ self allButFirst: (self indexOf: anElement ifAbsent: [^ self copyEmpty])"},{"name":"combinationsAt:in:after:do:","linesOfCode":12,"sourceCode":"combinationsAt: jj in: aCollection after: nn do: aBlock\r\t\"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1.\"\r\r\tnn + 1 to: self size do: [ :index | \r\t\taCollection at: jj put: (self at: index).\r\t\tjj = aCollection size\r\t\t\tifTrue: [ aBlock value: aCollection ]\r\t\t\tifFalse: [ \r\t\t\t\tself\r\t\t\t\t\tcombinationsAt: jj + 1\r\t\t\t\t\tin: aCollection\r\t\t\t\t\tafter: index\r\t\t\t\t\tdo: aBlock ] ]"},{"name":"reverseSortedAs:","linesOfCode":20,"sourceCode":"reverseSortedAs: aSortBlockOrSymbol\r\t\"Answer a SortedCollection whose elements are the elements of the \r\treceiver. The sort order is defined by the argument, aSortBlock.\"\r\r\t| aSortedCollection aSortBlock |\r\taSortedCollection := SortedCollection new: self size.\r\taSortBlock := \r\t\taSortBlockOrSymbol isSymbol \r\t\t\tifTrue: [ [:a :b | |t1 t2|\r\t\t\t\t\t\t\tt1 := (a perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\tt2 := (b perform: aSortBlockOrSymbol).\r\t\t\t\t\t\t\t((t1 isKindOf: Boolean) and: [t2 isKindOf: Boolean])\r\t\t\t\t\t\t\t\tifTrue: [ t1 ]\r\t\t\t\t\t\t\t\tifFalse: [ t1 > t2 ] ] ]\r\t\t\tifFalse: [ \r\t\t\t\t(aSortBlockOrSymbol numArgs = 1)\r\t\t\t\t\tifTrue: [ [ :v1 :v2 | (aSortBlockOrSymbol value: v1) > (aSortBlockOrSymbol value: v2) ] ]\r\t\t\t\t\tifFalse: [ aSortBlockOrSymbol ] ].\r\taSortedCollection sortBlock: aSortBlock.\r\taSortedCollection addAll: self.\r\t^ aSortedCollection"},{"name":"from:to:put:","linesOfCode":20,"sourceCode":"from: startIndex to: endIndex put: anObject\r\t\"Put anObject in all indexes between startIndex \r\tand endIndex. Very fast. Faster than to:do: for\r\tmore than 26 positions. Answer anObject\"\r\t\"(#(a b c d e) from: 3 to: 4 put: #x; yourself) >>> #(a b x x e)\"\r\r\t| written toWrite thisWrite |\r\r\tstartIndex > endIndex ifTrue: [^self].\r\tself at: startIndex put: anObject.\r\twritten := 1.\r\ttoWrite := endIndex - startIndex + 1.\r\t[written < toWrite] whileTrue:\r\t\t[\r\t\t\tthisWrite := written min: toWrite - written.\r\t\t\tself \r\t\t\t\treplaceFrom: startIndex + written\r\t\t\t\tto: startIndex + written + thisWrite - 1\r\t\t\t\twith: self startingAt: startIndex.\r\t\t\twritten := written + thisWrite\r\t\t].\r\t^anObject"},{"name":"reduceLeft:","linesOfCode":17,"sourceCode":"reduceLeft: aBlock\r\t\"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments.\"\r\r\t\"(#(1 2 3) reduceLeft: [ :a :b | a - b ])>>> ((1 - 2) - 3)\"\r\t\"(#(1 2 3) reduceLeft: [ :a :b | a - b ]) >>> -4\"\r\t\"(#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ]) >>> ((1 + 3) - 5)\"\r\t\"(#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ]) >>> -1\"\r\r\t| arguments |\r\tself emptyCheck.\r\targuments := Array new: aBlock argumentCount.\r\t(arguments size = 0 or: [ (self size + 1) \\\\ (arguments size - 1) > 0 ])\r\t\tifTrue: [ self error: 'Collection size and block argument count do not match.' ].\r\targuments at: 1 put: self first.\r\t2 to: self size by: arguments size - 1 do: [ :index |\r\t\targuments\r\t\t\treplaceFrom: 2 to: arguments size with: self startingAt: index;\r\t\t\tat: 1 put: (aBlock valueWithArguments: arguments) ].\r\t^ arguments first"},{"name":"at:ifAbsent:","linesOfCode":7,"sourceCode":"at: index ifAbsent: exceptionBlock \r\t\"Answer the element at my position index. If I do not contain an element \r\tat index, answer the result of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d) at: 3 ifAbsent: #z) >>> #c\"\r\t\"(#(a b c d) at: 5 ifAbsent: #z) >>> #z\"\r\r\t(index between: 1 and: self size) ifTrue: [^ self at: index].\r\t^ exceptionBlock value"},{"name":"detectIndex:ifNone:","linesOfCode":7,"sourceCode":"detectIndex: aBlock ifNone: exceptionBlock\r\r\t\"Return index of first element that satisfies aBlock.\r\tIf no matching element is found, evaluate exceptionBlock.\"\r\t\r\t\"(#(1 5 10) detectIndex: [ :each | each > 3 ] ifNone: ['Not found']) >>> 2\"\r\t\"(#(1 5 10) detectIndex: [ :each | each > 15 ] ifNone: ['Not found']) >>> 'Not found'\"\r\t\r\tself doWithIndex: [:each :index | (aBlock value: each) ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"select:thenCollect:","linesOfCode":8,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Optimized version of Collection>>#select:thenCollect:\"\r\t\r\t\"(#(1 2 3 4)  select: [:each | each > 2 ] thenCollect: [:each | each + 10 ]) >>> #(13 14)\"\r\t\r\t| each |\r\t^ self class new: self size streamContents: [ :stream|\r\t\t1 to: self size do: [ :index |\r\t\t\t(selectBlock value: (each := self at: index))\r\t\t\t\tifTrue: [ stream nextPut: (collectBlock value: each) ]]]"},{"name":"asColorArray","linesOfCode":2,"sourceCode":"asColorArray\r\t^ColorArray withAll: self"},{"name":"copyWithoutIndex:","linesOfCode":7,"sourceCode":"copyWithoutIndex: index\r\t\"Return a copy containing all elements except the index-th.\"\r\r\t| copy |\r\tcopy := self species ofSize: self size - 1.\r\tcopy replaceFrom: 1 to: index-1 with: self startingAt: 1.\r\tcopy replaceFrom: index to: copy size with: self startingAt: index+1.\r\t^ copy"},{"name":"asValueHolder","linesOfCode":2,"sourceCode":"asValueHolder\r\r\t^ CollectionValueHolder value: self"},{"name":"middle","linesOfCode":5,"sourceCode":"middle\r\t\"Answer the middle element of the receiver.\"\r\t\"#(a b c d e) middle >>> #c\"\r\t\"#(a b c d) middle >>> #c\"\r\t\r\t^ self at: self size // 2 + 1"},{"name":"keysAndValuesDo:","linesOfCode":4,"sourceCode":"keysAndValuesDo: aBlock \r\t\"Enumerate the receiver with all the keys (aka indices) and values.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) keysAndValuesDo:  [:key :value | stream nextPut: (key * 2 + value)]]) >>> #(12 24 36)\"\r\r\t1 to: self size do: [:index | aBlock value: index value: (self at: index)]"},{"name":"pairsCollect:","linesOfCode":5,"sourceCode":"pairsCollect: aBlock\r\t\"Evaluate aBlock with my elements taken two at a time, and return an Array with the results\"\r\r\t\"(#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect: [:a :b | b, ' is number ', a printString]) >>> #('fred is number 1' 'charlie is number 2' 'elmer is number 3')\"\r\r\t^ (1 to: self size // 2)\r\t\tcollect: [ :index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]"},{"name":"fourth","linesOfCode":5,"sourceCode":"fourth\r\t\"Answer the fourth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) fourth >>> #d\"\r\r\t^ self at: 4"},{"name":"splitOn:indicesDo:","linesOfCode":4,"sourceCode":"splitOn: splitter indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of the receiver element that have been identified by splitting the receiver using the splitter argument. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\t\"(String streamContents: [:s | 'Pharo is cool' splitOn: Character space indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:5 s:7 e:8 s:10 e:13 '\"\r\t\r\t\r\t^ splitter split: self indicesDo: aBlock"},{"name":"asGPUFloat32Array","linesOfCode":2,"sourceCode":"asGPUFloat32Array\r\t^ self asGPUArrayOfType: #Float32"},{"name":"atAllPut:","linesOfCode":7,"sourceCode":"atAllPut: anObject \r\t\"Put anObject at every one of the receiver's indices.\"\r\t\"(#(x y z) atAllPut: #a) >>> #(a a a)\"\r\r\t| size |\r\t(size := self size) > 26 \"first method faster from 27 accesses and on\"\r\t\tifTrue: [self from: 1 to: size put: anObject]\r\t\tifFalse: [1 to: size do: [:index | self at: index put: anObject]]"},{"name":"after:ifAbsent:","linesOfCode":11,"sourceCode":"after: target ifAbsent: exceptionBlock\r\t\"Answer the element after target.  Answer the result of evaluation\r\tthe exceptionBlock if target is not in the receiver, or if there are \r\tno elements after it.\"\r\t\"(#(a b c d) after: #b ifAbsent: #z) >>> #c\"\r\t\"(#(a b c d) after: #x ifAbsent: #z) >>> #z\"\r\r\t| index |\r\tindex := self indexOf: target.\r\t^ (index = 0 or: [index = self size])\r\t\tifTrue: [exceptionBlock value]\r\t\tifFalse: [self at: index + 1]"},{"name":"identityIndexOf:ifAbsent:","linesOfCode":9,"sourceCode":"identityIndexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of anElement within the receiver. If the receiver does \r\tnot contain anElement, answer the result of evaluating the argument, \r\texceptionBlock.\"\r\t\"(#(a b c d e) identityIndexOf: #c ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) identityIndexOf: #x ifAbsent: 7) >>> 7\"\r\t\r\t1 to: self size do:\r\t\t[:i | (self at: i) == anElement ifTrue: [^ i]].\r\t^ exceptionBlock value"},{"name":"replaceFrom:to:with:","linesOfCode":8,"sourceCode":"replaceFrom: start to: stop with: replacement \r\t\"This destructively replaces elements from start to stop in the receiver. \r\tAnswer the receiver itself. Use copyReplaceFrom:to:with: for \r\tinsertion/deletion which may alter the size of the result.\"\r\t\"(#(a b c d e) replaceFrom: 3 to: 4 with: #(x y)) >>> #(a b x y e)\"\r\r\treplacement size = (stop - start + 1)\r\t\tifFalse: [self error: 'Size of replacement doesnt match'].\r\t^self replaceFrom: start to: stop with: replacement startingAt: 1"},{"name":"shuffled","linesOfCode":2,"sourceCode":"shuffled\r\t^ self copy shuffle"},{"name":"mergeSortFrom:to:by:","linesOfCode":21,"sourceCode":"mergeSortFrom: startIndex to: stopIndex by: aBlock\r\t\"Sort the given range of indices using the mergesort algorithm.\r\tMergesort is a worst-case O(N log N) sorting algorithm that usually\r\tdoes only half as many comparisons as heapsort or quicksort.\"\r\r\t\"Details: recursively split the range to be sorted into two halves,\r\tmergesort each half, then merge the two halves together. An extra \r\tcopy of the data is used as temporary storage and successive merge \r\tphases copy data back and forth between the receiver and this copy.\r\tThe recursion is set up so that the final merge is performed into the\r\treceiver, resulting in the receiver being completely sorted.\"\r\t\"(#(a b z d i l) mergeSortFrom: 3 to: 5 by: [ :a :b | a<=b ]) >>> #(a b d i z l)\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tstartIndex = stopIndex ifTrue: [^ self].\r\t[startIndex >= 1 and: [startIndex < stopIndex]] assert. \"bad start index\"\r\t[stopIndex <= self size] assert. \"bad stop index\"\r\tself\r\t\tmergeSortFrom: startIndex\r\t\tto: stopIndex \r\t\tsrc: self copy \r\t\tdst: self \r\t\tby: aBlock"},{"name":"sort:","linesOfCode":10,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\t\"(#(3 9 1) sort: [:a :b | a <= b ]) >>> #(1 3 9)\"\r\t\"(#(3 9 1) sort: [:a :b | a >= b ]) >>> #(9 3 1)\"\r\t\"(#(xa xc xz xb xy) sort: #last ascending) >>> #(xa xb xc xy xz)\"\r\r\tself\r\t\tmergeSortFrom: 1\r\t\tto: self size\r\t\tby: aSortBlock"},{"name":"indexOf:","linesOfCode":6,"sourceCode":"indexOf: anElement\r\t\"Answer the index of the first occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer 0.\"\r\t\"(#(a b c d e) indexOf: #c) >>> 3\"\r\t\"(#(a b c d e) indexOf: #x) >>> 0\"\r\r\t^ self indexOf: anElement ifAbsent: 0"},{"name":"groupsOf:atATimeCollect:","linesOfCode":16,"sourceCode":"groupsOf: n atATimeCollect: aBlock\r\t\"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end. \r\tAllows use of a flattened array for things that naturally group into groups of n. \r\tIf aBlock has a single argument, pass it an array of n items, otherwise, pass the items as separate arguments. See also pairsDo:\"\r\r\t\"(#(16 17 17 16 18 17 18   19 19 19 18 19 19 20   19 20 19 20 20 20 19   20) groupsOf: 7 atATimeCollect: [ :x | x ]) >>> #(#(16 17 17 16 18 17 18) #(19 19 19 18 19 19 20) #(19 20 19 20 20 20 19))\"\r\r\t\"(#(1 1 1 10 10 10 100  100 100) groupsOf: 3 atATimeCollect: [ :x :y :z | x + y + z]) >>> #(3 30 300)\"\r\r\t\"(#(1 1 1 10 10 10 100  100 100) groupsOf: 3 atATimeCollect: [ :x | x ]) >>> #(#(1 1 1) #(10 10 10) #(100 100 100))\"\r\r\t| passArray |\r\tpassArray := aBlock numArgs <= 1.\r\t^ (n to: self size by: n)\r\t\tcollect: [ :index | \r\t\t\t| args |\r\t\t\targs := (self copyFrom: index - n + 1 to: index) asArray.\r\t\t\tpassArray\r\t\t\t\tifTrue: [ aBlock value: args ]\r\t\t\t\tifFalse: [ aBlock valueWithArguments: args ] ]"},{"name":"collect:thenReject:","linesOfCode":9,"sourceCode":"collect: collectBlock thenReject: rejectBlock\r\t\"Optimized version of Collection>>#thenReject:\"\r\t\r\t\"(#(1 2 3) collect: [:each | each + 10 ] thenReject: [:each | each even]) >>> #(11 13)\"\r\t\r\t| each |\r\t\r\t^  self class new: self size streamContents: [ :stream |\r\t\t1 to: self size do: [:index |\r\t\t\teach := collectBlock value: (self at: index).\r\t\t\t(rejectBlock value: each)\r\t\t\t\tifFalse: [ stream nextPut: each ]]]"},{"name":"copyFrom:to:","linesOfCode":10,"sourceCode":"copyFrom: start to: stop \r\t\"Answer a copy of a subset of the receiver, starting from element at \r\tindex start until element at index stop.\"\r\r\t| newSize |\r\tnewSize := stop - start + 1.\r\t^(self species new: newSize)\r\t\treplaceFrom: 1\r\t\tto: newSize\r\t\twith: self\r\t\tstartingAt: start"},{"name":"copyWithFirst:","linesOfCode":11,"sourceCode":"copyWithFirst: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element.\"\r\r\t| newIC |\r\tnewIC := self species ofSize: self size + 1.\r\tnewIC \r\t\treplaceFrom: 2\r\t\tto: self size + 1\r\t\twith: self\r\t\tstartingAt: 1.\r\tnewIC at: 1 put: newElement.\r\t^ newIC"},{"name":"copyUpThrough:","linesOfCode":4,"sourceCode":"copyUpThrough: anElement\r    \"Answer all elements up to and including anObject. If there\r     is no such object, answer a copy of the receiver.\"\r\r\t^self first: (self indexOf: anElement ifAbsent: [^ self copy])"},{"name":"asPetit2Context","linesOfCode":2,"sourceCode":"asPetit2Context\r\t^ PP2InMemoryContext on: self position: 0"},{"name":"sixth","linesOfCode":5,"sourceCode":"sixth\r\t\"Answer the sixth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) sixth >>> #f\"\r\r\t^ self at: 6"},{"name":"atLast:ifAbsent:","linesOfCode":6,"sourceCode":"atLast: indexFromEnd ifAbsent: block\r\t\"Return element at indexFromEnd from the last position.\r\t atLast: 1 ifAbsent: [] returns the last element\"\r\t\"(#(x y z) atLast: 1 ifAbsent: #a) >>> #z\"\r\t\"(#(x y z) atLast: 4 ifAbsent: #a) >>> #a\"\r\r\t^ self at: self size + 1 - indexFromEnd ifAbsent: block"},{"name":"grownBy:","linesOfCode":7,"sourceCode":"grownBy: length\r\t\"Answer a copy of receiver collection with size grown by length\"\r\r\t| newCollection size |\r\tsize := self size.\r\tnewCollection := self species ofSize: size + length.\r\tnewCollection replaceFrom: 1 to: size with: self startingAt: 1.\r\t^ newCollection"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":10,"sourceCode":"indexOf: anElement startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement after start\r\twithin the receiver. If the receiver does not contain anElement, \r\tanswer the \tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOf: #c startingAt: 2 ifAbsent: 7) >>> 3\" \r\t\"(#(a b c d e) indexOf: #c startingAt: 4 ifAbsent: 7) >>> 7\"\r\r\tstart to: self size do:\r\t\t[:index |\r\t\t(self at: index) = anElement ifTrue: [^ index]].\r\t^ exceptionBlock value"},{"name":"includes:","linesOfCode":3,"sourceCode":"includes: anObject\r\t\"Answer whether anObject is one of the receiver's elements.\"\r\r\t^ (self indexOf: anObject) ~= 0"},{"name":"asGPUFloat64Array","linesOfCode":2,"sourceCode":"asGPUFloat64Array\r\t^ self asGPUArrayOfType: #Float64"},{"name":"collect:","linesOfCode":11,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\t\r\t\"#(1 2 3) collect: [:each | each  + 10] >>> #(11 12 13) \"\r\r\t| newCollection |\r\tnewCollection := self species new: self size.\r\t1 to: self size do:\r\t\t[:index |\r\t\tnewCollection at: index put: (aBlock value: (self at: index))].\r\t^ newCollection"},{"name":"last","linesOfCode":4,"sourceCode":"last\r\t\"Answer the last element of the receiver\"\r\t\"#(a b c d e) last >>> #e\"\r\r\t^ self at: self size"},{"name":"copyUpToLast:","linesOfCode":4,"sourceCode":"copyUpToLast: anElement\r\t\"Answer a copy of the receiver from index 1 to the last occurrence of \r\tanElement, not including anElement.\"\r\r\t^ self first: (self lastIndexOf: anElement ifAbsent: [^ self copy]) - 1"},{"name":"last:","linesOfCode":8,"sourceCode":"last: n\r\t\"Answer the last n elements of the receiver.  \r\tRaise an error if there are not enough elements.\"\r\t\"(#(a b c d e) last: 2) >>> #(d e)\"\r\t\"(#(a b c d e) last: 3) >>> #(c d e)\"\r\r\t| size |\r\tsize := self size.\r\t^ self copyFrom: size - n + 1 to: size"},{"name":"asArray","linesOfCode":3,"sourceCode":"asArray\r\t\"Answer an Array whose elements are the elements of the receiver.\"\r\r\t^ Array withAll: self"},{"name":"findLast:","linesOfCode":10,"sourceCode":"findLast: aBlock\r\t\"Return the index of my last element for which aBlock evaluates as true.\r\tIf no matching element is found, return 0\"\r\t\r\t\"(#(10 20 30 40 50) findLast: [ :each | each > 10 ]) >>> 5\"\r\t\"(#(10 20 30 40 50) findLast: [ :each | each > 60 ]) >>> 0\"\r\t\r\t| index |\r\tindex := self size + 1.\r\t[(index := index - 1) >= 1] whileTrue:\r\t\t[(aBlock value: (self at: index)) ifTrue: [^index]].\r\t^ 0"},{"name":"reverseWith:do:","linesOfCode":10,"sourceCode":"reverseWith: aSequenceableCollection do: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements, in reverse order, \r\talong with the  corresponding element, also in reverse order, from \r\taSequencableCollection. \"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3) reverseWith: #(4 5 6) do: [:a :b | stream nextPut: (a + b)]]) >>> #(9 7 5)\"\r\r\tself size ~= aSequenceableCollection size ifTrue: [^ self errorSizeMismatch].\r\tself size to: 1 by: -1 do: [:index | \r\t\t\taBlock \r\t\t\t\tvalue: (self at: index)\r\t\t\t\tvalue: (aSequenceableCollection at: index)]"},{"name":"select:thenDo:","linesOfCode":7,"sourceCode":"select: selectBock thenDo: aBlock\r\t\"Refer to the comment in Collection>>#select:thenDo:\"\r\t\r\t\"(Array streamContents: [:stream | #(1 2 3 4) select: [:each | each > 2 ] thenDo: [:each | stream nextPut: each + 10]]) >>> #(13 14)\"\r\t\r\t| each |\r\t1 to: self size do: [ :index |\r\t\t(selectBock value: (each := self at: index))\r\t\t\tifTrue: [ aBlock value: each ]]."},{"name":"before:ifAbsent:","linesOfCode":11,"sourceCode":"before: target ifAbsent: exceptionBlock\r\t\"Answer the receiver's element immediately before target. Answer\r\tthe result of evaluating the exceptionBlock if target is not an element\r\tof the receiver, or if there are no elements before it.\"\r\t\"(#(11 22 33) before: 22 ifAbsent: 55) >>> 11\"\r\t\"(#(11 22 33) before: 44 ifAbsent: 55) >>> 55\"\r\r\t| index |\r\tindex := self indexOf: target.\r\t^ (index = 0 or: [index = 1])\r\t\tifTrue: [exceptionBlock value]\r\t\tifFalse: [self at: index - 1]"},{"name":"asMoebiusBandCollectionWithContext","linesOfCode":2,"sourceCode":"asMoebiusBandCollectionWithContext\r\t^ MbndCollectionWithContext new collection: self"},{"name":"atRandom:","linesOfCode":7,"sourceCode":"atRandom: aGenerator\r\t\"Answer a random element of the receiver.  Uses aGenerator which\r\tshould be kept by the user in a variable and used every time. Use\r\tthis instead of #atRandom for better uniformity of random numbers \r\tbecause only you use the generator.  Causes an error if self has no \r\telements.\"\r\r\t^ self at: (aGenerator nextInteger: self size)"},{"name":"findBinaryIndex:ifNone:","linesOfCode":14,"sourceCode":"findBinaryIndex: aBlock ifNone: exceptionBlock\r\t\"Search for an element in the receiver using binary search.\r\tThe argument aBlock is a one-element block returning\r\t\t0 \t- if the element is the one searched for\r\t\t<0\t- if the search should continue in the first half\r\t\t>0\t- if the search should continue in the second half\r\tIf no matching element is found, evaluate exceptionBlock,\r\twith the 'bounding' elements as optional arguments.\"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] ifNone: [ :a :b | 'between: ',{a. b} printString ]) >>> 'between: #(7 8)' \"\r\t\r\t\"(#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 25 - arg ] ifNone: [ :a :b | 'over index: ', a printString ]) >>> 'over index: 7' \"\r\r\t^ self \r\t\tfindBinaryIndex: aBlock \r\t\tdo: [ :found | found ] \r\t\tifNone: exceptionBlock"},{"name":"copyAfterLast:","linesOfCode":5,"sourceCode":"copyAfterLast: anElement\r\t\"Answer a copy of the receiver from after the last occurrence\r\tof anElement up to the end. If no such element exists, answer \r\tan empty copy.\"\r\r\t^ self allButFirst: (self lastIndexOf: anElement ifAbsent: [^ self copyEmpty])"},{"name":"takeFirst:","linesOfCode":2,"sourceCode":"takeFirst: anInteger\r\t^ self first: (self size min: anInteger)"},{"name":"withIndexDo:","linesOfCode":4,"sourceCode":"withIndexDo: elementAndIndexBlock\r\t\"Just like do: except that the iteration index supplies the second argument to the block\"\r\r\t\"(Array streamContents: [:stream| #(11 22 13) withIndexDo: [ :each :i | stream nextPut: (each * each + i)]]) >>> #(122 486 172)\"\r\r\t1 to: self size do: [ :index | elementAndIndexBlock value: (self at: index) value: index ]"},{"name":"groupByRuns:","linesOfCode":21,"sourceCode":"groupByRuns: aBlock\r\t\"Answer a new collection of the same species as the receiver with elements being collections (of the receiver species) containing those elements of the receiver for which the given block consecutively evaluates to the same object.\"\r\r\t\"(#(1 2 3 4 4 1 2 3 5 6 ) groupByRuns: [ :each | each = 4]) >>> #(#(1 2 3) #(4 4) #(1 2 3 5 6))\"\r\r\t\"(#(1 2 3 4 1 2 3 4 5 6 ) groupByRuns: [ :each | each = 4]) >>> #(#(1 2 3) #(4) #(1 2 3) #(4) #(5 6))\"\r\r\t\"((1 to: 12) groupByRuns: [ :each | (each \\\\ 3) = 0]) >>> #(#(1 2) #(3) #(4 5) #(6) #(7 8) #(9) #(10 11) #(12))\"\r\r\t| str eStr r |\r\tstr := Array new writeStream.\r\tr := nil.\r\teStr := Array new writeStream.\r\tself\r\t\tdo: [ :e | \r\t\t\t| t |\r\t\t\t(t := aBlock value: e) = r\r\t\t\t\tifFalse: [ r := t.\r\t\t\t\t\teStr isEmpty\r\t\t\t\t\t\tifFalse: [ str nextPut: (eStr contents as: self species).\r\t\t\t\t\t\t\teStr reset ] ].\r\t\t\teStr nextPut: e ].\r\teStr isEmpty\r\t\tifFalse: [ str nextPut: (eStr contents as: self species) ].\r\t^ str contents as: self species"},{"name":"running:of:","linesOfCode":14,"sourceCode":"running: aBlock of: aSubsetSize\r\t\"This is a generalization of a running average (a.k.a. moving average, rolling average) which allows you to apply any given block to the shifting subsets of a given size.\r\t\r\tFor example, given a collection #(1 2 3 4 5) and a window size 2, we collect subsets of this collection by starting with first 2 elements and shifting the window 1 element to the right: #((1 2)(2 3)(3 4)(4 5)), then we apply aBlock to each subset and collect the results. For example, if aBlock is [ :subset | subset average ], this will give us #(1.5 2.5 3.5 4.5)\"\r\t| result |\r\t\r\taSubsetSize > self size ifTrue: [\r\t\tSubscriptOutOfBounds\r\t\t\tsignal: 'The subset size can not exceed the size of a collection' ].\r\t\t\r\taSubsetSize < 0 ifTrue: [\r\t\tSubscriptOutOfBounds\r\t\t\tsignal: 'The subset size must be positive' ].\r\t\r\tresult := (1 to: self size - aSubsetSize + 1) collect: [ :i |\r\t\taBlock value: (self copyFrom: i to: i + aSubsetSize - 1) ].\r\t\r\t^ self species withAll: result"},{"name":"indexOfAnyOf:","linesOfCode":6,"sourceCode":"indexOfAnyOf: aCollection\r\t\"Answer the index of the first occurrence of any element included in aCollection within the receiver.\r\tIf the receiver does not contain anElement, answer zero, which is an invalid index.\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y c)) >>> 3\"\r\t\"(#(a b c d e) indexOfAnyOf: #(x y z)) >>> 0\"\r\r\t^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: [0]"},{"name":"join:","linesOfCode":8,"sourceCode":"join: aCollection\r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\r\t\"({Character space. Character space} join: #('Pharo' 'is' 'cool')) >>>  {$P. $h. $a. $r. $o. Character space. Character space. $i. $s. Character space. Character space. $c. $o. $o. $l}\"\r\r\t\"NB: this implementation only works for Array, since WriteStreams only work for Arrays and Strings. (!) Overridden in OrderedCollection and SortedCollection.\"\r\t\r\t^ self class\r\t\tstreamContents: [:stream | aCollection\r\t\t\t\tdo: [:each | each joinTo: stream]\r\t\t\t\tseparatedBy: [stream nextPutAll: self]]"},{"name":"indexOfSubCollection:startingAt:ifAbsent:","linesOfCode":20,"sourceCode":"indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the receiver's first element, such that that element \r\tequals the first element of sub, and the next elements equal \r\tthe rest of the elements of sub. Begin the search at element \r\tstart of the receiver. If no such match is found, answer the result of \r\tevaluating argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 2 ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOfSubCollection: #(c d) startingAt: 4 ifAbsent: 7) >>> 7\"\r\t\r\t| first index |\r\tsub isEmpty ifTrue: [^ exceptionBlock value].\r\tfirst := sub first.\r\tstart to: self size - sub size + 1 do:\r\t\t[:startIndex |\r\t\t(self at: startIndex) = first ifTrue:\r\t\t\t[index := 1.\r\t\t\t[(self at: startIndex+index-1) = (sub at: index)]\r\t\t\t\twhileTrue:\r\t\t\t\t[index = sub size ifTrue: [^startIndex].\r\t\t\t\tindex := index+1]]].\r\t^ exceptionBlock value"},{"name":"eighth","linesOfCode":5,"sourceCode":"eighth\r\t\"Answer the eighth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) eighth  >>> #h\"\r\r\t^ self at: 8"},{"name":"asByteArray","linesOfCode":3,"sourceCode":"asByteArray\r\t\"Answer a ByteArray whose elements are the elements of the receiver.\"\r\r\t^ ByteArray withAll: self"},{"name":"atAll:put:","linesOfCode":5,"sourceCode":"atAll: aCollection put: anObject \r\t\"Put anObject at every index specified by the elements of aCollection.\"\r\t\"(#(x y z) atAll: #(1 3) put: #e; yourself) >>> #(e y e)\"\r\r\taCollection do: [:index | self at: index put: anObject].\r\t^ anObject"},{"name":"indexOf:ifAbsent:","linesOfCode":7,"sourceCode":"indexOf: anElement ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement within the  \r\treceiver. If the receiver does not contain anElement, answer the \r\tresult of evaluating the argument, exceptionBlock.\"\r\t\"(#(a b c d e) indexOf: #c ifAbsent: 7) >>> 3\"\r\t\"(#(a b c d e) indexOf: #x ifAbsent: 7) >>> 7\"\r\r\t^ self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock"},{"name":"fifth","linesOfCode":5,"sourceCode":"fifth\r\t\"Answer the fifth element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h ) fifth >>> #e\"\r\r\t^ self at: 5"},{"name":"errorOutOfBounds","linesOfCode":2,"sourceCode":"errorOutOfBounds\r\r\tSubscriptOutOfBounds signal"},{"name":"allButFirst:","linesOfCode":6,"sourceCode":"allButFirst: n\r\t\"Answer a copy of the receiver containing all but the first n\r\telements. Raise an error if there are not enough elements.\"\r\t\"(#(a b c d) allButFirst: 2) >>> #(c d)\"\r\t\"(#(a b c d) allButFirst: 3) >>> #(d)\"\r\t\r\t^ self copyFrom: n + 1 to: self size"},{"name":"atLast:put:","linesOfCode":5,"sourceCode":"atLast: indexFromEnd put: obj\r\t\"Set the element at indexFromEnd from the last position.\r\t atLast: 1 put: obj, sets the last element\"\r\t\"(#(x y z) atLast: 2 put: #e; yourself) >>> #(x e z)\"\r\r\t^ self at: self size + 1 - indexFromEnd put: obj"},{"name":"reverseWithIndexDo:","linesOfCode":7,"sourceCode":"reverseWithIndexDo: elementAndIndexBlock \r\t\"Just like reverseWith:do: except that the iteration index supplies the second argument to the block.\"\r\t\r\t\"(Array streamContents: [:stream | #(10 20 30) reverseWithIndexDo: [:each :index | stream nextPut: each + index]]) >>> #(33 22 11)\"\r\t\r\tself size to: 1 by: -1 do: [:index |\r\t\telementAndIndexBlock\r\t\t\tvalue: (self at: index)\r\t\t\tvalue: index]"},{"name":"forceTo:paddingStartWith:","linesOfCode":17,"sourceCode":"forceTo: length paddingStartWith: elem \r\t\"Force the length of the collection to length, padding  \r\tthe beginning of the result if necessary with elem.  \r\tNote that this makes a copy.\"\r\t| newCollection padLen |\r\tnewCollection := self species ofSize: length.\r\tpadLen := length - self size max: 0.\r\tnewCollection\r\t\tfrom: 1\r\t\tto: padLen\r\t\tput: elem.\r\tnewCollection\r\t\treplaceFrom: padLen + 1\r\t\tto: ((padLen + self size) min: length)\r\t\twith: self\r\t\tstartingAt:  1.\r\t^ newCollection"},{"name":"appendTo:","linesOfCode":3,"sourceCode":"appendTo: aCollection\r\t\"double dispatch for join:\"\r\t^ aCollection addAllLast: self"},{"name":"shuffleBy:","linesOfCode":5,"sourceCode":"shuffleBy: aRandom\r\t\"Durstenfeld's version of the Fisher-Yates shuffle\"\r\t\"#(1 2 3 4 5) shuffleBy: (Random seed: 42) >>> #(2 5 4 3 1)\"\r\r\tself size to: 2 by: -1 do: [ :i | \r\t\tself swap: i with: (aRandom nextInteger: i) ]"},{"name":"pairsDo:","linesOfCode":4,"sourceCode":"pairsDo: aBlock\r\t\"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:\"\r\r\t\"(#(1 'fred' 2 'charlie' 3 'elmer') pairsDo: [:a :b | Transcript cr; show: b, ' is number ', a printString]) >>> #(1 'fred' 2 'charlie' 3 'elmer')\"\r\r\t1 to: self size // 2 do: [ :index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]"},{"name":"hasEqualElements:","linesOfCode":12,"sourceCode":"hasEqualElements: otherCollection\r\t\"Answer whether the receiver's size is the same as otherCollection's\r\tsize, and each of the receiver's elements equal the corresponding \r\telement of otherCollection.\r\tThis should probably replace the current definition of #= .\"\r\r\t| size |\r\t(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].\r\t(size := self size) = otherCollection size ifFalse: [^ false].\r\t1 to: size do:\r\t\t[:index |\r\t\t(self at: index) = (otherCollection at: index) ifFalse: [^ false]].\r\t^ true"},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t| hash |\r\r\thash := self species hash.\r\t1 to: self size do: [:i | hash := (hash + (self at: i) hash) hashMultiply].\r\t^hash"},{"name":"joinTo:","linesOfCode":3,"sourceCode":"joinTo: stream\r\t\"double dispatch for join:\"\r\t^ stream nextPutAll: self"},{"name":"atAll:putAll:","linesOfCode":6,"sourceCode":"atAll: indexArray putAll: valueArray\r\t\"Store the elements of valueArray into the slots\r\tof this collection selected by indexArray.\"\r\t\"(#(x y z) atAll: #(1 3) putAll: #(a e); yourself) >>> #(a y e)\"\r\r\tindexArray with: valueArray do: [:index :value | self at: index put: value].\r\t^ valueArray"},{"name":"sorted:","linesOfCode":9,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\"(#(3 9 1) sorted: [:a :b | a <= b ]) >>> #(1 3 9)\"\r\t\"(#(3 9 1) sorted: [:a :b | a >= b ]) >>> #(9 3 1)\"\r\t\"(#(xa xc xz xb xy) sorted: #last ascending) >>> #(xa xb xc xy xz)\"\r\t\r\t^self copy sort: aSortBlockOrNil"},{"name":"third","linesOfCode":5,"sourceCode":"third\r\t\"Answer the third element of the receiver.\r\tRaise an error if there are not enough elements.\"\r\t\"#(a b c d e f g h i) third >>> #c\"\r\r\t^ self at: 3"},{"name":"isSequenceable","linesOfCode":2,"sourceCode":"isSequenceable\r\t^ true"},{"name":"forceTo:paddingWith:","linesOfCode":7,"sourceCode":"forceTo: length paddingWith: elem\r\t\"Force the length of the collection to length, padding\r\tif necessary with elem.  Note that this makes a copy.\"\r\r\t| newCollection |\r\tnewCollection := self species new: length withAll: elem.\r\tnewCollection replaceFrom: 1 to: (self size min: length) with: self startingAt: 1.\r\t^ newCollection"},{"name":"asGPUFloat64x3Array","linesOfCode":2,"sourceCode":"asGPUFloat64x3Array\r\t^ self asGPUArrayOfType: #Float64x3"},{"name":"allButLast:","linesOfCode":6,"sourceCode":"allButLast: n\r\t\"Answer a copy of the receiver containing all but the last n\r\telements. Raise an error if there are not enough elements.\"\r\t\"(#(a b c d) allButLast: 2) >>> #(a b)\"\r\t\"(#(a b c d) allButLast: 3) >>> #(a)\"\r\r\t^ self copyFrom: 1 to: self size - n"},{"name":"splitOn:","linesOfCode":6,"sourceCode":"splitOn: splitter\r\t\"Split a collection of objects based on a splitter. splitter - can be a subsequence, a Block or a Regex (String receiver only). Any other object used as a splitter is treated as an Array containing that object.\"\r\r\t\"(#(1 2 3 3 4 1 2 3 5 4 6) splitOn: 4) >>> #(#(1 2 3 3) #(1 2 3 5) #(6))asOrderedCollection\"\r\t\"(#(1 2 3 3 4 1 2 3 3 5 6) splitOn: #(3 3)) >>> #(#(1 2) #(4 1 2) #(5 6)) asOrderedCollection\"\r\t\"(#(2 2 3 3 4 1 2 3 3 5) splitOn: [:each | each > 3])>>> #(#(2 2 3 3) #(1 2 3 3) #()) asOrderedCollection\"\r\r\t^ splitter split: self"},{"name":"identityIndexOf:","linesOfCode":6,"sourceCode":"identityIndexOf: anElement \r\t\"Answer the index of anElement within the receiver. If the receiver does \r\tnot contain anElement, answer 0.\"\r\t\"(#(a b c d e) identityIndexOf: #c) >>> 3\"\r\t\"(#(a b c d e) identityIndexOf: #x) >>> 0\"\r\r\t^self identityIndexOf: anElement ifAbsent: [0]"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ encoder encodeArray: self"},{"name":"asGPUFloat64x2Array","linesOfCode":2,"sourceCode":"asGPUFloat64x2Array\r\t^ self asGPUArrayOfType: #Float64x2"},{"name":"runningAverage:","linesOfCode":4,"sourceCode":"runningAverage: aSubsetSize\r\t\"Running average (a.k.a. moving average, rolling average). See the comment of self >> #running:of: for more information.\"\r\t\"(#(1 1 2 2 3 3) runningAverage: 2) >>> {1 . (3/2) . 2 . (5/2) . 3}\"\r\r\t^ self running: [ :subset | subset average ] of: aSubsetSize"},{"name":"polynomialEval:","linesOfCode":11,"sourceCode":"polynomialEval: thisX\r\t\"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power.\r\t#(1 2 3) polynomialEval: 2  is 3*X^2 + 2*X + 1 with X = 2\"\r\r\t\"(#(1 2 3) polynomialEval: 2) >>> 17\"\r\r\t| sum valToPower |\r\tsum := self first.\r\tvalToPower := thisX.\r\t2 to: self size do: [ :ind | \r\t\tsum := sum + ((self at: ind) * valToPower).\r\t\tvalToPower := valToPower * thisX ].\r\t^ sum"}],"meta":{"name":"SequenceableCollection class","instanceVariables":[],"methods":[{"name":"streamContents:limitedTo:","linesOfCode":10,"sourceCode":"streamContents: blockWithArg limitedTo: sizeLimit\r\t\"A variant of #streamContents: with a strict size limit\"\r\r\t\"(String streamContents: [:s | 10 timesRepeat: [s nextPutAll: 'foo']] limitedTo: 9) >>> 'foofoofoo'\"\r\r\t| stream |\r\tstream := LimitedWriteStream\r\t\ton: (self streamSpecies new: (100 min: sizeLimit))\r\t\tlimit: sizeLimit\r\t\tlimitBlock: [ ^ stream contents ].\r\tblockWithArg value: stream.\r\t^ stream contents"},{"name":"new:streamContents:","linesOfCode":11,"sourceCode":"new: newSize streamContents: blockWithArg\r\t\"A variant of #streamContents: where the initial or even final size is given to optimize memory consumption\"\r\t\r\t\"(Array new: 3 streamContents: [ :out | 3 timesRepeat: [ out nextPut: 42 ] ]) >>> #(42 42 42)\"\r\t\r\t| stream |\r\tstream := WriteStream on: (self streamSpecies new: newSize).\r\tblockWithArg value: stream.\r\t\"If the write position of stream is at the end of the internal buffer of stream (originalContents),\r\twe can return it directly instead of making a copy as contents would do\"\r\t^ stream position = stream originalContents size\r\t\tifTrue: [ stream originalContents ]\r\t\tifFalse: [ stream contents ]"},{"name":"streamSpecies","linesOfCode":3,"sourceCode":"streamSpecies\r\t\"I return the class that is used for streaming. If override consider overriding #new:streamContents:\"\r\t^ self"},{"name":"ofSize:","linesOfCode":5,"sourceCode":"ofSize: n\r\t\"Create a new collection of size n with nil as its elements.\r\tThis method exists because OrderedCollection new: n creates an\r\tempty collection,  not one of size n.\"\r\t^ self new: n"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeCollectionInspector"},{"name":"fromSton:","linesOfCode":5,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to use #streamContents: and #nextPut:\"\r\t\r\t^ self streamContents: [ :stream |\r\t\tstonReader parseListDo: [ :each |\r\t\t\tstream nextPut: each ] ]"},{"name":"<<","linesOfCode":4,"sourceCode":"<< blockWithArg\r\t\"An alias to #streamContents:\"\r\t\r\t\"Array << [ :stream | 0 to: 100 by: 25 do: [ :each | stream nextPut: each ] ] >>> #(0 25 50 75 100)\"\r\t\r\t^ self streamContents: blockWithArg"},{"name":"streamContents:","linesOfCode":8,"sourceCode":"streamContents: blockWithArg\r\t\"Build an instance of the receiver by writing elements to a stream.\r\tMore specifically: blockWithArg will be given a WriteStream on an instance of the receiver.\r\tInside blockWithArg you write elements to the stream to build up the collection.\r\tAt the end, the contents of the stream up to that point will be returned.\r\tNote that the underlying collection grows as needed.\"\r\t\r\t\"(Array streamContents: [ :out | out nextPut: 1; nextPutAll: #(2 3 4); nextPut: 5 ]) >>> #(1 2 3 4 5)\"\r\r\t^ self new: 100 streamContents: blockWithArg"},{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #SequenceableCollection"}],"meta":null}},{"name":"BlockClosure","instanceVariables":[{"name":"outerContext"},{"name":"startpc"},{"name":"numArgs"}],"methods":[{"name":"copiedValueAt:","linesOfCode":3,"sourceCode":"copiedValueAt: i\r\t<primitive: 60>\r\t^self basicAt: i"},{"name":"valueWithInterval:","linesOfCode":10,"sourceCode":"valueWithInterval: aDelay\r\t\"Executes the block every x milliseconds specified in arguments. Answers the process, so you can terminate it\"\r\t\r\t^ [ [ self value. aDelay wait. ] repeat ] \r\t\tforkAt: Processor userBackgroundPriority \r\t\tnamed: (String streamContents: [ :s |\r\t\t\t\ts \r\t\t\t\t\t<< 'every ';\r\t\t\t\t\tprint: aDelay;\r\t\t\t\t\t<<' do: ';\r\t\t\t\t\tprint: self ] )"},{"name":"valueAt:","linesOfCode":14,"sourceCode":"valueAt: blockPriority \r\t\"Evaluate the receiver (block), with another priority as the actual one \r\tand restore it afterwards. The caller should be careful with using \r\thigher priorities.\"\r\t| activeProcess result outsidePriority |\r\tactiveProcess := Processor activeProcess.\r\toutsidePriority := activeProcess priority.\r\tactiveProcess priority: blockPriority.\r\tresult := self ensure: [activeProcess priority: outsidePriority].\r\t\"Yield after restoring lower priority to give the preempted processes a  \r\tchance to run.\"\r\tblockPriority > outsidePriority\r\t\tifTrue: [Processor yield].\r\t^ result"},{"name":"sourceNode","linesOfCode":4,"sourceCode":"sourceNode\r\t\"Return an instance of RBBlockNode representing the receiver's AST.\"\r\r\t\"the bytecode just before the first bytecode of the block is a bytecode that creates the complete block\"\r\r\t^ self method sourceNodeForPC: self startpc - 1"},{"name":"valueSupplyingMetacelloAnswers:","linesOfCode":24,"sourceCode":"valueSupplyingMetacelloAnswers: aListOfPairs\r\t\"evaluate the block using a list of questions / answers that might be called upon to\r\tautomatically respond to Object>>confirm: or FillInTheBlank requests\"\r\r\t^ [ self value ]\r\t\ton: ProvideAnswerNotification\r\t\tdo: [ :notify | \r\t\t\t| caption |\r\t\t\tcaption := notify messageText withSeparatorsCompacted.\t\"to remove new lines\"\r\t\t\taListOfPairs\r\t\t\t\tdetect: [ :each | \r\t\t\t\t\tcaption = each first\r\t\t\t\t\t\tor: [ (caption includesSubstring: each first caseSensitive: false)\r\t\t\t\t\t\t\t\tor: [ (each first match: caption)\r\t\t\t\t\t\t\t\t\t\tor: [ (String includesSelector: #matchesRegex:)\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ [ caption matchesRegex: each first ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\ton: Error\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo: [ :ignored | false ] ] ] ] ] ]\r\t\t\t\tifFound: [ :answer | notify resume: answer second ]\r\t\t\t\tifNone: [ | outerAnswer |\r\t\t\t\t\touterAnswer := ProvideAnswerNotification\r\t\t\t\t\t\tsignal: notify messageText.\r\t\t\t\t\touterAnswer\r\t\t\t\t\t\tifNil: [ notify resume ]\r\t\t\t\t\t\tifNotNil: [ notify resume: outerAnswer ] ] ]"},{"name":"memoizedUsing:","linesOfCode":5,"sourceCode":"memoizedUsing: cache\r\t\"Provide a memoization block using the given cache. So one can tune by\r     passing a LRUCache for instance\"\r  \r    ^[ :x | cache at: x ifAbsentPut: [ self value: x ] ]\r"},{"name":"rsValue:","linesOfCode":2,"sourceCode":"rsValue: value\r\t^ self cull: value"},{"name":"asParser","linesOfCode":3,"sourceCode":"asParser\r\t\"Answer a parser implemented in the receiving one-argument block.\"\r\r\t^ PPPluggableParser on: self"},{"name":"assertWithDescription:","linesOfCode":6,"sourceCode":"assertWithDescription: aStringOrABlock\r\t| value |\r\tself value\r\t\tifTrue: [ ^ self ].\r\tvalue := aStringOrABlock value.\r\tAssertionFailure signal: value"},{"name":"noiseValueAt:withAmplitude:withTilingPeriod:","linesOfCode":4,"sourceCode":"noiseValueAt: coord withAmplitude: amplitude withTilingPeriod: tilingPeriod\r\tself numArgs = 2 ifTrue: [ ^ (self value: coord value: tilingPeriod) * amplitude ].\r\tself numArgs = 3 ifTrue: [ ^ self value: coord value: tilingPeriod value: amplitude ].\r\tself error: 'Invalid noise function for fBM.'"},{"name":"fork","linesOfCode":3,"sourceCode":"fork\r\t\"Create and schedule a Process running the code in the receiver.\"\r\r\t^ self newProcess resume"},{"name":"blockCreationBytecodeMessage","linesOfCode":4,"sourceCode":"blockCreationBytecodeMessage\r\t\"Answer the abstract bytecode message that created the receiver.\"\r\t^self method encoderClass blockCreationBytecodeMessageAt: startpc method: self method\r\r\t\"(SortedCollection sortBlock: [:a :b| a compare: b caseSensitive: false]) sortBlock blockCreationBytecodeMessage\""},{"name":"valueUninterruptably","linesOfCode":3,"sourceCode":"valueUninterruptably\r\t\"Prevent remote returns from escaping the sender.  Even attempts to terminate (unwind) this process will be halted and the process will resume here.  A terminate message is needed for every one of these in the sender chain to get the entire process unwound.\"\r\r\t^ self ifCurtailed: [^ self]"},{"name":"repeatWithGCIf:","linesOfCode":6,"sourceCode":"repeatWithGCIf: testBlock\r\t| ans |\r\t\"run the receiver, and if testBlock returns true, garbage collect and run the receiver again\"\r\tans := self value.\r\t(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self value ].\r\t^ans"},{"name":"value:value:","linesOfCode":9,"sourceCode":"value: firstArg value: secondArg\r\t\"Activate the receiver, creating a closure activation (MethodContext)\r\t whose closure is the receiver and whose caller is the sender of this message.\r\t Supply the arguments and copied values to the activation as its arguments and copied temps.\r\t Primitive. Optional (but you're going to want this for performance).\"\r\t<primitive: 203>\r\tnumArgs ~= 2 ifTrue:\r\t\t[self numArgsError: 2].\r\t^self primitiveFailed"},{"name":"gtInspectorSourceCodeIn:","linesOfCode":5,"sourceCode":"gtInspectorSourceCodeIn: composite \r\t<gtInspectorPresentationOrder: 40>\r\t^(self sourceNode gtInspectorSourceCodeIn: composite)\r\t\tdoItReceiver: [ self receiver ];\r\t\tdoItContext: [ self outerContext ]"},{"name":"valueWithPossibleArgs:","linesOfCode":24,"sourceCode":"valueWithPossibleArgs: anArray \r\t\"Execute the receiver with the correct number of arguments taken from the argument.\"\r\t\"([:x | x + 1] valueWithPossibleArgs: #( 13 12 15))\r\t>>> 14\r\t\"\r\t\"([:x :y | x + y] valueWithPossibleArgs: #( 13 12 15)) \r\t>>> 25\r\t\"\r\t\"([:x :y :z | x + y + z] valueWithPossibleArgs: #( 13 12 15)) \r\t>>> 40\r\t\"\r\t\"([:x :y :z | x + y + z] valueWithPossibleArgs: #( 13 12 15)) \r\t>>> 40\r\t\"\r\t^numArgs = 0\r\t\tifTrue: [self value]\r\t\tifFalse:\r\t\t\t[self valueWithArguments:\r\t\t\t\t(numArgs = anArray size\r\t\t\t\t\tifTrue: [anArray]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[numArgs > anArray size\r\t\t\t\t\t\t\tifTrue: [anArray, (Array new: numArgs - anArray size)]\r\t\t\t\t\t\t\tifFalse: [anArray copyFrom: 1 to: numArgs]])]"},{"name":"asMinimalRepresentation","linesOfCode":3,"sourceCode":"asMinimalRepresentation\r\t\"Answer the receiver.\"\r\r\t^self"},{"name":"split:indicesDo:","linesOfCode":12,"sourceCode":"split: aSequenceableCollection indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of aSequenceableCollection that have been identified by taking the receiver as a splitter.\" \r\t\r\t\"(String streamContents: [:s | [:c | c isSeparator ] split:  'Pharo is cool'  indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>>  's:1 e:5 s:7 e:8 s:10 e:13 '\"\r\t\r\t\r\t| position |\r\t\r\tposition := 1.\r\t\r\taSequenceableCollection withIndexDo: [:element :idx |\r\t\t(self value: element) \r\t\t\tifTrue: [\r\t\t\t\taBlock value: position value: idx - 1.\r\t\t\t\tposition := idx + 1 ]].\r\t\t\r\taBlock value: position value: aSequenceableCollection size"},{"name":"printOn:","linesOfCode":7,"sourceCode":"printOn: aStream\r\t\t\r\t[self doPrintOn: aStream] \r\t\tonErrorDo: [ aStream \r\t\t\t\tnextPutAll: '<Error printing blockClosure in: ';\r\t\t\t\tprint: self method;\r\t\t\t\tnextPutAll: ' >' ]"},{"name":"isClosure","linesOfCode":2,"sourceCode":"isClosure\r\t^true"},{"name":"valueWithEnoughArguments:","linesOfCode":11,"sourceCode":"valueWithEnoughArguments: anArray\r\t\"call me with enough arguments from anArray\"\r\t| args |\r\t(anArray size == self numArgs)\r\t\tifTrue: [ ^self valueWithArguments: anArray ].\r\r\targs := Array new: self numArgs.\r\targs replaceFrom: 1\r\t\tto: (anArray size min: args size)\r\t\twith: anArray\r\t\tstartingAt: 1.\r\r\t^ self valueWithArguments: args"},{"name":"matchesPatternElement:","linesOfCode":2,"sourceCode":"matchesPatternElement: matchedElement\r\t^ self cull: matchedElement"},{"name":"clearTemporariesOn:","linesOfCode":2,"sourceCode":"clearTemporariesOn: aContext\r\r\t\" I do nothing in the non-full blocks\""},{"name":"valueWithin:onTimeout:","linesOfCode":26,"sourceCode":"valueWithin: aDuration onTimeout: timeoutBlock\r\t\"Evaluate the receiver.\r\tIf the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead\"\r\t<debuggerCompleteToSender>\r\t| theProcess delay watchdog tag |\r\r\taDuration <= Duration zero ifTrue: [^ timeoutBlock value ].\r\r\t\"the block will be executed in the current process\"\r\ttheProcess := Processor activeProcess.\r\tdelay := aDuration asDelay.\r\ttag := self.\r\r\t\"make a watchdog process\"\r\twatchdog := [\r\t\tdelay wait. \t\"wait for timeout or completion\"\r\t\ttheProcess ifNotNil:[ theProcess signalException: (TimedOut new tag: tag)] \r\t] newProcess.\r\r\t\"Watchdog needs to run at high priority to do its job (but not at timing priority)\"\r\twatchdog priority: Processor timingPriority-1.\r\r\t\"catch the timeout signal\"\r\t^ [\twatchdog resume.\t\t\t\t\"start up the watchdog\"\r\t\tself ensure:[\t\t\t\t\t\t\"evaluate the receiver\"\r\t\t\ttheProcess := nil.\t\t\t\t\"it has completed, so ...\"\r\t\t\tdelay delaySemaphore signal.\t\"arrange for the watchdog to exit\"\r\t\t]] on: TimedOut do: [ :e | \r\t\t\te tag == tag \r\t\t\t\tifTrue:[ timeoutBlock value ]\r\t\t\t\tifFalse:[ e pass]]."},{"name":"shouldBeSubstitutedByCleanCopy","linesOfCode":2,"sourceCode":"shouldBeSubstitutedByCleanCopy\r\t^ self isClean "},{"name":"valueWithPossibleArgument:","linesOfCode":10,"sourceCode":"valueWithPossibleArgument: anArg \r\t\"Evaluate the block represented by the receiver. \r\t If the block requires one argument, use anArg, if it requires more than one,\r\t fill up the rest with nils.\"\r\r\t| a |\r\tnumArgs = 0 ifTrue: [^self value].\r\tnumArgs = 1 ifTrue: [^self value: anArg].\r\ta := Array new: numArgs.\r\ta at: 1 put: anArg.\r\t^self valueWithArguments: a"},{"name":"forkAt:","linesOfCode":5,"sourceCode":"forkAt: priority \r\t\"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process.\"\r\r\t^ self newProcess\r\t\tpriority: priority;\r\t\tresume"},{"name":"home","linesOfCode":2,"sourceCode":"home\r\t^outerContext home"},{"name":"asContextWithSender:","linesOfCode":9,"sourceCode":"asContextWithSender: aContext\r\t\"Inner private support method for evaluation.  Do not use unless you know what you're doing.\"\r\r\t^(Context newForMethod: outerContext compiledCode)\r\t\tsetSender: aContext\r\t\treceiver: outerContext receiver\r\t\tmethod: outerContext compiledCode\r\t\tclosure: self\r\t\tstartpc: startpc;\r\t\tprivRefresh"},{"name":"numLocalTemps","linesOfCode":3,"sourceCode":"numLocalTemps\r\t\"Answer the number of local temporaries for the receiver\"\r\t^ self method encoderClass numLocalTempsForBlockAt: startpc in: outerContext compiledCode"},{"name":"setBlessingInMetacelloConfig:","linesOfCode":2,"sourceCode":"setBlessingInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setBlessingWithBlock: self"},{"name":"cleanOuterContext","linesOfCode":3,"sourceCode":"cleanOuterContext\r\t\"Clean my outerContext preserving just the receiver and method, which are the only needed by a clean block closure.\"\r\r\touterContext := outerContext cleanCopy"},{"name":"rfEnsure:","linesOfCode":11,"sourceCode":"rfEnsure: aBlock\r\t\"same as #esure, carefully written to never have active meta-links as it is called in the code path that checks for recursion\"\r\r\t<primitive: 198>\r\t<metaLinkOptions: #( + optionDisabledLink)>\r\t| returnValue complete |\r\treturnValue := self rfvalueNoContextSwitch.\r\tcomplete ifNil:[\r\t\tcomplete := true.\r\t\taBlock rfvalue.\r\t].\r\t^ returnValue"},{"name":"argumentNames","linesOfCode":2,"sourceCode":"argumentNames\r\t^ self sourceNode argumentNames"},{"name":"forkAndWait","linesOfCode":6,"sourceCode":"forkAndWait\r\t\"Suspend current process and execute self in new process, when it completes resume current process\"\r\r\t| semaphore |\r\tsemaphore := Semaphore new.\r\t[self ensure: [semaphore signal]] fork.\r\tsemaphore wait.\r"},{"name":"valueSelector","linesOfCode":5,"sourceCode":"valueSelector\r\tself numArgs = 0 ifTrue: [^#value].\r\t^(String streamContents: [:stream | \r\t\tstream nextPutAll: 'value:'.\r\t\t(self numArgs - 1) timesRepeat: [stream nextPutAll: 'value:']]) asSymbol."},{"name":"collatedBy:","linesOfCode":4,"sourceCode":"collatedBy: aSortFunction\r\t\"Return a SortFunction around the receiver. If the receiver is a 2 arg block, it is assumed it will do the collation directly itself, returning -1, 0, or 1. If the receiver is a one arg block, it will be evaluated for each a and b and of the sort input, and the result of using aSortFunction on those will be used\"\r\t\r\tself numArgs = 1 ifTrue: [^PropertySortFunction property: self collatedWith: aSortFunction asSortFunction].\r\tself error: 'Cant be converted to sort function. It should hava one arg'\t"},{"name":"valueCachedInDiskWithKey:","linesOfCode":2,"sourceCode":"valueCachedInDiskWithKey: keyValue\r\t^ self valueCachedInDiskWithHash: (SHA256 hashMessage: keyValue closureDescriptionForCaching) hex"},{"name":"cull:","linesOfCode":11,"sourceCode":"cull: anArg\r\t\"Execute the receiver with one or zero arguments depending on the receiver\"\r\t\"([ 12 ] cull: 13)\r\t>>> 12 \r\t\"\r\t\"([:x | x + 12] cull: 3)\r\t>>> 15\r\t\"\r\t^numArgs = 0 \r\t\tifTrue: [self value]\r\t\tifFalse: [self value: anArg]\r\t"},{"name":"future","linesOfCode":2,"sourceCode":"future\r\r\t^ self asTask future"},{"name":"valueWithExit","linesOfCode":2,"sourceCode":"valueWithExit\r\r\t^ self value: [ ^ nil ]"},{"name":"rfvalueNoContextSwitch","linesOfCode":7,"sourceCode":"rfvalueNoContextSwitch\r\t\"same as valueNoContextSwitch, for recursion stopping metalinks\"\r\t<primitive: 221>\r\t<metaLinkOptions: #( + optionDisabledLink)>\r\tnumArgs ~= 0 ifTrue:\r\t\t[self numArgsError: 0].\r\tself primitiveFailed"},{"name":"on:fork:","linesOfCode":30,"sourceCode":"on: exception fork: handlerAction\r\t\"Activate the receiver. In case of exception, fork a new process, which will handle an error.\r\tAn original process will continue running as if receiver evaluation finished and answered nil,\r\ti.e., an expression like:\r\t\r\t[ self error: 'some error'] on: Error fork: [:ex |  123 ] \r\t\r\twill always answer nil for original process, not 123.\r\r\tThe context stack , starting from context which sent this message to receiver and\r\tup to the top of the stack will be transferred to forked process, with handlerAction on top.\r\t(so when the forked process will be resuming, it will enter the handlerAction)\r\t \"\r\r\t^ self\r\t\t  on: exception\r\t\t  do: [ :ex | \r\t\t\t  | onDoCtx handler bottom thisCtx |\r\t\t\t  onDoCtx := thisContext.\r\t\t\t  thisCtx := onDoCtx home.\r\r\t\t\t  \"find the context on stack for which this method's is sender\"\r\r\t\t\t  [ onDoCtx sender == thisCtx ] whileFalse: [ \r\t\t\t\t  onDoCtx := onDoCtx sender.\r\t\t\t\t  onDoCtx ifNil: [ \"Can't find our home context. seems like we're already forked\r\t\t\t\tand handling another exception in new thread. In this case, just pass it through handler.\" \r\t\t\t\t\t  ^ handlerAction cull: ex ] ].\r\r\t\t\t  bottom := [ Processor terminateActive ] asContext.\r\t\t\t  onDoCtx privSender: bottom.\r\r\t\t\t  handler := [ handlerAction cull: ex ] asContext.\r\t\t\t  handler privSender: thisContext sender.\r\r\t\t\t  (Process forContext: handler priority: Processor activePriority) resume.\r\r\t\t\t  \"cut the stack of current process\"\r\t\t\t  thisContext privSender: thisCtx.\r\t\t\t  nil ]"},{"name":"numArgsError:","linesOfCode":2,"sourceCode":"numArgsError: numArgsForInvocation\r\r\tArgumentsCountMismatch signalExpectedArgumentsCount: numArgs calledArgumentsCount: numArgsForInvocation "},{"name":"inspectionSourceCode","linesOfCode":3,"sourceCode":"inspectionSourceCode\r\t<inspectorPresentationOrder: 30 title: 'Source code'>\r\r\t^ self sourceNode inspectionSourceCode"},{"name":"endPC","linesOfCode":2,"sourceCode":"endPC\r\t^self blockCreationBytecodeMessage arguments last + startpc - 1"},{"name":"phlowValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"phlowValue: anObject withEnoughArguments: aCollection\r\r\t^ self valueWithEnoughArguments:  aCollection"},{"name":"setProject:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setProject: aString withInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setProject: aString withBlock: self"},{"name":"hasTemporaryVariableNamed:","linesOfCode":2,"sourceCode":"hasTemporaryVariableNamed: aName\r\t^self tempNames includes: aName"},{"name":"gtIterator","linesOfCode":6,"sourceCode":"gtIterator\r\t\" 1:filter 2:context[optional] \"\r\tself assert: (self numArgs between: 1 and: 2). \r\t\r\t^ GTSpotterBlockIterator new \r\t\tonDo: self;\r\t\tyourself"},{"name":"asSortFunction","linesOfCode":5,"sourceCode":"asSortFunction\r\t\"Return a SortFunction around the receiver. If the receiver is a 2 arg block, it is assumed it will do the collation directly itself, returning -1, 0, or 1. If the receiver is a one arg block, it will be evaluated for each a and b and of the sort input, and the result of sending <=> to those will be used\"\r\t\r\tself numArgs = 1 ifTrue: [^PropertySortFunction property: self].\r\tself numArgs = 2 ifTrue: [^CollatorBlockFunction usingBlock: self].\r\r\tself error: 'Cant be converted to sort function. It should has one or two args'\t"},{"name":"ifErrorDo:","linesOfCode":6,"sourceCode":"ifErrorDo: errorHandlerBlock\r \r\t\"This method is called with a block expecting description and receiver as arguments\"\r\t\"This method is deprecated in favor of #onErrorDo: that takes the exception object instead of its parts.\"\r\tself deprecated: 'Use #onErrorDo: instead.'.\r\r\t^ self on: Error do: [:ex |\r\t\terrorHandlerBlock cull: ex description cull: ex receiver ]"},{"name":"numArgs","linesOfCode":3,"sourceCode":"numArgs\r\t\"Answer the number of arguments that must be used to evaluate this block\"\r\r\t^numArgs"},{"name":"simulateValueWithArguments:caller:","linesOfCode":19,"sourceCode":"simulateValueWithArguments: anArray caller: aContext\r\t\"Simulate the valueWithArguments: primitive. Fail if anArray is not an array of the right arity.\"\r\t| newContext sz |\r\tnewContext := (Context newForMethod: outerContext compiledCode)\r\t\t\t\t\t\tsetSender: aContext\r\t\t\t\t\t\treceiver: outerContext receiver\r\t\t\t\t\t\tmethod: outerContext compiledCode\r\t\t\t\t\t\tclosure: self\r\t\t\t\t\t\tstartpc: startpc.\r\t((newContext objectClass: anArray) ~~ Array\r\t or: [numArgs ~= anArray size]) ifTrue:\r\t\t[^Context primitiveFailTokenFor: nil].\r\tsz := self basicSize.\r\tnewContext stackp: sz + numArgs.\r\t1 to: numArgs do:\r\t\t[:i| newContext at: i put: (anArray at: i)].\r\t1 to: sz do:\r\t\t[:i| newContext at: i + numArgs put: (self at: i)].\r\t^newContext"},{"name":"initialStackPointer","linesOfCode":2,"sourceCode":"initialStackPointer\r\r\t^ self numArgs + self numCopiedValues"},{"name":"isValid","linesOfCode":3,"sourceCode":"isValid\r\t\"Answer the receiver.\"\r\r\t^true"},{"name":"valueSuppressingMessages:supplyingAnswers:","linesOfCode":2,"sourceCode":"valueSuppressingMessages: aListOfStrings supplyingAnswers: aListOfPairs\r\r\t^ self valueSupplyingAnswers: aListOfPairs, (aListOfStrings collect: [:each | {each . true}])"},{"name":"setPackage:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setPackage: aString withInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setPackage: aString withBlock: self"},{"name":"asContext","linesOfCode":3,"sourceCode":"asContext\r\t\"Create a MethodContext that is ready to execute self.  Assumes self takes no args (if it does the args will be nil)\"\r\r\t^self asContextWithSender: nil"},{"name":"value:","linesOfCode":9,"sourceCode":"value: anArg\r\t\"Activate the receiver, creating a closure activation (MethodContext)\r\t whose closure is the receiver and whose caller is the sender of this message.\r\t Supply the argument and copied values to the activation as its arguments and copied temps.\r\t Primitive. Optional (but you're going to want this for performance).\"\t \r\t<primitive: 202>\r\tnumArgs ~= 1 ifTrue:\r\t\t[self numArgsError: 1].\r\tself primitiveFailed"},{"name":"isDead","linesOfCode":3,"sourceCode":"isDead\r\t\"Has self finished\"\r\t^false"},{"name":"on:fork:return:","linesOfCode":24,"sourceCode":"on: exception fork: handlerAction return: answerAction\r\t\"This is the same as #on:fork: but instead just fork and letting the flow continues, in \r\t case of an error it also evaluates answerAction and returns its result.\"\r\t\t\r\t^ self on: exception do: [:ex |\r\t\t| onDoCtx handler bottom thisCtx |\r\t\t\r\t\tonDoCtx := thisContext.\r\t\tthisCtx := onDoCtx home.\r\r\t\t\"find the context on stack for which this method's is sender\"\r\r\t\t[ onDoCtx sender == thisCtx] whileFalse: [ \r\t\t\tonDoCtx := onDoCtx sender.\r\t\t\tonDoCtx ifNil: [ \r\t\t\t\t\"Can't find our home context. seems like we're already forked\r\t\t\t\tand handling another exception in new thread. In this case, just pass it through handler.\"\r\t\t\t\t^ handlerAction cull: ex ] ].\r\r\t\tbottom := [ Processor terminateActive ] asContext.\r\t\tonDoCtx privSender: bottom.\r\r\t\thandler := [ handlerAction cull: ex ] asContext.\r\t\thandler privSender: thisContext sender.\r\r\t\t(Process forContext: handler priority: Processor activePriority) resume.\r\r\t\t\"cut the stack of current process\"\r\t\tthisContext privSender: thisCtx.\r\t\tanswerAction cull: exception ]\r"},{"name":"timeProfile","linesOfCode":2,"sourceCode":"timeProfile\r\t^Smalltalk tools timeProfiler onBlock: self"},{"name":"whileFalse","linesOfCode":5,"sourceCode":"whileFalse\r\t\"Ordinarily compiled in-line, and therefore not overridable.\r\tThis is in case the message is sent to other than a literal block.\r\tEvaluate the receiver, as long as its value is false.\"\r \r\tself value ifFalse: [ self whileFalse ]"},{"name":"glamourValueWithArgs:","linesOfCode":2,"sourceCode":"glamourValueWithArgs: anArray \r\t^ self valueWithPossibleArgs: anArray"},{"name":"valueCachedInDiskWithHash:","linesOfCode":9,"sourceCode":"valueCachedInDiskWithHash: hashString\r\t| fileName value |\r\tfileName := WDCResourceCache proceduralContentDiskCache / (hashString , '.fuel').\r\tfileName exists ifTrue: [ \r\t\t^ FLMaterializer materializeFromFileNamed: fileName fullName\r\t].\r\r\tvalue := self value.\r\tFLSerializer serialize: value toFileNamed: fileName fullName.\r\t^ value"},{"name":"on:do:","linesOfCode":6,"sourceCode":"on: exception do: handlerAction\r\t\"Evaluate the receiver in the scope of an exception handler.\r\tThe following primitive is just a marker used to find the error handling context. \r\tSee MethodContext>>#isHandlerOrSignalingContext. \"\r\t<primitive: 199>  \r\t^ self value"},{"name":"phlowValue:","linesOfCode":2,"sourceCode":"phlowValue: anObject\r\r\t^ self cull: anObject"},{"name":"newProcess","linesOfCode":11,"sourceCode":"newProcess\r\t\"Answer a Process running the code in the receiver. The process is not \r\tscheduled.\r\tIMPORTANT! Debug stepping this deep infrastructure may lock your Image\r  \tIf you are not sure what you are doing, close the debugger now.\"\r\t<primitive: 19> \"Simulation guard\"\r\t^Process\r\t\tforContext: \r\t\t\t[self value.\r\t\t\tProcessor terminateActive] asContext\r\t\tpriority: Processor activePriority"},{"name":"fuelAccept:","linesOfCode":5,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^ self shouldBeSubstitutedByCleanCopy\r\t\t\"The 'onRecursionDo:' is just to avoid an infinitive loop for the substitution. The cleanCopy MUST be a clean copy so it can be serialized normally\"\r\t\tifTrue: [ aGeneralMapper visitSubstitution: self by: self cleanCopy onRecursionDo: [ aGeneralMapper visitVariableObject: self ]  ]\r\t\tifFalse: [ aGeneralMapper visitVariableObject: self ]"},{"name":"whileTrue","linesOfCode":5,"sourceCode":"whileTrue\r\t\"Ordinarily compiled in-line, and therefore not overridable.\r\tThis is in case the message is sent to other than a literal block.\r\tEvaluate the receiver, as long as its value is true.\"\r \r\tself value ifTrue: [ self whileTrue ]"},{"name":"whileFalse:","linesOfCode":6,"sourceCode":"whileFalse: aBlock \r\t\"Ordinarily compiled in-line, and therefore not overridable.\r\tThis is in case the message is sent to other than a literal block.\r\tEvaluate the argument, aBlock, as long as the value of the receiver is false.\"\r\r\tself value ifFalse: [ aBlock value. self whileFalse: aBlock ].\r\t^ nil"},{"name":"descending","linesOfCode":3,"sourceCode":"descending\r\t\"Opposite direction as ascending.\"\r\r\t^self asSortFunction reversed"},{"name":"execute:against:","linesOfCode":2,"sourceCode":"execute: projectSpecBlock against: aScriptExecutor\r    aScriptExecutor executeBlock: self do: projectSpecBlock"},{"name":"valueSuppressingAllMessages","linesOfCode":2,"sourceCode":"valueSuppressingAllMessages\r\r\t^ self valueSuppressingMessages: #('*')"},{"name":"value:value:value:value:","linesOfCode":9,"sourceCode":"value: firstArg value: secondArg value: thirdArg value: fourthArg\r\t\"Activate the receiver, creating a closure activation (MethodContext)\r\t whose closure is the receiver and whose caller is the sender of this message.\r\t Supply the arguments and copied values to the activation as its arguments and copied temps.\r\t Primitive. Optional (but you're going to want this for performance).\"\r\t<primitive: 205>\r\tnumArgs ~= 4 ifTrue:\r\t\t[self numArgsError: 4].\r\t^self primitiveFailed"},{"name":"copyForSaving","linesOfCode":7,"sourceCode":"copyForSaving\r\t\"Answer a copy of the receiver suitable for serialization.\r\t Notionally, if the receiver's outerContext has been returned from then nothing\r\t needs to be done and we can use the receiver. But there's a race condition\r\t determining if the receiver has been returned from (it could be executing in a\r\t different process). So answer a copy anyway.\"\r\t^self shallowCopy postCopy"},{"name":"repeat","linesOfCode":3,"sourceCode":"repeat\r\t\"Evaluate the receiver repeatedly, ending only if the block explicitly returns.\"\r\r\t[self value. true] whileTrue"},{"name":"numCopiedValues","linesOfCode":7,"sourceCode":"numCopiedValues\r\t\"Answer the number of copied values of the receiver.  Since these are\r\t stored in the receiver's indexable fields this is the receiver's basic size.\r\t Primitive. Answer the number of indexable variables in the receiver. \r\t This value is the same as the largest legal subscript.\"\r\r\t<primitive: 62>\r\t^self basicSize"},{"name":"assert","linesOfCode":2,"sourceCode":"assert\r\r\tself value ifFalse: [AssertionFailure signal: 'Assertion failed']\r"},{"name":"timeToRun","linesOfCode":3,"sourceCode":"timeToRun\r\t\"Answer the number of milliseconds taken to execute this block.\"\r\r\t^ Duration milliSeconds: (Time millisecondsToRun: self)"},{"name":"ascending","linesOfCode":3,"sourceCode":"ascending\r\t\"Return a SortFunction around the receiver. If the receiver is a 2 arg block, it is assumed it will do the collation directly itself, returning -1, 0, or 1. If the receiver is a one arg block, it will be evaluated for each a and b and of the sort input, and the result of sending <=> to those will be used.\"\r\r\t^self asSortFunction"},{"name":"doWhileFalse:","linesOfCode":6,"sourceCode":"doWhileFalse: conditionBlock\r\t\"Evaluate the receiver once, then again as long the value of conditionBlock is false.\"\r \r\t| result |\r\t[result := self value.\r\tconditionBlock value] whileFalse.\r\r\t^ result"},{"name":"shapeFor:","linesOfCode":2,"sourceCode":"shapeFor: model\r\t^ self cull: model"},{"name":"tfPrintString","linesOfCode":2,"sourceCode":"tfPrintString\r\r\t^ self printString"},{"name":"wbtEvaluateSubstitutionVariableInEnvironment:","linesOfCode":2,"sourceCode":"wbtEvaluateSubstitutionVariableInEnvironment: evaluationEnvironment\r\t^ self cull: evaluationEnvironment"},{"name":"noiseValueAt:withAmplitude:","linesOfCode":4,"sourceCode":"noiseValueAt: coord withAmplitude: amplitude\r\tself numArgs = 1 ifTrue: [ ^ (self value: coord) * amplitude ].\r\tself numArgs = 2 ifTrue: [ ^ self value: coord value: amplitude ].\r\tself error: 'Invalid noise function for fBM.'"},{"name":"valueCachedInDisk","linesOfCode":2,"sourceCode":"valueCachedInDisk\r\t^ self valueCachedInDiskWithHash: self closureHashForCaching hex"},{"name":"tempNames","linesOfCode":2,"sourceCode":"tempNames\r\t^ self sourceNode temporaryNames\r"},{"name":"sender","linesOfCode":3,"sourceCode":"sender\r\t\"Answer the context that sent the message that created the receiver.\"\r\r\t^outerContext sender"},{"name":"gpuType:","linesOfCode":2,"sourceCode":"gpuType: aGPUType\r\t^ SGPUBlockClosure for: self withTypeExpression: aGPUType"},{"name":"asPParser","linesOfCode":3,"sourceCode":"asPParser\r\t\"Answer a parser implemented in the receiving one-argument block.\"\r\r\t^ PP2PluggableNode on: self"},{"name":"rfvalue","linesOfCode":7,"sourceCode":"rfvalue\r\t\"same as value, for recursion stopping metalinks\"\r\t<primitive: 201>\r\t<metaLinkOptions: #( + optionDisabledLink)>\r\tnumArgs ~= 0 ifTrue:\r\t\t[self numArgsError: 0].\r\t^self primitiveFailed"},{"name":"durationToRun","linesOfCode":3,"sourceCode":"durationToRun\r\t\"Answer the duration taken to execute this block.\"\r\r\t^ self timeToRun\r\r\r\r"},{"name":"whileNotNil:","linesOfCode":3,"sourceCode":"whileNotNil: aBlock \r\t\"Unlike #whileTrue/False: this is not compiled inline.\"\r\t^ [self value notNil] whileTrue: [aBlock value]\r\t"},{"name":"temporaryVariables","linesOfCode":2,"sourceCode":"temporaryVariables\r\t^self sourceNode temporaries collect: [ :each | each binding ] \r"},{"name":"valueNoContextSwitch","linesOfCode":8,"sourceCode":"valueNoContextSwitch\r\t\"An exact copy of BlockClosure>>value except that this version will not preempt\r\t the current process on block activation if a higher-priority process is runnable.\r\t Primitive. Essential.\"\r\t<primitive: 221>\r\tnumArgs ~= 0 ifTrue:\r\t\t[self numArgsError: 0].\r\tself primitiveFailed"},{"name":"asText","linesOfCode":2,"sourceCode":"asText\r\r\t^ self asString asText"},{"name":"cleanCopy","linesOfCode":5,"sourceCode":"cleanCopy\r\t\"Answer a copy of myself preserving in outerContext just the receiver and method, which are the only needed by a clean block closure.\"\r\r\t^ self shallowCopy\r\t\tcleanOuterContext;\r\t\tyourself"},{"name":"gtFilter","linesOfCode":2,"sourceCode":"gtFilter\r\t^ self "},{"name":"valueWithArguments:","linesOfCode":17,"sourceCode":"valueWithArguments: anArray\r\t\"Activate the receiver, creating a closure activation (MethodContext)\r\t whose closure is the receiver and whose caller is the sender of this message.\r\t Supply the arguments in an anArray and copied values to the activation as its arguments and copied temps.\r\t Primitive. Optional (but you're going to want this for performance).\"\r\t| newContext ncv |\r\t<primitive: 206>\r\tnumArgs ~= anArray size ifTrue:\r\t\t[self numArgsError: anArray size].\r\tnewContext := self asContextWithSender: thisContext sender.\r\tncv := self numCopiedValues.\r\tnewContext stackp: ncv + numArgs.\r\t1 to: numArgs do:\r\t\t[:i| newContext at: i put: (anArray at: i)].\r\t1 to: ncv do:\r\t\t[:i| newContext at: i + numArgs put: (self at: i)].\r\tthisContext privSender: newContext"},{"name":"valueAfterWaiting:","linesOfCode":10,"sourceCode":"valueAfterWaiting: aDelay\r\t\"Waits for a delay, then executes the block. Answers the process so you can terminate it\"\r\t\r\t^ [ aDelay wait. self value ] \r\t\tforkAt: Processor userBackgroundPriority\r\t\tnamed: (String streamContents: [ :s |\r\t\t\t\ts \r\t\t\t\t\t<< 'After ';\r\t\t\t\t\tprint: aDelay;\r\t\t\t\t\t<<' do: ';\r\t\t\t\t\tprint: self ] )"},{"name":"forkNamed:","linesOfCode":4,"sourceCode":"forkNamed: aString\r\r\t\"Create and schedule a Process running the code in the receiver and\r\r\thaving the given name.\"\r\r\r\r\t^ self newProcess name: aString; resume"},{"name":"asTask","linesOfCode":2,"sourceCode":"asTask\r\r\t^ TKTTask valuable: self"},{"name":"ifCurtailed:","linesOfCode":12,"sourceCode":"ifCurtailed: aBlock\r\t\"Evaluate the receiver with an abnormal termination action.\r\t Evaluate aBlock only if execution is unwound during execution\r\t of the receiver.  If execution of the receiver finishes normally do\r\t not evaluate aBlock.  N.B.  This method is *not* implemented as a\r\t primitive.  Primitive 198 always fails.  The VM uses prim 198 in a\r\t context's method as the mark for an ensure:/ifCurtailed: activation.\"\r\t| complete result |\r\t<primitive: 198>\r\tresult := self valueNoContextSwitch.\r\tcomplete := true.\r\t^result"},{"name":"valueUnpreemptively","linesOfCode":16,"sourceCode":"valueUnpreemptively\r\t\"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!\"\r\t\"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that! \r\tAfter you've done all that thinking, go right ahead and use it...\"\r\t| activeProcess oldPriority result semaphore |\r\tactiveProcess := Processor activeProcess.\r\toldPriority := activeProcess priority.\r\tactiveProcess priority: Processor highestPriority.\r\tresult := self ensure: [activeProcess priority: oldPriority].\r\t\r\t\"Yield after restoring priority to give the preempted processes a chance to run.\r\tWe inline the code of Processor yield here, but without the primitive.\r\tThe reason: the yield primitive does not take into account a change of priority as done above\" \r\tsemaphore := Semaphore new.\r\t[semaphore signal] fork.\r\tsemaphore wait.\r\t^result"},{"name":"setConfiguration:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setConfiguration: aString withInMetacelloConfig: aMetacelloConfig\r    aMetacelloConfig setConfiguration: aString withBlock: self"},{"name":"hasMethodReturn","linesOfCode":7,"sourceCode":"hasMethodReturn\r\t\"Answer whether the receiver has a method-return ('^') in its code.\"\r\t| scanner endpc |\r\tscanner := InstructionStream new method: outerContext compiledCode pc: startpc.\r\tendpc := self endPC.\r\tscanner scanFor: [:byte | (outerContext compiledCode encoderClass methodReturnBytecodes includes: byte) or: [scanner pc > endpc]].\r\t^scanner pc <= endpc"},{"name":"brickValue:","linesOfCode":2,"sourceCode":"brickValue: aBrick\r\r\t^ self cull: aBrick"},{"name":"cull:cull:cull:cull:","linesOfCode":5,"sourceCode":"cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg\r\t\"Execute the receiver with four or less arguments. Check cull:cull: for examples\"\r\t\r\t^numArgs < 4 \r\t\tifTrue: [self cull: firstArg cull: secondArg cull: thirdArg]\r\t\tifFalse: [self value: firstArg value: secondArg value: thirdArg value: fourthArg]\r\t"},{"name":"doPrintOn:","linesOfCode":2,"sourceCode":"doPrintOn: aStream\r\taStream nextPutAll: self sourceNode sourceCode "},{"name":"hasDynamicItems","linesOfCode":2,"sourceCode":"hasDynamicItems\r\t^ self numArgs ~= 0"},{"name":"rwValue:","linesOfCode":7,"sourceCode":"rwValue: valueOrArray\r\tself numArgs = 0 ifTrue: [ ^ self value ].  \r\tself numArgs = 1 ifTrue: [ ^ self value: valueOrArray ].\r\t\r\t\"if I have more than 1 argument, then the valueOrArray is a collection\"\r\tvalueOrArray isCollection ifFalse: [ self error: 'A block with more than one argument can only be evaluated with a collection ' ].\r\t\r\tself numArgs = valueOrArray size ifTrue: [ ^ self valueWithArguments: valueOrArray ]. \r\t\r\tself error: 'Incorrect number of arguments'\r"},{"name":"valueWithoutNotifications","linesOfCode":2,"sourceCode":"valueWithoutNotifications \r\t^SystemAnnouncer uniqueInstance suspendAllWhile: self"},{"name":"gtSpotterCodePreviewIn:","linesOfCode":3,"sourceCode":"gtSpotterCodePreviewIn: aComposite\r\t<spotterPreview: 10>\r\r\t^ self sourceNode gtSpotterCodePreviewIn: aComposite"},{"name":"schedule","linesOfCode":2,"sourceCode":"schedule\r\r\t^ self asTask schedule"},{"name":"newProcessWith:","linesOfCode":10,"sourceCode":"newProcessWith: anArray \r\t\"Answer a Process running the code in the receiver. The receiver's block \r\targuments are bound to the contents of the argument, anArray. The \r\tprocess is not scheduled.\"\r\t<primitive: 19> \"Simulation guard\"\r\t^Process\r\t\tforContext: \r\t\t\t[self valueWithArguments: anArray.\r\t\t\tProcessor terminateActive] asContext\r\t\tpriority: Processor activePriority"},{"name":"asJob","linesOfCode":2,"sourceCode":"asJob\r\r\t^ Job block: self"},{"name":"valueSupplyingAnswers:","linesOfCode":24,"sourceCode":"valueSupplyingAnswers: aListOfPairs\r\t\"evaluate the block using a list of questions / answers that might be called upon to\r\tautomatically respond to Object>>confirm: or FillInTheBlank requests\"\r\r\t^ self\r\t\ton: ProvideAnswerNotification\r\t\tdo: [ :notify | \r\t\t\t| caption |\r\t\t\tcaption := notify messageText withSeparatorsCompacted.\t\"to remove new lines\"\r\t\t\taListOfPairs\r\t\t\t\tdetect: [ :each | \r\t\t\t\t\tcaption = each first\r\t\t\t\t\t\tor: [ (caption includesSubstring: each first caseSensitive: false)\r\t\t\t\t\t\t\t\tor: [ (each first match: caption)\r\t\t\t\t\t\t\t\t\t\tor: [ (String includesSelector: #matchesRegex:)\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ [ caption matchesRegex: each first ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\ton: Error\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo: [ :ignored | false ] ] ] ] ] ]\r\t\t\t\tifFound: [ :answer | notify resume: answer second ]\r\t\t\t\tifNone: [ | outerAnswer |\r\t\t\t\t\touterAnswer := ProvideAnswerNotification\r\t\t\t\t\t\tsignal: notify messageText.\r\t\t\t\t\touterAnswer\r\t\t\t\t\t\tifNil: [ notify resume ]\r\t\t\t\t\t\tifNotNil: [ notify resume: outerAnswer ] ] ]"},{"name":"timeToRunWithoutGC","linesOfCode":3,"sourceCode":"timeToRunWithoutGC\r\t\"Answer the number of milliseconds taken to execute this block without GC time.\"\r \r\t^ Smalltalk vm totalGCTime + self timeToRun asMilliSeconds -  Smalltalk vm totalGCTime\r"},{"name":"brickValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"brickValue: anObject withEnoughArguments: aCollection\r\r\t^ self valueWithEnoughArguments:  { anObject }, aCollection"},{"name":"setDescriptionInMetacelloConfig:","linesOfCode":2,"sourceCode":"setDescriptionInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setDescriptionWithBlock: self"},{"name":"isFullBlock","linesOfCode":2,"sourceCode":"isFullBlock\r\r\t^ false"},{"name":"fuelValueWithoutNotifications","linesOfCode":2,"sourceCode":"fuelValueWithoutNotifications\r\tSystemAnnouncer uniqueInstance suspendAllWhile: self"},{"name":"asCharSetPredicate","linesOfCode":2,"sourceCode":"asCharSetPredicate\r\t^ PP2CharSetPredicate on: self"},{"name":"isClean","linesOfCode":7,"sourceCode":"isClean\r\t\"Answer if the receiver does not close-over any variables other than globals, and does\r\t not ^-return (does not close over the home context).  Clean blocks are amenable to\r\t being created at compile-time.\"\r\tself numCopiedValues > 0 ifTrue:\r\t\t[^false].\r\r\t^ CleanBlockChecker check: self method"},{"name":"method","linesOfCode":2,"sourceCode":"method\r\t^outerContext compiledCode"},{"name":"phlowValue:value:","linesOfCode":2,"sourceCode":"phlowValue: anObject value: otherObject\r\r\t^ self cull: anObject cull: otherObject"},{"name":"valueNoContextSwitch:","linesOfCode":8,"sourceCode":"valueNoContextSwitch: anArg\r\t\"An exact copy of BlockClosure>>value: except that this version will not preempt\r\t the current process on block activation if a higher-priority process is runnable.\r\t Primitive. Essential.\"\r\t<primitive: 222>\r\tnumArgs ~= 1 ifTrue:\r\t\t[self numArgsError: 1].\r\tself primitiveFailed"},{"name":"cull:cull:cull:","linesOfCode":4,"sourceCode":"cull: firstArg cull: secondArg cull: thirdArg\r\t^numArgs < 3 \r\t\tifTrue: [self cull: firstArg cull: secondArg]\r\t\tifFalse: [self value: firstArg value: secondArg value: thirdArg]\r\t"},{"name":"ensure:","linesOfCode":13,"sourceCode":"ensure: aBlock\r\t\"Evaluate a termination block after evaluating the receiver, regardless of\r\t whether the receiver's evaluation completes.  N.B.  This method is *not*\r\t implemented as a primitive.  Primitive 198 always fails.  The VM uses prim\r\t 198 in a context's method as the mark for an ensure:/ifCurtailed: activation.\"\r\r\t| complete returnValue |\r\t<primitive: 198>\r\treturnValue := self valueNoContextSwitch.\r\tcomplete ifNil:[\r\t\tcomplete := true.\r\t\taBlock value.\r\t].\r\t^ returnValue"},{"name":"isBlock","linesOfCode":2,"sourceCode":"isBlock\r\r\t^ true"},{"name":"numTemps","linesOfCode":6,"sourceCode":"numTemps\r\t\"Answer the number of temporaries for the receiver; this includes\r\t the number of arguments and the number of copied values.\"\r\t^self numCopiedValues\r\t + self numArgs\r\t + self numLocalTemps"},{"name":"startpc","linesOfCode":2,"sourceCode":"startpc\r\t^startpc"},{"name":"valueSuppressingMessages:","linesOfCode":4,"sourceCode":"valueSuppressingMessages: aListOfStrings\r\r\t^ self\r\t\tvalueSuppressingMessages: aListOfStrings\r\t\tsupplyingAnswers: #()"},{"name":"doWhileTrue:","linesOfCode":6,"sourceCode":"doWhileTrue: conditionBlock\r\t\"Evaluate the receiver once, then again as long the value of conditionBlock is true.\"\r \r\t| result |\r\t[result := self value.\r\tconditionBlock value] whileTrue.\r\r\t^ result"},{"name":"outerContext:startpc:numArgs:copiedValues:","linesOfCode":7,"sourceCode":"outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil\r\touterContext := aContext.\r\tstartpc := aStartpc.\r\tnumArgs := argCount.\r\t1 to: self numCopiedValues do:\r\t\t[:i|\r\t\tself at: i put: (anArrayOrNil at: i)]"},{"name":"bench","linesOfCode":8,"sourceCode":"bench\r\t\"Return how many times the receiver can get executed in 5 seconds. \r\tAnswer a string with meaningful description.\r\tSee #benchFor: which returns a BenchmarkResult\"\r\t\r\t\"[3.14 printString] bench\"\r\t\r\t| benchmarkResult |\r\tbenchmarkResult := self benchFor: 5 seconds.\r\t^ benchmarkResult shortPrintString "},{"name":"abstractBytecodeMessagesDo:","linesOfCode":11,"sourceCode":"abstractBytecodeMessagesDo: aBlock\r\t\"Evaluate aBlock with the sequence of abstract bytecodes in the receiver.\"\r\tself method\r\t\tabstractBytecodeMessagesFrom: startpc\r\t\tto: self endPC\r\t\tdo: aBlock\r\r\t\"| msgs |\r\t msgs := OrderedCollection new.\r\t (SortedCollection sortBlock: [:a :b| a compare: b caseSensitive: false]) sortBlock\r\t\tabstractBytecodeMessagesDo: [:msg| msgs add: msg selector].\r\t msgs\""},{"name":"closureHashForCaching","linesOfCode":2,"sourceCode":"closureHashForCaching\r\t^ SHA256 hashMessage: self closureDescriptionForCaching"},{"name":"forkAt:named:","linesOfCode":9,"sourceCode":"forkAt: priority named: name\r\r\t\"Create and schedule a Process running the code in the receiver at the\r\r\tgiven priority and having the given name. Answer the newly created \r\r\tprocess.\"\r\r\r\r\t| forkedProcess |\r\r\tforkedProcess := self newProcess.\r\r\tforkedProcess priority: priority.\r\r\tforkedProcess name: name.\r\r\t^ forkedProcess resume"},{"name":"outerContext","linesOfCode":2,"sourceCode":"outerContext\r\t^outerContext"},{"name":"setAuthorInMetacelloConfig:","linesOfCode":2,"sourceCode":"setAuthorInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setAuthorWithBlock: self"},{"name":"whileNil:","linesOfCode":3,"sourceCode":"whileNil: aBlock \r\t\"Unlike #whileTrue/False: this is not compiled inline.\"\r\t^ [self value isNil] whileTrue: [aBlock value]\r\t"},{"name":"argumentCount","linesOfCode":3,"sourceCode":"argumentCount\r\t\"Answer the number of arguments that must be used to evaluate this block\"\r\r\t^numArgs\r\t\r"},{"name":"evaluateMatchedPatternElement:","linesOfCode":2,"sourceCode":"evaluateMatchedPatternElement: matchedElement\r\t^ self cull: matchedElement"},{"name":"reentrant","linesOfCode":4,"sourceCode":"reentrant\r\t\"Answer a version of the recever that can be reentered.\r\t Closures are reentrant (unlike BlockContect) so simply answer self.\"\r\t^self"},{"name":"valueSupplyingAnswer:","linesOfCode":4,"sourceCode":"valueSupplyingAnswer: anObject\r\t^ (anObject isCollection and: [anObject isString not])\r\t\tifTrue: [self valueSupplyingAnswers: {anObject}]\r\t\tifFalse: [self valueSupplyingAnswers: {{'*'. anObject}}]"},{"name":"ifError:","linesOfCode":7,"sourceCode":"ifError: errorHandlerBlock\r\r\t\"This method is called with a block expecting description and receiver as arguments\"\r\t\"This method is deprecated in favor of #onErrorDo: that takes the exception object instead of its parts.\"\r\tself deprecated: 'Use #onErrorDo: instead.'.\r\t\t\r\t^ self on: Error do: [:ex |\r\t\terrorHandlerBlock cull: ex description cull: ex receiver ]"},{"name":"generateDastrelFunctionWith:withName:argumentTypes:returnType:","linesOfCode":5,"sourceCode":"generateDastrelFunctionWith: codeConverter withName: requiredName argumentTypes: argumentType returnType: returnType\r\t^ DASLPharoBlockConverter new\r\t\tcodeConverter: codeConverter;\r\t\tfunctionName: requiredName;\r\t\tconvertClosure: self argumentTypes: argumentType returnType: returnType"},{"name":"setBaseline:withInMetacelloConfig:","linesOfCode":2,"sourceCode":"setBaseline: aString withInMetacelloConfig: aMetacelloConfig\r    aMetacelloConfig setBaseline: aString withBlock: self"},{"name":"memoized","linesOfCode":4,"sourceCode":"memoized\r\t\"Returns a memoized version of a one argument block (so values that were\r\t  already calculated will not be computed a second time but returned from a cache).\"\r\t\r\t^ self memoizedUsing:  Dictionary new."},{"name":"value:value:value:","linesOfCode":9,"sourceCode":"value: firstArg value: secondArg value: thirdArg\r\t\"Activate the receiver, creating a closure activation (MethodContext)\r\t whose closure is the receiver and whose caller is the sender of this message.\r\t Supply the arguments and copied values to the activation as its arguments and copied temps.\r\t Primitive. Optional (but you're going to want this for performance).\"\r\t<primitive: 204>\r\tnumArgs ~= 3 ifTrue:\r\t\t[self numArgsError: 3].\r\t^self primitiveFailed"},{"name":"temporaryVariableNamed:","linesOfCode":3,"sourceCode":"temporaryVariableNamed: aName\r\t(self hasTemporaryVariableNamed: aName) ifFalse: [ ^nil ].\r\t^self sourceNode scope lookupVar: aName"},{"name":"benchFor:","linesOfCode":13,"sourceCode":"benchFor: duration\r\t\"Run me for duration and return a BenchmarkResult\"\r\t\r\t\"[ 100 factorial ] benchFor: 2 seconds\"\r\t\r\t| count run started |\r\tcount := 0.\r\trun := true.\r\t[ duration wait. run := false ] forkAt: Processor timingPriority - 1.\r\tstarted := Time millisecondClockValue.\r\t[ run ] whileTrue: [ self value. count := count + 1 ].\r\t^ BenchmarkResult new \r\t\titerations: count; \r\t\telapsedTime: (Time millisecondsSince: started) milliSeconds; \r\t\tyourself"},{"name":"assertWellMaterializedInto:in:","linesOfCode":15,"sourceCode":"assertWellMaterializedInto: aBlockClosure in: aTestCase\r\r\taTestCase assert: self ~~ aBlockClosure.\r\taTestCase assert: self class == aBlockClosure class.\r\taTestCase assert: numArgs = aBlockClosure numArgs.\r\taTestCase assert: startpc = aBlockClosure startpcOrOuterCode.\r\r\touterContext\r\t\tifNil: [ self assert: aBlockClosure outerContext isNil ]\r\t\tifNotNil: [ self isClean\r\t\t\t\tifTrue: [ \"self assert: self receiver = aBlockClosure receiver.\"\r\t\t\t\t\tself assert: ( self method isEqualRegardlessTrailerTo: aBlockClosure method ).\r\t\t\t\t\tself assert: aBlockClosure outerContext sender isNil.\r\t\t\t\t\tself assert: aBlockClosure outerContext arguments isEmpty\r\t\t\t\t\t]\r\t\t\t\tifFalse: [ outerContext assertWellMaterializedInto: aBlockClosure outerContext in: aTestCase ]\r\t\t\t]"},{"name":"startpcOrOuterCode","linesOfCode":2,"sourceCode":"startpcOrOuterCode\r\t^ startpc "},{"name":"asRWElementBehavior","linesOfCode":2,"sourceCode":"asRWElementBehavior\r\t^ RWBlockBehavior new block: self"},{"name":"onErrorDo:","linesOfCode":9,"sourceCode":"onErrorDo: errorHandlerBlock\r\t\"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero or one parameter (the error object).\"\r\t\"Examples:\r\t\t[1 whatsUpDoc] onErrorDo: [:err | 'huh?'].\r\t\t[1 / 0] onErrorDo: [:err |\r\t\t\tZeroDivide = err class\r\t\t\t\tifTrue: [Float infinity]\r\t\t\t\tifFalse: [self error: err]]\r\"\r\r\t^ self on: Error do: [:ex | errorHandlerBlock cull: ex]"},{"name":"cull:cull:","linesOfCode":11,"sourceCode":"cull: firstArg cull: secondArg\r\t\"Execute the receiver with one or two arguments depending on the receiver\"\r\t\"([:x | x + 1] cull: 13 cull: 12)\r\t>>> 14\r\t\"\r\t\"([:x :y | x + y] cull: 3 cull: 2)\r\t>>> 5\r\t\"\r\t^numArgs < 2 \r\t\tifTrue: [self cull: firstArg]\r\t\tifFalse: [self value: firstArg value: secondArg]\r\t"},{"name":"closureDescriptionForCaching","linesOfCode":11,"sourceCode":"closureDescriptionForCaching\r\t^ ByteString streamContents: [ :out |\r\t\tout nextPut: $[.\r\t\tout nextPutAll: self method sourceCode; cr.\r\t\tout nextPut: $|.\r\t\t1 to: self numCopiedValues do: [ :i |\r\t\t\tout nextPutAll: (self copiedValueAt: i) closureDescriptionForCaching\r\t\t].\r\t\tout nextPut: $|.\r\t\tout nextPut: $].\r\t]"},{"name":"onDNU:do:","linesOfCode":7,"sourceCode":"onDNU: selector do: handleBlock\r\t\"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)\"\r\r\t^ self on: MessageNotUnderstood do: [:exception |\r\t\texception message selector = selector\r\t\t\tifTrue: [handleBlock cull: exception]\r\t\t\tifFalse: [exception pass]\r\t  ]"},{"name":"value","linesOfCode":9,"sourceCode":"value\r\t\"Activate the receiver, creating a closure activation (MethodContext)\r\t whose closure is the receiver and whose caller is the sender of this message.\r\t Supply the copied values to the activation as its arguments and copied temps.\r\t Primitive. Optional (but you're going to want this for performance).\"\r\t<primitive: 201>\r\tnumArgs ~= 0 ifTrue:\r\t\t[self numArgsError: 0].\r\t^self primitiveFailed"},{"name":"whileTrue:","linesOfCode":6,"sourceCode":"whileTrue: aBlock \r\t\"Ordinarily compiled in-line, and therefore not overridable.\r\tThis is in case the message is sent to other than a literal block.\r\tEvaluate the argument, aBlock, as long as the value of the receiver is true.\"\r\r\tself value ifTrue: [ aBlock value. self whileTrue: aBlock ].\r\t^ nil"},{"name":"setTimestampInMetacelloConfig:","linesOfCode":2,"sourceCode":"setTimestampInMetacelloConfig: aMetacelloConfig\r\r\taMetacelloConfig setTimestampWithBlock: self"},{"name":"receiver","linesOfCode":2,"sourceCode":"receiver\r\t^outerContext receiver"}],"meta":{"name":"BlockClosure class","instanceVariables":[],"methods":[{"name":"outerContext:startpc:numArgs:copiedValues:","linesOfCode":6,"sourceCode":"outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil\r\t^(self new: anArrayOrNil basicSize)\r\t\touterContext: aContext\r\t\tstartpc: aStartpc\r\t\tnumArgs: argCount\r\t\tcopiedValues: anArrayOrNil"}],"meta":null}},{"name":"CollectionsAssembly","instanceVariables":[],"methods":[],"meta":{"name":"CollectionsAssembly class","instanceVariables":[],"methods":[{"name":"version","linesOfCode":2,"sourceCode":"version\r\t^ '1.0-dev'"},{"name":"description","linesOfCode":2,"sourceCode":"description\r\t^ 'I contain all basic collections.'"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #Collections"},{"name":"parts","linesOfCode":12,"sourceCode":"parts\r\t^ {#'Collections-Abstract' -> #().\r\t#'Collections-Arithmetic' -> #().\r\t#'Collections-Atomic' -> #().\r\t#'Collections-Native' -> #().\r\t#'Collections-Sequenceable' -> #().\r\t#'Collections-Stack' -> #().\r\t#'Collections-Streams' -> #().\r\t#'Collections-Strings' -> #().\r\t#'Collections-Support' -> #().\r\t#'Collections-Unordered' -> #().\r\t#'Collections-Weak' -> #()}"}],"meta":null}},{"name":"CompiledMethod class","instanceVariables":[],"methods":[{"name":"methodPropertiesClass","linesOfCode":6,"sourceCode":"methodPropertiesClass\r\t\"Answer the class to use to create a method's properties, which can be a poor man's way\r\t to add instance variables to subclassses of CompiledMethod.  Subclasses of CompiledMethod\r\t should define a corresponding subclass of AdditionalMethodState that adds any instance variables\r\t required, and override this method to answer that class.\"\r\t^AdditionalMethodState"},{"name":"explicitRequirementMarker","linesOfCode":2,"sourceCode":"explicitRequirementMarker\r\t^ #explicitRequirement"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeCompiledMethodInspector"},{"name":"basicNew:","linesOfCode":2,"sourceCode":"basicNew: size\r\r\tself error: 'CompiledMethods may only be created with newMethod:header:' "},{"name":"basicNew","linesOfCode":2,"sourceCode":"basicNew\r\r\tself error: 'CompiledMethods may only be created with newMethod:header:' "},{"name":"headerFlagForEncoder:","linesOfCode":4,"sourceCode":"headerFlagForEncoder: anEncoderClass\r\tanEncoderClass == PrimaryBytecodeSetEncoderClass ifTrue: [ ^ 0 ].\r\tanEncoderClass == SecondaryBytecodeSetEncoderClass ifTrue: [ ^ SmallInteger minVal ].\r\tself error: 'The encoder is not one of the two installed bytecode sets'"},{"name":"primitive:numArgs:numTemps:stackSize:literals:bytecodes:trailer:","linesOfCode":17,"sourceCode":"primitive: primNum numArgs: numArgs numTemps: numTemps stackSize: stackSize literals: literals bytecodes: bytecodes trailer: trailerBytes\r\t\"Create method with given attributes.  numTemps includes numArgs.  stackSize does not include numTemps.\"\r\r\t| compiledMethod |\r\tcompiledMethod := self\r\t\tnewBytes: bytecodes size\r\t\ttrailerBytes: trailerBytes \r\t\tnArgs: numArgs\r\t\tnTemps: numTemps\r\t\tnStack: 0\r\t\tnLits: literals size\r\t\tprimitive: primNum.\r\t(WriteStream with: compiledMethod)\r\t\tposition: compiledMethod initialPC - 1;\r\t\tnextPutAll: bytecodes.\r\tliterals withIndexDo: [:obj :i | compiledMethod literalAt: i put: obj].\r\tcompiledMethod needsFrameSize: stackSize.\r\t^ compiledMethod"},{"name":"smallFrameSize","linesOfCode":2,"sourceCode":"smallFrameSize\r\r\t^ SmallFrame"},{"name":"newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:flag:","linesOfCode":26,"sourceCode":"newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex flag: flag\r\t\"Answer an instance of me. The header is specified by the message \r\t arguments. The remaining parts are not as yet determined.\"\r\t| method pc |\r\tnArgs > 15 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many arguments'].\r\tnTemps > 63 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many temporary variables'].\t\r\tnLits > 65535 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many literals'].\r\r\tmethod := trailer\r\t\t\t\tcreateMethod: numberOfBytes\r\t\t\t\tclass: self\r\t\t\t\theader:    (nArgs bitShift: 24)\r\t\t\t\t\t\t+ (nTemps bitShift: 18)\r\t\t\t\t\t\t+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])\r\t\t\t\t\t\t+ nLits\r\t\t\t\t\t\t+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])\r\t\t\t\t\t\t+ (flag ifTrue: [1 bitShift: 29] ifFalse: [0]).\r\tprimitiveIndex > 0 ifTrue:\r\t\t[pc := method initialPC.\r\t\t method\r\t\t\tat: pc + 0 put: method encoderClass callPrimitiveCode;\r\t\t\tat: pc + 1 put: (primitiveIndex bitAnd: 16rFF);\r\t\t\tat: pc + 2 put: (primitiveIndex bitShift: -8)].\r\t^method"},{"name":"cleanUpSourceInTrailers","linesOfCode":4,"sourceCode":"cleanUpSourceInTrailers\r\r\tself allInstances do: [:e | e isInstalled ifFalse: [e embeddSourceInTrailer]].  \r\t\"pay attention since embeddSourceInTrailer creates a new compiled method. So iterating while\r\tchanging it is a bad idea. This is why we use allInstances do and not allInstancesDo:\""},{"name":"newBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:","linesOfCode":25,"sourceCode":"newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex\r\t\"Answer an instance of me. The header is specified by the message \r\t arguments. The remaining parts are not as yet determined.\"\r\t| method pc |\r\tnArgs > 15 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many arguments'].\r\tnTemps > 63 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many temporary variables'].\t\r\tnLits > 65535 ifTrue:\r\t\t[^self error: 'Cannot compile -- too many literals'].\r\r\tmethod := trailer\r\t\t\t\tcreateMethod: numberOfBytes\r\t\t\t\tclass: self\r\t\t\t\theader:    (nArgs bitShift: 24)\r\t\t\t\t\t\t+ (nTemps bitShift: 18)\r\t\t\t\t\t\t+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])\r\t\t\t\t\t\t+ nLits\r\t\t\t\t\t\t+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).\r\tprimitiveIndex > 0 ifTrue:\r\t\t[pc := method initialPC.\r\t\t method\r\t\t\tat: pc + 0 put: method encoderClass callPrimitiveCode;\r\t\t\tat: pc + 1 put: (primitiveIndex bitAnd: 16rFF);\r\t\t\tat: pc + 2 put: (primitiveIndex bitShift: -8)].\r\t^method"},{"name":"toReturnSelf","linesOfCode":3,"sourceCode":"toReturnSelf\r\t\"Answer an instance of me that is a quick return of the instance (^self).\"\r\r\t^ self toReturnSelfTrailerBytes: CompiledMethodTrailer empty"},{"name":"subclassResponsibilityMarker","linesOfCode":2,"sourceCode":"subclassResponsibilityMarker\r\t^ #subclassResponsibility"},{"name":"conflictMarker","linesOfCode":2,"sourceCode":"conflictMarker\r\t^ #traitConflict"},{"name":"sortBlock","linesOfCode":6,"sourceCode":"sortBlock\r\t\"Return a sort block that orders methods by class name and then by selector\"\r\t^  [ :a :b| \r\t\t\ta methodClass = b methodClass\r\t\t\t\tifTrue: [ a selector <= b selector ]\r\t\t\t\tifFalse: [ a methodClass name <= b methodClass name ]]"},{"name":"newFrom:","linesOfCode":6,"sourceCode":"newFrom: aCompiledMethod\r\t| inst |\r\tinst := super basicNew: aCompiledMethod size.\r\t1 to: aCompiledMethod size do: [:index |\r\t\tinst at: index put: (aCompiledMethod at: index)].\r\t^ inst."},{"name":"toReturnSelfTrailerBytes:","linesOfCode":3,"sourceCode":"toReturnSelfTrailerBytes: trailer\r\t\"Answer an instance of me that is a quick return of the instance (^self).\"\r\r\t^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256"},{"name":"checkBytecodeSetConflictsInMethodsWith:","linesOfCode":4,"sourceCode":"checkBytecodeSetConflictsInMethodsWith: aBlock\r\r\tself allSubInstances\r\t\tdetect: aBlock\r\t\tifFound: [ Warning signal: 'There are existing CompiledMethods with a different encoderClass.' ]"},{"name":"installPrimaryBytecodeSet:","linesOfCode":7,"sourceCode":"installPrimaryBytecodeSet: aBytecodeEncoderSubclass\r\tPrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:\r\t\t[ ^self ].\r\tself checkIsValidBytecodeEncoder: aBytecodeEncoderSubclass.\r\tself checkBytecodeSetConflictsInMethodsWith: [:m| \r\t\tm usesPrimaryBytecodeSet and: [m encoderClass ~~ aBytecodeEncoderSubclass]].\r\tPrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass"},{"name":"installSecondaryBytecodeSet:","linesOfCode":7,"sourceCode":"installSecondaryBytecodeSet: aBytecodeEncoderSubclass\r\tPrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:\r\t\t[ ^ self ].\r\tself checkIsValidBytecodeEncoder: aBytecodeEncoderSubclass.\r\tself checkBytecodeSetConflictsInMethodsWith: [ :m | \r\t\tm usesSecondaryBytecodeSet and: [ m encoderClass ~~ aBytecodeEncoderSubclass ] ].\r\tSecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass"},{"name":"initialize","linesOfCode":7,"sourceCode":"initialize    \"CompiledMethod initialize\"\r\t\"Initialize class variables specifying the size of the temporary frame\r\tneeded to run instances of me.\"\r\r\tSmallFrame := 16.\t\"Context range for temps+stack\"\r\tLargeFrame := 56.\r\tPrimaryBytecodeSetEncoderClass := EncoderForV3PlusClosures.\r\tSecondaryBytecodeSetEncoderClass := EncoderForSistaV1"},{"name":"new","linesOfCode":4,"sourceCode":"new\r\t\"This will not make a meaningful method, but it could be used\r\tto invoke some otherwise useful method in this class.\"\r\t^self newMethod: 2 header: 1024"},{"name":"disabledMarker","linesOfCode":2,"sourceCode":"disabledMarker\r\t^ #shouldNotImplement"},{"name":"toReturnField:trailerBytes:","linesOfCode":4,"sourceCode":"toReturnField: field trailerBytes: trailer\r\t\"Answer an instance of me that is a quick return of the instance variable \r\tindexed by the argument, field.\"\r\r\t^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 264 + field"},{"name":"abstractMarker","linesOfCode":2,"sourceCode":"abstractMarker\r\t^ #subclassResponsibility"},{"name":"handleFailingNewMethod:header:","linesOfCode":19,"sourceCode":"handleFailingNewMethod: numberOfBytes header: headerWord\r\t\"This newMethod:header: gets sent after newMethod:header: has failed\r\t and allowed a scavenging garbage collection to occur.  The scavenging\r\t collection will have happened as the VM is activating the (failing) basicNew:.\r\t If handleFailingBasicNew: fails then the scavenge failed to reclaim sufficient\r\t space and a global garbage collection is required.  Retry after garbage\r\t collecting and growing memory if necessary.\r\r\t Primitive. Answer an instance of this class with the number of indexable variables\r\t specified by the argument, headerWord, and the number of bytecodes specified\r\t by numberOfBytes.  Fail if this if the arguments are not Integers, or if numberOfBytes\r\t is negative, or if the receiver is not a CompiledMethod class, or if there is not enough\r\t memory available. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 79>\r\t| bytesRequested |\r\tbytesRequested := (headerWord bitAnd: 16rFFFF) + 1 * Smalltalk wordSize + numberOfBytes + 16.\r\tSmalltalk garbageCollect < bytesRequested ifTrue:\r\t\t[Smalltalk growMemoryByAtLeast: bytesRequested].\r\t\"retry after global garbage collect and possible grow\"\r\t^self handleFailingFailingNewMethod: numberOfBytes header: headerWord"},{"name":"toReturnConstant:trailerBytes:","linesOfCode":4,"sourceCode":"toReturnConstant: index trailerBytes: trailer\r\t\"Answer an instance of me that is a quick return of the constant\r\tindexed in (true false nil -1 0 1 2).\"\r\r\t^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256 + index"},{"name":"fullFrameSize","linesOfCode":2,"sourceCode":"fullFrameSize  \"CompiledMethod fullFrameSize\"\r\t^ LargeFrame"},{"name":"checkIsValidBytecodeEncoder:","linesOfCode":3,"sourceCode":"checkIsValidBytecodeEncoder: aBytecodeEncoderSubclass\r\t(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:\r\t\t[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder']."},{"name":"handleFailingFailingNewMethod:header:","linesOfCode":14,"sourceCode":"handleFailingFailingNewMethod: numberOfBytes header: headerWord\r\t\"This newMethod:header: gets sent after handleFailingBasicNew: has done a full\r\t garbage collection and possibly grown memory.  If this basicNew: fails then the\r\t system really is low on space, so raise the OutOfMemory signal.\r\r\t Primitive. Answer an instance of this class with the number of indexable variables\r\t specified by the argument, headerWord, and the number of bytecodes specified\r\t by numberOfBytes.  Fail if this if the arguments are not Integers, or if numberOfBytes\r\t is negative, or if the receiver is not a CompiledMethod class, or if there is not enough\r\t memory available. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 79>\r\t\"space must be low.\"\r\tOutOfMemory signal.\r\t\"retry if user proceeds\"\r\t^self newMethod: numberOfBytes header: headerWord"},{"name":"newInstanceFrom:variable:size:map:","linesOfCode":11,"sourceCode":"newInstanceFrom: oldInstance variable: variable size: instSize map: map\r\t\"Create a new instance of the receiver based on the given old instance.\r\tThe supplied map contains a mapping of the old instVar names into\r\tthe receiver's instVars\"\r\t| new |\r\tnew := self newFrom: oldInstance.\r\t1 to: instSize do: \r\t\t[:offset |  (map at: offset) > 0 ifTrue:\r\t\t\t[new instVarAt: offset\r\t\t\t\t\tput: (oldInstance instVarAt: (map at: offset))]].\r\t^new"}],"meta":null},{"name":"SizeMismatch","instanceVariables":[],"methods":[{"name":"messageText","linesOfCode":3,"sourceCode":"messageText\r\t\"Overwritten to initialiaze the message text to a standard text if it has not yet been set\"\r\t\r\t^ messageText ifNil: [ messageText := self standardMessageText ]"},{"name":"standardMessageText","linesOfCode":3,"sourceCode":"standardMessageText\r\t\"Generate a standard textual description\"\r\t\r\t^ 'Collections sizes do not match'"}],"meta":{"name":"SizeMismatch class","instanceVariables":[],"methods":[],"meta":null}},{"name":"Object","instanceVariables":[],"methods":[{"name":"storeString","linesOfCode":4,"sourceCode":"storeString\r\t\"Answer a String representation of the receiver from which the receiver \r\tcan be reconstructed.\"\r\r\t^ String streamContents: [:s | self storeOn: s]"},{"name":"asWeakReference","linesOfCode":4,"sourceCode":"asWeakReference\r\t^ (WeakArray new: 1)\r\t\tat: 1 put: self;\r\t\tyourself"},{"name":"printString","linesOfCode":4,"sourceCode":"printString\r\t\"Answer a String whose characters are a description of the receiver. \r\tIf you want to print without a character limit, use fullPrintString.\"\r\r\t^ self printStringLimitedTo: 50000"},{"name":"hasActionForEvent:","linesOfCode":3,"sourceCode":"hasActionForEvent: anEventSelector\r    \"Answer true if there is an action associated with anEventSelector\"\r\r    ^(self actionForEvent: anEventSelector) notNil"},{"name":"closeTo:","linesOfCode":3,"sourceCode":"closeTo: anObject\r\t\"Do not use this Method! It is a workaround for MethodFinder\"\r\r\t^[self = anObject] onErrorDo: [false]"},{"name":"gtListFilter","linesOfCode":2,"sourceCode":"gtListFilter\r\t^ GTFilterSubstring new"},{"name":"assert:description:","linesOfCode":5,"sourceCode":"assert: aBlock description: aStringOrBlock\r\t\"Throw an assertion error if aBlock does not evaluates to true.\"\r\t<debuggerCompleteToSender>\r\taBlock value \r\t\tifFalse: [ AssertionFailure signal: aStringOrBlock value ]"},{"name":"gtDebuggerSUnitPrint","linesOfCode":3,"sourceCode":"gtDebuggerSUnitPrint\r\t\"I return a textual representation of the object that is used by the SUnit debugger to compare objects using a textual diff.\"\r\t\r\t^ self printString"},{"name":"isReadOnlyObject","linesOfCode":9,"sourceCode":"isReadOnlyObject\r\t\"Answer if the receiver is read-only.\r\t If the VM supports read-only objects it will not write to read-only objects.\r\t An attempt to write to an instance variable of a read-only object will\r\t cause the VM to send attemptToAssign:withIndex: to the read-only object.\r\t An attempt to modify a read-only object in a primitive will cause the\r\t primitive to fail with a #'no modification' error code.\"\r\t<primitive: 163 error: ec>\r\t^self isImmediateObject"},{"name":"perform:with:with:","linesOfCode":6,"sourceCode":"perform: aSymbol with: firstObject with: secondObject \r\t\"Send the selector, aSymbol, to the receiver with the given arguments.\r\tFail if the number of arguments expected by the selector is not two.\r\tPrimitive. Optional. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 83>\r\t^ self perform: aSymbol withArguments: {firstObject . secondObject}"},{"name":"removeActionsWithReceiver:forEvent:","linesOfCode":7,"sourceCode":"removeActionsWithReceiver: anObject\rforEvent: anEventSelector\r\r    self\r        removeActionsSatisfying:\r            [:anAction |\r            anAction receiver == anObject]\r        forEvent: anEventSelector"},{"name":"setActionSequence:forEvent:","linesOfCode":11,"sourceCode":"setActionSequence: actionSequence\rforEvent: anEventSelector\r\r    | action |\r    action := actionSequence asMinimalRepresentation.\r    action \r\t  ifNil:\r            [self removeActionsForEvent: anEventSelector]\r        ifNotNil:\r            [self updateableActionMap\r                at: anEventSelector asSymbol\r                put: action]"},{"name":"errorImproperStore","linesOfCode":3,"sourceCode":"errorImproperStore\r\t\"Create an error notification that an improper store was attempted.\"\r\r\tself error: 'Improper store into indexable object'"},{"name":"inspector","linesOfCode":2,"sourceCode":"inspector\r\t^ Smalltalk tools inspector inspector: self"},{"name":"defaultObjectInspectorClass","linesOfCode":2,"sourceCode":"defaultObjectInspectorClass\r\r\t^ StObjectInspectorPresenter"},{"name":"putOn:","linesOfCode":5,"sourceCode":"putOn: aStream\r\t\"Write the receiver onto aStream.\r\tIn general we assume aStream accepts the receiver as element type.\r\tReturn self.\"\r\t\r\taStream nextPut: self"},{"name":"isDictionary","linesOfCode":2,"sourceCode":"isDictionary\r\t^false"},{"name":"split:indicesDo:","linesOfCode":17,"sourceCode":"split: aSequenceableCollection indicesDo: aBlock\r\t\"Perform an action specified as aBlock (with a start and end argument) to each of the indices of the receiver element that have been identified by splitting the receiver using the splitter argument. optimized version for single delimiters.\"\r\t\r\t\"(String streamContents: [:s | Character space split: 'Pharo is cool'  indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:5 s:7 e:8 s:10 e:13 '\"\r\t\t\r\t\t\r\t\t\r\t|  position oldPosition |\r\t\r\tposition := 1.\r\toldPosition := position.\r\t\r\tposition := aSequenceableCollection indexOf: self startingAt: position.\r\t[ position > 0 ] whileTrue: [\r\t\taBlock value: oldPosition value: position - 1.\r\t\tposition := position + 1.\r\t\toldPosition := position.\r\t\tposition := aSequenceableCollection indexOf: self startingAt: position.\r\t].\r\r\taBlock value: oldPosition value: aSequenceableCollection size.\r"},{"name":"storeAt:inTempFrame:","linesOfCode":5,"sourceCode":"storeAt: offset inTempFrame: aContext\r\t\"This message had to get sent to an expression already on the stack\r\tas a Block argument being accessed by the debugger.\r\tJust re-route it to the temp frame.\"\r\t^ aContext tempAt: offset put: self"},{"name":"caseOf:","linesOfCode":11,"sourceCode":"caseOf: aBlockAssociationCollection\r\t\"DO NOT USE THIS METHOD! It will be removed from Pharo.\"\r\r\t\"The elements of aBlockAssociationCollection are associations between blocks.\r\t Answer the evaluated value of the first association in aBlockAssociationCollection\r\t whose evaluated key equals the receiver.  If no match is found, report an error.\"\r\r\t^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]\r\r\"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z\"\r\"| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z\"\r\"The following are compiled in-line:\"\r\"#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}\"\r\"#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}\""},{"name":"deprecated:on:in:transformWith:when:","linesOfCode":11,"sourceCode":"deprecated: anExplanationString on: date in: version transformWith: aRule when: conditionBlock\r\t\"Automatically tranform the deprecated call if it matches the condition\"\r\t\r\tDeprecation new\r\t\tcontext: thisContext sender;\r\t\texplanation: anExplanationString;\r\t\tdate: date;\r\t\tversion: version;\r\t\trule: aRule;\r\t\tcondition: conditionBlock;\r\t\ttransform.\r\t\t"},{"name":"stDisplayString","linesOfCode":5,"sourceCode":"stDisplayString\r\r\t[ self gtDisplayString linesDo: [ :each | ^ each contractTo: 200 ] ]\r\t\ton: Error\r\t\tdo: [ :err | ^ err stDisplayString ].\r\r\t^ ''"},{"name":"fullPrintString","linesOfCode":3,"sourceCode":"fullPrintString\r\t\"Answer a String whose characters are a description of the receiver.\"\r\r\t^ String streamContents: [:s | self printOn: s]"},{"name":"taskbarLabel","linesOfCode":4,"sourceCode":"taskbarLabel\r\t\"Answer the label string for the receiver in a task bar\r\tor nil for the default.\"\r\r\t^self class taskbarLabel"},{"name":"isPrimitiveError","linesOfCode":3,"sourceCode":"isPrimitiveError\r\t\"Answer a boolean indicating if the receiver is an error object returned by a primitive\"\r\t^false"},{"name":"isCompiledMethod","linesOfCode":2,"sourceCode":"isCompiledMethod\r\r\t^ false"},{"name":"valueForLinearInterpolation","linesOfCode":2,"sourceCode":"valueForLinearInterpolation\r\t^ self"},{"name":"actionForEvent:ifAbsent:","linesOfCode":9,"sourceCode":"actionForEvent: anEventSelector\rifAbsent: anExceptionBlock\r    \"Answer the action to be evaluated when <anEventSelector> has been triggered.\"\r\r\t| actions |\r\tactions := self actionMap\r\t\tat: anEventSelector asSymbol\r\t\tifAbsent: [nil].\r\tactions ifNil: [^anExceptionBlock value].\r\t^ actions asMinimalRepresentation"},{"name":"errorNonIntegerIndex","linesOfCode":3,"sourceCode":"errorNonIntegerIndex\r\t\"Create an error notification that an improper object was used as an index.\"\r\r\tself error: 'only integers should be used as indices'"},{"name":"asMorph","linesOfCode":3,"sourceCode":"asMorph\r\t\"Open a morph, as best one can, on the receiver\"\r\r\t^ self asStringMorph \r"},{"name":"link:toAST:","linesOfCode":2,"sourceCode":"link: aMetaLink toAST: aNode\r\taNode link: aMetaLink forObject: self"},{"name":"intanceSpecificMetaLinksAvailable","linesOfCode":2,"sourceCode":"intanceSpecificMetaLinksAvailable\r\t^true"},{"name":"okToClose","linesOfCode":4,"sourceCode":"okToClose\r\t\"Sent to models when a window closing.\r\tAllows this check to be independent of okToChange.\"\r\t\r\t^true"},{"name":"traitConflict","linesOfCode":2,"sourceCode":"traitConflict\r\tself error: 'A class or trait does not properly resolve a conflict between multiple traits it uses.'"},{"name":"link:toClassVariableNamed:option:","linesOfCode":6,"sourceCode":"link: aMetaLink toClassVariableNamed: aClassVariableName option: option\r\taMetaLink\r\t\tinstallOnVariableNamed: aClassVariableName\r\t\tfor: self\r\t\toption: option\r\t\tinstanceSpecific: self intanceSpecificMetaLinksAvailable"},{"name":"addWodenResourceDependant:","linesOfCode":1,"sourceCode":"addWodenResourceDependant: dependant"},{"name":"subclassResponsibility","linesOfCode":5,"sourceCode":"subclassResponsibility\r\t\"This message sets up a framework for the behavior of the class' subclasses.\r\tAnnounce that the subclass should have implemented this message.\"\r\t<debuggerCompleteToSender>\r\tSubclassResponsibility signalFor: thisContext sender selector"},{"name":"link:toSlotNamed:","linesOfCode":2,"sourceCode":"link: aMetaLink toSlotNamed: aSlotName\r\tself link: aMetaLink toSlotNamed: aSlotName option: #all"},{"name":"isAnnouncingObject","linesOfCode":2,"sourceCode":"isAnnouncingObject\r\r\t^ false"},{"name":"errorNotIndexable","linesOfCode":3,"sourceCode":"errorNotIndexable\r\t\"Create an error notification that the receiver is not indexable.\"\r\r\tself error: ('Instances of {1} are not indexable' format: {self class name})"},{"name":"inspectionBreakpoints","linesOfCode":3,"sourceCode":"inspectionBreakpoints\r\t<inspectorPresentationOrder: 998 title: 'Breakpoints'>\r\r\t^ StObjectBreakpointInspection on: self"},{"name":"isMbndType","linesOfCode":2,"sourceCode":"isMbndType\r\t^ false"},{"name":"stInspect","linesOfCode":3,"sourceCode":"stInspect\r\t\"Temporary to experiment, should be replaced by inspect later\"\r\r\t^ StInspector inspect: self"},{"name":"primitiveChangeClassTo:","linesOfCode":8,"sourceCode":"primitiveChangeClassTo: anObject\r\t\"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.\r\tNote: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).\r\tThe facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use.\"\r\r\t<primitive: 115>\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #primitiveChangeClassTo: value: anObject ]. \r\tself primitiveFailed"},{"name":"caseError","linesOfCode":4,"sourceCode":"caseError\r\t\"DO NOT USE THIS METHOD! It will be removed from Pharo.\"\r\t\"Report an error from an in-line or explicit case statement.\"\r\r\tself error: 'Case not found (', self printString, '), and no otherwise clause'"},{"name":"trace:","linesOfCode":3,"sourceCode":"trace: anObject\r\t\"Log the argument. Use self trace: instead of Transcript show: \"\r\t\r\tTranscript show: anObject asString"},{"name":"asScriptResultStringInCalypso","linesOfCode":2,"sourceCode":"asScriptResultStringInCalypso\r\t^self printString"},{"name":"finalize","linesOfCode":2,"sourceCode":"finalize\r\t\"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority.\""},{"name":"stepIn:","linesOfCode":2,"sourceCode":"stepIn: aWindow\r\r\t^ self step"},{"name":"asInspectorModel","linesOfCode":2,"sourceCode":"asInspectorModel\r\r\t^ StInspectorModel on: self"},{"name":"isText","linesOfCode":2,"sourceCode":"isText\r\t^ false"},{"name":"bindingOf:","linesOfCode":2,"sourceCode":"bindingOf: aString\r\t^nil"},{"name":"wbtEvaluateSubstitutionVariableInEnvironment:","linesOfCode":2,"sourceCode":"wbtEvaluateSubstitutionVariableInEnvironment: evaluationEnvironment\r\t^ self"},{"name":"isThisEverCalled","linesOfCode":2,"sourceCode":"isThisEverCalled\r\t^ self isThisEverCalled: thisContext sender printString"},{"name":"when:send:to:withArguments:","linesOfCode":10,"sourceCode":"when: anEventSelector\rsend: aMessageSelector\rto: anObject\rwithArguments: anArgArray\r \r    self\r        when: anEventSelector\r        evaluate: (WeakMessageSend\r            receiver: anObject\r            selector: aMessageSelector\r\t\targuments: anArgArray)"},{"name":"deprecated:transformWith:","linesOfCode":8,"sourceCode":"deprecated: anExplanationString transformWith: aRule\r\t\"Automatically tranform the deprecated call\"\r\t\r\tDeprecation new\r\t\tcontext: thisContext sender;\r\t\texplanation: anExplanationString;\r\t\trule: aRule;\r\t\ttransform.\r\t\t"},{"name":"flattenOn:","linesOfCode":2,"sourceCode":"flattenOn: aStream\r\t\taStream nextPut: self"},{"name":"printSystemPath","linesOfCode":2,"sourceCode":"printSystemPath\r\r\t^self calypsoEnvironmentType printSystemPathTo: self "},{"name":"perform:orSendTo:","linesOfCode":3,"sourceCode":"perform: selector orSendTo: otherTarget\r\t\"If I wish to intercept and handle selector myself, do it; else send it to otherTarget\"\r\t^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]"},{"name":"traceCr","linesOfCode":2,"sourceCode":"traceCr\r\tself traceCr: self"},{"name":"=","linesOfCode":5,"sourceCode":"= anObject \r\t\"Answer whether the receiver and the argument represent the same \r\tobject. If = is redefined in any subclass, consider also redefining the \r\tmessage hash.\"\r\r\t^self == anObject "},{"name":"browseHierarchy","linesOfCode":2,"sourceCode":"browseHierarchy\r\r\tself systemNavigation browseHierarchy: self class"},{"name":"pin","linesOfCode":6,"sourceCode":"pin\r\t\"self\r\t\tdeprecated: 'Please use #pinInMemory instead'\r\t\ttransformWith: '`@receiver pin' -> '`@receiver pinInMemory'.\"\r\t\t\r\tself pinInMemory"},{"name":"acceptSettings:","linesOfCode":2,"sourceCode":"acceptSettings: aVisitor \r\t^ aVisitor visitObject: self"},{"name":"hasLiteralSuchThat:","linesOfCode":3,"sourceCode":"hasLiteralSuchThat: testBlock\r\t\"This is the end of the imbedded structure path so return false.\"\r\r\t^ false"},{"name":"inspectionBreakpointsContext:","linesOfCode":2,"sourceCode":"inspectionBreakpointsContext: aContext\r\r\taContext withoutEvaluator"},{"name":"inspectionMetaContext:","linesOfCode":2,"sourceCode":"inspectionMetaContext: aContext\r\r\taContext withoutEvaluator"},{"name":"asCollectionElement","linesOfCode":4,"sourceCode":"asCollectionElement\r\t\"Answer an object, which can be put into a Set as element , wrapped\r\tby one of SetElement instance, if necessary. \r\tDefault implementation is to answer self\"\r"},{"name":"currentEvent","linesOfCode":3,"sourceCode":"currentEvent\r\t\"Answer the current Morphic event.  This method never returns nil.\"\r\t^ self currentHand lastEvent"},{"name":"perform:withArguments:","linesOfCode":7,"sourceCode":"perform: selector withArguments: argArray \r\t\"Send the selector, aSymbol, to the receiver with arguments in argArray.\r\tFail if the number of arguments expected by the selector \r\tdoes not match the size of argArray.\r\tPrimitive. Optional. See Object documentation whatIsAPrimitive.\"\r\t\r\t<primitive: 84>\r\t^ self perform: selector withArguments: argArray inSuperclass: self class"},{"name":"isPetit2Parser","linesOfCode":2,"sourceCode":"isPetit2Parser\r\t^ false"},{"name":"unpinInMemory","linesOfCode":6,"sourceCode":"unpinInMemory\r\t\"The VM's garbage collector routinely moves objects as it reclaims and compacts\r\t memory. But it can also pin an object so that it will not be moved, which can make\r\t it easier to pass objects out through the FFI.  Objects are unpinnned when created.\r\t This method ensures an object is unpinned, and answers whether it was pinned.\"\r\t^self setPinnedInMemory: false"},{"name":"isPresenter","linesOfCode":2,"sourceCode":"isPresenter\r\r\t^ false"},{"name":"perform:withEnoughArguments:","linesOfCode":13,"sourceCode":"perform: selector withEnoughArguments: anArray\r\t\"Send the selector, aSymbol, to the receiver with arguments in argArray.\r\tOnly use enough arguments for the arity of the selector; supply nils for missing ones.\"\r\t| numArgs args |\r\tnumArgs := selector numArgs.\r\tanArray size == numArgs\r\t\tifTrue: [ ^self perform: selector withArguments: anArray asArray ].\r\r\targs := Array new: numArgs.\r\targs replaceFrom: 1\r\t\tto: (anArray size min: args size)\r\t\twith: anArray\r\t\tstartingAt: 1.\r\r\t^ self perform: selector withArguments: args"},{"name":"error:","linesOfCode":4,"sourceCode":"error: aString\r\t\"Throw a generic Error exception.\"\r\t<debuggerCompleteToSender>\r\t^ Error new signal: aString"},{"name":"phlowValue:value:","linesOfCode":2,"sourceCode":"phlowValue: anObject value: otherObject\r\r\t^ self"},{"name":"isEpEvent","linesOfCode":2,"sourceCode":"isEpEvent\r\t\r\t^ false"},{"name":"inspectOnce","linesOfCode":7,"sourceCode":"inspectOnce\r\t\"Inspect unless we have already done it once.\"\r\t\r\t| node |\r\tnode := thisContext sender sourceNodeExecuted.\r\t(node hasProperty: #Once) ifTrue: [^self]. \r\tnode propertyAt: #Once put: true.\r\t^self inspect"},{"name":"isFraction","linesOfCode":3,"sourceCode":"isFraction\r\t\"Answer true if the receiver is a Fraction.\"\r\r\t^ false"},{"name":"isRingObject","linesOfCode":2,"sourceCode":"isRingObject\r\r\t^false"},{"name":"systemIcon","linesOfCode":4,"sourceCode":"systemIcon\r\t\"dont use this method. It will be deprecated.\r\tTools should resolve real icon object based on icon name\"\r\t^ self iconNamed: self systemIconName"},{"name":"mbndLiteralTypeWithTarget:","linesOfCode":2,"sourceCode":"mbndLiteralTypeWithTarget: compilationTarget\r\t^ compilationTarget compilerObjectType"},{"name":"readFromString:","linesOfCode":3,"sourceCode":"readFromString: aString \r\t\"Create an object based on the contents of aString.\"\r\t^ self readFrom: aString readStream"},{"name":"basicSize","linesOfCode":7,"sourceCode":"basicSize\r\t\"Primitive. Answer the number of indexable variables in the receiver. \r\tThis value is the same as the largest legal subscript. Essential. Do not \r\toverride in any subclass. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 62>\r\t\"The number of indexable fields of fixed-length objects is 0\"\r\t^0\t"},{"name":"isMethodProperties","linesOfCode":2,"sourceCode":"isMethodProperties\r\t^false"},{"name":"settingStoreOn:","linesOfCode":2,"sourceCode":"settingStoreOn: aStream\r\t^ self storeOn: aStream"},{"name":"crTrace:","linesOfCode":4,"sourceCode":"crTrace: aString\r\t\"Log the argument. Use self crTrace: instead of Transcript cr; show: \"\r\t\r\tTranscript cr.\r\tself trace: aString"},{"name":"actionsDo:","linesOfCode":2,"sourceCode":"actionsDo: aBlock\r\r\tself actionMap do: aBlock"},{"name":"asCalypsoBrowserItem","linesOfCode":2,"sourceCode":"asCalypsoBrowserItem\r\r\t^self calypsoEnvironmentType convertToCalypsoBrowserItem: self "},{"name":"yourself","linesOfCode":18,"sourceCode":"yourself\r\t\"Answer self. The message yourself deserves a bit of explanation.\r\tSending yourself is handy to get the receiver of a message. It is especially useful when using a cascade since all the cascaded messages are send to the receiver. Let us look at an example.\r\t\r\tImagine that you have the following expression\r\t\t#('hello' 'world') at: 2 put: 'pharo'\r\tand that you would like to get the modified array #('hello' 'pharo') - the receiver of the message at:put:. \r\t\r\tRight now the expression #('hello' 'world') at: 2 put: 'pharo' returns 'pharo' and not the receiver because the message at:put: always returns the second argument.\r\t \r\tTo get the receiver we can simply use a cascade as follows:\r\t\t#('hello' 'world') at: 2 put: 'pharo'; yourself\r\tand since yourself returns the receiver of the message we will get the modified array.\r\t\r\tStepping back using a cascade and yourself is equivalent to declare a variable, assign the expression and return the variable as follows:\r\t| a |\r\ta := #('hello' 'world'). \r\ta at: 2 put: 'pharo'.\r\ta \r\t\"\r\t\r\t^self"},{"name":"spotterActDefault:","linesOfCode":3,"sourceCode":"spotterActDefault: aStep\r\taStep exit.\r\tself spotterActDefault"},{"name":"isKindOf:","linesOfCode":4,"sourceCode":"isKindOf: aClass\r\t\"Answer whether the class, aClass, is a superclass or class of the receiver.\r\tThe current implemementation allows for a Trait to be used as argument\"\r\r\t^ self class == aClass or: [ self class inheritsFrom: aClass ]"},{"name":"isMbndProgramEntity","linesOfCode":2,"sourceCode":"isMbndProgramEntity\r\t^ false"},{"name":"printStringLimitedTo:using:","linesOfCode":7,"sourceCode":"printStringLimitedTo: limit using: printBlock\r\t\"Answer a String whose characters are a description of the receiver\r\tproduced by given printBlock. It ensures the result will be not bigger than given limit\"\r\t| limitedString |\r\tlimitedString := String streamContents: printBlock limitedTo: limit.\r\tlimitedString size < limit ifTrue: [^ limitedString].\r\t^ limitedString , '...etc...'"},{"name":"isSpecLayout","linesOfCode":2,"sourceCode":"isSpecLayout\r\r\t^ false"},{"name":"isTreeNodeModel","linesOfCode":2,"sourceCode":"isTreeNodeModel\r\r\t^ false"},{"name":"asString","linesOfCode":3,"sourceCode":"asString\r\t\"Answer a string that represents the receiver.\"\r\r\t^ self printString "},{"name":"orDefaultForUnresolved","linesOfCode":2,"sourceCode":"orDefaultForUnresolved\r\r\t^ self"},{"name":"caseOf:otherwise:","linesOfCode":14,"sourceCode":"caseOf: aBlockAssociationCollection otherwise: aBlock\r\t\"DO NOT USE THIS METHOD! It will be removed from Pharo.\"\r\t\r\t\"The elements of aBlockAssociationCollection are associations between blocks.\r\t Answer the evaluated value of the first association in aBlockAssociationCollection\r\t whose evaluated key equals the receiver.  If no match is found, answer the result\r\t of evaluating aBlock.\"\r\r\taBlockAssociationCollection associationsDo:\r\t\t[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].\r\t^ aBlock value\r\r\"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]\"\r\"| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]\"\r\"The following are compiled in-line:\"\r\"#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]\"\r\"#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]\""},{"name":"addModelYellowButtonMenuItemsTo:forMorph:hand:","linesOfCode":6,"sourceCode":"addModelYellowButtonMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph \r\t\"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items\"\r\tMorph cmdGesturesEnabled ifTrue: [ \r\t\taCustomMenu add: 'inspect model'  target: self selector: #inspect.\r\t].\r\t^aCustomMenu\r"},{"name":"isSessionPersistentExternalBuffer","linesOfCode":2,"sourceCode":"isSessionPersistentExternalBuffer\r\t^ false"},{"name":"asMoebiusValueWithType:","linesOfCode":2,"sourceCode":"asMoebiusValueWithType: aType\r\t^ MbndValue value: self type: aType\r\t"},{"name":"shouldBeImplemented","linesOfCode":4,"sourceCode":"shouldBeImplemented\r\t\"Announce that this message should be implemented\"\r\t<debuggerCompleteToSender>\r\tShouldBeImplemented signalFor: thisContext sender selector"},{"name":"taskbarIcon","linesOfCode":4,"sourceCode":"taskbarIcon\r\t\"Answer the icon for the receiver in a task bar\r\tor nil for the default.\"\r\r\t^self class taskbarIcon"},{"name":"handleProcessTerminationOfWaitingContext:","linesOfCode":2,"sourceCode":"handleProcessTerminationOfWaitingContext: suspendedContext\r\t^suspendedContext"},{"name":"unplug","linesOfCode":1,"sourceCode":"unplug\r"},{"name":"isSpecAdapter","linesOfCode":2,"sourceCode":"isSpecAdapter\r\r\t^ false"},{"name":"errorSubscriptBounds:","linesOfCode":3,"sourceCode":"errorSubscriptBounds: index \r\t\"Create an error notification that an improper integer was used as an index.\"\r\r\tSubscriptOutOfBounds signalFor: index"},{"name":"metacelloIntegerLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloIntegerLessThanSelf: anInteger\r\r\t^self error: 'Invalid Metacello verson component - should be String or Integer.'"},{"name":"inspectorClass","linesOfCode":4,"sourceCode":"inspectorClass\r\t\"Answer the class of the inspector to be used on the receiver.  Called by inspect; \r\tuse basicInspect to get a normal (less useful) type of inspector.\"\r\r\t^ EyeInspector "},{"name":"asParser","linesOfCode":3,"sourceCode":"asParser\r\t\"Answer a parser accepting the receiving object.\"\r\r\t^ PPPredicateObjectParser expect: self"},{"name":"asMoebiusValueWithTarget:","linesOfCode":2,"sourceCode":"asMoebiusValueWithTarget: compilationTarget\r\t^ self asMoebiusValueWithType: (self mbndLiteralTypeWithTarget: compilationTarget)"},{"name":"isPrimitiveMatrix","linesOfCode":2,"sourceCode":"isPrimitiveMatrix\r\t^ false"},{"name":"breakDependents","linesOfCode":3,"sourceCode":"breakDependents\r\t\"Remove all of the receiver's dependents.\"\r\r\tself myDependents: nil"},{"name":"asMapArgument","linesOfCode":8,"sourceCode":"asMapArgument\r\t\"JK: Hack alert. OrderedCollection is returned from the repeating parsers.\r\t\tArray is returned from the sequence parser.\r\t\t\r\t\tAs an argument into the mapping parser, ordered collection is transformed into an array\r\t\twith that collection. Array is passed unmodified.\r\t\"\r\t^ Array with: self"},{"name":"adaptToFraction:andSend:","linesOfCode":4,"sourceCode":"adaptToFraction: rcvr andSend: selector\r\t\"If no method has been provided for adapting an object to a Fraction,\r\tthen it may be adequate to simply adapt it to a number.\"\r\t^ self adaptToNumber: rcvr andSend: selector"},{"name":"asTextMorph","linesOfCode":3,"sourceCode":"asTextMorph\r\t\"Open a TextMorph, as best one can, on the receiver\"\r\r\t^ TextMorph new contentsAsIs: self asStringOrText\r"},{"name":"isMbndAnonymousSymbol","linesOfCode":2,"sourceCode":"isMbndAnonymousSymbol\r\t^ false"},{"name":"browse","linesOfCode":2,"sourceCode":"browse\r\t^ Smalltalk tools browser openOnClass: self class"},{"name":"asAlphaImageMorph","linesOfCode":2,"sourceCode":"asAlphaImageMorph\r\r\t^ self asMorph"},{"name":"handles:","linesOfCode":3,"sourceCode":"handles: exception\r\t\"This method exists in case a non exception class is the first arg in an on:do: (for instance using a exception class that is not loaded). We prefer this to raising an error during error handling itself. Also, semantically it makes sense that the exception handler is not active if its exception class is not loaded\"\r\r\t^ false"},{"name":"dragTransferType","linesOfCode":2,"sourceCode":"dragTransferType\r\t^nil"},{"name":"currentHand","linesOfCode":3,"sourceCode":"currentHand\r\t\"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned.\"\r\r\t^ self currentWorld primaryHand"},{"name":"gtInspectorVariableValuePairs","linesOfCode":9,"sourceCode":"gtInspectorVariableValuePairs\r\t\"This is a helper method that returns a collection of \r\t\tvariable_name -> value\r\tfor the current object.\r\tSubclasses can override it to specialize what appears in the variables presentation\"\r\t| bindings |\r\tbindings := OrderedCollection new.\r\tself gtInspectorVariableNodesIn: bindings.\r\t^ bindings collect: [ :aNode | aNode key -> aNode value ]"},{"name":"spotterPreviewRawIn:","linesOfCode":14,"sourceCode":"spotterPreviewRawIn: aComposite\r\t<spotterPreview: 40>\r\r\taComposite table\r\t\ttitle: [ self gtDisplayString ];\r\t\tdisplay: [ :anObject | (anObject gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself) addFirst: 'self' -> anObject; yourself ];\r\t\tcolumn: 'Variable'\r\t\t\tevaluated: [:assoc |\tGTObjectPrinter asNonTruncatedTextFrom: assoc key ]\r\t\t\tstyled: [ :aBrick | aBrick textPosition: #rightCenter; margin: #(0 15 0 0); textColor: aComposite themer textLightColor; height: 30 ];\r\t\tcolumn: 'Value'\r\t\t\tevaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ]\r\t\t\tstyled: [ :aBrick | aBrick margin: #(0 0 0 15); height: 30 ];\r\t\tentity: self.\r\t\t\r\tself flag: 'move \"entity: self\" somewhere else, maybe'"},{"name":"changed","linesOfCode":4,"sourceCode":"changed\r\t\"Receiver changed in a general way; inform all the dependents by \r\tsending each dependent an update: message.\"\r\r\tself changed: self"},{"name":"instVarNamed:","linesOfCode":7,"sourceCode":"instVarNamed: aString\r\t\"Return the value of the instance variable in me with that name.  Slow, but very useful.\r\tWe support here all slots (even non indexed) but raise a backward compatible exception\"\r\r\t^ self class\r\t\tslotNamed: aString\r\t\tifFound: [ :slot | slot read: self ]\r\t\tifNone: [ InstanceVariableNotFound signalFor: aString asString ]"},{"name":"printOn:","linesOfCode":8,"sourceCode":"printOn: aStream\r\t\"Append to the argument, aStream, a sequence of characters that  \r\tidentifies the receiver.\"\r\r\t| title |\r\ttitle := self class name.\r\taStream\r\t\tnextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);\r\t\tnextPutAll: title"},{"name":"spotterActDefault","linesOfCode":2,"sourceCode":"spotterActDefault\r\t^ self inspect"},{"name":"isClosure","linesOfCode":2,"sourceCode":"isClosure\r\t^false"},{"name":"matchesPatternElement:","linesOfCode":2,"sourceCode":"matchesPatternElement: matchedElement\r\t^ matchedElement = self"},{"name":"nodesDo:","linesOfCode":3,"sourceCode":"nodesDo: aBlock\r\t\"JK: this is kind of hack, I don't like having this method here\"\r\t\"nothing to do\""},{"name":"isExceptionSignalledForDebuggedExecution","linesOfCode":2,"sourceCode":"isExceptionSignalledForDebuggedExecution\r\t^ false"},{"name":"displayString","linesOfCode":5,"sourceCode":"displayString\r\t\"While printString is about to give a detailled information about an object, displayString is a message that should return a short string-based representation to be used by list and related UI frameworks. By default, simply return printString.\r\tSubclasses should not override this method \r\tbut instead stream based method #displayStringOn:\"\r\t\r\t^ self displayStringLimitedTo: 50000"},{"name":"at:","linesOfCode":12,"sourceCode":"at: index \r\t\"Primitive. Assumes receiver is indexable. Answer the value of an \r\tindexable element in the receiver. Fail if the argument index is not an \r\tInteger or is out of bounds. Essential. See Object documentation \r\twhatIsAPrimitive. Read the class comment for a discussion about that the fact\r\tthat the index can be a float.\"\r\r\t<primitive: 60>\r\tindex isInteger ifTrue:\r\t\t[self class isVariable\r\t\t\tifTrue: [self errorSubscriptBounds: index]\r\t\t\tifFalse: [self errorNotIndexable]].\r\tself errorNonIntegerIndex"},{"name":"externalCallFailed","linesOfCode":5,"sourceCode":"externalCallFailed\r\t\"Raise an error after a failed call to an external function\"\r\t| errCode |\r\terrCode := ExternalFunction getLastError. \"this allows us to look at the actual error code\"\r\t^self error: (ExternalFunction errorMessageFor: errCode)."},{"name":"isSpLayout","linesOfCode":2,"sourceCode":"isSpLayout\r\r\t^ false"},{"name":"trace","linesOfCode":2,"sourceCode":"trace\r\tself trace: self"},{"name":"removeActionsSatisfying:","linesOfCode":7,"sourceCode":"removeActionsSatisfying: aBlock\r\r\tself actionMap keysDo:\r\t\t[:eachEventSelector |\r\t\t\tself\r   \t\t\t\tremoveActionsSatisfying: aBlock\r\t\t\t\tforEvent: eachEventSelector\r\t\t]"},{"name":"spotterProcessorsFor:pragma:","linesOfCode":12,"sourceCode":"spotterProcessorsFor: aSpotterStep pragma: aPragma\r\r  | processorsSize addedProcessorsSize |\r\t\"To allow nice arrangement of processor within UI we need to assign to\r\t\teach processor its spotter order. Because it is possible\r\t\tto define multiple (or none) processors using pragma\r\t\twe need to detect how many new processors were added\"\r\tprocessorsSize := aSpotterStep processors size.\r\t\r\tself perform: aPragma methodSelector with: aSpotterStep.\r\t\r\taddedProcessorsSize := aSpotterStep processors size - processorsSize.\r\t\"assign spotter order for newly added ones\"\r\t(aSpotterStep processors last: addedProcessorsSize)\r\t\tdo: [ :processor | processor order: (aPragma argumentAt: 1) ] "},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ self isLiteral"},{"name":"ffiCall:library:","linesOfCode":3,"sourceCode":"ffiCall: fnSpec library: aLibrary\r\t<ffiCalloutTranslator>\r\t\r\tself ffiCall: fnSpec library: aLibrary options: #()"},{"name":"selectCase:","linesOfCode":7,"sourceCode":"selectCase: cases\r\tcases do: [ :each |\r\t\t(each matchesSelectCaseFor: self) ifTrue: [\r\t\t\t^ each evaluateMatchedSelectCaseWith: self\r\t\t]\r\t].\r\r\tself error: 'Pattern not found.'"},{"name":"halt","linesOfCode":4,"sourceCode":"halt\r\t\"This is the typical message to use for inserting breakpoints during debugging.\"\r\t<debuggerCompleteToSender>\r\tHalt now"},{"name":"isMessageSend","linesOfCode":2,"sourceCode":"isMessageSend\r\t^false\r"},{"name":"asValueHolder","linesOfCode":3,"sourceCode":"asValueHolder\r\t\"See NewValueHolder class comment\"\r\r\t^ NewValueHolder value: self"},{"name":"haltOnWrite","linesOfCode":2,"sourceCode":"haltOnWrite\r\t^VariableBreakpoint watchVariablesWritesInObject: self"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\tself subclassResponsibility"},{"name":"gtInspectorHash","linesOfCode":2,"sourceCode":"gtInspectorHash\r\r\t^ self identityHash."},{"name":"haltFromCount:","linesOfCode":4,"sourceCode":"haltFromCount: anInteger\r\t\"Always halt after a count has been reached\"\r\r\t<debuggerCompleteToSender>\r\tHalt fromCount: anInteger"},{"name":"isExternalType","linesOfCode":2,"sourceCode":"isExternalType\r\t^ false"},{"name":"removeActionsForEvent:","linesOfCode":6,"sourceCode":"removeActionsForEvent: anEventSelector\r\r    | map |\r    map := self actionMap.\r    map removeKey: anEventSelector asSymbol ifAbsent: [].\r    map isEmpty\r        ifTrue: [self releaseActionMap]"},{"name":"update:with:","linesOfCode":6,"sourceCode":"update: anAspect with: anObject\r\t\"Receive a change notice from an object of whom the receiver is a \r\tdependent. The default behavior is to call update:,\r\twhich by default does nothing; a subclass might want \r\tto change itself in some way.\"\r\r\t^ self update: anAspect"},{"name":"removeActionsWithReceiver:","linesOfCode":7,"sourceCode":"removeActionsWithReceiver: anObject\r\r\tself actionMap copy keysDo:\r\t\t[:eachEventSelector |\r\t\t\tself\r   \t\t\t\tremoveActionsSatisfying: [:anAction | anAction receiver == anObject]\r\t\t\t\tforEvent: eachEventSelector\r\t\t]"},{"name":"currentWorld","linesOfCode":3,"sourceCode":"currentWorld\r\t\"Answer a morphic world that is the current UI focus.\"\r\t^ UIManager default currentWorld"},{"name":"haltIfTest","linesOfCode":4,"sourceCode":"haltIfTest\r\t\"Halt if execution was started by a test. These #halts are just active in the tests, useful when you want to add a halt in methods that are executed a lot (e.g. collections)\"\r\t<debuggerCompleteToSender>\r\tHalt ifTest"},{"name":"copy","linesOfCode":3,"sourceCode":"copy\r\t\"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy. Copy is a template method in the sense of Design Patterns. So do not override it. Override postCopy instead. Pay attention that normally you should call postCopy of your superclass too.\"\r\r\t^self shallowCopy postCopy"},{"name":"instVarNamed:put:","linesOfCode":7,"sourceCode":"instVarNamed: aString put: aValue\r\t\"Store into the value of the instance variable in me of that name. Slow, but very useful.\r\tWe support here all slots (even non indexed) but raise a backward compatible exception\"\r\r\t^ self class\r\t\tslotNamed: aString\r\t\tifFound: [ :slot | slot write: aValue to: self ]\r\t\tifNone: [ InstanceVariableNotFound signalFor: aString asString ]"},{"name":"logExit","linesOfCode":2,"sourceCode":"logExit\r\tself traceCr: 'Exited ' , thisContext sender printString"},{"name":"attemptToAssign:withIndex:","linesOfCode":8,"sourceCode":"attemptToAssign: value withIndex: index \r\t\"Called by the VM when assigning an instance variable of an immutable object.\r\tUpon return, executing will resume *after* the inst var assignment. If the inst var mutation has to be \r\tperformed, do it manually here in the call back with instVarAt:put:.\r\tThis method has to return *no* value by jumping to the context's sender\"\r\t\r\tself modificationForbiddenFor: #instVarAt:put: index: index value: value.\r\r\tthisContext sender jump\r\t\"CAN'T REACH\""},{"name":"haltIf:","linesOfCode":3,"sourceCode":"haltIf: condition\r\t<debuggerCompleteToSender>\r\tHalt if: condition."},{"name":"isTrait","linesOfCode":2,"sourceCode":"isTrait\r\t^false"},{"name":"brickAlert","linesOfCode":2,"sourceCode":"brickAlert\r\r\tGLMAlertBrick alert: self"},{"name":"when:send:to:with:","linesOfCode":10,"sourceCode":"when: anEventSelector\rsend: aMessageSelector\rto: anObject\rwith: anArg\r \r    self\r        when: anEventSelector\r        evaluate: (WeakMessageSend\r            receiver: anObject\r            selector: aMessageSelector\r\t\targuments: {anArg})"},{"name":"isMorphicEvent","linesOfCode":2,"sourceCode":"isMorphicEvent\r\t^false"},{"name":"ffiLibraryName","linesOfCode":3,"sourceCode":"ffiLibraryName\r\tself flag: 'HACK: avoid direct subclassResponsibility to not break RB test cases..'.\r\t^ SubclassResponsibility signalFor: thisContext selector"},{"name":"spotterPreviewIn:inContext:","linesOfCode":20,"sourceCode":"spotterPreviewIn: aComposite inContext: aSpotter\r\t| pragmas |\r\tpragmas := Pragma\r\t\tallNamed: #spotterPreview:\r\t\tfrom: self class\r\t\tto: Object\r\t\tsortedUsing: [ :x :y | (x argumentAt: 1) < (y argumentAt: 1) ].\r\t\"We iterate through all pragmas and execute the corresponding methods\r\tto ensure that all possible previews are taken into account.\r\tEven though at this moment we only display one preview, we still have to go through\r\tall pragmas because it can happen that the method has a guarding if and thus, the actual\r\tpreview would not be triggered.\"\r\tpragmas\r\t\tdo: [ :eachPragma | \r\t\t\t(eachPragma methodSelector findTokens: $:) size = 1\r\t\t\t\tifTrue: [ self perform: eachPragma methodSelector with: aComposite ].\r\t\t\t(eachPragma methodSelector findTokens: $:) size = 2\r\t\t\t\tifTrue: [ self perform: eachPragma selector with: aComposite with: aSpotter ].\r\t\t\taComposite hasSubbricks\r\t\t\t\tifTrue: [ ^ self ] ]"},{"name":"acceptDroppingMorph:event:inMorph:","linesOfCode":2,"sourceCode":"acceptDroppingMorph: transferMorph event: evt inMorph: dstListMorph \r\t\r\t^false."},{"name":"newCallbackWithSignature:block:library:","linesOfCode":7,"sourceCode":"newCallbackWithSignature: signature block: aBlock library: aFFILibrary\r\t\"This method is used to create a callback in the callout api of the receiver\"\r\t\r\t^ (self ffiCalloutIn: thisContext sender)\r\t\tconvention: self ffiCallingConvention;\r\t\tnewCallbackWithSignature: signature\r\t\t\tblock: aBlock\r\t\t\tlibrary: aFFILibrary"},{"name":"confirm:","linesOfCode":6,"sourceCode":"confirm: queryString\r\t\"Put up a yes/no menu with caption queryString. Answer true if the \r\tresponse is yes, false if no. This is a modal question--the user must \r\trespond yes or no.\"\r\r\t\"nil confirm: 'Are you hungry?'\"\r\r\t^ UIManager default confirm: queryString"},{"name":"metacelloStringLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloStringLessThanSelf: anInteger\r\r\t^self error: 'Invalid Metacello verson component - should be String or Integer.'"},{"name":"traceCr:","linesOfCode":4,"sourceCode":"traceCr: anObject\r\t\"Log the argument. Use self traceCr: 'something' instead of Transcript show: 'something'  ; cr \"\r\t\r\tself trace: anObject.\r\tTranscript cr"},{"name":"wantsVisualFeedback","linesOfCode":2,"sourceCode":"wantsVisualFeedback\r\r\t^ true"},{"name":"shouldBePrintedAsLiteral","linesOfCode":2,"sourceCode":"shouldBePrintedAsLiteral\r\r\t^self isLiteral"},{"name":"link:toSlotNamed:option:","linesOfCode":6,"sourceCode":"link: aMetaLink toSlotNamed: aSlotName option: option\r\taMetaLink\r\t\tinstallOnVariableNamed: aSlotName\r\t\tfor: self\r\t\toption: option\r\t\tinstanceSpecific: self intanceSpecificMetaLinksAvailable"},{"name":"serializeToFileNamed:","linesOfCode":2,"sourceCode":"serializeToFileNamed: aFilename\r\t^ FLSerializer serialize: self toFileNamed: aFilename"},{"name":"link:toTemporaryNamed:inMethod:option:","linesOfCode":8,"sourceCode":"link: aMetaLink toTemporaryNamed: aTempVarName inMethod: aMethodName option: option\r\t| variable |\r\t\r\tvariable := (self nonAnonymousClass lookupSelector: aMethodName) lookupVar: aTempVarName.\r\r\taMetaLink\r\t\tinstallOnVariable: variable\r\t\tfor: self\r\t\toption: option\r\t\tinstanceSpecific: true"},{"name":"renderGlamorouslyOn:","linesOfCode":3,"sourceCode":"renderGlamorouslyOn: aRenderer \r\t \r\t^aRenderer renderObject: self"},{"name":"isRingFullyUnresolved","linesOfCode":2,"sourceCode":"isRingFullyUnresolved\r\r\t^ false"},{"name":"printDirectlyToDisplay","linesOfCode":4,"sourceCode":"printDirectlyToDisplay\r\t\"For debugging: write the receiver's printString directly to the display at (0, 100); senders of this are detected by the check-for-slips mechanism.\"\r\r\tself asString displayAt: 0@100\r\r\"StringMorph someInstance printDirectlyToDisplay\""},{"name":"canDiscardEdits","linesOfCode":6,"sourceCode":"canDiscardEdits\r\t\"Answer true if none of the views on this model has unaccepted edits that matter.\"\r\r\tself dependents\r\t\tdo: [:each | each canDiscardEdits ifFalse: [^ false]]\r\t\twithout: self.\r\t^ true"},{"name":"isSYMLASTNode","linesOfCode":2,"sourceCode":"isSYMLASTNode\r\t^ false"},{"name":"inspectionMeta","linesOfCode":3,"sourceCode":"inspectionMeta\r\t<inspectorPresentationOrder: 999 title: 'Meta'>\r\r\t^ StMetaBrowser on: self"},{"name":"isPetitFailure","linesOfCode":2,"sourceCode":"isPetitFailure\r\t^ false"},{"name":"isInterval","linesOfCode":2,"sourceCode":"isInterval\r\r\t^ false"},{"name":"myDependents","linesOfCode":3,"sourceCode":"myDependents\r\t\"Private. Answer a list of all the receiver's dependents.\"\r\r\t^ DependentsFields at: self ifAbsent: []"},{"name":"isMemberOf:","linesOfCode":3,"sourceCode":"isMemberOf: aClass \r\t\"Answer whether the receiver is an instance of the class, aClass.\"\r\r\t^self class == aClass"},{"name":"ffiCall:","linesOfCode":7,"sourceCode":"ffiCall: fnSpec\r\t<ffiCalloutTranslator>\r\t\r\t\"All the ffiCall: messages are used to perform Foreign-Function calls (FFI calls).\r\tFFI calls allows Pharo code to interact with external dynamic linked libraries.\r\tPlease refer to the booklet about more configuration details\r\tor some of the examples on the image LibC / FreeTypeFont / Athens / SDL.\"\r\t\r\tself ffiCall: fnSpec library: self ffiLibrary"},{"name":"ffiLibrary","linesOfCode":15,"sourceCode":"ffiLibrary\r\t\r\t\"This method returns the ffiLibrary to use in the Foreign-Function calls performed in this object.\r\tFFI calls allows Pharo to call functions in other external dynamic linked libraries.\r\t\r\tSee #ffiCall: to see how to perform a FFI call.\r\tSubclasses can redefine this method to use a different FFILibrary class (see class FFILibrary). \r\tA FFILibrary object not only returns the path to the dynamic linked library to use (DLL/SO/DYLIB)\r\tbut it can also configure different behaviours for the FFI Calls. For example, the backend to use \r\tor how the types are mapped. \r\t\r\tThis default implementation is kept as backward compatibility. \r\tIts implementation only returns a default configured FFILibrary using the path to the \r\tdynamic library file returned by #ffiLibraryName \r\t\r\tNew users of FFI should return here a subclass of FFILibrary configured as required by the target \r\texternal library to call by FFI\"\r\t\t\r\t^ self ffiLibraryName asFFILibrary"},{"name":"crTrace","linesOfCode":2,"sourceCode":"crTrace\r\tself crTrace: self"},{"name":"link:toClassVariable:","linesOfCode":3,"sourceCode":"link: aMetaLink toClassVariable: aClassVariable\r\t\"Object specific links cannot be put on class variables\"\r\r\tself shouldNotImplement"},{"name":"gtConstructDebuggerInspectorIn:for:","linesOfCode":4,"sourceCode":"gtConstructDebuggerInspectorIn: composite for: aDebugger\r\t\r\t^ composite custom: (GTDebuggerInspector new \r\t\tdebugger: aDebugger;\r\t\tstartOn: self)"},{"name":"haltOnAccess:to:","linesOfCode":4,"sourceCode":"haltOnAccess: access to: anInstVarName\r\taccess = #read ifTrue:[^self haltOnReadTo: anInstVarName].\r\taccess = #write ifTrue:[^self haltOnWriteTo: anInstVarName].\r\t^self haltOnAccessTo: anInstVarName"},{"name":"inspectWithLabel:","linesOfCode":3,"sourceCode":"inspectWithLabel: aLabel\r\t\"Create and schedule an Inspector in which the user can examine the receiver's variables.\"\r\t^Smalltalk tools inspector inspect: self label: aLabel"},{"name":"actionForEvent:","linesOfCode":7,"sourceCode":"actionForEvent: anEventSelector\r    \"Answer the action to be evaluated when <anEventSelector> has been triggered.\"\r\r\t| actions |\r\tactions := self actionMap\r\t\tat: anEventSelector asSymbol\r\t\tifAbsent: [^nil].\r \r\t^ actions asMinimalRepresentation"},{"name":"hasActionsWithReceiver:","linesOfCode":5,"sourceCode":"hasActionsWithReceiver: anObject\r\r\t^self actionMap keys anySatisfy:\r\t\t[:eachEventSelector |\r\t\t\t(self actionSequenceForEvent: eachEventSelector)\r\t\t\t\tanySatisfy: [:anAction | anAction receiver == anObject]]"},{"name":"handleLGitReturnCode","linesOfCode":2,"sourceCode":"handleLGitReturnCode\r\t^ self"},{"name":"asArray","linesOfCode":2,"sourceCode":"asArray\r\t^ Array with: self"},{"name":"longPrintStringLimitedTo:","linesOfCode":6,"sourceCode":"longPrintStringLimitedTo: aLimitValue\r\t\"Answer a String whose characters are a description of the receiver.\"\r\t\r\t| str |\r\tstr := String streamContents: [:aStream | self longPrintOn: aStream limitedTo: aLimitValue indent: 0].\r\t\"Objects without inst vars should return something\"\r\t^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]"},{"name":"isArray","linesOfCode":2,"sourceCode":"isArray\r\t^false"},{"name":"haltOnReadTo:","linesOfCode":2,"sourceCode":"haltOnReadTo: aVariableName\r\t^VariableBreakpoint watchVariableReads: aVariableName inObject: self"},{"name":"instVarAt:put:","linesOfCode":11,"sourceCode":"instVarAt: index put: anObject\r\t\"Primitive. Store a value into a fixed variable in an object. The numbering of the\r\t variables corresponds to the named instance variables, followed by the indexed\r\t instance variables. Fail if the index is not an Integer or is not the index of a fixed\r\t variable or indexed variable. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 174 error: ec>\r\t (index isInteger \r\t\tand: [ index between: 1 and: self class instSize + self basicSize]) \r\t\t\tifFalse: [ ^ self errorSubscriptBounds: index ].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #instVarAt:put: index: index value: anObject ]"},{"name":"settingFixedDomainValueNodeFrom:","linesOfCode":2,"sourceCode":"settingFixedDomainValueNodeFrom: aSettingNode \r\t^ aSettingNode fixedDomainValueNodeForObject: self"},{"name":"adaptToFraction:andCompare:","linesOfCode":4,"sourceCode":"adaptToFraction: rcvr andCompare: selector \r\t\"If I am involved in comparison with a Fraction.\r\tDefault behaviour is to process comparison as any other selectors.\"\r\t^ self adaptToFraction: rcvr andSend: selector"},{"name":"hasDynamicItems","linesOfCode":2,"sourceCode":"hasDynamicItems\r\t^ false"},{"name":"copySameFrom:","linesOfCode":11,"sourceCode":"copySameFrom: otherObject\r\t\"Copy to myself all instance variables named the same in otherObject.\r\tThis ignores otherObject's control over its own inst vars.\"\r\r\t| myInstVars otherInstVars |\r\tmyInstVars := self class allInstVarNames.\r\totherInstVars := otherObject class allInstVarNames.\r\tmyInstVars doWithIndex: [:each :index | | match |\r\t\t(match := otherInstVars indexOf: each) > 0 ifTrue:\r\t\t\t[self instVarAt: index put: (otherObject instVarAt: match)]].\r\t1 to: (self basicSize min: otherObject basicSize) do: [:i |\r\t\tself basicAt: i put: (otherObject basicAt: i)].\r"},{"name":"hasModelYellowButtonMenuItems","linesOfCode":2,"sourceCode":"hasModelYellowButtonMenuItems\r\t^Morph cmdGesturesEnabled"},{"name":"rwValue:","linesOfCode":2,"sourceCode":"rwValue: anArgument \r\t^ self"},{"name":"createActionMap","linesOfCode":2,"sourceCode":"createActionMap\r\r\t^IdentityDictionary new"},{"name":"isSLVMDynamicInlineLiteral","linesOfCode":2,"sourceCode":"isSLVMDynamicInlineLiteral\r\t^ false"},{"name":"readSlot:","linesOfCode":2,"sourceCode":"readSlot: aSlot\r\t^aSlot read: self"},{"name":"writeSlotNamed:value:","linesOfCode":2,"sourceCode":"writeSlotNamed: aName value: anObject\r\t^(self class slotNamed: aName) write: anObject to: self"},{"name":"isPoint","linesOfCode":3,"sourceCode":"isPoint\r\t\"Overridden to return true in Point.\"\r\r\t^ false"},{"name":"isThisEverCalled:","linesOfCode":3,"sourceCode":"isThisEverCalled: msg\r\t\"Send this message, with some useful printable argument, from methods or branches of methods which you believe are never reached.\"\r\r\tself error: 'This is indeed called: ', msg printString"},{"name":"haltIfNil","linesOfCode":1,"sourceCode":"haltIfNil"},{"name":"someObject","linesOfCode":5,"sourceCode":"someObject\r\t\"Primitive. Answer the first object in the enumeration of all\r\t objects.\"\r\r\t<primitive: 138>\r\tself primitiveFailed."},{"name":"withoutListWrapper","linesOfCode":2,"sourceCode":"withoutListWrapper\r\r\t^self"},{"name":"dragPassengersFor:inMorph:","linesOfCode":2,"sourceCode":"dragPassengersFor: item inMorph: dragSource \r\r\t^ { item }"},{"name":"isEpiceaInterestingJobOwner","linesOfCode":2,"sourceCode":"isEpiceaInterestingJobOwner\r\r\t^ false"},{"name":"asWBTVarSubstitution","linesOfCode":2,"sourceCode":"asWBTVarSubstitution\r\t^ self asString asWBTVarSubstitution"},{"name":"iconNamed:","linesOfCode":2,"sourceCode":"iconNamed: aSymbol\r\t\r\t^ Smalltalk ui icons iconNamed: aSymbol"},{"name":"deprecated:transformWith:when:","linesOfCode":9,"sourceCode":"deprecated: anExplanationString transformWith: aRule when: conditionBlock\r\t\"Automatically tranform the deprecated call if it matches the condition\"\r\t\r\tDeprecation new\r\t\tcontext: thisContext sender;\r\t\texplanation: anExplanationString;\r\t\trule: aRule;\r\t\tcondition: conditionBlock;\r\t\ttransform.\r\t\t"},{"name":"haltOnAccess","linesOfCode":2,"sourceCode":"haltOnAccess\r\t^ VariableBreakpoint watchVariablesInObject: self"},{"name":"isVariableBinding","linesOfCode":3,"sourceCode":"isVariableBinding\r\t\"Return true if I represent a literal variable binding\"\r\t^false\r\t"},{"name":"isMbndAstNode","linesOfCode":2,"sourceCode":"isMbndAstNode\r\t^ false"},{"name":"basicAt:put:","linesOfCode":17,"sourceCode":"basicAt: index put: value \r\t\"Primitive. Assumes receiver is indexable. Store the second argument \r\tvalue in the indexable element of the receiver indicated by index. Fail \r\tif the index is not an Integer or is out of bounds. Or fail if the value is \r\tnot of the right type for this kind of collection. Answer the value that \r\twas stored. Essential. Do not override in a subclass. See Object \r\tdocumentation whatIsAPrimitive.\"\r\r\t<primitive: 61>\r\tindex isInteger \r\t\tifTrue: [self class isVariable\r\t\t\tifTrue: [(index between: 1 and: self size)\r\t\t\t\tifFalse: [ ^ self errorSubscriptBounds: index ]]\r\t\t\tifFalse: [ ^ self errorNotIndexable ]]\r\t\tifFalse: [ ^ self errorNonIntegerIndex ].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #basicAt:put: index: index value: value ].\r\tself errorImproperStore "},{"name":"isRWObject","linesOfCode":2,"sourceCode":"isRWObject\r\t^ false"},{"name":"packToArity:","linesOfCode":10,"sourceCode":"packToArity: arity\r\t\"This will answer a pointer to this object. \r\t It is like doing ==var ptr=&aVariable== in C (up to arity). \r\t\r\t In general, arity>1 will not work because then object has to be copied to \r\t heap, but my overrides will handle this case\"\r\t| rolledPointer |\r\t\t\r\trolledPointer := self.\r\t1 to: arity do: [ :index | rolledPointer := rolledPointer pointer ].\r\t^ rolledPointer"},{"name":"removeActionsSatisfying:forEvent:","linesOfCode":7,"sourceCode":"removeActionsSatisfying: aOneArgBlock \rforEvent: anEventSelector\r\r    self\r        setActionSequence:\r            ((self actionSequenceForEvent: anEventSelector)\r                reject: [:anAction | aOneArgBlock value: anAction])\r        forEvent: anEventSelector"},{"name":"isSysmelNativeType","linesOfCode":2,"sourceCode":"isSysmelNativeType\r\t^ false"},{"name":"isBlock","linesOfCode":2,"sourceCode":"isBlock\r\r\t^ false"},{"name":"->","linesOfCode":7,"sourceCode":"-> anObject\r\t\"Answer an Association between self and anObject\"\r\t\"The following example creates an association whose key is number 1 and value string 'one'.\"\r\r\t\"(1 -> 'one') key >>> 1\"\r\t\"(1 -> 'one') value >>> 'one'\"\r\t\r\t\"Note that key and value can be ANY object.\"\r\t\r\t^Association key: self value: anObject"},{"name":"isCompiledBlock","linesOfCode":2,"sourceCode":"isCompiledBlock\r\r\t^ false"},{"name":"nominallyUnsent:","linesOfCode":6,"sourceCode":"nominallyUnsent: aSelectorSymbol\r\t\"From within the body of a method which is not formally sent within the system, but which you intend to have remain in the system (for potential manual invocation, or for documentation, or perhaps because it's sent by commented-out-code that you anticipate uncommenting out someday, send this message, with the selector itself as the argument.\r\rThis will serve two purposes:\r\r\t(1)  The method will not be returned by searches for unsent selectors (because it, in a manner of speaking, sends itself).\r\t(2)\tYou can locate all such methods by browsing senders of #nominallyUnsent:\"\r\r\tfalse ifTrue: [self flag: #nominallyUnsent:]    \"So that this method itself will appear to be sent\"\r"},{"name":"readSlotNamed:","linesOfCode":2,"sourceCode":"readSlotNamed: aName\r\t^(self class slotNamed: aName) read: self"},{"name":"perform:with:with:with:","linesOfCode":7,"sourceCode":"perform: aSymbol with: firstObject with: secondObject with: thirdObject \r\t\"Send the selector, aSymbol, to the receiver with the given arguments.\r\tFail if the number of arguments expected by the selector is not three.\r\tPrimitive. Optional. See Object documentation whatIsAPrimitive.\"\r\t\r\t<primitive: 83>\r\t^ self perform: aSymbol\r\t\twithArguments: {firstObject . secondObject . thirdObject}"},{"name":"appendTo:","linesOfCode":3,"sourceCode":"appendTo: aCollection\r\t\"double dispatch for join:\"\r\t^ aCollection addLast: self"},{"name":"isForm","linesOfCode":2,"sourceCode":"isForm\r\t^false"},{"name":"asActionSequence","linesOfCode":2,"sourceCode":"asActionSequence\r\r\t^WeakActionSequence with: self"},{"name":"haltOnCallTo:","linesOfCode":2,"sourceCode":"haltOnCallTo: aSelector\r\t^Breakpoint breakOn: aSelector inObject: self"},{"name":"joinTo:","linesOfCode":3,"sourceCode":"joinTo: stream\r\t\"double dispatch for join:\"\r\t^ stream nextPut: self"},{"name":"asMoebiusLiteralValueNodeWithTarget:","linesOfCode":5,"sourceCode":"asMoebiusLiteralValueNodeWithTarget: compilationTarget\r\t^ MbndAstLiteralValueNode new\r\t\tvalue: self;\r\t\ttype: (self mbndLiteralTypeWithTarget: compilationTarget);\r\t\tyourself"},{"name":"beRecursivelyWritableObject","linesOfCode":2,"sourceCode":"beRecursivelyWritableObject\r\t^self recursivelySetIsReadOnlyObject: false"},{"name":"isTransferable","linesOfCode":2,"sourceCode":"isTransferable\r\r\t^ false"},{"name":"beReadOnlyObject","linesOfCode":8,"sourceCode":"beReadOnlyObject\r\t\"If the VM supports read-only objects it will not write to read-only objects.\r\t An attempt to write to an instance variable of a read-only object will\r\t cause the VM to send attemptToAssign:withIndex: to the read-only object.\r\t An attempt to modify a read-only object in a primitive will cause the\r\t primitive to fail with a #'no modification' error code.\r\t Set the read-only flag of the receiver to true and answer the previous vaue of the flag.\"\r\t^self setIsReadOnlyObject: true"},{"name":"haltOnWriteTo:","linesOfCode":2,"sourceCode":"haltOnWriteTo: aVariableName\r\t^VariableBreakpoint watchVariableWrites: aVariableName inObject: self"},{"name":"fuelReplacement","linesOfCode":2,"sourceCode":"fuelReplacement\r\t^ self"},{"name":"hasMultipleExecutors","linesOfCode":3,"sourceCode":"hasMultipleExecutors\r\t\"All objects, except ObjectFinalizerCollection instances should answer false to this message\"\r\t^ false"},{"name":"assert:","linesOfCode":5,"sourceCode":"assert: aBlock\r\t\"Throw an assertion error if aBlock does not evaluates to true.\r\tWe check for true explicitly to make the assertion fail for non booleans\"\r\t<debuggerCompleteToSender>\r\tself assert: aBlock description: 'Assertion failed'."},{"name":"isNotNil","linesOfCode":3,"sourceCode":"isNotNil\r\t\"Coerces nil to false and everything else to true.\"\r\r\t^true"},{"name":"error","linesOfCode":4,"sourceCode":"error\r\t\"Throw a generic Error exception.\"\r\t<debuggerCompleteToSender>\r\t^ self error: 'Error!'"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\t^ self asSLVMMessagePackSerializableObject slvmMessagePackEncodeWith: encoder"},{"name":"removeWodenResourceDependant:","linesOfCode":1,"sourceCode":"removeWodenResourceDependant: dependant"},{"name":"newCallbackWithSignature:block:","linesOfCode":7,"sourceCode":"newCallbackWithSignature: signature block: aBlock\r\t\"This method is used to create a callback in the same library and callout api of the receiver\"\r\t\r\t^ (self ffiCalloutIn: thisContext sender)\r\t\tconvention: self ffiCallingConvention;\r\t\tnewCallbackWithSignature: signature\r\t\t\tblock: aBlock\r\t\t\tlibrary: self ffiLibrary"},{"name":"performOnSmaCCParser:","linesOfCode":2,"sourceCode":"performOnSmaCCParser: aSmaCCParser\r\t^ self"},{"name":"isClass","linesOfCode":2,"sourceCode":"isClass\r\t^ false"},{"name":"split:do:","linesOfCode":6,"sourceCode":"split: aSequenceableCollection do: aBlock\r\t\"optimized version for single delimiters:\r\tExample:\r\t\t$/ split: '/foo/bar' indicesDo: [ :item | ]\"\r\tself split: aSequenceableCollection indicesDo: [ :start :end | \r\t\taBlock value: (aSequenceableCollection copyFrom: start to: end) ]"},{"name":"recursivelySetIsReadOnlyObject:exceptObjectsIn:","linesOfCode":15,"sourceCode":"recursivelySetIsReadOnlyObject: aBoolean exceptObjectsIn: alreadyDone\r\r\t\"Handle self if not already done, and note it as done.\"\r\r\t(alreadyDone includes: self) ifFalse:\r\t\t[\tself setIsReadOnlyObject: aBoolean.\r\t\t\talreadyDone add: self ].\r\r\t\"Handle all instance vars of self.\"\r\tself class allSlots do: [ :ivar | \r\t\t(ivar read: self)\r\t\t\trecursivelySetIsReadOnlyObject: aBoolean\r\t\t\texceptObjectsIn: alreadyDone ].\r\t\r\t\"Handle all indexed elements of self.\"\r\t1 to: self basicSize do: [ :i | \r\t\t(self basicAt: i)\r\t\t\trecursivelySetIsReadOnlyObject: aBoolean\r\t\t\texceptObjectsIn: alreadyDone ]\r"},{"name":"isMbndGeneratedSymbol","linesOfCode":2,"sourceCode":"isMbndGeneratedSymbol\r\t^ false"},{"name":"closureDescriptionForCaching","linesOfCode":2,"sourceCode":"closureDescriptionForCaching\r\t^ self printString"},{"name":"actionMap","linesOfCode":2,"sourceCode":"actionMap\r\r\t^EventManager actionMapFor: self"},{"name":"literalEqual:","linesOfCode":2,"sourceCode":"literalEqual: other\r\r\t^ self class == other class and: [self = other]"},{"name":"printStringLimitedTo:","linesOfCode":4,"sourceCode":"printStringLimitedTo: limit\r\t\"Answer a String whose characters are a description of the receiver.\r\tIf you want to print without a character limit, use fullPrintString.\"\r\t^self printStringLimitedTo: limit using: [:s | self printOn: s]"},{"name":"rsValue:","linesOfCode":2,"sourceCode":"rsValue: anArgument \r\t^ self"},{"name":"dependents","linesOfCode":4,"sourceCode":"dependents\r\t\"Answer a collection of objects that are 'dependent' on the receiver;\r\t that is, all objects that should be notified if the receiver changes.\"\r\r\t^ self myDependents ifNil: [#()]"},{"name":"isCharacter","linesOfCode":2,"sourceCode":"isCharacter\r\r\t^ false.\r"},{"name":"actAsExecutor","linesOfCode":3,"sourceCode":"actAsExecutor\r\t\"Prepare the receiver to act as executor for any resources associated with it\"\r\tself breakDependents"},{"name":"stonOn:","linesOfCode":8,"sourceCode":"stonOn: stonWriter\r\t\"Encode non-variable classes with a map of their instance variable and values.\r\tOverride to customize and add a matching #fromSton: (see implementors).\"\r\r\tself class isVariable \r\t\tifTrue: [\r\t\t\tstonWriter error: 'custom #stonOn: implementation needed for variable/indexable class' ]\r\t\tifFalse: [\r\t\t\tstonWriter writeObject: self ]\r"},{"name":"removeDependent:","linesOfCode":6,"sourceCode":"removeDependent: anObject\r\t\"Remove the given object as one of the receiver's dependents.\"\r\r\t| dependents |\r\tdependents := self dependents reject: [:each | each == anObject].\r\tself myDependents: (dependents isEmpty ifFalse: [dependents]).\r\t^ anObject"},{"name":"ffiCall:module:","linesOfCode":3,"sourceCode":"ffiCall: fnSpec module: aModuleName\r\t<ffiCalloutTranslator>\r\t\r\tself ffiCall: fnSpec library: aModuleName"},{"name":"isPrimitiveVector","linesOfCode":2,"sourceCode":"isPrimitiveVector\r\t^ false"},{"name":"displayStringOn:","linesOfCode":4,"sourceCode":"displayStringOn: aStream\r\t\"While #printOn: is about to give a detailled information about an object, #displayStringOn: is a message that should return a string-based representation to be used by list and related UI frameworks. By default, simply use printOn: method.\r\tSubclasses should override this method instead of #displayString\"\r\r\tself printOn: aStream"},{"name":"asDraggableMorph","linesOfCode":2,"sourceCode":"asDraggableMorph\r\t^ self asStringMorph "},{"name":"veryDeepCopy","linesOfCode":9,"sourceCode":"veryDeepCopy\r\t\"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy.\"\r\r\t| copier new |\r\tcopier := DeepCopier new initialize: 4096 \"self initialDeepCopierSize\".\r\tnew := self veryDeepCopyWith: copier.\r\tcopier references associationsDo: [:assoc | \r\t\tassoc value veryDeepFixupWith: copier].\r\tcopier fixDependents.\r\t^ new"},{"name":"asOrderedCollection","linesOfCode":3,"sourceCode":"asOrderedCollection\r\t\"Answer an OrderedCollection with the receiver as its only element.\"\r\r\t^ OrderedCollection with: self"},{"name":"isAssociation","linesOfCode":2,"sourceCode":"isAssociation\r\t^ false"},{"name":"explicitRequirement","linesOfCode":24,"sourceCode":"explicitRequirement\r\t\"If one of the superclasses can perform the selector, we execute the method of that class, otherwise, the explicit requirement error is thrown\"\r\t<debuggerCompleteToSender>\r\t| originalMethod originalArguments errorBlock originalReceiver callingContext originalSelector |\r\terrorBlock := [ ^ self error: 'Explicitly required method' ].\r\tcallingContext := thisContext sender.\r\toriginalMethod := callingContext compiledCode method.\r\toriginalMethod isFromTrait\r\t\tifFalse: errorBlock.\r\toriginalReceiver := callingContext receiver.\r\toriginalSelector := originalMethod selector.\r\toriginalArguments := callingContext arguments.\r\toriginalReceiver class superclass\r\t\twithAllSuperclassesDo: [ :superClass | \r\t\t\tsuperClass\r\t\t\t\tcompiledMethodAt: originalSelector\r\t\t\t\tifPresent: [ :method | \r\t\t\t\t\t(method isProvided or: [ method isFromTrait not ])\r\t\t\t\t\t\tifTrue: [ callingContext\r\t\t\t\t\t\t\t\treturn:\r\t\t\t\t\t\t\t\t\t(method\r\t\t\t\t\t\t\t\t\t\tvalueWithReceiver: originalReceiver\r\t\t\t\t\t\t\t\t\t\targuments: originalArguments) ] ] ].\r\terrorBlock value"},{"name":"beWritableObject","linesOfCode":8,"sourceCode":"beWritableObject\r\t\"If the VM supports read-only objects it will not write to read-only objects.\r\t An attempt to write to an instance variable of a read-only object will\r\t cause the VM to send attemptToAssign:withIndex: to the read-only object.\r\t An attempt to modify a read-only object in a primitive will cause the\r\t primitive to fail with a #'no modification' error code.\r\t Set the read-only flag of the receiver to false and answer the previous vaue of the flag.\"\r\t^self setIsReadOnlyObject: false"},{"name":"copyFrom:","linesOfCode":12,"sourceCode":"copyFrom: anotherObject\r\t\"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  \"\r\r\t| mine his |\r\t<primitive: 168>\r\tmine := self class allInstVarNames.\r\this := anotherObject class allInstVarNames.\r\t1 to: (mine size min: his size) do: [:ind |\r\t\t(mine at: ind) = (his at: ind) ifTrue: [\r\t\t\tself instVarAt: ind put: (anotherObject instVarAt: ind)]].\r\tself class isVariable & anotherObject class isVariable ifTrue: [\r\t\t1 to: (self basicSize min: anotherObject basicSize) do: [:ind |\r\t\t\tself basicAt: ind put: (anotherObject basicAt: ind)]]."},{"name":"stepTimeIn:","linesOfCode":2,"sourceCode":"stepTimeIn: aSystemWindow\r\t\r\t^ 1000 \"milliseconds -- default backstop for objects serving as models of system windows\""},{"name":"gtInspectorInterestingObject","linesOfCode":2,"sourceCode":"gtInspectorInterestingObject\r\t^ self"},{"name":"isFloat","linesOfCode":3,"sourceCode":"isFloat\r\t\"Overridden to return true in Float, natch\"\r\t^ false"},{"name":"asDoubleLink","linesOfCode":2,"sourceCode":"asDoubleLink\r\t^ DoubleLink value: self"},{"name":"gtDebuggerEvaluatorIn:","linesOfCode":3,"sourceCode":"gtDebuggerEvaluatorIn: composite\r\t\r\t(GTObjectVariablesBrowser new evaluatorIn: composite)\r\t\ttitle: 'Evaluator'"},{"name":"refersToLiteral:","linesOfCode":2,"sourceCode":"refersToLiteral: aLitteral\r\t^ self literalEqual: aLitteral"},{"name":"isColor","linesOfCode":3,"sourceCode":"isColor\r\t\"Answer true if receiver is a Color. False by default.\"\r\r\t^ false\r"},{"name":"ffiCall:options:","linesOfCode":3,"sourceCode":"ffiCall: fnSpec options: callOptions\r\t<ffiCalloutTranslator>\r\t\r\tself ffiCall: fnSpec library: self ffiLibrary options: callOptions"},{"name":"asStringOrText","linesOfCode":3,"sourceCode":"asStringOrText\r\t\"Answer a string that represents the receiver.\"\r\r\t^ self asString "},{"name":"~~>","linesOfCode":13,"sourceCode":"~~> aValueLinkOrNil\r\t\"Answer a ValueLink between self and aValueLinkOrNil.\r\tThis message allows the receiver to be inserted in a chain of objects, terminated by nil.\"\r\r\t\"Code of ValueLink>>#nextLink: and ValueLink>>#value: are inline here for speed.\"\r\r\t\"(1 ~~> nil) = ValueLink new value: 1\"\r\t\"(1 ~~> 'one') value >>> 1\"\r\t\"(1 ~~> nil) nextLink >>> nil\"\r\r\t\"Note that `value` can be ANY object; on the other hand, `nextLink` should be either another \r\tValueLink object or nil.\"\r\r\t^ ValueLink basicNew\r\t\tvalue: self;\r\t\tnextLink: aValueLinkOrNil;\r\t\tyourself"},{"name":"link:toNodes:","linesOfCode":2,"sourceCode":"link: aMetaLink toNodes: nodes\r\tnodes do: [ :node | self link: aMetaLink toAST: node ]"},{"name":"in:","linesOfCode":3,"sourceCode":"in: aBlock\r\t\"Evaluate the given block with the receiver as its argument.\"\r\r\t^ aBlock value: self\r"},{"name":"inferDastrelTypeIn:for:","linesOfCode":2,"sourceCode":"inferDastrelTypeIn: context for: variable\r\t^ context error: 'Cannot infer type for captured object {1}.' format: {self printString} at: variable position"},{"name":"writeSlot:value:","linesOfCode":2,"sourceCode":"writeSlot: aSlot value: anObject\r\t^aSlot write: anObject to: self"},{"name":"notNil","linesOfCode":3,"sourceCode":"notNil\r\t\"Coerces nil to false and everything else to true.\"\r\r\t^true"},{"name":"deepCopy","linesOfCode":21,"sourceCode":"deepCopy\r\t\"Answer a copy of the receiver with its own copy of each instance variable. deepCopy does a deep copy. It should never be overridden and only be used if you want to get these very specific semantics.\rIt doesn't handle cycles, #veryDeepCopy does. In the future we will make it handle cycles and deprecate veryDeepCopy\"\r\r\r\t| newObject class index |\r\tclass := self class.\r\t(class == Object) ifTrue: [^self].\r\tclass isVariable\r\t\tifTrue: \r\t\t\t[index := self basicSize.\r\t\t\tnewObject := class basicNew: index.\r\t\t\t[index > 0]\r\t\t\t\twhileTrue: \r\t\t\t\t\t[newObject basicAt: index put: (self basicAt: index) deepCopy.\r\t\t\t\t\tindex := index - 1]]\r\t\tifFalse: [newObject := class basicNew].\r\tindex := class instSize.\r\t[index > 0]\r\t\twhileTrue: \r\t\t\t[newObject instVarAt: index put: (self instVarAt: index) deepCopy.\r\t\t\tindex := index - 1].\r\t^newObject"},{"name":"linearRampMultiply:","linesOfCode":2,"sourceCode":"linearRampMultiply: factor\r\t^ self * factor"},{"name":"windowIsClosing","linesOfCode":2,"sourceCode":"windowIsClosing\r\t\"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open.\"\r"},{"name":"isRectangle","linesOfCode":2,"sourceCode":"isRectangle\r\t^false"},{"name":"comeFullyUpOnReload:","linesOfCode":3,"sourceCode":"comeFullyUpOnReload: smartRefStream\r\t\"Normally this read-in object is exactly what we want to store.\"\r\r\t^ self"},{"name":"myDependents:","linesOfCode":5,"sourceCode":"myDependents: aCollectionOrNil\r\t\"Private. Set (or remove) the receiver's dependents list.\"\r\r\taCollectionOrNil\r\t\tifNil: [DependentsFields removeKey: self ifAbsent: []]\r\t\tifNotNil: [DependentsFields at: self put: aCollectionOrNil]"},{"name":"okToChange","linesOfCode":3,"sourceCode":"okToChange\r\t\"Allows a controller to ask this of any model\"\r\t^ true"},{"name":"haltOnAccess:","linesOfCode":4,"sourceCode":"haltOnAccess: access\r\taccess = #read ifTrue:[^self haltOnRead].\r\taccess = #write ifTrue:[^self haltOnWrite].\r\t^self haltOnAccess"},{"name":"implicitCastTo:","linesOfCode":2,"sourceCode":"implicitCastTo: targetType\r\t^ targetType validateImplicitCastOfValue: self"},{"name":"isSpAnnouncingObject","linesOfCode":2,"sourceCode":"isSpAnnouncingObject\r\r\t^ false"},{"name":"respondsTo:","linesOfCode":4,"sourceCode":"respondsTo: aSymbol \r\t\"Answer whether the method dictionary of the receiver's class contains \r\taSymbol as a message selector.\"\r\r\t^self class canUnderstand: aSymbol"},{"name":"notify:","linesOfCode":5,"sourceCode":"notify: aString \r\t\"Create and schedule a Notifier with the argument as the message in \r\torder to request confirmation before a process can proceed.\"\r\t<debuggerCompleteToSender>\r\tWarning signal: aString"},{"name":"isColorForm","linesOfCode":2,"sourceCode":"isColorForm\r\t^false"},{"name":"triggerEvent:with:","linesOfCode":5,"sourceCode":"triggerEvent: anEventSelector\rwith: anObject\r\r    ^self \r\t\ttriggerEvent: anEventSelector\r\t\twithArguments: { anObject }"},{"name":"representsSimpleAnnotationUser:","linesOfCode":2,"sourceCode":"representsSimpleAnnotationUser: someUserClass\r\r\t^self isKindOf: someUserClass"},{"name":"stonShouldWriteNilInstVars","linesOfCode":4,"sourceCode":"stonShouldWriteNilInstVars\r\t\"Return true if my instance variables that are nil should be written out, \r\tfalse otherwise. Overwrite when necessary. By default, return false.\"\r\t\r\t^ false"},{"name":"isRingResolved","linesOfCode":2,"sourceCode":"isRingResolved\r\r\t^ true"},{"name":"notYetImplemented","linesOfCode":4,"sourceCode":"notYetImplemented\r\t\"Announce that this message is not yet implemented\"\r\t<debuggerCompleteToSender>\r\tNotYetImplemented signalFor: thisContext sender selector"},{"name":"isSAsmBinaryObjectSection","linesOfCode":2,"sourceCode":"isSAsmBinaryObjectSection\r\t^ false"},{"name":"isPinnedInMemory","linesOfCode":7,"sourceCode":"isPinnedInMemory\r\t\"Answer if the receiver is pinned.  The VM's garbage collector routinely moves\r\t objects as it reclaims and compacts memory.  But it can also pin an object so\r\t that it will not be moved, which can make it easier to pass objects out through\r\t the FFI.\"\r\t<primitive: 183 error: ec>\r\t^self primitiveFailed"},{"name":"isPinned","linesOfCode":6,"sourceCode":"isPinned\r\t\"self\r\t\tdeprecated: 'Please use #isPinnedInMemory instead'\r\t\ttransformWith: '`@receiver isPinned' -> '`@receiver isPinnedInMemory'.\"\r\t\t\r\t^self isPinnedInMemory"},{"name":"gtInspectorVariableNodesIn:","linesOfCode":17,"sourceCode":"gtInspectorVariableNodesIn: aCollection\r\t\"This is a helper method that adds to the given collection all nodes modeling named and \r\tindexed attributes for the current object.\r\tSubclasses can override it to specialize what appears in the variables presentation.\"\r\t| indexableDisplayLimit top bottom topLimit bottomLimit |\r\t\r\tindexableDisplayLimit := GTInspector indexableDisplayLimit.        \r\ttop := 1.\r\tbottom := self basicSize.\r\ttopLimit    := indexableDisplayLimit min: bottom.\r\tbottomLimit := indexableDisplayLimit max: (bottom - indexableDisplayLimit).\r\r\ttop to: topLimit do: [ :index | \r\t\taCollection add: (GTInspectorIndexedNode hostObject: self index: index) ].\r\t\r\tbottomLimit + 1 to: bottom do: [ :index |\r\t\taCollection add: (GTInspectorIndexedNode hostObject: self index: index) ].\r\t\r\taCollection\r\t\taddAll: ((self class allSlots collect: [ :slot | \r\t\t\tGTInspectorSlotNode hostObject: self slot: slot ]))"},{"name":"gtInspectorActionSpot","linesOfCode":18,"sourceCode":"gtInspectorActionSpot\r\t<gtInspectorAction>\r\t^ GLMGenericAction new\r\t\taction: [ \r\t\t\tGTSpotterMorph new\r\t\t\t\textent: (self currentWorld width / 2.4 @ (self currentWorld height / 1.6)) asIntegerPoint;\r\t\t\t\t\"extent: 400@500;\"\r\t\t\t\tdoLayout;\r\t\t\t\tspotterModel: (GTSpotter on: self);\r\t\t\t\topenCenteredInWorld\r\t\t\t ];\r\t\ticon: GLMUIThemeExtraIcons glamorousSearch;\r\t\tcondition: [ \r\t\t\t\t| fakeStep |\r\t\t\t\tfakeStep := GTSpotter new newStep origin: self.\r\t\t\t\tself spotterProcessorsFor: fakeStep.\r\t\t\t\tfakeStep processors notEmpty ];\r\t\ttitle: 'Search'"},{"name":"isBehavior","linesOfCode":4,"sourceCode":"isBehavior\r\t\"Return true if the receiver is a behavior.\r\tNote: Do not override in any class except behavior.\"\r\t^false"},{"name":">>>","linesOfCode":6,"sourceCode":">>> anObject\r\t\"Return a pair. It is handy to support the tweaking of pharo doc expression. A pharo doc expression is a comment as the following one:\"\r\r\t\"4 + 3 >>> 7\"\r\t\r\t\"Pay attention when you write an executable comment for keyword-based method : surround with parentheses your expression because, otherwise the executable comment won't work as the message is binary.\"\r\t\r\t\"(1 max: 1000) >>> 1000\"\r\r\t^ self -> anObject "},{"name":"fuelAccept:","linesOfCode":13,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t\"Be careful because the order is important. For example, weak are also variable, but we need that weak objects send #visitWeakObject: and not #visitVariableObject: \"\r\tself class isFixed\r\t\tifTrue: [ ^ aGeneralMapper visitFixedObject: self ].\r\tself class isWeak\r\t\tifTrue: [ ^ aGeneralMapper visitWeakObject: self ].\r\tself class isPointers\r\t\tifTrue: [ ^ aGeneralMapper visitVariableObject: self ].\r\tself class isBytes\r\t\tifTrue: [ ^ aGeneralMapper visitBytesObject: self ].\r\tself class isWords\r\t\tifTrue: [\t^ aGeneralMapper visitWordsObject: self ].\r\tself error: 'Something is wrong!'"},{"name":"phlowValue:","linesOfCode":2,"sourceCode":"phlowValue: anObject\r\r\t^ self"},{"name":"isCollection","linesOfCode":3,"sourceCode":"isCollection\r\t\"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:\"\r\t^false"},{"name":"storeOn:","linesOfCode":24,"sourceCode":"storeOn: aStream \r\t\"Append to the argument aStream a sequence of characters that is an \r\texpression whose evaluation creates an object similar to the receiver.\"\r\r\taStream nextPut: $(.\r\tself class isVariable\r\t\tifTrue: [aStream nextPutAll: '(', self class name, ' basicNew: ';\r\t\t\t\t\tstore: self basicSize;\r\t\t\t\t\tnextPutAll: ') ']\r\t\tifFalse: [aStream nextPutAll: self class name, ' basicNew'].\r\t1 to: self class instSize do:\r\t\t[:i |\r\t\taStream nextPutAll: ' instVarAt: ';\r\t\t\tstore: i;\r\t\t\tnextPutAll: ' put: ';\r\t\t\tstore: (self instVarAt: i);\r\t\t\tnextPut: $;].\r\t1 to: self basicSize do:\r\t\t[:i |\r\t\taStream nextPutAll: ' basicAt: ';\r\t\t\tstore: i;\r\t\t\tnextPutAll: ' put: ';\r\t\t\tstore: (self basicAt: i);\r\t\t\tnextPut: $;].\r\taStream nextPutAll: ' yourself)'\r"},{"name":"metacelloSemanticStringLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloSemanticStringLessThanSelf: anInteger\r    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'"},{"name":"populateCBMenu:","linesOfCode":2,"sourceCode":"populateCBMenu: aMenu\r\r\taMenu add: 'Browse' target: self selector: #browse"},{"name":"asLiteralNode","linesOfCode":2,"sourceCode":"asLiteralNode\r\t^RBLiteralNode value: self"},{"name":"asSpotterProcessorLink","linesOfCode":2,"sourceCode":"asSpotterProcessorLink\r\r\t^ GTSpotterProcessorLink value: self"},{"name":"isPetit2Success","linesOfCode":2,"sourceCode":"isPetit2Success\r\t^ true"},{"name":"isToken","linesOfCode":2,"sourceCode":"isToken\r\t^ false"},{"name":"primitiveError:","linesOfCode":4,"sourceCode":"primitiveError: aString \r\t\"This method is called when the error handling results in a recursion in \r\tcalling on error: or halt or halt:.\"\r\r\tUIManager default onPrimitiveError: aString"},{"name":"inform:","linesOfCode":4,"sourceCode":"inform: aString\r\t\"Display a message for the user to read and then dismiss.\"\r\r\taString isEmptyOrNil\r\t\tifFalse: [ UIManager default inform: aString ]"},{"name":"isSymbol","linesOfCode":2,"sourceCode":"isSymbol\r\t^ false "},{"name":"pointer","linesOfCode":3,"sourceCode":"pointer\r\t\"Answers a pointer to me (see overrides for implementations)\"\r\tself error: 'You cannot get a pointer to me.'"},{"name":"longPrintString","linesOfCode":6,"sourceCode":"longPrintString\r\t\"Answer a String whose characters are a description of the receiver.\"\r\t\r\t| str |\r\tstr := String streamContents: [:aStream | self longPrintOn: aStream].\r\t\"Objects without inst vars should return something\"\r\t^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]"},{"name":"longPrintOn:","linesOfCode":11,"sourceCode":"longPrintOn: aStream\r\t\"Append to the argument, aStream, the names and values of all \r\tof the receiver's instance variables.\"\r\r\tself class allInstVarNames doWithIndex:\r\t\t[:title :index |\r\t\taStream nextPutAll: title;\r\t\t nextPut: $:;\r\t\t space;\r\t\t tab;\r\t\t print: (self instVarAt: index);\r\t\t cr]"},{"name":"fullDisplayString","linesOfCode":3,"sourceCode":"fullDisplayString\r\t\"Answer a String whose characters are a description of the receiver suitable for UI\"\r\r\t^ String streamContents: [:s | self displayStringOn: s]"},{"name":"triggerEvent:withArguments:","linesOfCode":4,"sourceCode":"triggerEvent: anEventSelector\rwithArguments: anArgumentList\r\r    ^(self actionForEvent: anEventSelector)\r        valueWithArguments: anArgumentList"},{"name":"shouldNotImplement","linesOfCode":5,"sourceCode":"shouldNotImplement\r\t\"Announce that, although the receiver inherits this message, \r\tit should not implement it.\"\r\t<debuggerCompleteToSender>\r\tShouldNotImplement signalFor: thisContext sender selector"},{"name":"gtDebuggerRawIn:","linesOfCode":4,"sourceCode":"gtDebuggerRawIn: composite\r\t\r\t(GTObjectVariablesBrowser new variablesIn: composite)\r\t\ttitle: 'Raw';\r\t\tsend: #value"},{"name":"treeNodeTail","linesOfCode":2,"sourceCode":"treeNodeTail\r\r\t^ nil"},{"name":"gtFilter","linesOfCode":3,"sourceCode":"gtFilter\r\t^ GTFilterBlock gtFilter\r\t\t"},{"name":"unpin","linesOfCode":6,"sourceCode":"unpin\r\t\"self\r\t\tdeprecated: 'Please use #unpinInMemory instead'\r\t\ttransformWith: '`@receiver unpin' -> '`@receiver unpinInMemory'.\"\r\t\t\r\tself unpinInMemory"},{"name":"clone","linesOfCode":18,"sourceCode":"clone\r\t\"Answer a shallow copy of the receiver.\"\r\t<primitive: 148 error: ec>\r\t| class newObject |\r\tec == #'insufficient object memory' ifFalse:\r\t\t[^self primitiveFailed].\r\t\"If the primitive fails due to insufficient memory, instantiate via basicNew: to invoke\r\t the garbage collector before retrying, and use copyFrom: to copy state.\"\r\tnewObject := (class := self class) isVariable\r\t\t\t\t\tifTrue: \r\t\t\t\t\t\t[class isCompiledMethodClass\r\t\t\t\t\t\t\tifTrue:\r\t\t\t\t\t\t\t\t[class newMethod: self basicSize - self initialPC + 1 header: self header]\r\t\t\t\t\t\t\tifFalse:\r\t\t\t\t\t\t\t\t[class basicNew: self basicSize]]\r\t\t\t\t\tifFalse:\r\t\t\t\t\t\t[class basicNew].\r\t^newObject copyFrom: self"},{"name":"valueWithArguments:","linesOfCode":2,"sourceCode":"valueWithArguments: aSequenceOfArguments\r\r\t^self"},{"name":"sizeInMemory","linesOfCode":6,"sourceCode":"sizeInMemory\r\tself class isImmediateClass\r\t\tifTrue: [ ^ 0 ].\r\t^ self class isVariable\r\t\tifTrue: [ self class byteSizeOfInstanceOfSize: self basicSize ]\r\t\tifFalse: [ self class byteSizeOfInstance ]"},{"name":"isValueHolder","linesOfCode":2,"sourceCode":"isValueHolder\r\r\t^ false"},{"name":"species","linesOfCode":8,"sourceCode":"species\r\t\"Answer the preferred class for reconstructing the receiver.  For example, \r\tcollections create new collections whenever enumeration messages such as \r\tcollect: or select: are invoked.  The new kind of collection is determined by \r\tthe species of the original collection.  Species and class are not always the \r\tsame.  For example, the species of Interval is Array.\"\r\t<primitive: 111>\r\t^self class"},{"name":"basicInspect","linesOfCode":2,"sourceCode":"basicInspect\r\t^ Smalltalk tools basicInspector inspect: self"},{"name":"hasBindingOf:","linesOfCode":2,"sourceCode":"hasBindingOf: aString\r\t^false"},{"name":"size","linesOfCode":7,"sourceCode":"size\r\t\"Primitive. Answer the number of indexable variables in the receiver. \r\tThis value is the same as the largest legal subscript. Essential. See Object \r\tdocumentation whatIsAPrimitive.\"\r\r\t<primitive: 62>\r\tself class isVariable ifFalse: [self errorNotIndexable].\r\t^ 0"},{"name":"asLink","linesOfCode":3,"sourceCode":"asLink\r\t\"Answer a string that represents the receiver.\"\r\r\t^ ValueLink value: self"},{"name":"readDataFrom:size:","linesOfCode":21,"sourceCode":"readDataFrom: aDataStream size: varsOnDisk\r\t\"Fill in the fields of self based on the contents of aDataStream.  Return self.\r\t Read in the instance-variables written by Object>>storeDataOn:.\r\t NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.\r\t Allow aDataStream to have fewer inst vars.  See SmartRefStream.\"\r\t| cntInstVars cntIndexedVars |\r\r\tcntInstVars := self class instSize.\r\tself class isVariable\r\t\tifTrue: [cntIndexedVars := varsOnDisk - cntInstVars.\r\t\t\t\tcntIndexedVars < 0 ifTrue: [\r\t\t\t\t\tself error: 'Class has changed too much.  Define a convertxxx method']]\r\t\tifFalse: [cntIndexedVars := 0.\r\t\t\t\tcntInstVars := varsOnDisk]. \t\"OK if fewer than now\"\r\r\taDataStream beginReference: self.\r\t1 to: cntInstVars do:\r\t\t[:i | self instVarAt: i put: aDataStream next].\r\t1 to: cntIndexedVars do:\r\t\t[:i | self basicAt: i put: aDataStream next].\r\t\"Total number read MUST be equal to varsOnDisk!\"\r\t^ self\t\"If we ever return something other than self, fix calls \r\t\t\ton (super readDataFrom: aDataStream size: anInteger)\""},{"name":"ffiCalloutIn:","linesOfCode":5,"sourceCode":"ffiCalloutIn: aContext\r\t\"For backwards compatibility.\r\tIt receives the context that is performing the ffi callout.\r\tThis context will be used to know what method to compile and where to restart the execution\"\r\t^ self calloutAPIClass inContext: aContext"},{"name":"calloutAPIClass","linesOfCode":2,"sourceCode":"calloutAPIClass\r\t^ self ffiLibrary calloutAPIClass"},{"name":"wantsDroppedMorph:event:inMorph:","linesOfCode":2,"sourceCode":"wantsDroppedMorph: aMorph event: anEvent inMorph: destinationLM \r\t^false "},{"name":"update:","linesOfCode":5,"sourceCode":"update: aParameter \r\t\"Receive a change notice from an object of whom the receiver is a \r\tdependent. The default behavior is to do nothing; a subclass might want \r\tto change itself in some way.\"\r\r\t^ self"},{"name":"isSLVMMessagePackExtensionData","linesOfCode":2,"sourceCode":"isSLVMMessagePackExtensionData\r\t^ false"},{"name":"isStream","linesOfCode":3,"sourceCode":"isStream\r\t\"Return true if the receiver responds to the stream protocol\"\r\t^false\r"},{"name":"metacelloSemanticIntegerLessThanSelf:","linesOfCode":2,"sourceCode":"metacelloSemanticIntegerLessThanSelf: anInteger\r    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'"},{"name":"metacelloVersionComponentLessThan:","linesOfCode":2,"sourceCode":"metacelloVersionComponentLessThan: aMetacelloVersonComponent\r\r\t^self error: 'Invalid Metacello verson component - should be String or Integer.'"},{"name":"storeDataOn:","linesOfCode":14,"sourceCode":"storeDataOn: aDataStream\r\t\"Store myself on a DataStream.  Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  NOTE: This method must send 'aDataStream beginInstance:size:' and then (nextPut:/nextPutWeak:) its subobjects.  readDataFrom:size: reads back what we write here.\"\r\t| cntInstVars cntIndexedVars |\r\r\tcntInstVars := self class instSize.\r\tcntIndexedVars := self basicSize.\r\taDataStream\r\t\tbeginInstance: self class\r\t\tsize: cntInstVars + cntIndexedVars.\r\t1 to: cntInstVars do:\r\t\t[:i | aDataStream nextPut: (self instVarAt: i)].\r\r\t\"Write fields of a variable length object. \"\r\t(self class isBits) ifFalse: [\r\t\t1 to: cntIndexedVars do:\r\t\t\t[:i | aDataStream nextPut: (self basicAt: i)]].\r"},{"name":"stepAt:in:","linesOfCode":2,"sourceCode":"stepAt: millisecondClockValue in: aWindow\r\r\t^ self stepIn: aWindow"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ self subclassResponsibility"},{"name":"link:toTemporaryNamed:inMethod:","linesOfCode":6,"sourceCode":"link: aMetaLink toTemporaryNamed: aTempVarName inMethod: aMethodName\r\tself\r\t\tlink: aMetaLink\r\t\ttoTemporaryNamed: aTempVarName\r\t\tinMethod: aMethodName\r\t\toption: #all"},{"name":"~=","linesOfCode":4,"sourceCode":"~= anObject \r\t\"Answer whether the receiver and the argument do not represent the \r\tsame object.\"\r\r\t^self = anObject == false"},{"name":"ffiCall:library:options:","linesOfCode":8,"sourceCode":"ffiCall: fnSpec library: aLibrary options: callOptions\r\t<ffiCalloutTranslator>\r\t\r\t| ffiLibrary |\r\tffiLibrary := aLibrary asFFILibrary.\r\t^ (ffiLibrary calloutAPIClass inUFFIContext: thisContext)\r\t\tconvention: self ffiCallingConvention;\r\t\toptions: (ffiLibrary options), callOptions;\r\t\tfunction: fnSpec library: ffiLibrary"},{"name":"systemIconName","linesOfCode":2,"sourceCode":"systemIconName\r\r\t^ #classIcon"},{"name":"releaseActionMap","linesOfCode":2,"sourceCode":"releaseActionMap\r\r\tEventManager releaseActionMapFor: self"},{"name":"toFinalizeSend:to:with:","linesOfCode":10,"sourceCode":"toFinalizeSend: aSelector to: aFinalizer with: aResourceHandle\r\t\"When I am finalized (e.g., garbage collected) close the associated resource handle by sending aSelector to the appropriate finalizer (the guy who knows how to get rid of the resource).\r\tWARNING: Neither the finalizer nor the resource handle are allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken.\"\r\tself == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].\r\tself == aResourceHandle ifTrue:[self error: 'I cannot finalize myself'].\r\t^self finalizationRegistry add: self executor:\r\t\t(ObjectFinalizer new\r\t\t\treceiver: aFinalizer\r\t\t\tselector: aSelector\r\t\t\targument: aResourceHandle)"},{"name":"isRingFullyResolved","linesOfCode":2,"sourceCode":"isRingFullyResolved\r\r\t^ true"},{"name":"adaptToFloat:andSend:","linesOfCode":4,"sourceCode":"adaptToFloat: rcvr andSend: selector\r\t\"If no method has been provided for adapting an object to a Float,\r\tthen it may be adequate to simply adapt it to a number.\"\r\t^ self adaptToNumber: rcvr andSend: selector"},{"name":"stonPostReferenceResolution","linesOfCode":2,"sourceCode":"stonPostReferenceResolution\r\t\"Hook that is called when references were resolved processing this object or one of its sub objects. This will most probably influence hash values. Override to take appropriate action.\""},{"name":"asStyleVariable","linesOfCode":2,"sourceCode":"asStyleVariable\r\r\t^ SpStyleVariable newValue: self"},{"name":"basicAt:","linesOfCode":8,"sourceCode":"basicAt: index \r\t\"Primitive. Assumes receiver is indexable. Answer the value of an \r\tindexable element in the receiver. Fail if the argument index is not an \r\tInteger or is out of bounds. Essential. Do not override in a subclass. See \r\tObject documentation whatIsAPrimitive.\"\r\r\t<primitive: 60>\r\tindex isInteger ifTrue: [self errorSubscriptBounds: index].\r\tself errorNonIntegerIndex"},{"name":"fallbackMenuOn:","linesOfCode":2,"sourceCode":"fallbackMenuOn: aMenuMorph\r\t\"When pragma menu building goes wrong, a fallback menu is created. To add custom items to that menu, override me in subclasses. See WorldState>>#fallbackMenuOn: for an example\""},{"name":"notify:at:","linesOfCode":5,"sourceCode":"notify: aString at: location\r\tself \r\t\tdeprecated: 'use #notify:' \r\t\ttransformWith: '`@receiver notify: `@arg1 at: `@arg2' -> '`@receiver notify: `@arg1'.\r\tself notify: aString"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self subclassResponsibility"},{"name":"calypsoEnvironmentType","linesOfCode":2,"sourceCode":"calypsoEnvironmentType\r\r\t^self class"},{"name":"wantsStepsIn:","linesOfCode":2,"sourceCode":"wantsStepsIn: aSystemWindow\r\t\r\t^ self wantsSteps"},{"name":"metacelloSemanticVersionComponentLessThan:","linesOfCode":2,"sourceCode":"metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent\r    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'"},{"name":"dragTransferTypeForMorph:","linesOfCode":2,"sourceCode":"dragTransferTypeForMorph: dragSource \r\t^nil"},{"name":"adaptToInteger:andCompare:","linesOfCode":4,"sourceCode":"adaptToInteger: rcvr andCompare: selector \r\t\"If I am involved in comparison with an Integer.\r\tDefault behaviour is to process comparison as any other selectors.\"\r\t^ self adaptToInteger: rcvr andSend: selector"},{"name":"asStringMorph","linesOfCode":3,"sourceCode":"asStringMorph\r\t\"Open a StringMorph, as best one can, on the receiver\"\r\r\t^ self asString asStringMorph\r"},{"name":"isMbndVTablePointerValue","linesOfCode":2,"sourceCode":"isMbndVTablePointerValue\r\t^ false"},{"name":"matchesQueryBrowserFilter:","linesOfCode":2,"sourceCode":"matchesQueryBrowserFilter: aQueryBrowserFilter\r\r\t^self calypsoEnvironmentType match: self forQueryBrowserFilter: aQueryBrowserFilter"},{"name":"isNumber","linesOfCode":3,"sourceCode":"isNumber\r\t\"Overridden to return true in Number, natch\"\r\t^ false"},{"name":"updateableActionMap","linesOfCode":2,"sourceCode":"updateableActionMap\r\r\t^EventManager updateableActionMapFor: self"},{"name":"isClassOrTrait","linesOfCode":2,"sourceCode":"isClassOrTrait\r\t^ self isClass or: [ self isTrait ]"},{"name":"pinInMemory","linesOfCode":6,"sourceCode":"pinInMemory\r\t\"The VM's garbage collector routinely moves objects as it reclaims and compacts\r\t memory. But it can also pin an object so that it will not be moved, which can make\r\t it easier to pass objects out through the FFI.  Objects are unpinnned when created.\r\t This method ensures an object is pinned, and answers whether it was already pinned.\"\r\t^self setPinnedInMemory: true"},{"name":"isRWElement","linesOfCode":2,"sourceCode":"isRWElement\r\t^ false"},{"name":"at:put:","linesOfCode":16,"sourceCode":"at: index put: value \r\t\"Primitive. Assumes receiver is indexable. Store the argument value in \r\tthe indexable element of the receiver indicated by index. Fail if the \r\tindex is not an Integer or is out of bounds. Or fail if the value is not of \r\tthe right type for this kind of collection. Answer the value that was \r\tstored. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 61>\r\tindex isInteger \r\t\tifTrue: [self class isVariable\r\t\t\tifTrue: [(index between: 1 and: self size)\r\t\t\t\tifFalse: [ ^ self errorSubscriptBounds: index]]\r\t\t\tifFalse: [ ^ self errorNotIndexable ]]\r\t\tifFalse: [ ^ self errorNonIntegerIndex ].\r\tself isReadOnlyObject \r\t\tifTrue: [ ^ self modificationForbiddenFor: #at:put: index: index value: value ].\r\tself errorImproperStore "},{"name":"veryDeepCopyWith:","linesOfCode":40,"sourceCode":"veryDeepCopyWith: deepCopier\r\t\"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied.\"\r\t\r\t| class selfNumberOfInstanceVariables fieldOfSelf copyOfSelf currentClass hasVeryDeepInnerMethod currentNumberOfInstanceVariables |\r\t\r\tdeepCopier references at: self ifPresent: [ :newer | \t\"already copied\" ^ newer].\r\tclass := self class.\r\tclass isMeta ifTrue: [ \"a metaclass\" ^ self ].\r\tcopyOfSelf := self shallowCopy.\r\tdeepCopier references at: self put: copyOfSelf.\t\"remember\"\r\t\t\r\t(class isVariable and: [class isPointers]) ifTrue: [\r\t\tself basicSize to: 1 by: -1 do: [ :i |\r\t\t\tfieldOfSelf := self basicAt: i. \r\t\t\tcopyOfSelf \r\t\t\t\tbasicAt: i\r\t\t\t\tput: (deepCopier references \r\t\t\t\t\tat: fieldOfSelf\r\t\t\t\t\tifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ])]].\r\t\r\t\"Ask each superclass if it wants to share (weak copy) any inst vars\"\r\tcopyOfSelf veryDeepInner: deepCopier.\r\r\t\"other superclasses want all instance variables deep copied\"\r\tcurrentClass := class.  \r\tselfNumberOfInstanceVariables := class instSize.\r\t\r\t[ selfNumberOfInstanceVariables == 0 ] whileFalse: [\r\t\thasVeryDeepInnerMethod := currentClass includesSelector: #veryDeepInner:.\r\t\tcurrentNumberOfInstanceVariables := currentClass instSize - currentClass superclass instSize.\r\t\thasVeryDeepInnerMethod \r\t\t\tifTrue: [\"skip inst vars\"\r\t\t\t\tselfNumberOfInstanceVariables := selfNumberOfInstanceVariables - currentNumberOfInstanceVariables]\t\r\t\t\tifFalse: [ \r\t\t\t\tcurrentNumberOfInstanceVariables timesRepeat: [ \r\t\t\t\t\tfieldOfSelf := self instVarAt: selfNumberOfInstanceVariables.\r\t\t\t\t\tcopyOfSelf \r\t\t\t\t\t\tinstVarAt: selfNumberOfInstanceVariables \r\t\t\t\t\t\tput: (deepCopier references \r\t\t\t\t\t\t\tat: fieldOfSelf \r\t\t\t\t\t\t\tifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ]).\r\t\t\t\t\tselfNumberOfInstanceVariables := selfNumberOfInstanceVariables - 1 ]].\r\t\tcurrentClass := currentClass superclass ].\r\t\t\r\t^ copyOfSelf\r"},{"name":"className","linesOfCode":3,"sourceCode":"className\r\t\"Answer a string characterizing the receiver's class, for use in list views for example\"\r\r\t^ self class name asString"},{"name":"ffiCallingConvention","linesOfCode":2,"sourceCode":"ffiCallingConvention\r\t^ OSPlatform current ffiCallingConvention"},{"name":"traceCrTab:","linesOfCode":4,"sourceCode":"traceCrTab: anObject\r\t\"Log the argument. Use self traceCr: 'something' instead of Transcript show: 'something'  ; cr \"\r\t\r\tself trace: anObject.\r\tTranscript cr ; tab"},{"name":"longPrintOn:limitedTo:indent:","linesOfCode":12,"sourceCode":"longPrintOn: aStream limitedTo: sizeLimit indent: indent\r\t\"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  Limit is the length limit for each inst var.\"\r\r\tself class allInstVarNames doWithIndex:\r\t\t[:title :index |\r\t\tindent timesRepeat: [aStream tab].\r\t\taStream nextPutAll: title;\r\t\t nextPut: $:;\r\t\t space;\r\t\t tab;\r\t\t nextPutAll: \r\t\t\t((self instVarAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1));\r\t\t cr]"},{"name":"deprecated:on:in:transformWith:","linesOfCode":10,"sourceCode":"deprecated: anExplanationString on: date in: version transformWith: aRule\r\t\"Automatically tranform the deprecated call\"\r\t\r\tDeprecation new\r\t\tcontext: thisContext sender;\r\t\texplanation: anExplanationString;\r\t\tdate: date;\r\t\tversion: version;\r\t\trule: aRule;\r\t\ttransform.\r\t\t"},{"name":"addDependent:","linesOfCode":7,"sourceCode":"addDependent: anObject\r\t\"Make the given object one of the receiver's dependents.\"\r\r\t| dependents |\r\tdependents := self dependents.\r\t(dependents includes: anObject) ifFalse:\r\t\t[self myDependents: (dependents copyWithDependent: anObject)].\r\t^ anObject"},{"name":"explore","linesOfCode":5,"sourceCode":"explore\r\tself\r\t\tdeprecated: 'Please use #inspect instead'\r\t\ttransformWith: '`@receiver explore' -> '`@receiver inspect'.\r\t\r\t^self inspect"},{"name":"instVarAt:","linesOfCode":7,"sourceCode":"instVarAt: index\r\t\"Primitive. Answer a fixed variable in an object. The numbering of the variables\r\t corresponds to the named instance variables, followed by the indexed instance\r\t variables. Fail if the index is not an Integer or is not the index of a fixed \r\t variable or indexed variable. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 173 error: ec>\r\tself primitiveFailed"},{"name":"shallowCopy","linesOfCode":20,"sourceCode":"shallowCopy\r\t\"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method.\"\r\t\r\t| class newObject index |\r\t<primitive: 148>\r\tclass := self class.\r\tclass isVariable\r\t\tifTrue: \r\t\t\t[index := self basicSize.\r\t\t\tnewObject := class basicNew: index.\r\t\t\t[index > 0]\r\t\t\t\twhileTrue: \r\t\t\t\t\t[newObject basicAt: index put: (self basicAt: index).\r\t\t\t\t\tindex := index - 1]]\r\t\tifFalse: [newObject := class basicNew].\r\tindex := class instSize.\r\t[index > 0]\r\t\twhileTrue: \r\t\t\t[newObject instVarAt: index put: (self instVarAt: index).\r\t\t\tindex := index - 1].\r\t^ newObject"},{"name":"systemNavigation","linesOfCode":2,"sourceCode":"systemNavigation\r\r\t^ SystemNavigation new"},{"name":"asBeaconSignal","linesOfCode":2,"sourceCode":"asBeaconSignal\r\t^ WrapperSignal on: self"},{"name":"link:toMethodNamed:","linesOfCode":2,"sourceCode":"link: aMetaLink toMethodNamed: aMethodName\r\tself link: aMetaLink toAST: (self nonAnonymousClass lookupSelector: aMethodName asSymbol) ast"},{"name":"isSysmelObjectFileTarget","linesOfCode":2,"sourceCode":"isSysmelObjectFileTarget\r\t^ false"},{"name":"isSGPUBlockClosure","linesOfCode":2,"sourceCode":"isSGPUBlockClosure\r\t^ false"},{"name":"beRecursivelyReadOnlyObject","linesOfCode":2,"sourceCode":"beRecursivelyReadOnlyObject\r\t^self recursivelySetIsReadOnlyObject: true"},{"name":"when:evaluate:","linesOfCode":8,"sourceCode":"when: anEventSelector evaluate: anAction \r\r\t| actions |\r\tactions := self actionSequenceForEvent: anEventSelector.\r\t(actions includes: anAction)\r\t\tifTrue: [^ self].\r\tself \r\t\tsetActionSequence: (actions copyWith: anAction)\r\t\tforEvent: anEventSelector"},{"name":"defaultLabel","linesOfCode":3,"sourceCode":"defaultLabel\r\t\"Answer the default label to be used in morphs.\"\r\r\t^ self class name"},{"name":"isMbndGenerateSymbolRemovedFromDebug","linesOfCode":2,"sourceCode":"isMbndGenerateSymbolRemovedFromDebug\r\t^ self isMbndAnonymousSymbol"},{"name":"wantsSteps","linesOfCode":4,"sourceCode":"wantsSteps\r\t\"Overridden by morphic classes whose instances want to be stepped,\r\tor by model classes who want their morphic views to be stepped.\"\r\r\t^ false"},{"name":"perform:withArguments:inSuperclass:","linesOfCode":14,"sourceCode":"perform: selector withArguments: argArray inSuperclass: lookupClass\r\t\"NOTE:  This is just like perform:withArguments:, except that\r\tthe message lookup process begins, not with the receivers's class,\r\tbut with the supplied superclass instead.  It will fail if lookupClass\r\tcannot be found among the receiver's superclasses.\r\tPrimitive. Essential. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 100>\r\tselector isSymbol\r\t\tifFalse: [ ^ self error: 'selector argument must be a Symbol' ].\r\tselector numArgs = argArray size\r\t\tifFalse: [ ^ self error: 'incorrect number of arguments' ].\r\t(self class includesBehavior: lookupClass)\r\t\tifFalse: [ ^ self error: 'lookupClass is not in my inheritance chain' ].\r\tself primitiveFailed"},{"name":"isHeap","linesOfCode":2,"sourceCode":"isHeap\r\r\t^ false"},{"name":"veryDeepFixupWith:","linesOfCode":3,"sourceCode":"veryDeepFixupWith: deepCopier\r\t\"I have no fields and no superclass.  Catch the super call.\"\r\t\r\t\"avoid to use me we will deprecate it in the future\""},{"name":"addModelItemsToWindowMenu:","linesOfCode":2,"sourceCode":"addModelItemsToWindowMenu: aMenu\r\t\"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic window.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself.\""},{"name":"isRGObject","linesOfCode":2,"sourceCode":"isRGObject\r\r\t^ false"},{"name":"asSpotterCandidateLink","linesOfCode":2,"sourceCode":"asSpotterCandidateLink\r\r\t^ GTSpotterCandidateLink value: self"},{"name":"perform:with:","linesOfCode":6,"sourceCode":"perform: aSymbol with: anObject \r\t\"Send the selector, aSymbol, to the receiver with anObject as its argument.\r\tFail if the number of arguments expected by the selector is not one.\r\tPrimitive. Optional. See Object documentation whatIsAPrimitive.\"\r\t\r\t<primitive: 83>\r\t^ self perform: aSymbol withArguments: {anObject}"},{"name":"isLiteral","linesOfCode":4,"sourceCode":"isLiteral\r\t\"Answer whether the receiver has a literal text form recognized by the \r\tcompiler.\"\r\r\t^false"},{"name":"halt:","linesOfCode":3,"sourceCode":"halt: aString \r\t<debuggerCompleteToSender>\r\tHalt now: aString"},{"name":"link:toSlot:","linesOfCode":3,"sourceCode":"link: aMetaLink toSlot: aSlot\r\t\"Object specific links cannot be put on slots\"\r\r\tself shouldNotImplement"},{"name":"isContext","linesOfCode":2,"sourceCode":"isContext\r\t^false"},{"name":"isPetitParser","linesOfCode":2,"sourceCode":"isPetitParser\r\t^ false"},{"name":"link:toTemporary:","linesOfCode":3,"sourceCode":"link: aMetaLink toTemporary: aTempVar\r\t\"Object specific links cannot be put on temporaries\"\r\r\tself shouldNotImplement"},{"name":"treeNodeHead","linesOfCode":2,"sourceCode":"treeNodeHead\r\r\t^ self"},{"name":"iconOrThumbnailOfSize:","linesOfCode":3,"sourceCode":"iconOrThumbnailOfSize: aNumberOrPoint \r\t\"Answer an appropiate form to represent the receiver\"\r\t^ nil"},{"name":"nbCall:module:options:","linesOfCode":10,"sourceCode":"nbCall: fnSpec module: aModuleNameOrHandle options: callOptions\r\t\"You can override this method if you need to\"\r\t<ffiCalloutTranslator>\r\tself\r\t\tdeprecated: 'use ffiCall:module:options: instead'\r\t\ttransformWith: '`@rec nbCall: `@arg1 module: `@arg2 options: `@arg3' -> '`@rec ffiCall: `@arg1 module: `@arg2 options: `@arg3'.\r\t\r\t^ (self ffiCalloutIn: thisContext sender)\r\t\tconvention: self ffiCallingConvention;\r\t\toptions: callOptions;\r\t\tfunction: fnSpec library: aModuleNameOrHandle"},{"name":"asMethodConstant","linesOfCode":10,"sourceCode":"asMethodConstant\r\t| const constNode link |\r\t\"this method will replace full sender message send of sender with me (or my value which usefull for block). So following sender method execution will not evaluate my receiver expresion but instead push precomputed literal with me\"\r\tconst := self value.\r\tconstNode := thisContext sender sourceNodeExecuted.\r\tlink := MetaLink new\r\t\tmetaObject: const;\r\t\tcontrol: #instead.\r\tconstNode link: link.\r\t^const"},{"name":"castTo:","linesOfCode":2,"sourceCode":"castTo: targetType\r\t^ targetType validateExplicitCastOfValue: self"},{"name":"isSLVMObject","linesOfCode":2,"sourceCode":"isSLVMObject\r\t^ false"},{"name":"haltOnCount:","linesOfCode":4,"sourceCode":"haltOnCount: anInteger\r\t\"Halts once when a count is reached\"\r\r\t<debuggerCompleteToSender>\r\tHalt onCount: anInteger"},{"name":"isEmbeddedBlock","linesOfCode":3,"sourceCode":"isEmbeddedBlock\r\t\"returns true for CleanBlockBlockClosure and CompiledBlock\"\r\t^ false"},{"name":"stepTime","linesOfCode":2,"sourceCode":"stepTime\r\t\r\t^ 1000 \"milliseconds -- default backstop for objects serving as models of system windows\""},{"name":"mourn","linesOfCode":4,"sourceCode":"mourn\r\t\"Sent by the new Finalization mechanism.\r\tAll weak objects (instances of weak classes) and Ephemerons may be mourned if they point to an object that needs to be collected.\r\t\r\tThis default implementation does nothing. To override in specific subclasses.\""},{"name":"nbCall:module:","linesOfCode":9,"sourceCode":"nbCall: fnSpec module: aModuleNameOrHandle\r\t\"You can override this method if you need to\"\r\t<ffiCalloutTranslator>\r\tself\r\t\tdeprecated: 'use ffiCall:module: instead'\r\t\ttransformWith: '`@rec nbCall: `@arg1 module: `@arg2' -> '`@rec ffiCall: `@arg1 module: `@arg2'.\r\t\r\t^ (self ffiCalloutIn: thisContext sender)\r\t\tconvention: self ffiCallingConvention;\r\t\tfunction: fnSpec library: aModuleNameOrHandle"},{"name":"phlowValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"phlowValue: anObject withEnoughArguments: aCollection\r\r\t^ self"},{"name":"adaptToInteger:andSend:","linesOfCode":4,"sourceCode":"adaptToInteger: rcvr andSend: selector\r\t\"If no method has been provided for adapting an object to a Integer,\r\tthen it may be adequate to simply adapt it to a number.\"\r\t^ self adaptToNumber: rcvr andSend: selector"},{"name":"haltOnce","linesOfCode":3,"sourceCode":"haltOnce\r\t<debuggerCompleteToSender>\r\tHalt once."},{"name":"isPetit2Failure","linesOfCode":2,"sourceCode":"isPetit2Failure\r\t^ false"},{"name":"isInteger","linesOfCode":3,"sourceCode":"isInteger\r\t\"Overridden to return true in Integer.\"\r\r\t^ false"},{"name":"gtInspectorRawIn:","linesOfCode":3,"sourceCode":"gtInspectorRawIn: composite\r\t\"This is the most basic presentation showing the state of the object\"\r\t^ composite custom: GTObjectVariablesBrowser new"},{"name":"gtIterator","linesOfCode":2,"sourceCode":"gtIterator\r\t^ Error signal: 'This is not a spotter iterator'"},{"name":"dragPassengerFor:inMorph:","linesOfCode":2,"sourceCode":"dragPassengerFor: item inMorph: dragSource \r\t^item"},{"name":"gtInspectorIcon","linesOfCode":2,"sourceCode":"gtInspectorIcon\r\t^ self iconOrThumbnailOfSize: 16"},{"name":"spotterProcessorsFor:","linesOfCode":17,"sourceCode":"spotterProcessorsFor: aSpotterStep\r\t\"This is a utility method that collects all extensions (processors) for the current object.\r\tBy default, it simply looks for the #spotterOrder: pragma.\r\tThe step can decice whether or not an extension should be enabled.\r\tThe step can also configure each extension (e.g. override any property)\"\r\t\r\t^ (((Pragma \r\t\tallNamed: #spotterOrder:\r\t\tfrom: self class \r\t\tto: Object)\r\t\t\tselect: [:pragma | aSpotterStep processorsFilter shouldEnableProcessorsCreateBy: pragma method])\r\t\t\tsort: [ :first :second | (first argumentAt: 1) < (second argumentAt: 1) ])\r\t\t\tdo: [ :pragma ||currentSize|\r\t\t\t\tcurrentSize := aSpotterStep processors size.\r\t\t\t\tself spotterProcessorsFor: aSpotterStep pragma: pragma.\r\t\t\t\taSpotterStep \"configure the new processors if required\"\r\t\t\t\t\tconfigureProcessorsStartingAt: currentSize+1 \r\t\t\t\t\twith: (aSpotterStep processorsFilter configurationBlockForProcessorsCreatedBy: pragma method)]"},{"name":"finalizationRegistry","linesOfCode":3,"sourceCode":"finalizationRegistry\r\t\"Answer the finalization registry associated with the receiver.\"\r\t^WeakRegistry default"},{"name":"pointsOnlyWeaklyTo:","linesOfCode":7,"sourceCode":"pointsOnlyWeaklyTo: anObject\r\t\"Assume, we already know that receiver points to an object,\r\tanswer true if receiver points only weakly to it \"\r\t\r\tself class isWeak ifFalse: [ ^ false ].\r\t1 to: self class instSize do:\r\t\t[:i | (self instVarAt: i) == anObject ifTrue: [^ false]].\r\t^ true"},{"name":"asBrick","linesOfCode":2,"sourceCode":"asBrick\r\r\t^ GLMMorphBrick on: self asMorph"},{"name":"changed:with:","linesOfCode":5,"sourceCode":"changed: anAspect with: anObject\r\t\"Receiver changed. The change is denoted by the argument anAspect. \r\tUsually the argument is a Symbol that is part of the dependent's change \r\tprotocol. Inform all of the dependents. Also pass anObject for additional information.\"\r\r\tself dependents do: [:aDependent | aDependent update: anAspect with: anObject]"},{"name":"transferFor:from:","linesOfCode":2,"sourceCode":"transferFor: passenger from: aMorph\r\r\t^ TransferMorph withPassenger: passenger from: aMorph"},{"name":"release","linesOfCode":4,"sourceCode":"release\r\t\"Remove references to objects that may refer to the receiver. This message \r\tshould be overridden by subclasses with any cycles, in which case the \r\tsubclass should also include the expression super release.\"\r\r\t"},{"name":"isSystemWindow","linesOfCode":3,"sourceCode":"isSystemWindow\r\"answer whatever the receiver is a SystemWindow\"\r\t^ false"},{"name":"as:","linesOfCode":4,"sourceCode":"as: aSimilarClass\r\t\"Create an object of class aSimilarClass that has similar contents to the receiver if the object is not already an instance of this class.\"\r\r\taSimilarClass == self class ifTrue: [ ^ self ].\r\r\t^ aSimilarClass newFrom: self"},{"name":"isMbndSymbolBinding","linesOfCode":2,"sourceCode":"isMbndSymbolBinding\r\t^ false"},{"name":"doesNotUnderstand:","linesOfCode":13,"sourceCode":"doesNotUnderstand: aMessage \r\t<debuggerCompleteToSender>\r\t \"Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector).\"\r\t\"Testing: (3 activeProcess)\"\r\t\t\r\t| exception resumeValue |\r\t(exception := MessageNotUnderstood new)\r\t\tmessage: aMessage;\r\t\treceiver: self.\r\tresumeValue := exception signal.\r\t^exception reachedDefaultHandler\r\t\tifTrue: [aMessage sentTo: self]\r\t\tifFalse: [resumeValue]"},{"name":"split:","linesOfCode":11,"sourceCode":"split: aSequenceableCollection\r\t\"Split the argument using the receiver as a separator.\"\r\t\"optimized version for single delimiters\"\r\t\"($/ split: '/foo/bar')>>>#('' 'foo' 'bar') asOrderedCollection\"\r\t\"([:c| c isSeparator] split: 'aa bb cc dd')>>> #('aa' 'bb' 'cc' 'dd') asOrderedCollection\"\r\t\t\r\t| result |\r\tresult := OrderedCollection new: (aSequenceableCollection size / 2) asInteger.\r\tself split: aSequenceableCollection do: [ :item |\r\t\tresult add: item ].\r\t^ result\r"},{"name":"asPresenter","linesOfCode":2,"sourceCode":"asPresenter\r\r\t^ self asString asPresenter"},{"name":"isSpecContainer","linesOfCode":2,"sourceCode":"isSpecContainer\r\t^ false"},{"name":"when:send:to:","linesOfCode":8,"sourceCode":"when: anEventSelector\rsend: aMessageSelector\rto: anObject\r \r    self\r        when: anEventSelector\r        evaluate: (WeakMessageSend\r            receiver: anObject\r            selector: aMessageSelector)"},{"name":"fromSton:","linesOfCode":8,"sourceCode":"fromSton: stonReader\r\t\"Decode non-variable classes from a map of their instance variables and values.\r\tOverride to customize and add a matching #toSton: (see implementors).\"\r\t\r\tself class isVariable \r\t\tifTrue: [\r\t\t\tstonReader error: 'custom #fromSton: implementation needed for variable/indexable class' ]\r\t\tifFalse: [\r\t\t\tstonReader parseNamedInstVarsFor: self ]"},{"name":"modelWakeUpIn:","linesOfCode":2,"sourceCode":"modelWakeUpIn: aWindow\r\t\"A window with me as model is being entered or expanded.  Default response is no-op\" "},{"name":"unwrapMbndValue","linesOfCode":2,"sourceCode":"unwrapMbndValue\r\t^ self"},{"name":"logExecution","linesOfCode":2,"sourceCode":"logExecution\r\tself traceCr: 'Executing ' , thisContext sender printString"},{"name":"inspectInExternalWindow","linesOfCode":2,"sourceCode":"inspectInExternalWindow\r\t^ GTInspector new openInExternalWindowOn: self"},{"name":"ffiCall:module:options:","linesOfCode":3,"sourceCode":"ffiCall: fnSpec module: aModuleName options: callOptions\r\t<ffiCalloutTranslator>\r\t\r\tself ffiCall: fnSpec library: aModuleName options: callOptions"},{"name":"displayStringLimitedTo:","linesOfCode":4,"sourceCode":"displayStringLimitedTo: limit\r\t\"Answer a String whose characters are a description of the receiver.\r\tIf you want to print without a character limit, use fullDisplayString.\"\r\t^self printStringLimitedTo: limit using: [:s | self displayStringOn: s]"},{"name":"stonContainSubObjects","linesOfCode":4,"sourceCode":"stonContainSubObjects\r\t\"Return true if I contain subObjects that should be processed, false otherwise.\r\tOverwrite when necessary. See also #stonProcessSubObjects:\"\r\t\r\t^ true"},{"name":"nbCall:","linesOfCode":9,"sourceCode":"nbCall: fnSpec\r\t\"You can override this method if you need to\"\r\t<ffiCalloutTranslator>\r\tself\r\t\tdeprecated: 'use ffiCall: instead'\r\t\ttransformWith: '`@rec nbCall: `@arg' -> '`@rec ffiCall: `@arg'.\r\t\r\t^ (self ffiCalloutIn: thisContext sender)\r\t\tconvention: self ffiCallingConvention;\r\t\tfunction: fnSpec library: self ffiLibraryName"},{"name":"brickValue:","linesOfCode":2,"sourceCode":"brickValue: aBrick\r\r\t^ self"},{"name":"isStonReference","linesOfCode":2,"sourceCode":"isStonReference\r\t^ false"},{"name":"setPinnedInMemory:","linesOfCode":8,"sourceCode":"setPinnedInMemory: aBoolean\r\t\"The VM's garbage collector routinely moves objects as it reclaims and compacts\r\t memory. But it can also pin an object so that it will not be moved around in memory,\r    while still being reclamable by the garbage collector. This can make\r\t it easier to pass objects out through the FFI. Objects are unpinnned when created.\r\t This primitive either pins or unpins an object, and answers if it was already pinned.\"\r\t<primitive: 184 error: ec>\r\t^self primitiveFailed"},{"name":"printAsConstantQueryItem","linesOfCode":2,"sourceCode":"printAsConstantQueryItem\r\t^self printString"},{"name":"perform:","linesOfCode":6,"sourceCode":"perform: aSymbol \r\t\"Send the unary selector, aSymbol, to the receiver.\r\tFail if the number of arguments expected by the selector is not zero.\r\tPrimitive. Optional. See Object documentation whatIsAPrimitive.\"\r\t\r\t<primitive: 83>\r\t^ self perform: aSymbol withArguments: #()"},{"name":"asWidget","linesOfCode":2,"sourceCode":"asWidget\r\r\t^ self"},{"name":"haltOnAccessTo:","linesOfCode":2,"sourceCode":"haltOnAccessTo: aVariableName\r\t^VariableBreakpoint watchVariable: aVariableName inObject: self"},{"name":"haltOnRead","linesOfCode":2,"sourceCode":"haltOnRead\r\t^VariableBreakpoint watchVariablesReadsInObject: self"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeObject: self"},{"name":"isMbndAbstractValue","linesOfCode":2,"sourceCode":"isMbndAbstractValue\r\t^ false"},{"name":"brickValue:withEnoughArguments:","linesOfCode":2,"sourceCode":"brickValue: anObject withEnoughArguments: aCollection\r\r\t^ self"},{"name":"recursivelySetIsReadOnlyObject:","linesOfCode":2,"sourceCode":"recursivelySetIsReadOnlyObject: aBoolean\r\t^self recursivelySetIsReadOnlyObject: aBoolean exceptObjectsIn: IdentitySet new"},{"name":"changed:","linesOfCode":5,"sourceCode":"changed: aParameter \r\t\"Receiver changed. The change is denoted by the argument aParameter. \r\tUsually the argument is a Symbol that is part of the dependent's change \r\tprotocol. Inform all of the dependents.\"\r\r\tself dependents do: [:aDependent | aDependent update: aParameter]"},{"name":"setPinned:","linesOfCode":6,"sourceCode":"setPinned: aBoolean\r\t\"self\r\t\tdeprecated: 'Please use #setPinnedInMemory: instead'\r\t\ttransformWith: '`@receiver setPinned: `@statements' -> '`@receiver setPinnedInMemory: `@statements'.\"\r\t\t\r\tself setPinnedInMemory: aBoolean"},{"name":"actionSequenceForEvent:","linesOfCode":5,"sourceCode":"actionSequenceForEvent: anEventSelector\r\r    ^(self actionMap\r        at: anEventSelector asSymbol\r        ifAbsent: [^WeakActionSequence new])\r            asActionSequence"},{"name":"retryWithGC:until:","linesOfCode":10,"sourceCode":"retryWithGC: execBlock until: testBlock\r\t\"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try.\"\r\t| blockValue |\r\tblockValue := execBlock value.\r\t(testBlock value: blockValue) ifTrue:[^blockValue].\r\tSmalltalk garbageCollectMost.\r\tblockValue := execBlock value.\r\t(testBlock value: blockValue) ifTrue:[^blockValue].\r\tSmalltalk garbageCollect.\r\t^execBlock value."},{"name":"haltIfNotTest","linesOfCode":4,"sourceCode":"haltIfNotTest\r\t\"Halt if execution was not started by a test. This is useful as this means one can just run tests undisturbed, while a execution for example from the Playground would be halted\"\r\t<debuggerCompleteToSender>\r\tHalt ifNotTest"},{"name":"nbCall:options:","linesOfCode":10,"sourceCode":"nbCall: fnSpec options: callOptions\r\t\"You can override this method if you need to\"\r\t<ffiCalloutTranslator>\r\tself\r\t\tdeprecated: 'use ffiCall:options: instead'\r\t\ttransformWith: '`@rec nbCall: `@arg1 options: `@arg2' -> '`@rec ffiCall: `@arg1 options: `@arg2'.\r\t\r\t^ (self ffiCalloutIn: thisContext sender)\r\t\tconvention: self ffiCallingConvention;\r\t\toptions: callOptions;\r\t\tfunction: fnSpec library: self ffiLibraryName"},{"name":"join:","linesOfCode":4,"sourceCode":"join: aSequenceableCollection\r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\"(Character space join: #('Pharo' 'is' 'cool')) >>> 'Pharo is cool'\"\r\t\r\t^ (Array with: self) join: aSequenceableCollection"},{"name":"isString","linesOfCode":3,"sourceCode":"isString\r\t\"Overridden to return true in String, natch\"\r\t^ false"},{"name":"deprecated:","linesOfCode":6,"sourceCode":"deprecated: anExplanationString\r\t\"Warn that the sending method has been deprecated\"\r\t\r\tDeprecation new\r\t\tcontext: thisContext sender;\r\t\texplanation: anExplanationString;\r\t\tsignal"},{"name":"fuelAfterMaterialization","linesOfCode":2,"sourceCode":"fuelAfterMaterialization\r\t\"Materialization process will send this message after materializing instances of my class\""},{"name":"isRGUnresolvedValue","linesOfCode":2,"sourceCode":"isRGUnresolvedValue\r\r\t^ false"},{"name":"markAsRingResolved","linesOfCode":2,"sourceCode":"markAsRingResolved\r\r\t\"do nothing\""},{"name":"isMorph","linesOfCode":2,"sourceCode":"isMorph\r\r\t^ false"},{"name":"resultForLinearInterpolation","linesOfCode":2,"sourceCode":"resultForLinearInterpolation\r\t^ self"},{"name":"executor","linesOfCode":3,"sourceCode":"executor\r\t\"Return an object which can act as executor for finalization of the receiver\"\r\t^self shallowCopy actAsExecutor"},{"name":"stonProcessSubObjects:","linesOfCode":10,"sourceCode":"stonProcessSubObjects: block\r\t\"Execute block to (potentially) change each of my subObjects.\r\tIn general, all instance and indexable variables are processed.\r\tOverwrite when necessary. Not used when #stonContainSubObjects returns false.\"\r\t\r\t1 to: self class instSize do: [ :each |\r\t\tself instVarAt: each put: (block value: (self instVarAt: each)) ].\r\t(self class isVariable and: [ self class isBytes not ])\r\t\tifTrue: [\r\t\t\t1 to: self basicSize do: [ :each |\r\t\t\t\tself basicAt: each put: (block value: (self basicAt: each)) ] ]"},{"name":"link:toClassVariableNamed:","linesOfCode":2,"sourceCode":"link: aMetaLink toClassVariableNamed: aClassVariableName\r\tself link: aMetaLink toClassVariableNamed: aClassVariableName option: #all"},{"name":"enclosedElement","linesOfCode":6,"sourceCode":"enclosedElement\r\t\"The receiver is included into a set as an element. \r\tSince some objects require wrappers (see SetElement) to be able to be included into a Set,\r\ta set sends this message to its element to make sure it getting real object,\r\tinstead of its wrapper.\r\tOnly SetElement instance or its subclasses allowed to answer something different than receiver itself\"\r\t\r"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\t\"I'm a hook method in the sense of Design Patterns TemplateHook/Methods. I'm called by copy. self is a shallow copy, subclasses should copy fields as necessary to complete the full copy\"\r\r\t^ self "},{"name":"inspect","linesOfCode":3,"sourceCode":"inspect\r\t\"Create and schedule an Inspector in which the user can examine the receiver's variables.\"\r\t^ Smalltalk tools inspector inspect: self"},{"name":"gtDisplayOn:","linesOfCode":3,"sourceCode":"gtDisplayOn: stream\r\t\"This offers a means to customize how the object is shown in the inspector\"\r\t^ self printOn: stream"},{"name":"veryDeepInner:","linesOfCode":3,"sourceCode":"veryDeepInner: deepCopier\r\t\"No special treatment for inst vars of my superclasses.  Override when some need to be weakly copied.  Object>>veryDeepCopyWith: will veryDeepCopy any inst var whose class does not actually define veryDeepInner:\"\r\r\t\"avoid to use me we will deprecate it in the future\""},{"name":"gtDisplayString","linesOfCode":9,"sourceCode":"gtDisplayString\r\t\"This offers a means to customize how the object is shown in the inspector.\r\tDo not override this method. Override gtDisplayOn: instead\"\r\t\t\r\t| limitedString limit |\r\tlimit := 1000.\r\tlimitedString := String streamContents: [:s | self gtDisplayOn: s] limitedTo: limit.\r\tlimitedString size < limit ifTrue: [^ limitedString].\r\t^ limitedString , ' ...'"},{"name":"hash","linesOfCode":4,"sourceCode":"hash\r\t\"Answer a SmallInteger whose value is related to the receiver's identity.\r\tMay be overridden, and should be overridden in any classes that define = \"\r\r\t^ self identityHash "},{"name":"wrappedInValueHolderIfNeeded","linesOfCode":2,"sourceCode":"wrappedInValueHolderIfNeeded\r\r\t^ self asValueHolder"},{"name":"removeAction:forEvent:","linesOfCode":5,"sourceCode":"removeAction: anAction\rforEvent: anEventSelector\r\r    self\r        removeActionsSatisfying: [:action | action = anAction]\r        forEvent: anEventSelector"},{"name":"evaluateMatchedPatternElement:","linesOfCode":2,"sourceCode":"evaluateMatchedPatternElement: matchedElement\r\t^ self"},{"name":"setIsReadOnlyObject:","linesOfCode":13,"sourceCode":"setIsReadOnlyObject: aBoolean\r\t\"If the VM supports read-only objects it will not write to read-only objects.\r\t An attempt to write to an instance variable of a read-only object will\r\t cause the VM to send attemptToAssign:withIndex: to the read-only object.\r\t An attempt to modify a read-only object in a primitive will cause the\r\t primitive to fail with a #'no modification' error code.\r\t This primitive sets the read-only flag of the receiver to the given\r\t value and answers the previous vaue of the flag.\r\t Note: Some objects can't be read-only, currently contexts and objects related\r\t to process scheduling (Processor, Process instances, Semaphore instances, ...)\"\r\t<primitive: 164 error: ec>\r\tself isImmediateObject ifTrue: [ ^true ].\r\t^self primitiveFailed\r\t"},{"name":"adoptForNewCalypsoQuery","linesOfCode":2,"sourceCode":"adoptForNewCalypsoQuery\r\r\t^self"},{"name":"logEntry","linesOfCode":2,"sourceCode":"logEntry\r\tself traceCr: 'Entered ' , thisContext sender printString"},{"name":"additionalInspectorClasses","linesOfCode":3,"sourceCode":"additionalInspectorClasses\r\t\"Answer addtional inspector classes that are used to show alternative views of instances of myself\"\r\r\t^ { }"},{"name":"inspectorNodes","linesOfCode":3,"sourceCode":"inspectorNodes\r\t\"Answer a list of attributes as nodes\"\r\t\r\t^ (StNodeCollector for: self) collectNodes"},{"name":"adaptToFloat:andCompare:","linesOfCode":4,"sourceCode":"adaptToFloat: rcvr andCompare: selector \r\t\"If I am involved in comparison with a Float.\r\tDefault behaviour is to process comparison as any other selectors.\"\r\t^ self adaptToFloat: rcvr andSend: selector"},{"name":"deprecated:on:in:","linesOfCode":8,"sourceCode":"deprecated: anExplanationString on: date in: version\r\t\"Warn that the sending method has been deprecated\"\r\t\r\tDeprecation new\r\t\tcontext: thisContext sender;\r\t\texplanation: anExplanationString;\r\t\tdate: date;\r\t\tversion: version;\r\t\tsignal"},{"name":"perform:with:with:with:with:","linesOfCode":7,"sourceCode":"perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject\r\t\"Send the selector, aSymbol, to the receiver with the given arguments.\r\tFail if the number of arguments expected by the selector is not four.\r\tPrimitive. Optional. See Object documentation whatIsAPrimitive.\"\r\r\t<primitive: 83>\r\t^ self perform: aSymbol\r\t\twithArguments: {firstObject . secondObject . thirdObject . fourthObject}"},{"name":"triggerEvent:","linesOfCode":3,"sourceCode":"triggerEvent: anEventSelector\r\t\"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action.\"\r\r    ^(self actionForEvent: anEventSelector) value"},{"name":"value","linesOfCode":2,"sourceCode":"value\r\r\t^self"},{"name":"complexContents","linesOfCode":2,"sourceCode":"complexContents\r\r\t^self"}],"meta":{"name":"Object class","instanceVariables":[],"methods":[{"name":"taskbarIcon","linesOfCode":3,"sourceCode":"taskbarIcon\r\t\"Answer the icon for an instance of the receiver in a task bar\"\r\r\t^self iconNamed: self taskbarIconName"},{"name":"decorateBrowserItem:by:","linesOfCode":4,"sourceCode":"decorateBrowserItem: aBrowserItem by: anEnvironmentPlugin\r\t^ anEnvironmentPlugin\r\t\tdecorateBrowserItem: aBrowserItem\r\t\tofObject: aBrowserItem actualObject"},{"name":"checkCalypsoItem:isEqualTo:","linesOfCode":2,"sourceCode":"checkCalypsoItem: anObject isEqualTo: anObject2\r\t^anObject = anObject2"},{"name":"fromSton:","linesOfCode":6,"sourceCode":"fromSton: stonReader\r\t\"Create a new instance and delegate decoding to instance side.\r\tOverride only when new instance should be created directly (see implementors). \"\r\t\r\t^ self new\r\t\tfromSton: stonReader;\r\t\tyourself"},{"name":"registerToolsOn:","linesOfCode":2,"sourceCode":"registerToolsOn: aToolRegistry\r\r\t\" Override to register any tools for Smalltalk tools registry. \" "},{"name":"itemsSortOrderForCalypso","linesOfCode":7,"sourceCode":"itemsSortOrderForCalypso\r\t\"This method allows specify order of group of concrete type of items \r\tLarger value will put items to the end of list comparing to the items of another type.\r\tBy default it is big value multiplied by hash of type. \r\tIt gives behavior where items of different type will be always splitted in the list\r\tand sorted separatelly\"\r\t^1000 * self hash"},{"name":"metacelloVersion:loads:","linesOfCode":5,"sourceCode":"metacelloVersion: versionString loads: anArrayOrString\r\t\"Stash the last version loaded and the list of packages loaded for that version. The list\r\t of packages will be used by the tools when doing 'Load Package Version'.\r\tSee MetacelloConfigTemplate for example\"\r\t\r\t\"noop by default\""},{"name":"checkCalypsoItem:isSameAs:","linesOfCode":2,"sourceCode":"checkCalypsoItem: anObject isSameAs: anObject2\r\t^anObject == anObject2"},{"name":"stonAllInstVarNames","linesOfCode":3,"sourceCode":"stonAllInstVarNames\r\t\"Override to encode my instances using a custom set of instance variables or to define their order.\"\r\t\r\t^ self allInstVarNames "},{"name":"asDastrelConversionTypeWith:","linesOfCode":2,"sourceCode":"asDastrelConversionTypeWith: codeConverter\r\tself error: 'Unsupported dastrel conversion as dastrel type.'"},{"name":"lastMetacelloVersionLoad","linesOfCode":4,"sourceCode":"lastMetacelloVersionLoad\r\t\"Answer the last version loaded and the list of packages loaded for that version.\r\t See MetacelloConfigTemplate.\"\r\r\t^nil -> 'default'"},{"name":"canonicalArgumentName","linesOfCode":10,"sourceCode":"canonicalArgumentName\r\t\"Imagine you write a method using this object (self) as argument, I return how you would likely \r\tname that argument. \r\tUsed by DynamicMessageImplementor in the debugger to create a template method when an execution \r\tcalls a method that does not exist.\"\r\t| prefix |\r\tprefix := self name first isVowel\r\t\tifTrue: [ 'an' ]\r\t\tifFalse: [ 'a' ].\r\t^ prefix, self name"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aSimilarObject\r\t\"Create an object that has similar contents to aSimilarObject. If the classes have any instance variables with the same names, copy them across. If this is bad for a class, override this method.\"\r\r\t^ (self isVariable\r\t\tifTrue: [self basicNew: aSimilarObject basicSize]\r\t\tifFalse: [self basicNew]) copySameFrom: aSimilarObject"},{"name":"approvedSelectorsForMethodFinder","linesOfCode":5,"sourceCode":"approvedSelectorsForMethodFinder\r\r\t^ #(at: basicAt: basicSize yourself size\r\t    ->\r\t    = == ~= hash literalEqual\r\t   )"},{"name":"reInitializeDependentsFields","linesOfCode":7,"sourceCode":"reInitializeDependentsFields\r\t<script>\r\r\t| oldFields |\r\toldFields := DependentsFields.\r\tDependentsFields := WeakIdentityKeyDictionary new.\r\toldFields\r\t\tkeysAndValuesDo: [ :obj :deps | deps do: [ :d | obj addDependent: d ] ]"},{"name":"readFrom:","linesOfCode":6,"sourceCode":"readFrom: textStringOrStream\r\t\"Create an object based on the contents of textStringOrStream.\"\r\r\t| object |\r\tobject := self class compiler evaluate: textStringOrStream.\r\t(object isKindOf: self) ifFalse: [self error: self name, ' expected'].\r\t^object"},{"name":"flushDependents","linesOfCode":5,"sourceCode":"flushDependents\r\tDependentsFields keysAndValuesDo:[:key :dep|\r\t\tkey ifNotNil:[key removeDependent: nil].\r\t].\r\tDependentsFields finalizeValues."},{"name":"printSystemPathTo:","linesOfCode":2,"sourceCode":"printSystemPathTo: myInstance\r\t^''"},{"name":"fileReaderServicesForFile:suffix:","linesOfCode":4,"sourceCode":"fileReaderServicesForFile: fullName suffix: suffix\r\t<fileService>\r\t\"Backstop\"\r\t^#()"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\t\"Object initialize\"\r\tDependentsFields ifNil:[ self initializeDependentsFields ]"},{"name":"taskbarIconName","linesOfCode":3,"sourceCode":"taskbarIconName\r\t\"Answer the icon for an instance of the receiver in a task bar\"\r\r\t^#smallWindowIcon"},{"name":"isCalypsoItemType:","linesOfCode":2,"sourceCode":"isCalypsoItemType: aClass\r\t^self includesBehavior: aClass"},{"name":"initializeDependentsFields","linesOfCode":3,"sourceCode":"initializeDependentsFields\r\t<script: 'Object initialize'>\r\t\r\tDependentsFields := WeakIdentityKeyDictionary new\r"},{"name":"asCalypsoItemContext","linesOfCode":2,"sourceCode":"asCalypsoItemContext\r\t^ClyBrowserItemContext itemType: self"},{"name":"asDastrelLiteralAt:inContext:for:","linesOfCode":4,"sourceCode":"asDastrelLiteralAt: aPosition inContext: context for: variable\r\t| instanceType literalNode |\r\tinstanceType := self asDastrelConversionTypeWith: context codeConverter.\r\t^ instanceType asDastrelTypeNode position: aPosition"},{"name":"howToModifyPrimitives","linesOfCode":46,"sourceCode":"howToModifyPrimitives\r\t\"You are allowed to write methods which specify primitives, but please use \r\tcaution.  If you make a subclass of a class which contains a primitive method, \r\tthe subclass inherits the primitive.  The message which is implemented \r\tprimitively may be overridden in the subclass (E.g., see at:put: in String's \r\tsubclass Symbol).  The primitive behavior can be invoked using super (see \r\tSymbol string:). \r\t \r\tA class which attempts to mimic the behavior of another class without being \r\tits subclass may or may not be able to use the primitives of the original class.  \r\tIn general, if the instance variables read or written by a primitive have the \r\tsame meanings and are in the same fields in both classes, the primitive will \r\twork.  \r\r\tFor certain frequently used 'special selectors', the compiler emits a \r\tsend-special-selector bytecode instead of a send-message bytecode.  \r\tSpecial selectors were created because they offer two advantages.  Code \r\twhich sends special selectors compiles into fewer bytes than normal.  For \r\tsome pairs of receiver classes and special selectors, the interpreter jumps \r\tdirectly to a primitive routine without looking up the method in the class.  \r\tThis is much faster than a normal message lookup. \r\t \r\tA selector which is a special selector solely in order to save space has a \r\tnormal behavior.  Methods whose selectors are special in order to \r\tgain speed contain the comment, 'No Lookup'.  When the interpreter \r\tencounters a send-special-selector bytecode, it checks the class of the \r\treceiver and the selector.  If the class-selector pair is a no-lookup pair, \r\tthen the interpreter swiftly jumps to the routine which implements the \r\tcorresponding primitive.  (A special selector whose receiver is not of the \r\tright class to make a no-lookup pair, is looked up normally).  The pairs are \r\tlisted below.  No-lookup methods contain a primitive number specification, \r\t<primitive: xx>, which is redundant.  Since the method is not normally looked \r\tup, deleting the primitive number specification cannot prevent this \r\tprimitive from running.  If a no-lookup primitive fails, the method is looked \r\tup normally, and the expressions in it are executed. \r\t \r\tNo Lookup pairs of (class, selector) \r\t \r\tSmallInteger with any of\t\t+ - * /  \\\\  bitOr: bitShift: bitAnd:  // \r\tSmallInteger with any of\t\t=  ~=  >  <  >=  <= \r\tAny class with\t\t\t\t\t== \r\tAny class with \t\t\t\t\t@ \r\tPoint with either of\t\t\t\tx y \r\tContext with\t\t\t\t\tblockCopy: \r\tBlockContext with either of \t\tvalue value:\r\t\"\r\r\tself error: 'comment only'"},{"name":"stonName","linesOfCode":4,"sourceCode":"stonName\r\t\"Override to encode my instances using a different class name.\r\tUse symbols as class name/tag.\"\r\t\r\t^ self name"},{"name":"taskbarLabel","linesOfCode":4,"sourceCode":"taskbarLabel\r\t\"Answer the label string for the receiver in a task bar\r\tor nil for the default.\"\r\r\t^nil"},{"name":"fileReaderServicesForDirectory:","linesOfCode":4,"sourceCode":"fileReaderServicesForDirectory: aFileDirectory\r\t<directoryService>\r\t\"Backstop\"\r\t^#()"},{"name":"prepareCalypsoItemCopy:","linesOfCode":1,"sourceCode":"prepareCalypsoItemCopy: aBrowserItem"},{"name":"whatIsAPrimitive","linesOfCode":62,"sourceCode":"whatIsAPrimitive\r\t\"Some messages in the system are responded to primitively. A primitive   \r\tresponse is performed directly by the interpreter rather than by evaluating   \r\texpressions in a method. The methods for these messages indicate the   \r\tpresence of a primitive response by including <primitive: xx> or \r\t<primitive: 79 error: ec>before the first expression in the method.   \r\t\r\tIn the second case, ec is a special temporary variable that holds an error code. \r\tIn the VM primitive, failure is indicated by a variable called primFailCode being \r\tnon-zero. On activating a method with a failing primitive, if the index is in \r\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \r\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \r\tit supplies the integer value.\r\t  \r\tPrimitives exist for several reasons. Certain basic or 'primitive' \r\toperations cannot be performed in any other way. Smalltalk without \r\tprimitives can move values from one variable to another, but cannot add two \r\tSmallIntegers together. Many methods for arithmetic and comparison \r\tbetween numbers are primitives. Some primitives allow Smalltalk to \r\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \r\tSome primitives exist only to make the system run faster; each does the same \r\tthing as a certain Smalltalk method, and its implementation as a primitive is \r\toptional.  \r\t  \r\tWhen the Smalltalk interpreter begins to execute a method which specifies a \r\tprimitive response, it tries to perform the primitive action and to return a \r\tresult. If the routine in the interpreter for this primitive is successful, \r\tit will return a value and the expressions in the method will not be evaluated. \r\tIf the primitive routine is not successful, the primitive 'fails', and the \r\tSmalltalk expressions in the method are executed instead. These \r\texpressions are evaluated as though the primitive routine had not been \r\tcalled.  \r\t  \r\tThe Smalltalk code that is evaluated when a primitive fails usually \r\tanticipates why that primitive might fail. If the primitive is optional, the \r\texpressions in the method do exactly what the primitive would have done (See \r\tNumber @). If the primitive only works on certain classes of arguments, the \r\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \r\ta more general way of doing the operation (see SmallInteger +). If the \r\tprimitive is never supposed to fail, the expressions signal an error (see \r\tSmallInteger asFloat).  \r\t  \r\tEach method that specifies a primitive has a comment in it. If the primitive is \r\toptional, the comment will say 'Optional'. An optional primitive that is not \r\timplemented always fails, and the Smalltalk expressions do the work \r\tinstead.  \r\t \r\tIf a primitive is not optional, the comment will say, 'Essential'. Some \r\tmethods will have the comment, 'No Lookup'. See Object \r\thowToModifyPrimitives for an explanation of special selectors which are \r\tnot looked up.  \r\t  \r\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \r\tin Float, the primitive constructs and returns a 16-bit \r\tLargePositiveInteger when the result warrants it. Returning 16-bit \r\tLargePositiveIntegers from these primitives instead of failing is \r\toptional in the same sense that the LargePositiveInteger arithmetic \r\tprimitives are optional. The comments in the SmallInteger primitives say, \r\t'Fails if result is not a SmallInteger', even though the implementor has the \r\toption to construct a LargePositiveInteger. For further information on \r\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \r\tspecification of the interpreter in the Smalltalk book.\"\r\t\r\t\r\r\tself error: 'comment only'"},{"name":"services","linesOfCode":3,"sourceCode":"services\r\t\"Backstop\"\r\t^#()"}],"meta":null}},{"name":"Character","instanceVariables":[],"methods":[{"name":"asParser","linesOfCode":3,"sourceCode":"asParser\r\t\"Answer a parser that accepts the receiving character.\"\r\t\r\t^ PPLiteralObjectParser on: self"},{"name":"isSpaceSeparator","linesOfCode":2,"sourceCode":"isSpaceSeparator\r^ self characterSet isSpaceSeparator: self"},{"name":"isCharacter","linesOfCode":2,"sourceCode":"isCharacter\r\r\t^ true\r"},{"name":"storeBinaryOn:","linesOfCode":4,"sourceCode":"storeBinaryOn: aStream\r\tself asInteger < 256\r\t\tifTrue: [ aStream basicNextPut: self asInteger ]\r\t\tifFalse: [ aStream nextInt32Put: self asInteger ]"},{"name":"stonOn:","linesOfCode":2,"sourceCode":"stonOn: stonWriter\r\tstonWriter writeObject: self listSingleton: self asString"},{"name":"shallowCopy","linesOfCode":3,"sourceCode":"shallowCopy\r\t\"Answer the receiver, because Characters are unique.\"\r\t^self"},{"name":"asLowercase","linesOfCode":3,"sourceCode":"asLowercase\r\t\"If the receiver is uppercase, answer its matching lowercase Character.\"\r\t^ self characterSet toLowercase: self"},{"name":"isCurrencySymbol","linesOfCode":6,"sourceCode":"isCurrencySymbol\r\t\"Return whether the receiver is one of these characters:   $ and euro\"\r\t\"$$ isCurrencySymbol >>> true\"\r\t\"Character euro isCurrencySymbol >>> true\"\r\t\"$} isControlOther >>> false\"\r\t\r\t^ self characterSet isCurrencySymbol: self"},{"name":"asCharacter","linesOfCode":3,"sourceCode":"asCharacter\r\t\"Answer the receiver itself.\"\r\r\t^ self"},{"name":"isSurrogateOther","linesOfCode":2,"sourceCode":"isSurrogateOther\r^ self characterSet isSurrogateOther: self"},{"name":"isOtherPunctuation","linesOfCode":2,"sourceCode":"isOtherPunctuation\r^ self characterSet isOtherPunctuation: self"},{"name":"canBeGlobalVarInitial","linesOfCode":2,"sourceCode":"canBeGlobalVarInitial\r\t^ self characterSet canBeGlobalVarInitial: self "},{"name":"printOn:","linesOfCode":10,"sourceCode":"printOn: aStream\r\t| name |\r\t(self asInteger > 32 and: [ self asInteger ~= 127])\r\t\tifTrue: [ aStream nextPut: $$; nextPut: self ]\r\t\tifFalse: [\r\t\t\tname := self class constantNameFor: self.\r\t\t\taStream nextPutAll: self class name.\r\t\t\tname notNil\r\t\t\t\tifTrue: [ aStream space; nextPutAll: name ]\r\t\t\t\tifFalse: [ aStream nextPutAll: ' value: '; print: self asInteger ] ]"},{"name":"gtInspectorCharacterIn:","linesOfCode":13,"sourceCode":"gtInspectorCharacterIn: composite\r\t<gtInspectorPresentationOrder: 30>\r\t^ composite table\r\t\ttitle: 'Character';\r\t\tdisplay: [\r\t\t\t{'self' -> self.\r\t\t\t'codepoint' -> self codePoint.\r\t\t\t'unicode' -> (String streamContents: [ :stream | \r\t\t\t\tstream << 'U+'.\r\t\t\t\tself codePoint printOn: stream base: 16 nDigits: 4 ])} ];\r\t\tcolumn: 'Key' evaluated: #key;\r\t\tcolumn: 'Value' evaluated: [ :each | each value printString ];\r\t\tsend: #value"},{"name":"isLiteral","linesOfCode":2,"sourceCode":"isLiteral\r\r\t^ true"},{"name":"isOtherLetter","linesOfCode":2,"sourceCode":"isOtherLetter\r^ self characterSet isOtherLetter: self"},{"name":"alt","linesOfCode":2,"sourceCode":"alt\r\t^ KMModifier alt + self"},{"name":"isAlphaNumeric","linesOfCode":8,"sourceCode":"isAlphaNumeric\r\t\"Answer whether the receiver is a letter or a digit.\"\r\t\"$a isAlphaNumeric >>> true\"\r\t\"$A isAlphaNumeric >>> true\"\r\t\"$' isAlphaNumeric >>> false\"\r\t\"$1 isAlphaNumeric >>> true\"\r\t\"Character space isAlphaNumeric >>> false\"\r\r\t^ self isLetter or: [ self isDigit ]"},{"name":"isSpacingCombiningMark","linesOfCode":2,"sourceCode":"isSpacingCombiningMark\r^ self characterSet isSpacingCombiningMark: self"},{"name":"asUnicode","linesOfCode":2,"sourceCode":"asUnicode\r\r\t^ self asInteger"},{"name":"isParagraphSeparator","linesOfCode":2,"sourceCode":"isParagraphSeparator\r^ self characterSet isParagraphSeparator: self"},{"name":"isUppercase","linesOfCode":2,"sourceCode":"isUppercase\r\r\t^ self characterSet isUppercase: self\r"},{"name":"deepCopy","linesOfCode":3,"sourceCode":"deepCopy\r\t\"Answer the receiver, because Characters are unique.\"\r\t^self"},{"name":"isControlOther","linesOfCode":13,"sourceCode":"isControlOther\r\t\"Return whether the receiver is one of these characters: backspace, delete, escape, arrowUp, arrowLeft, arrowDown, arrowRight, pageUp, pageDown, end, home, nbsp, insert\"\r\t\"Character delete isControlOther >>> true\"\r\t\"Character backspace isControlOther >>> true\"\r\t\"Character space isControlOther >>> false\"\r\t\"Character home isControlOther >>> true\"\r\t\"Character pageUp isControlOther >>> true\"\r\t\"Character arrowDown isControlOther >>> true\"\r\t\"Character end isControlOther >>> true\"\r\t\r\t\"$) isControlOther >>> false\"\r\t\"$> isControlOther >>> false\"\r\t\"$} isControlOther >>> false\"\r\t\r\t^ self characterSet isControlOther: self\r"},{"name":"hexDigitValue","linesOfCode":9,"sourceCode":"hexDigitValue\r\t\"Return the case independent hexadecimal digit value of the receiver.\r\t$0 to: $9 will return 0 to 9, while $a to $f and $A to $F both will return 10 to 15.\r\tIf the receiver does not represent a hexadecimal digit, return nil.\r\tReturns an integer between 0 and 15.\"\r\t\r\t| codePoint |\r\t^ ((codePoint := self asInteger) between: 0 and: 127)\r\t\tifTrue: [ #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 0 1 2 3 4 5 6 7 8 9 nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil) at: codePoint + 1 ]\r\t\tifFalse: [ nil ]"},{"name":"printStringHex","linesOfCode":3,"sourceCode":"printStringHex\r\t\"$A printStringHex >>> '41'\"\r\r\t^ self asInteger printStringBase: 16"},{"name":"meta","linesOfCode":2,"sourceCode":"meta\r\t^ KMModifier meta + self"},{"name":"unicodeToMacRoman","linesOfCode":3,"sourceCode":"unicodeToMacRoman\r\t\"Convert the receiver from Unicode to MacRoman encoding.\"\r\r\t^MacRomanTextConverter new byteToUnicode: self"},{"name":"isDashPunctuation","linesOfCode":5,"sourceCode":"isDashPunctuation\r\t\"Return whether the receiver is one of these characters:   $-\"\r\t\"$- isDashPunctuation >>> true\"\r\t\"$_ isDashPunctuation >>> false\"\r\t\r\t^ self characterSet isDashPunctuation: self"},{"name":"isEnclosingMark","linesOfCode":4,"sourceCode":"isEnclosingMark\r\t\"Return whether the receiver is ... one of these https://www.compart.com/en/unicode/category/Me\"\r\t\"$' isEnclosingMark >>> false\"\r\t\r\t\r\t^ self characterSet isEnclosingMark: self"},{"name":"copy","linesOfCode":3,"sourceCode":"copy\r\t\"Answer the receiver, because Characters are unique.\"\r\t^self"},{"name":"hex","linesOfCode":6,"sourceCode":"hex\r\t\"Returns a string representation of the receiver as hex, prefixed with 16r.  \r\tDO NOT CHANGE THIS!  The Cog VMMaker depends on this.\"\r\t\"$A hex >>> '16r41'\"\t\r\t\t\t\r\t^ self asInteger hex"},{"name":"asShortcut","linesOfCode":2,"sourceCode":"asShortcut\r\t^ self asKeyCombination"},{"name":"isLetterNumber","linesOfCode":3,"sourceCode":"isLetterNumber\r\t\"Return whether the receiver is part of https://www.compart.com/en/unicode/category/Nl\"\r\t^ self characterSet isLetterNumber: self"},{"name":"isLetter","linesOfCode":6,"sourceCode":"isLetter\r\t\"Return whether the receiver is a letter.\"\r\t\"$a isLetter >>> true\"\r\t\"$ isLetter >>> true\"\r\t\"$A isLetter >>> true\"\r\r\t^ self characterSet isLetter: self\r"},{"name":"isClosePunctuation","linesOfCode":8,"sourceCode":"isClosePunctuation\r\t\"Return whether the receiver is one of these characters:  )]}\"\r\t\"$a isClosePunctuation >>> false\"\r\t\"$( isClosePunctuation >>> false\"\r\t\"$) isClosePunctuation >>> true\"\r\t\"$] isClosePunctuation >>> true\"\r\t\"$} isClosePunctuation >>> true\"\r\t\r\t^ self characterSet isClosePunctuation: self"},{"name":"asHTMLString","linesOfCode":5,"sourceCode":"asHTMLString\r\t\"substitute the < & > into HTML compliant elements\"\r\t\r\t#($< '&lt;' $> '&gt;' $& '&amp;') pairsDo: [:k :v |\r\t\tself = k ifTrue: [^ v]].\r\t^ String with: self"},{"name":"shift","linesOfCode":2,"sourceCode":"shift\r\t^ KMModifier shift + self"},{"name":"shouldBePrintedAsLiteral","linesOfCode":2,"sourceCode":"shouldBePrintedAsLiteral\r\t^ self asInteger between: 33 and: 255"},{"name":"ctrl","linesOfCode":2,"sourceCode":"ctrl\r\t^ KMModifier ctrl + self"},{"name":">","linesOfCode":3,"sourceCode":"> aCharacter \r\t\"Answer true if the receiver's value > aCharacter's value.\"\r\r\t^self asciiValue > aCharacter asciiValue"},{"name":"asSymbol","linesOfCode":3,"sourceCode":"asSymbol \r\t\"Answer a Symbol consisting of the receiver as the only element.\"\r\r\t^Symbol internCharacter: self"},{"name":"canBeNonGlobalVarInitial","linesOfCode":2,"sourceCode":"canBeNonGlobalVarInitial\r  ^ self characterSet canBeNonGlobalVarInitial: self"},{"name":"isFormatOther","linesOfCode":3,"sourceCode":"isFormatOther\r\t\"Return whether the receiver in this category: https://www.compart.com/en/unicode/category/Cf\"\r\t^ self characterSet isFormatOther: self"},{"name":"isPrivateOther","linesOfCode":2,"sourceCode":"isPrivateOther\r^ self characterSet isPrivateOther: self"},{"name":"isOctetCharacter","linesOfCode":2,"sourceCode":"isOctetCharacter\r\t^ self asInteger < 256"},{"name":"storeOn:","linesOfCode":13,"sourceCode":"storeOn: aStream\r\t\"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value.\"\r\r\t| name |\r\tself shouldBePrintedAsLiteral\r\t\tifTrue: [ aStream nextPut: $$; nextPut: self ]\r\t\tifFalse: [\r\t\t\tname := self class constantNameFor: self.\r\t\t\tname notNil\r\t\t\t\tifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]\r\t\t\t\tifFalse: [\r\t\t\t\t\taStream \r\t\t\t\t\t\tnextPut: $(; nextPutAll: self class name; \r\t\t\t\t\t\tnextPutAll: ' value: '; print: self asInteger; nextPut: $) ] ]"},{"name":"basicPharoToIso","linesOfCode":9,"sourceCode":"basicPharoToIso\r\t| tmp1 |\r\tself asInteger < 128\r\t\tifTrue: [ ^ self ].\r\tself asInteger > 255\r\t\tifTrue: [ ^ self ].\r\ttmp1 := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 253 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 254 255 256)\r\t\tat: self asciiValue - 127.\r\t^ Character value: tmp1"},{"name":"fuelAccept:","linesOfCode":2,"sourceCode":"fuelAccept: aGeneralMapper\r\r\t^aGeneralMapper visitHookPrimitive: self"},{"name":"asKeyCombination","linesOfCode":5,"sourceCode":"asKeyCombination\r\t| lowerCaseCombination |\r\tself asLowercase = self ifTrue: [^ KMSingleKeyCombination from: self].\r\tlowerCaseCombination := KMSingleKeyCombination from: self asLowercase.\r\t^KMModifiedKeyCombination modifier: KMModifier shift character: lowerCaseCombination."},{"name":"isArrow","linesOfCode":2,"sourceCode":"isArrow\r\r\t^ { Character arrowUp. Character arrowDown. Character arrowLeft. Character arrowRight } includes: self"},{"name":"nextObject","linesOfCode":3,"sourceCode":"nextObject\r\t\"Characters are immediate objects, and, as such, do not have successors in object memory.\"\r\r\tself shouldNotImplement "},{"name":"serializeOn:","linesOfCode":2,"sourceCode":"serializeOn: anEncoder\r\r\tanEncoder encodeUint32: self asInteger"},{"name":"leadingChar","linesOfCode":2,"sourceCode":"leadingChar\r\t^ (self asInteger bitAnd: 1069547520) bitShift: -22"},{"name":"isOtherSymbol","linesOfCode":2,"sourceCode":"isOtherSymbol\r^ self characterSet isOtherSymbol: self"},{"name":"isSafeForHTTP","linesOfCode":6,"sourceCode":"isSafeForHTTP\r\t\"Return whether a character is 'safe', or needs to be escaped when used, eg, in a URL\"\r\t\"See http://www.faqs.org/rfcs/rfc1738.html. ~ is unsafe and has been removed\"\r\t\r\t^ self charCode < 128\r\t\tand: [self isAlphaNumeric\r\t\t\t\tor: ['.-_' includes: (Character value: self charCode)]]"},{"name":"isDecimalDigit","linesOfCode":5,"sourceCode":"isDecimalDigit\r\t\"Return whether the receiver is a digit.\"\r\t\"$1 isDecimalDigit >>> true\"\r\t\"$0 isDecimalDigit >>> true\"\r\r\t^ self characterSet isDecimalDigit: self"},{"name":"isDigit","linesOfCode":5,"sourceCode":"isDigit\r\t\"Return whether the receiver is a digit.\"\r\t\"$1 isDigit >>> true\"\r\t\"$0 isDigit >>> true\"\r\t\r\t^ self characterSet isDigit: self\r"},{"name":"isLowercase","linesOfCode":2,"sourceCode":"isLowercase\r\r\t^ self characterSet isLowercase: self\r"},{"name":"asUnicodeForTextConverter","linesOfCode":13,"sourceCode":"asUnicodeForTextConverter\r\t| table charset value |\r\tself leadingChar = 0\r\t\tifTrue: [ ^ self asInteger ].\r\tcharset := self characterSet.\r\tcharset isCharset\r\t\tifFalse: [ ^ self charCode ].\r\ttable := charset ucsTable.\r\ttable ifNil: [ ^ 65533 ].\r\tvalue := table at: self charCode + 1.\r\tvalue = -1\r\t\tifTrue: [ ^ 65533 ].\r\t^ value"},{"name":"asInteger","linesOfCode":4,"sourceCode":"asInteger\r\t\"Answer the receiver's character code.\"\r\t<primitive: 171>\r\t^self primitiveFailed"},{"name":"asPParser","linesOfCode":3,"sourceCode":"asPParser\r\t\"Answer a parser that accepts the receiving character.\"\r\t\r\t^ PP2LiteralObjectNode on: self"},{"name":"=","linesOfCode":6,"sourceCode":"= aCharacter \r\t\"Primitive. Answer if the receiver and the argument are the\r\t same object (have the same object pointer). Optional. See\r\t Object documentation whatIsAPrimitive.\"\r\t<primitive: 110>\r\t^self == aCharacter"},{"name":"isTitlecaseLetter","linesOfCode":2,"sourceCode":"isTitlecaseLetter\r^ self characterSet isTitlecaseLetter: self"},{"name":"asText","linesOfCode":2,"sourceCode":"asText\r\t^ self asString asText"},{"name":"<","linesOfCode":3,"sourceCode":"< aCharacter \r\t\"Answer true if the receiver's value < aCharacter's value.\"\r\r\t^self asciiValue < aCharacter asciiValue"},{"name":"isImmediateObject","linesOfCode":3,"sourceCode":"isImmediateObject\r\t\"This is needed for the boostrap\"\r\t^ true"},{"name":"isLetterModifier","linesOfCode":3,"sourceCode":"isLetterModifier\r\t\"Return whether the receiver is https://www.compart.com/en/unicode/category/Lm\"\r\t\r\t^ self characterSet isLetterModifier: self"},{"name":"asciiValue","linesOfCode":6,"sourceCode":"asciiValue\r\t\"Answer the receiver's character code.\r\t This will be ascii for characters with value <= 127,\r\t and Unicode for those with higher values.\"\r\t<primitive: 171>\r\t^self primitiveFailed"},{"name":"basicIdentityHash","linesOfCode":7,"sourceCode":"basicIdentityHash\r\t\"Answer the receiver's character code.\r\t The value answered is unsigned. It can in theory be in the full\r\t poisitive SmallInteger range, but based on Unicode, it is fair\r\t to assume that the value is in the range [ 0 ; 16r3FFFFF ]\"\r\t<primitive: 171>\r\t^self primitiveFailed"},{"name":"isVowel","linesOfCode":4,"sourceCode":"isVowel\r\t\"Answer whether the receiver is one of the vowels, AEIOU, in upper or \r\tlower case.\"\r\r\t^'AEIOU' includes: self asUppercase"},{"name":"sameAs:","linesOfCode":3,"sourceCode":"sameAs: aCharacter \r\t\"Answer whether the receiver is equal to aCharacter, ignoring case\"\r\t^ (self asLowercase = aCharacter asLowercase)\t"},{"name":"isLineSeparator","linesOfCode":3,"sourceCode":"isLineSeparator\r\t\"Return whether the receiver is https://www.compart.com/en/unicode/category/Zl\"\r\t\r\t^ self characterSet isLineSeparator: self"},{"name":"isOpenPunctuation","linesOfCode":2,"sourceCode":"isOpenPunctuation\r^ self characterSet isOpenPunctuation: self"},{"name":"isNonspacingMark","linesOfCode":2,"sourceCode":"isNonspacingMark\r^ self characterSet isNonspacingMark: self"},{"name":"command","linesOfCode":2,"sourceCode":"command\r\t^ KMModifier command + self"},{"name":"isSeparator","linesOfCode":10,"sourceCode":"isSeparator\r\t\"Returns whether the receiver is a separator i.e., a space, tab, lf, cr, and newPage\"\r\t\"Character space isSeparator >>> true\"\r\t\"Character lf isSeparator >>> true\"\r\t\"Character cr isSeparator >>> true\"\r\t\"Character newPage isSeparator >>> true\"\r\t\"Character tab isSeparator >>> true\"\r\t\"$' isSeparator >>> false\"\r\t\r\t| in |\r\t^ (in := self asInteger) == 32 or: [ in == 13 or: [ in == 9 or: [ in == 10 or: [ in == 12 ] ] ] ]"},{"name":"uppercase","linesOfCode":2,"sourceCode":"uppercase\r\t^ self asUppercase"},{"name":"control","linesOfCode":2,"sourceCode":"control\r\t^ KMModifier control + self"},{"name":"to:","linesOfCode":4,"sourceCode":"to: other\r\t\"Answer with a collection in ascii order -- $a to: $z\"\r\t^ (self asciiValue to: other asciiValue) collect:\r\t\t\t\t[:ascii | Character value: ascii]"},{"name":"isFullWidth","linesOfCode":20,"sourceCode":"isFullWidth\r\t\"base on this code:\r\thttps://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c\"\r\t|code|\r\tcode := self codePoint.\r\tcode < 256 ifTrue:[^false].\r\tself isCombining ifTrue: [ ^false ].\r\t^((code >= 16r1100) &\r     ((code <= 16r115f) |                  \r      (code = 16r2329) | (code = 16r232a) |\r      ((code >= 16r2e80 )& (code <= 16ra4cf) &\r       (code ~= 16r303f)) |                  \r      ((code >= 16rac00) & (code <= 16rd7a3)) | \r      ((code >= 16rf900) & (code <= 16rfaff)) | \r      ((code >= 16rfe10) & (code <= 16rfe19)) | \r      ((code >= 16rfe30) & (code <= 16rfe6f)) | \r      ((code >= 16rff00) & (code <= 16rff60)) |\r      ((code >= 16rffe0) & (code <= 16rffe6)) |\r      ((code >= 16r20000) & (code <= 16r2fffd)) |\r      ((code >= 16r30000) & (code <= 16r3fffd))))"},{"name":"isSpecial","linesOfCode":3,"sourceCode":"isSpecial\r\t\"Answer whether the receiver is one of the special characters: i.e., +-/\\*~<>=@,%|&?! and a couple of others.\"\r\r\t^ self class specialCharacters includes: self\r"},{"name":"isCasedLetter","linesOfCode":6,"sourceCode":"isCasedLetter\r\t\"We are sorry but this method is unclear and will probably be removed.\r\tThis method only returning false.\"\r\t\"$a isCasedLetter >>> false\"\r\t\"$A isCasedLetter >>> false\"\r\t\r\t^ self characterSet isCasedLetter: self"},{"name":"join:","linesOfCode":4,"sourceCode":"join: aSequenceableCollection\r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\"(Character space join: #('Pharo' 'is' 'cool')) >>> 'Pharo is cool'\"\r\t^ self asString join: aSequenceableCollection\r"},{"name":"largeIdentityHash","linesOfCode":2,"sourceCode":"largeIdentityHash\r\r\t^ self identityHash"},{"name":"characterSet","linesOfCode":2,"sourceCode":"characterSet\r\t^ self class characterSet"},{"name":"macRomanToUnicode","linesOfCode":3,"sourceCode":"macRomanToUnicode\r\t\"Convert the receiver from MacRoman Unicode.\"\r\r\t^MacRomanTextConverter new unicodeToByte: self"},{"name":"tokenish","linesOfCode":7,"sourceCode":"tokenish\r\t\"Answer whether the receiver is a valid token-character -- letter, digit, underscore, or colon.\"\r\t\"$' tokenish >>> false\"\r\t\"$: tokenish >>> true\"\r\t\"${ tokenish >>> false\"\r\t\"Character space tokenish >>> false\"\r\t\r\t^ self isLetter or: [ self isDigit or: [ self = $_ or: [ self = $: ] ] ]"},{"name":"asUppercase","linesOfCode":3,"sourceCode":"asUppercase\r\t\"If the receiver is lowercase, answer its matching uppercase Character.\"\r\t^ self characterSet toUppercase: self\r\t\r"},{"name":"codePoint","linesOfCode":3,"sourceCode":"codePoint\r\t\"Just for ANSI Compliance\"\t\r\t^self asciiValue"},{"name":"mbndLiteralTypeWithTarget:","linesOfCode":2,"sourceCode":"mbndLiteralTypeWithTarget: compilationTarget\r\t^ compilationTarget literalCharacterType"},{"name":"isCombining","linesOfCode":17,"sourceCode":"isCombining\r\t|min mid table code max|\r\tcode := self codePoint.\r\ttable := Character combiningInterval.\r\tmax := table size.\r\tmin := 1.\r\tmid := 1.\r\t((code < table first first) & (code > table last last)) ifTrue:[^false].\r\t[ max >= min ] whileTrue: [\r\t\tmid := ((min + max) / 2) asInteger.\r\t\tcode > (table at:mid) last ifTrue:[\r\t\t\tmin := mid + 1\r\t\t] ifFalse:[\r\t\t\tcode < (table at:mid) first ifTrue:[max := mid - 1] ifFalse:[^true]\r\t\t]\r\t].\r\t^false"},{"name":"lowercase","linesOfCode":2,"sourceCode":"lowercase\r\t^ self asLowercase"},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t\"Hash is reimplemented because = is implemented.\r\t Answer the receiver's character code.\"\r\t<primitive: 171>\r\t^self primitiveFailed"},{"name":"isInitialQuote","linesOfCode":4,"sourceCode":"isInitialQuote\r\t\"Return whether the receiver is https://www.compart.com/en/unicode/category/Pi\"\r\t\"$' isInitialQuote >>> false\"\r\t\r\t^ self characterSet isInitialQuote: self"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"charCode","linesOfCode":2,"sourceCode":"charCode\r\t^ self asInteger bitAnd: 4194303"},{"name":"isConnectorPunctuation","linesOfCode":8,"sourceCode":"isConnectorPunctuation\r\t\"Return whether the receiver is one of these characters:   _\"\r\t\"$_ isConnectorPunctuation >>> true\"\r\t\"$( isConnectorPunctuation >>> false\"\r\t\"$) isConnectorPunctuation >>> false\"\r\t\"$> isConnectorPunctuation >>> false\"\r\t\"$} isConnectorPunctuation >>> false\"\r\t\r\t^ self characterSet isConnectorPunctuation: self"},{"name":"setValue:","linesOfCode":2,"sourceCode":"setValue: newValue\r\tself error: 'Characters are immutable'"},{"name":"isModifierSymbol","linesOfCode":2,"sourceCode":"isModifierSymbol\r\r\t^ self characterSet isModifierSymbol: self"},{"name":"digitValue","linesOfCode":4,"sourceCode":"digitValue\r\tself asInteger > 255\r\t\tifTrue: [ ^ self characterSet digitValueOf: self ].\r\t^ DigitValues at: 1 + self asInteger"},{"name":"isOtherNumber","linesOfCode":2,"sourceCode":"isOtherNumber\r\t^ self characterSet isOtherNumber: self"},{"name":"asString","linesOfCode":2,"sourceCode":"asString\r\t^ String with: self"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\tencoder encodeCharacter: self"},{"name":"isFinalQuote","linesOfCode":4,"sourceCode":"isFinalQuote\r\t\"Return whether the receiver is https://www.compart.com/en/unicode/category/Pf\"\r\t\"$' isFinalQuote >>> false\"\r\t\r\t^ self characterSet isFinalQuote: self"},{"name":"isCompletionCharacter","linesOfCode":3,"sourceCode":"isCompletionCharacter\r\t\"I defined the logic that completion can only happen with alphanumeric : characters.\"\r\t^ self isAlphaNumeric or: [ self = $: ]"},{"name":"isMathSymbol","linesOfCode":2,"sourceCode":"isMathSymbol\r\t^ self characterSet isMathSymbol: self"},{"name":"veryDeepCopyWith:","linesOfCode":3,"sourceCode":"veryDeepCopyWith: deepCopier\r\t\"Answer the receiver, because Characters are unique.\"\r\t^self"}],"meta":{"name":"Character class","instanceVariables":[],"methods":[{"name":"separators","linesOfCode":8,"sourceCode":"separators\r\t\"Answer a collection of the standard ASCII separator characters as string.\"\r\r\t^ #(32 \"space\"\r\t\t 13 \"cr\"\r\t\t  9 \"tab\"\r\t\t 10 \"line feed\"\r\t\t 12 \"form feed\")\r\t\tcollect: [:v | Character value: v] as: String"},{"name":"backspace","linesOfCode":3,"sourceCode":"backspace\r\t\"Answer the Character representing a backspace.\"\r\r\t^self value: 8"},{"name":"enter","linesOfCode":3,"sourceCode":"enter\r\t\"Answer the Character representing enter.\"\r\r\t^self value: 3"},{"name":"supportsNonASCII","linesOfCode":3,"sourceCode":"supportsNonASCII\r\r\t^ (self environment includesKey: #Unicode) and: [ \r\t\t((self environment  at: #EncodedCharSet) charsetAt: 255) name = #Unicode ]"},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ EyeCharacterInspector"},{"name":"fromSton:","linesOfCode":2,"sourceCode":"fromSton: stonReader\r\t^ stonReader parseListSingleton first"},{"name":"constantNameFor:","linesOfCode":4,"sourceCode":"constantNameFor: aCharacter\r\t^ self constantNames\r\t\tdetect: [ :each | (self perform: each) = aCharacter ]\r\t\tifNone: [ nil ]."},{"name":"combiningInterval","linesOfCode":50,"sourceCode":"combiningInterval\r\t^#(\r\t #( 16r0300 16r036F ) #( 16r0483 16r0486 ) #( 16r0488 16r0489 )\r    #( 16r0591 16r05BD ) #( 16r05BF 16r05BF ) #( 16r05C1 16r05C2 )\r    #( 16r05C4 16r05C5 ) #( 16r05C7 16r05C7 ) #( 16r0600 16r0603 )\r    #( 16r0610 16r0615 ) #( 16r064B 16r065E ) #( 16r0670 16r0670 )\r    #( 16r06D6 16r06E4 ) #( 16r06E7 16r06E8 ) #( 16r06EA 16r06ED )\r    #( 16r070F 16r070F ) #( 16r0711 16r0711 ) #( 16r0730 16r074A )\r    #( 16r07A6 16r07B0 ) #( 16r07EB 16r07F3 ) #( 16r0901 16r0902 )\r    #( 16r093C 16r093C ) #( 16r0941 16r0948 ) #( 16r094D 16r094D )\r    #( 16r0951 16r0954 ) #( 16r0962 16r0963 ) #( 16r0981 16r0981 )\r    #( 16r09BC 16r09BC ) #( 16r09C1 16r09C4 ) #( 16r09CD 16r09CD )\r    #( 16r09E2 16r09E3 ) #( 16r0A01 16r0A02 ) #( 16r0A3C 16r0A3C )\r    #( 16r0A41 16r0A42 ) #( 16r0A47 16r0A48 ) #( 16r0A4B 16r0A4D )\r    #( 16r0A70 16r0A71 ) #( 16r0A81 16r0A82 ) #( 16r0ABC 16r0ABC )\r    #( 16r0AC1 16r0AC5 ) #( 16r0AC7 16r0AC8 ) #( 16r0ACD 16r0ACD )\r    #( 16r0AE2 16r0AE3 ) #( 16r0B01 16r0B01 ) #( 16r0B3C 16r0B3C )\r    #( 16r0B3F 16r0B3F ) #( 16r0B41 16r0B43 ) #( 16r0B4D 16r0B4D )\r    #( 16r0B56 16r0B56 ) #( 16r0B82 16r0B82 ) #( 16r0BC0 16r0BC0 )\r    #( 16r0BCD 16r0BCD ) #( 16r0C3E 16r0C40 ) #( 16r0C46 16r0C48 )\r    #( 16r0C4A 16r0C4D ) #( 16r0C55 16r0C56 ) #( 16r0CBC 16r0CBC )\r    #( 16r0CBF 16r0CBF ) #( 16r0CC6 16r0CC6 ) #( 16r0CCC 16r0CCD )\r    #( 16r0CE2 16r0CE3 ) #( 16r0D41 16r0D43 ) #( 16r0D4D 16r0D4D )\r    #( 16r0DCA 16r0DCA ) #( 16r0DD2 16r0DD4 ) #( 16r0DD6 16r0DD6 )\r    #( 16r0E31 16r0E31 ) #( 16r0E34 16r0E3A ) #( 16r0E47 16r0E4E )\r    #( 16r0EB1 16r0EB1 ) #( 16r0EB4 16r0EB9 ) #( 16r0EBB 16r0EBC )\r    #( 16r0EC8 16r0ECD ) #( 16r0F18 16r0F19 ) #( 16r0F35 16r0F35 )\r    #( 16r0F37 16r0F37 ) #( 16r0F39 16r0F39 ) #( 16r0F71 16r0F7E )\r    #( 16r0F80 16r0F84 ) #( 16r0F86 16r0F87 ) #( 16r0F90 16r0F97 )\r    #( 16r0F99 16r0FBC ) #( 16r0FC6 16r0FC6 ) #( 16r102D 16r1030 )\r    #( 16r1032 16r1032 ) #( 16r1036 16r1037 ) #( 16r1039 16r1039 )\r    #( 16r1058 16r1059 ) #( 16r1160 16r11FF ) #( 16r135F 16r135F )\r    #( 16r1712 16r1714 ) #( 16r1732 16r1734 ) #( 16r1752 16r1753 )\r    #( 16r1772 16r1773 ) #( 16r17B4 16r17B5 ) #( 16r17B7 16r17BD )\r    #( 16r17C6 16r17C6 ) #( 16r17C9 16r17D3 ) #( 16r17DD 16r17DD )\r    #( 16r180B 16r180D ) #( 16r18A9 16r18A9 ) #( 16r1920 16r1922 )\r    #( 16r1927 16r1928 ) #( 16r1932 16r1932 ) #( 16r1939 16r193B )\r    #( 16r1A17 16r1A18 ) #( 16r1B00 16r1B03 ) #( 16r1B34 16r1B34 )\r    #( 16r1B36 16r1B3A ) #( 16r1B3C 16r1B3C ) #( 16r1B42 16r1B42 )\r    #( 16r1B6B 16r1B73 ) #( 16r1DC0 16r1DCA ) #( 16r1DFE 16r1DFF )\r    #( 16r200B 16r200F ) #( 16r202A 16r202E ) #( 16r2060 16r2063 )\r    #( 16r206A 16r206F ) #( 16r20D0 16r20EF ) #( 16r302A 16r302F )\r    #( 16r3099 16r309A ) #( 16rA806 16rA806 ) #( 16rA80B 16rA80B )\r    #( 16rA825 16rA826 ) #( 16rFB1E 16rFB1E ) #( 16rFE00 16rFE0F )\r    #( 16rFE20 16rFE23 ) #( 16rFEFF 16rFEFF ) #( 16rFFF9 16rFFFB )\r    #( 16r10A01 16r10A03 ) #( 16r10A05 16r10A06 ) #( 16r10A0C 16r10A0F )\r    #( 16r10A38 16r10A3A ) #( 16r10A3F 16r10A3F ) #( 16r1D167 16r1D169 )\r    #( 16r1D173 16r1D182 ) #( 16r1D185 16r1D18B ) #( 16r1D1AA 16r1D1AD )\r    #( 16r1D242 16r1D244 ) #( 16rE0001 16rE0001 ) #( 16rE0020 16rE007F )\r    #( 16rE0100 16rE01EF ))"},{"name":"null","linesOfCode":2,"sourceCode":"null\r\t^ self value: 0"},{"name":"specialCharacterNames","linesOfCode":22,"sourceCode":"specialCharacterNames\r\t^ Dictionary newFrom: { \r\t\t$+ -> 'plus'.\r\t\t$- -> 'minus'.\r\t\t$/ -> 'slash'.\r\t\t$\\ -> 'backslash'.\r\t\t$* -> 'star'.\r\t\t$~ -> 'tilda'.\r\t\t$< -> 'less than'.\r\t\t$> -> 'greater-than'.\r\t\t$= -> 'equals-sign'.\r\t\t$@ -> 'at sign'.\r\t\t$, -> 'comma'.\r\t\t$% -> 'percent sign'.\r\t\t$| -> 'pipe'.\r\t\t$& -> 'ampersand'.\r\t\t$? -> 'question mark'.\r\t\t$! -> 'exclamation mark'.\r\t\tself centeredDot -> 'centered dot'.\r\t\tself divide -> 'divide'.\r\t\tself plusOrMinus -> 'plus-minus'.\r\t\tself times -> 'times' }"},{"name":"centeredDot","linesOfCode":2,"sourceCode":"centeredDot\r\t^self codePoint: 183"},{"name":"euro","linesOfCode":3,"sourceCode":"euro\r\t\"The Euro currency sign, that E with two dashes. The code point is a official unicode ISO/IEC-10646-1\"\r\r\t^ Unicode value: 16r20AC"},{"name":"constantNames","linesOfCode":5,"sourceCode":"constantNames\r\t\"Added the rest of them!\"\r\t\r\t^#(backspace cr delete escape lf newPage space tab\r\t\tarrowDown arrowLeft arrowRight arrowUp\r\t\tenter end home insert nbsp pageDown pageUp null)"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\t\"Create the DigitsValues table.\"\r \r\tself initializeDigitValues"},{"name":"nbsp","linesOfCode":3,"sourceCode":"nbsp\r\t\"non-breakable space. Latin1 encoding common usage.\"\r\r\t^ Character value: 160"},{"name":"tab","linesOfCode":3,"sourceCode":"tab\r\t\"Answer the Character representing a tab.\"\r\r\t^self value: 9"},{"name":"alphabet","linesOfCode":3,"sourceCode":"alphabet\r\t\"($a to: $z) as: String\"\r\r\t^ 'abcdefghijklmnopqrstuvwxyz' copy"},{"name":"home","linesOfCode":2,"sourceCode":"home\r\t^ self value: 1"},{"name":"pageUp","linesOfCode":2,"sourceCode":"pageUp\r\t^ self value: 11"},{"name":"newPage","linesOfCode":3,"sourceCode":"newPage\r\t\"Answer the Character representing a form feed.\"\r\r\t^self value: 12"},{"name":"arrowDown","linesOfCode":2,"sourceCode":"arrowDown\r\t^ self value: 31"},{"name":"codePoint:","linesOfCode":4,"sourceCode":"codePoint: anInteger \r\t\"Just for ANSI Compliance\"\t\r\t\t\r\t^self value: anInteger\r\t"},{"name":"plusOrMinus","linesOfCode":2,"sourceCode":"plusOrMinus\r\t^self codePoint: 177"},{"name":"characterSet","linesOfCode":2,"sourceCode":"characterSet\r\t^ CharSet ifNil: [ AsciiCharset ]"},{"name":"lf","linesOfCode":3,"sourceCode":"lf\r\t\"Answer the Character representing a linefeed.\"\r\r\t^self value: 10"},{"name":"cr","linesOfCode":3,"sourceCode":"cr\r\t\"Answer the Character representing a carriage return.\"\r\r\t^self value: 13"},{"name":"escape","linesOfCode":3,"sourceCode":"escape\r\t\"Answer the ASCII ESC character\"\r\r\t^self value: 27"},{"name":"arrowRight","linesOfCode":2,"sourceCode":"arrowRight\r\t^ self value: 29"},{"name":"pageDown","linesOfCode":2,"sourceCode":"pageDown\r\t^ self value: 12"},{"name":"allByteCharacters","linesOfCode":3,"sourceCode":"allByteCharacters\r\t\"Answer all the characters that can be encoded in a byte\"\r\t\r\t^ (0 to: 255) collect: [:v | Character value: v] as: String\r"},{"name":"arrowUp","linesOfCode":2,"sourceCode":"arrowUp\r\t^ self value: 30"},{"name":"materializeFrom:","linesOfCode":2,"sourceCode":"materializeFrom: aDecoder\r\r\t^self value: aDecoder nextEncodedUint32"},{"name":"divide","linesOfCode":2,"sourceCode":"divide\r\t^self codePoint: 247"},{"name":"arrowLeft","linesOfCode":2,"sourceCode":"arrowLeft\r\t^ self value: 28"},{"name":"delete","linesOfCode":2,"sourceCode":"delete\r\t^ self value: 127"},{"name":"allCharacters","linesOfCode":3,"sourceCode":"allCharacters\r\t\"This name is obsolete since only the characters that will fit in a byte can be queried\"\r\t\r\t^self allByteCharacters\r\t\r"},{"name":"times","linesOfCode":2,"sourceCode":"times\r\t^self codePoint: 215"},{"name":"digitValue:","linesOfCode":6,"sourceCode":"digitValue: x \r\t\"Answer the Character whose digit value is x. For example,\r\t answer $9 for x=9, $0 for x=0, $A for x=10, $Z for x=35.\"\r\r\t| n |\r\tn := x asInteger.\r\t^self value: (n < 10 ifTrue: [n + 48] ifFalse: [n + 55])"},{"name":"initializeDigitValues","linesOfCode":10,"sourceCode":"initializeDigitValues\r\t\"Initialize the well known digit value of ascii characters.\r\tNote that the DigitValues table is 1-based while ascii values are 0-based, thus the offset+1.\"\r\tDigitValues := Array new: 256 withAll: -1.\r\t\"the digits\"\r\t0 to: 9 do: [:i | DigitValues at: 48 + i + 1 put: i].\r\t \"the uppercase letters\"\r\t10 to: 35 do: [:i | DigitValues at: 55 + i + 1 put: i].\r\t\"the lowercase letters\"\r\t10 to: 35 do: [:i | DigitValues at: 87 + i + 1 put: i]"},{"name":"value:","linesOfCode":4,"sourceCode":"value: anInteger\r\t\"Answer the Character whose value is anInteger.\"\r\t<primitive: 170>\r\t^self primitiveFailed"},{"name":"leadingChar:code:","linesOfCode":9,"sourceCode":"leadingChar: leadChar code: code\r\r\tcode >= 16r400000 ifTrue: [\r\t\tself error: 'code is out of range'.\r\t].\r\tleadChar >= 256 ifTrue: [\r\t\tself error: 'lead is out of range'.\r\t].\r\tcode < 256 ifTrue: [ ^self value: code ].\r\t^self value: (leadChar bitShift: 22) + code"},{"name":"end","linesOfCode":2,"sourceCode":"end\r\t^ self value: 4"},{"name":"maxVal","linesOfCode":3,"sourceCode":"maxVal\r\t\"Answer the maximum value (code point) for a Character.\"\r\r\t^ (2 ** 30) - 1"},{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"Creating new characters is not allowed.\"\r\r\tself error: 'cannot create new characters'"},{"name":"linefeed","linesOfCode":3,"sourceCode":"linefeed\r\t\"Answer the Character representing a linefeed.\"\r\r\t^self value: 10"},{"name":"characterSet:","linesOfCode":2,"sourceCode":"characterSet: aCharSet\r\t^ CharSet := aCharSet"},{"name":"insert","linesOfCode":2,"sourceCode":"insert\r\t^ self value: 5"},{"name":"space","linesOfCode":3,"sourceCode":"space\r\t\"Answer the Character representing a space.\"\r\r\t^self value: 32"},{"name":"specialCharacters","linesOfCode":6,"sourceCode":"specialCharacters\r\t^ '+-/\\*~<>=@,%|&?!' , (String\r\t\t   with: self centeredDot\r\t\t   with: self divide\r\t\t   with: self plusOrMinus\r\t\t   with: self times)"}],"meta":null}},{"name":"CollectionIsEmpty","instanceVariables":[],"methods":[{"name":"collection","linesOfCode":3,"sourceCode":"collection\r\t\"Return the collection where something is not found in\"\r\t\r\t^ self signaler"},{"name":"messageText","linesOfCode":3,"sourceCode":"messageText\r\t\"Overwritten to initialiaze the message text to a standard text if it has not yet been set\"\r\t\r\t^ messageText ifNil: [ messageText := self standardMessageText ]"},{"name":"standardMessageText","linesOfCode":5,"sourceCode":"standardMessageText\r\t\"Generate a standard textual description\"\r\t\r\t^ String streamContents: [ :stream |\r\t\tstream print: self collection.\r\t\tstream << ' is empty' ]"},{"name":"collection:","linesOfCode":3,"sourceCode":"collection: aCollection\r\t\"Set the collection where something is not found in\"\r\t\r\tself signaler: aCollection"}],"meta":{"name":"CollectionIsEmpty class","instanceVariables":[],"methods":[{"name":"signalWith:","linesOfCode":4,"sourceCode":"signalWith: aCollection\r\t^ self new\r\t\tcollection: aCollection;\r\t\tsignal"}],"meta":null}},{"name":"ArrayedCollection","instanceVariables":[],"methods":[{"name":"byteSize","linesOfCode":2,"sourceCode":"byteSize\r\t^self basicSize * self bytesPerBasicElement\r"},{"name":"fillFrom:with:","linesOfCode":7,"sourceCode":"fillFrom: aCollection with: aBlock\r\t\"Evaluate aBlock with each of aCollections's elements as the argument.  \r\tCollect the resulting values into self. Answer self.\"\r\r\t| index |\r\tindex := 0.\r\taCollection do: [ :each |\r\t\tself at: (index := index + 1) put: (aBlock value: each) ]"},{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\r\tself shouldNotImplement"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t<primitive: 62>\r\t^ self basicSize"},{"name":"bytesPerBasicElement","linesOfCode":6,"sourceCode":"bytesPerBasicElement\r\t\"Answer the number of bytes that each of my basic elements requires.\r\tIn other words:\r\t\tself basicSize * self bytesPerBasicElement\r\tshould equal the space required on disk by my variable sized representation.\"\r\t^self class isBytes ifTrue: [ 1 ] ifFalse: [ 4 ]"},{"name":"storeOn:","linesOfCode":9,"sourceCode":"storeOn: aStream\r\r\taStream nextPutAll: '(('.\r\taStream nextPutAll: self class name.\r\taStream nextPutAll: ' new: '.\r\taStream store: self size.\r\taStream nextPut: $).\r\t(self storeElementsFrom: 1 to: self size on: aStream)\r\t\tifFalse: [aStream nextPutAll: '; yourself'].\r\taStream nextPut: $)"},{"name":"storeElementsFrom:to:on:","linesOfCode":17,"sourceCode":"storeElementsFrom: firstIndex to: lastIndex on: aStream\r\r\t| noneYet defaultElement arrayElement |\r\tnoneYet := true.\r\tdefaultElement := self defaultElement.\r\tfirstIndex to: lastIndex do: \r\t\t[:index | \r\t\tarrayElement := self at: index.\r\t\tarrayElement = defaultElement\r\t\t\tifFalse: \r\t\t\t\t[noneYet\r\t\t\t\t\tifTrue: [noneYet := false]\r\t\t\t\t\tifFalse: [aStream nextPut: $;].\r\t\t\t\taStream nextPutAll: ' at: '.\r\t\t\t\taStream store: index.\r\t\t\t\taStream nextPutAll: ' put: '.\r\t\t\t\taStream store: arrayElement]].\r\t^noneYet"},{"name":"add:","linesOfCode":2,"sourceCode":"add: newObject\r\tself shouldNotImplement"},{"name":"defaultElement","linesOfCode":2,"sourceCode":"defaultElement\r\r\t^nil"},{"name":"restoreEndianness","linesOfCode":10,"sourceCode":"restoreEndianness\r \t\"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Reverse the byte order if the current machine is Little Endian.\r \tWe only intend this for non-pointer arrays.  Do nothing if I contain pointers.\"\r \r \tself class isPointers | self class isWords not ifTrue: [^self].\r \tEndianDetector isLittleEndian \r \t\tifTrue: \r \t\t\t[Bitmap \r \t\t\t\tswapBytesIn: self\r \t\t\t\tfrom: 1\r \t\t\t\tto: self basicSize]"},{"name":"swapHalves","linesOfCode":12,"sourceCode":"swapHalves\r \t\t\"A normal switch in endianness (byte order in words) reverses the order of 4 bytes.  That is not correct for SoundBuffers, which use 2-bytes units.  If a normal switch has be done, this method corrects it further by swapping the two halves of the long word.\r \tThis method is only used for 16-bit quanities in SoundBuffer, ShortIntegerArray, etc.\"\r \r \t| hack blt |\r \t\"The implementation is a hack, but fast for large ranges\"\r \thack := Form new hackBits: self.\r \tblt := (BitBlt toForm: hack) sourceForm: hack.\r \tblt combinationRule: Form reverse.  \"XOR\"\r \tblt sourceY: 0; destY: 0; height: self size; width: 2.\r \tblt sourceX: 0; destX: 2; copyBits.  \"Exchange bytes 0&1 with 2&3\"\r \tblt sourceX: 2; destX: 0; copyBits.\r \tblt sourceX: 0; destX: 2; copyBits.\r"},{"name":"writeOn:","linesOfCode":5,"sourceCode":"writeOn: aStream \r\t\"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds. We only intend this for non-pointer arrays.  Do nothing if I contain pointers.\"\r\t(self class isPointers or: [ self class isWords not ]) ifTrue: [^ self ].\r\taStream nextInt32Put: self basicSize.\r\taStream nextWordsPutAll: self."}],"meta":{"name":"ArrayedCollection class","instanceVariables":[],"methods":[{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^self name = #ArrayedCollection"},{"name":"new:withAll:","linesOfCode":4,"sourceCode":"new: size withAll: value \r\t\"Answer an instance of me, with number of elements equal to size, each \r\tof which refers to the argument, value.\"\r\r\t^(self new: size) atAllPut: value"},{"name":"with:with:with:with:with:with:","linesOfCode":11,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject\r\t\"Answer a new instance of me, containing only the 6 arguments as elements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 6.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\tnewCollection at: 4 put: fourthObject.\r\tnewCollection at: 5 put: fifthObject.\r\tnewCollection at: 6 put: sixthObject.\r\t^ newCollection"},{"name":"with:with:with:with:with:","linesOfCode":11,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject\r\t\"Answer a new instance of me, containing only the five arguments as\r\telements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 5.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\tnewCollection at: 4 put: fourthObject.\r\tnewCollection at: 5 put: fifthObject.\r\t^newCollection"},{"name":"with:with:with:with:","linesOfCode":10,"sourceCode":"with: firstObject with: secondObject with: thirdObject with: fourthObject \r\t\"Answer a new instance of me, containing only the three arguments as\r\telements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 4.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\tnewCollection at: 4 put: fourthObject.\r\t^newCollection"},{"name":"with:with:with:","linesOfCode":9,"sourceCode":"with: firstObject with: secondObject with: thirdObject \r\t\"Answer a new instance of me, containing only the three arguments as\r\telements.\"\r\r\t| newCollection |\r\tnewCollection := self new: 3.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\tnewCollection at: 3 put: thirdObject.\r\t^newCollection"},{"name":"with:with:","linesOfCode":7,"sourceCode":"with: firstObject with: secondObject \r\t\"Answer a new instance of me, containing firstObject and secondObject.\"\r\r\t| newCollection |\r\tnewCollection := self new: 2.\r\tnewCollection at: 1 put: firstObject.\r\tnewCollection at: 2 put: secondObject.\r\t^newCollection"},{"name":"new","linesOfCode":3,"sourceCode":"new\r\t\"Answer a new instance of me, with size = 0.\"\r\r\t^self new: 0"},{"name":"with:","linesOfCode":6,"sourceCode":"with: anObject \r\t\"Answer a new instance of me, containing only anObject.\"\r\r\t| newCollection |\r\tnewCollection := self new: 1.\r\tnewCollection at: 1 put: anObject.\r\t^newCollection"},{"name":"withAll:","linesOfCode":3,"sourceCode":"withAll: aCollection\r\t\"Create a new collection containing all the elements from aCollection.\"\r\r\t^ (self new: aCollection size) replaceFrom: 1 to: aCollection size with: aCollection"},{"name":"with:withAll:","linesOfCode":10,"sourceCode":"with: anObject withAll: aCollection\r\r\t| newArray |\r\tnewArray := self new: aCollection size + 1.\r\tnewArray at: 1 put: anObject.\r\tnewArray\r\t\treplaceFrom: 2\r\t\tto: newArray size\r\t\twith: aCollection.\r\t^newArray\r\t\r\"Array with: 1 withAll: #(2 3 4)\""},{"name":"newFrom:","linesOfCode":11,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\t| newArray |\r\tnewArray := self new: aCollection size.\r\t1 to: aCollection size do: [:i | newArray at: i put: (aCollection at: i)].\r\t^ newArray\r\r\"\tArray newFrom: {1. 2. 3}\r\t{1. 2. 3} as: Array\r\t{1. 2. 3} as: ByteArray\r\t{$c. $h. $r} as: String\r\t{$c. $h. $r} as: Text\r\""}],"meta":null}}]},{"name":"Collections-Abstract-Traits","classes":[{"name":"ManifestCollectionsAbstractTraits","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsAbstractTraits class","instanceVariables":[],"methods":[{"name":"ruleExcessiveArgumentsRuleV1FalsePositive","linesOfCode":2,"sourceCode":"ruleExcessiveArgumentsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#TSortable #mergeFirst:middle:last:into:by: #false)) #'2020-06-26T09:33:14.853351+02:00') #(#(#RGMethodDefinition #(#TSortable #mergeSortFrom:to:src:dst:by: #false)) #'2020-06-26T09:33:26.566053+02:00') )"}],"meta":null}},{"name":"TSortable","instanceVariables":[],"methods":[{"name":"isSorted","linesOfCode":12,"sourceCode":"isSorted\r\t\"Return true if the receiver is sorted by the given criterion.\r\tOptimization for isSortedBy: [:a :b | a <= b].\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\tlastElm <= elm ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"sort","linesOfCode":3,"sourceCode":"sort\r\t\"Sort this collection into ascending order using the '<=' operator.\"\r\r\tself sort: [:a :b | a <= b]"},{"name":"mergeSortFrom:to:src:dst:by:","linesOfCode":9,"sourceCode":"mergeSortFrom: first to: last src: src dst: dst by: aBlock\r\t\"Private. Split the range to be sorted in half, sort each half, and \r\tmerge the two half-ranges into dst.\"\r\r\t| middle |\r\tfirst = last ifTrue: [^ self].\r\tmiddle := (first + last) // 2.\r\tself mergeSortFrom: first to: middle src: dst dst: src by: aBlock.\r\tself mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.\r\tsrc mergeFirst: first middle: middle last: last into: dst by: aBlock"},{"name":"mergeFirst:middle:last:into:by:","linesOfCode":21,"sourceCode":"mergeFirst: first middle: middle last: last into: dst by: aBlock\r\t\"Private. Merge the sorted ranges [first..middle] and [middle+1..last] \r\tof the receiver into the range [first..last] of dst.\"\r\r\t| i1 i2 val1 val2 out |\r\ti1 := first.\r\ti2 := middle + 1.\r\tval1 := self at: i1.\r\tval2 := self at: i2.\r\tout := first - 1.  \"will be pre-incremented\"\r\r\t\"select 'lower' half of the elements based on comparator\"\r\t[(i1 <= middle) and: [i2 <= last]] whileTrue:\r\t\t[(aBlock value: val1 value: val2)\r\t\t\tifTrue: [dst at: (out := out + 1) put: val1.\r\t\t\t\t\tval1 := self at: (i1 := i1 + 1)]\r\t\t\tifFalse: [dst at: (out := out + 1) put: val2.\r\t\t\t\t\ti2 := i2 + 1.\r\t\t\t\t\ti2 <= last ifTrue: [val2 := self at: i2]]].\r\r\t\"copy the remaining elements\"\r\ti1 <= middle\r\t\tifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]\r\t\tifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]"},{"name":"sort:","linesOfCode":7,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\r\tself\r\t\tmergeSortFrom: 1\r\t\tto: self size\r\t\tby: aSortBlock"},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted in ascending order using the #'<=' operator.\"\r\t\r\t^self sorted: [ :a :b| a <= b ]"},{"name":"sorted:","linesOfCode":6,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\r\t^self copy sort: aSortBlockOrNil"},{"name":"isSortedBy:","linesOfCode":11,"sourceCode":"isSortedBy: aBlock\r\t\"Return true if the receiver is sorted by the given criterion.\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\t(aBlock value: lastElm value: elm) ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"mergeSortFrom:to:by:","linesOfCode":20,"sourceCode":"mergeSortFrom: startIndex to: stopIndex by: aBlock\r\t\"Sort the given range of indices using the mergesort algorithm.\r\tMergesort is a worst-case O(N log N) sorting algorithm that usually\r\tdoes only half as many comparisons as heapsort or quicksort.\"\r\r\t\"Details: recursively split the range to be sorted into two halves,\r\tmergesort each half, then merge the two halves together. An extra \r\tcopy of the data is used as temporary storage and successive merge \r\tphases copy data back and forth between the receiver and this copy.\r\tThe recursion is set up so that the final merge is performed into the\r\treceiver, resulting in the receiver being completely sorted.\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tstartIndex = stopIndex ifTrue: [^ self].\r\t[startIndex >= 1 and: [startIndex < stopIndex]] assert. \"bad start index\"\r\t[stopIndex <= self size] assert. \"bad stop index\"\r\tself\r\t\tmergeSortFrom: startIndex\r\t\tto: stopIndex \r\t\tsrc: self copy \r\t\tdst: self \r\t\tby: aBlock"}],"meta":{"name":"TSortable classTrait","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-DoubleLinkedList","classes":[{"name":"DoubleLinkedList","instanceVariables":[{"name":"head"},{"name":"tail"}],"methods":[{"name":"linksDo:","linesOfCode":8,"sourceCode":"linksDo: block\r\t\"Execute block for each of the links that I hold internally.\"\r\t\r\t| current |\r\tcurrent := head.\r\t[ current isNil ] \r\t\twhileFalse: [ \r\t \t\tblock value: current.\r\t\t\tcurrent := current nextLink ]"},{"name":"isEmpty","linesOfCode":3,"sourceCode":"isEmpty\r\t\"Return true when I contain no elements, false otherwise.\"\r\r\t^ head isNil and: [ tail isNil ]"},{"name":"add:","linesOfCode":4,"sourceCode":"add: anObjectOrLink\r\t\"Add anObjectOrLink at the end of me.\r\tReturn the internal link object.\"\r\t\r\t^ self addLast: anObjectOrLink"},{"name":"emptyCheck","linesOfCode":3,"sourceCode":"emptyCheck\r\r\tself isEmpty\r\t\tifTrue: [ CollectionIsEmpty signalWith: self ]"},{"name":"includes:","linesOfCode":5,"sourceCode":"includes: object\r\t\"Return true when I hold object as a value, false otherwise.\"\r\t\r\tself do: [ :each |\r\t\teach = object ifTrue: [ ^ true ] ].\r\t^ false"},{"name":"tail","linesOfCode":2,"sourceCode":"tail\r\r\t^ tail"},{"name":"collect:","linesOfCode":7,"sourceCode":"collect: block\r\t\"Execute block for each of my elements and return a new instance of me containing the results.\"\r\t\r\t| result |\r\tresult := self class new.\r\tself do: [ :each |\r\t\tresult add: (block value: each) ].\r\t^ result"},{"name":"last","linesOfCode":5,"sourceCode":"last\r\t\"Return the last element that I hold, also known as my tail value.\r\tSignal a CollectionIsEmpty excpetion when I am empty.\"\r\t\r\tself emptyCheck.\r\t^ tail value"},{"name":"firstLink","linesOfCode":5,"sourceCode":"firstLink\r\t\"Return the first link that I hold, also known as my head.\r\tSignal a CollectionIsEmpty excpetion when I am empty.\"\r\t\r\tself emptyCheck.\r\t^ head"},{"name":"head:","linesOfCode":2,"sourceCode":"head: aDoubleLink\r\r\thead := aDoubleLink"},{"name":"asArray","linesOfCode":4,"sourceCode":"asArray\r\t\"Return a new Array containing my elements\"\r\t\r\t^ Array streamContents: [ :out |\r\t\tself do: [ :each | out nextPut: each ] ]"},{"name":"addAll:","linesOfCode":4,"sourceCode":"addAll: collection\r\t\"Add all elements of collection to me, in order.\r\tEach can be either a value object or a link.\"\r\t\r\tcollection do: [ :each | self add: each ]"},{"name":"reject:","linesOfCode":9,"sourceCode":"reject: block\r\t\"Execute block for each of my elements and return a new instance of me \r\tcontaining those elements for which the block returned false.\"\r\r\t| result |\r\tresult := self class new.\r\tself do: [ :each |\r\t\t(block value: each)\r\t\t\tifFalse: [ result add: each ] ].\r\t^ result"},{"name":"reverseLinksDo:","linesOfCode":8,"sourceCode":"reverseLinksDo: block\r\t\"Execute block for each of the links that I hold internally, in reverse order.\"\r\r\t| current |\r\tcurrent := tail.\r\t[ current isNil ] \r\t\twhileFalse: [ \r\t \t\tblock value: current.\r\t\t\tcurrent := current previousLink ]"},{"name":"tail:","linesOfCode":2,"sourceCode":"tail: aDoubleLink\r\r\ttail := aDoubleLink"},{"name":"do:","linesOfCode":3,"sourceCode":"do: block\r\t\"Execute block for each of my elements.\"\r\r\tself linksDo: [ :each | block value: each value ]"},{"name":"removeLink:","linesOfCode":15,"sourceCode":"removeLink: link\r\t\"Remove the specified link.\r\tWhen otherLink is not part of me, the result is undefined.\r\tReturn the removed internal link.\"\r\r\t| predecessor successor |\r\tpredecessor := link previousLink.\r\tsuccessor := link nextLink.\r\tpredecessor\r\t\tifNil: [ head := successor ]\r\t\tifNotNil: [ predecessor nextLink: successor ].\r\tsuccessor\r\t\tifNil: [ tail := predecessor ]\r\t\tifNotNil: [ successor previousLink: predecessor ].\r\tlink clearLinks.\r\t^ link"},{"name":"noneSatisfy:","linesOfCode":4,"sourceCode":"noneSatisfy: aBlock\r\t\"Evaluate aBlock with the elements of the receiver. If aBlock returns false for all elements return true. Otherwise return false\"\r\r\tself do: [:item | (aBlock value: item) ifTrue: [^ false]].\r\t^ true"},{"name":"removeCycledLink:","linesOfCode":16,"sourceCode":"removeCycledLink: link\r\t| predecessor successor |\r\tpredecessor := link previousLink.\r\tsuccessor := link nextLink.\r\tpredecessor\r\t\tifNil: [ head := successor ]\r\t\tifNotNil: [ predecessor nextLink: successor ].\r\tsuccessor\r\t\tifNil: [ tail := predecessor ]\r\t\tifNotNil: [ successor previousLink: predecessor ].\r\tlink clearLinks.\r\t\r\t\"I'm the only one left, clear linked list and return\"\r\t(link = head & (link = tail)) ifTrue: [ head := nil. tail := nil. ^ link ].\r\t\r\tlink = head ifTrue: [ head := successor ].\r\tlink = tail ifTrue: [ tail := predecessor ].\r\t\r\t^ link"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\t\"Remove all the elements that I hold.\"\r\t\r\thead := tail := nil"},{"name":"errorEmptyCollection","linesOfCode":3,"sourceCode":"errorEmptyCollection\r\t\"Signal a CollectionIsEmpty exception\"\r\t\r\tCollectionIsEmpty signalWith: self "},{"name":"head","linesOfCode":2,"sourceCode":"head\r\r\t^ head"},{"name":"reverseDo:","linesOfCode":3,"sourceCode":"reverseDo: block\r\t\"Execute block for each of my elements, in reverse order.\"\r\r\tself reverseLinksDo: [ :each | block value: each value ]"},{"name":"first","linesOfCode":5,"sourceCode":"first\r\t\"Return the first element that I hold, also known as my head value.\r\tSignal a CollectionIsEmpty exception when I am empty.\"\r\t\r\tself emptyCheck.\r\t^ head value"},{"name":"add:beforeLink:","linesOfCode":14,"sourceCode":"add: anObjectOrLink beforeLink: otherLink\r\t\"Add anObjectOrLink right before otherLink in me.\r\tWhen otherLink is not part of me, the result is undefined.\r\tReturn the internal link object.\"\r\r\t| link otherLinkPredeccessor |\r\totherLink = head\r\t\tifTrue: [ ^ self addFirst: anObjectOrLink ].\r\tlink := anObjectOrLink asDoubleLink.\r\totherLinkPredeccessor := otherLink previousLink.\r\totherLink previousLink: link.\r\tlink nextLink: otherLink.\r\tlink previousLink: otherLinkPredeccessor.\r\totherLinkPredeccessor nextLink: link.\r\t^ link"},{"name":"addFirst:","linesOfCode":10,"sourceCode":"addFirst: anObjectOrLink\r\t\"Add anObjectOrLink to me, so that it becomes the first one.\r\tReturn the internal link object.\"\r\t\r\t| link |\r\tlink := anObjectOrLink asDoubleLink.\r\tlink nextLink: head.\r\thead ifNotNil: [ head previousLink: link ].\r\ttail ifNil: [ tail := link ].\r\thead := link.\r\t^ link"},{"name":"removeLast","linesOfCode":13,"sourceCode":"removeLast\r\t\"Remove my last element.\r\tSignal a CollectionIsEmpty exception when I am empty.\r\tReturn the removed internal link.\"\r\r\t| link |\r\tself emptyCheck.\r\tlink := tail.\r\ttail := tail previousLink.\r\ttail \r\t\tifNil: [ head := nil ]\r\t\tifNotNil: [ tail nextLink: nil ].\r\tlink clearLinks.\r\t^ link"},{"name":"add:afterLink:","linesOfCode":14,"sourceCode":"add: anObjectOrLink afterLink: otherLink\r\t\"Add anObjectOrLink right after otherLink in me.\r\tWhen otherLink is not part of me, the result is undefined.\r\tReturn the internal link object.\"\r\r\t| link otherLinkSuccessor |\r\totherLink = tail\r\t\tifTrue: [ ^ self addLast: anObjectOrLink ].\r\tlink := anObjectOrLink asDoubleLink.\r\totherLinkSuccessor := otherLink nextLink.\r\totherLink nextLink: link.\r\tlink previousLink: otherLink.\r\tlink nextLink: otherLinkSuccessor.\r\totherLinkSuccessor previousLink: link.\r\t^ link"},{"name":"lastLink","linesOfCode":5,"sourceCode":"lastLink\r\t\"Return the last link that I hold, also known as my tail.\r\tSignal a CollectionIsEmpty excpetion when I am empty.\"\r\t\r\tself emptyCheck.\r\t^ tail"},{"name":"addLast:","linesOfCode":10,"sourceCode":"addLast: anObjectOrLink\r\t\"Add anObjectOrLink to me, so that it becomes the last one.\r\tReturn the internal link object.\"\r\r\t| link |\r\tlink := anObjectOrLink asDoubleLink.\r\tlink previousLink: tail.\r\ttail ifNotNil: [ tail nextLink: link ].\r\thead ifNil: [ head := link ].\r\ttail := link.\r\t^ link"},{"name":"removeFirst","linesOfCode":13,"sourceCode":"removeFirst\r\t\"Remove my first element.\r\tSignal a CollectionIsEmpty exception when I am empty.\r\tReturn the removed internal link.\"\r\t\r\t| link |\r\tself emptyCheck.\r\tlink := head.\r\thead := head nextLink.\r\thead \r\t\tifNil: [ tail := nil ]\r\t\tifNotNil: [ head previousLink: nil ].\r\tlink clearLinks.\r\t^ link"},{"name":"select:","linesOfCode":9,"sourceCode":"select: block\r\t\"Execute block for each of my elements and return a new instance of me \r\tcontaining those elements for which the block returned true.\"\r\r\t| result |\r\tresult := self class new.\r\tself do: [ :each |\r\t\t(block value: each)\r\t\t\tifTrue: [ result add: each ] ].\r\t^ result"}],"meta":{"name":"DoubleLinkedList class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ManifestCollectionsDoubleLinkedList","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsDoubleLinkedList class","instanceVariables":[],"methods":[{"name":"ruleCollectionProtocolRuleV1FalsePositive","linesOfCode":2,"sourceCode":"ruleCollectionProtocolRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#DoubleLinkedList #addAll: #false)) #'2020-11-13T21:03:12.373876+01:00') #(#(#RGMethodDefinition #(#DoubleLinkedList #collect: #false)) #'2020-11-13T21:03:27.372294+01:00') )"}],"meta":null}},{"name":"DoubleLink","instanceVariables":[{"name":"value"},{"name":"nextLink"},{"name":"previousLink"}],"methods":[{"name":"previousLink","linesOfCode":2,"sourceCode":"previousLink\r\t^ previousLink"},{"name":"hasSuccessor","linesOfCode":2,"sourceCode":"hasSuccessor\r\t^ nextLink notNil"},{"name":"nextLink","linesOfCode":2,"sourceCode":"nextLink\r\t^ nextLink"},{"name":"clearLinks","linesOfCode":2,"sourceCode":"clearLinks\r\tnextLink := previousLink := nil"},{"name":"nextLink:","linesOfCode":2,"sourceCode":"nextLink: anObject\r\tnextLink := anObject"},{"name":"value:","linesOfCode":2,"sourceCode":"value: anObject\r\tvalue := anObject"},{"name":"asDoubleLink","linesOfCode":2,"sourceCode":"asDoubleLink\r\t^ self"},{"name":"hasPredecessor","linesOfCode":2,"sourceCode":"hasPredecessor\r\t^ previousLink notNil"},{"name":"value","linesOfCode":2,"sourceCode":"value\r\t^ value"},{"name":"previousLink:","linesOfCode":2,"sourceCode":"previousLink: anObject\r\tpreviousLink := anObject"},{"name":"asSpotterDoubleLink","linesOfCode":2,"sourceCode":"asSpotterDoubleLink\r\t\r\t^ GTSpotterCandidateLink value: self value"}],"meta":{"name":"DoubleLink class","instanceVariables":[],"methods":[{"name":"value:","linesOfCode":4,"sourceCode":"value: anObject\r\t^ self new\r\t\tvalue: anObject;\r\t\tyourself"}],"meta":null}}]},{"name":"Collections-Stack-Tests","classes":[{"name":"StackTest","instanceVariables":[{"name":"empty"},{"name":"nonEmpty"}],"methods":[{"name":"testTop","linesOfCode":9,"sourceCode":"testTop\r\t| aStack |\r\taStack := Stack new.\r\tself assertEmpty: aStack.\r\taStack push: 'a'.\r\taStack push: 'b'.\r\tself assert: aStack top equals: 'b'.\r\tself assert: aStack top equals: 'b'.\r\tself assert: aStack size equals: 2"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r \t^ nonEmpty"},{"name":"testSize","linesOfCode":12,"sourceCode":"testSize\r\t| aStack |\r\taStack := Stack new.\r\tself assert: aStack size equals: 0.\r\taStack push: 'a'.\r\tself assert: aStack size equals: 1.\r\taStack push: 'b'.\r\tself assert: aStack size equals: 2.\r\taStack pop.\r\tself assert: aStack size equals: 1.\r\taStack pop.\r\tself assert: aStack size equals: 0"},{"name":"setUp","linesOfCode":8,"sourceCode":"setUp\r\tsuper setUp.\r\tempty := Stack new.\r\tnonEmpty := Stack new.\r\tnonEmpty push: 1.\r\tnonEmpty push: -2.\r\tnonEmpty push: 3.\r\tnonEmpty push: 1.\r\t"},{"name":"testPush","linesOfCode":7,"sourceCode":"testPush\r\t| aStack |\r\taStack := Stack new.\r\taStack push: 'a'.\r\tself assert: aStack size equals: 1.\r\taStack push: 'b'.\r\tself assert: aStack size equals: 2"},{"name":"testPop","linesOfCode":13,"sourceCode":"testPop\r\t| aStack res elem |\r\telem := 'anElement'.\r\taStack := Stack new.\r\tself assertEmpty: aStack.\r\r\taStack push: 'a'.\r\taStack push: elem.\r\tres := aStack pop.\r\tself assert: res equals: elem.\r\tself assert: res identicalTo: elem.\r\r\tself assert: aStack size equals: 1.\r\taStack pop.\r\tself assertEmpty: aStack"},{"name":"testEmptyError","linesOfCode":10,"sourceCode":"testEmptyError\r\t| aStack |\r\taStack := Stack new.\r\tself should: [ aStack top ] raise: Error.\r\tself should: [ aStack pop ] raise: Error.\r\taStack push: 'element'.\r\taStack top.\r\taStack pop.\t\"The stack is empty again due to previous pop\"\r\tself should: [ aStack top ] raise: Error.\r\tself should: [ aStack pop ] raise: Error"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r \t^ empty"}],"meta":{"name":"StackTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Support","classes":[{"name":"ValueLink","instanceVariables":[{"name":"value"}],"methods":[{"name":"=","linesOfCode":4,"sourceCode":"= anotherObject\r\t^self species == anotherObject species \r\t\tand: [self value = anotherObject value \r\t\t\t\tand: [self nextLink == anotherObject nextLink]]"},{"name":"value","linesOfCode":2,"sourceCode":"value\r\t^value "},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^self value hash bitXor: nextLink identityHash \r"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\taStream nextPutAll: 'ValueLink('.\r\tvalue printOn: aStream.\r\taStream nextPut: $)\r"},{"name":"value:","linesOfCode":2,"sourceCode":"value: aValue\r\tvalue := aValue"}],"meta":{"name":"ValueLink class","instanceVariables":[],"methods":[{"name":"value:","linesOfCode":2,"sourceCode":"value:\t aValue\r\t^self new value: aValue"}],"meta":null}},{"name":"LookupKey","instanceVariables":[{"name":"key"}],"methods":[{"name":"=","linesOfCode":4,"sourceCode":"= aLookupKey\r\t^ self species = aLookupKey species\r\t\tifTrue: [ key = aLookupKey key ]\r\t\tifFalse: [ false ]"},{"name":"<","linesOfCode":3,"sourceCode":"< aLookupKey \r\t\"Refer to the comment in Magnitude|<.\"\r\r\t^key < aLookupKey key"},{"name":"printOn:","linesOfCode":2,"sourceCode":"printOn: aStream\r\r\tkey printOn: aStream"},{"name":"key:","linesOfCode":3,"sourceCode":"key: anObject \r\t\"Store the argument, anObject, as the lookup key of the receiver.\"\r\r\tkey := anObject"},{"name":"hash","linesOfCode":3,"sourceCode":"hash\r\t\"Hash is reimplemented because = is implemented.\"\r\r\t^key hash"},{"name":"key","linesOfCode":3,"sourceCode":"key\r\t\"Answer the lookup key of the receiver.\"\r\r\t^key"},{"name":"isVariableBinding","linesOfCode":6,"sourceCode":"isVariableBinding\r\r\t\"Return true if I represent a literal variable binding\"\r\r\tself\r\t\tdeprecated: 'Use #isAssociation instead'\r\t\ttransformWith: '`@rec isVariableBinding' -> '`@rec isAssociation'.\r\t^ self isAssociation"},{"name":"name","linesOfCode":4,"sourceCode":"name\r\r\t^ self key isString\r\t\tifTrue: [self key]\r\t\tifFalse: [self key printString]"}],"meta":{"name":"LookupKey class","instanceVariables":[],"methods":[{"name":"key:","linesOfCode":3,"sourceCode":"key: aKey \r\t\"Answer an instance of me with the argument as the lookup up.\"\r\r\t^self basicNew key: aKey"}],"meta":null}},{"name":"WeakKeyAssociation","instanceVariables":[{"name":"value"}],"methods":[{"name":"isVariableBinding","linesOfCode":6,"sourceCode":"isVariableBinding\r\r\t\"Return true if I represent a literal variable binding\"\r\r\tself\r\t\tdeprecated: 'Use #isAssociation instead'\r\t\ttransformWith: '`@rec isVariableBinding' -> '`@rec isAssociation'.\r\t^ self isAssociation"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\r\tself key printOn: aStream.\r\taStream nextPutAll: '->'.\r\tvalue printOn: aStream"},{"name":"value:","linesOfCode":4,"sourceCode":"value: anObject \r\t\"Store the argument, anObject, as the value of the receiver.\"\r\r\tanObject == self ifTrue: [self error: 'Using the WeakAssociation as its own value'].\r\tvalue := anObject"},{"name":"name","linesOfCode":4,"sourceCode":"name\r\r\t^ self key isString\r\t\tifTrue: [self key]\r\t\tifFalse: [self key printString]"},{"name":"=","linesOfCode":5,"sourceCode":"= aLookupKey\r\t\"XXX why doesn't this consider the value? mvl\"\r\r\t^ self species = aLookupKey species\r\t\tifTrue: [ self key = aLookupKey key ]\r\t\tifFalse: [ false ]"},{"name":"<","linesOfCode":3,"sourceCode":"< aLookupKey \r\t\"Refer to the comment in Magnitude|<.\"\r\r\t^self key < aLookupKey key"},{"name":"storeOn:","linesOfCode":14,"sourceCode":"storeOn: aStream\r\t\"Store in the format (WeakKeyAssociation key: theKey value: theValue)\"\r\taStream \r\t\tnextPut: $(;\r\t\tnextPutAll: self class name.\r\tself expired ifTrue:[\r\t\taStream nextPutAll: ' expired'\r\t] ifFalse: [\r\t\taStream nextPutAll:' key: '.\r\t\tself key storeOn: aStream.\r\t\taStream nextPutAll: ' value:'.\r\t\tvalue storeOn: aStream.\r\t].\r\taStream nextPut: $)"},{"name":"key:","linesOfCode":3,"sourceCode":"key: anObject \r\t\"Store the argument, anObject, as the lookup key of the receiver.\"\r\r\tself basicAt: 1 put:  anObject"},{"name":"key:value:","linesOfCode":4,"sourceCode":"key: aKey value: anObject \r\t\"Store the arguments as the variables of the receiver.\"\r\r\tself basicAt: 1 put: aKey.\r\tvalue := anObject"},{"name":"key","linesOfCode":3,"sourceCode":"key\r\t\"Answer the lookup key of the receiver.\"\r\r\t^self basicAt: 1"},{"name":"value","linesOfCode":3,"sourceCode":"value\r\t\"Answer the value of the receiver.\"\r\r\t^ value == self ifTrue:[nil] ifFalse:[value]"},{"name":"expire","linesOfCode":8,"sourceCode":"expire\r    \"Release the value if the key has gone. Return true if a modification was made.\"\r\t(self basicAt: 1) ifNil:[\r\t\tvalue == self ifTrue:[^false].\r\t\tvalue := self.\r\t\t^true\r\t].\r\t^false"},{"name":"expired","linesOfCode":2,"sourceCode":"expired\r\t^value == self"},{"name":"hash","linesOfCode":3,"sourceCode":"hash\r\t\"Hash is reimplemented because = is implemented.\"\r\r\t^self key hash"}],"meta":{"name":"WeakKeyAssociation class","instanceVariables":[],"methods":[{"name":"expired","linesOfCode":5,"sourceCode":"expired\r\t\"Answer an object that is already expired. Used for printing\"\r\t^(self key: nil value: nil)\r\t\texpire;\r\t\tyourself"},{"name":"key:value:","linesOfCode":4,"sourceCode":"key: newKey value: newValue\r\t\"Answer an instance of me with the arguments as the key and value of \r\tthe association.\"\r\r\t^(self basicNew: 1) key: newKey value: newValue"}],"meta":null}},{"name":"Association","instanceVariables":[{"name":"value"}],"methods":[{"name":"matchesSelectCaseFor:","linesOfCode":2,"sourceCode":"matchesSelectCaseFor: matchedElement\r\t^ key matchesPatternElement: matchedElement"},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ self class == Association and: [self key isSelfEvaluating and: [self value isSelfEvaluating]]"},{"name":"literalEqual:","linesOfCode":5,"sourceCode":"literalEqual: otherLiteral\r\t\"Answer true if the receiver and otherLiteral represent the same literal.\r\tVariable bindings are literally equals only if identical.\r\tThis is how variable sharing works, by preserving identity and changing only the value.\"\r\t^self == otherLiteral"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\r\tsuper printOn: aStream.\r\taStream nextPutAll: '->'.\r\tvalue printOn: aStream"},{"name":"value:","linesOfCode":3,"sourceCode":"value: anObject \r\t\"Store the argument, anObject, as the value of the receiver.\"\r\r\tvalue := anObject"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createAssociation: self class: objectModel associationClass"},{"name":"stonOn:","linesOfCode":4,"sourceCode":"stonOn: stonWriter\r\tself class == STON associationClass\r\t\tifTrue: [ stonWriter writeAssociation: self ]\r\t\tifFalse: [ super stonOn: stonWriter ]\r\t"},{"name":"asGlamourOriginIdentifier","linesOfCode":4,"sourceCode":"asGlamourOriginIdentifier\r\t^ GLMPortIdentifier new \r\t\tpaneName: self key;\r\t\tportName: self value"},{"name":"asTestParameter","linesOfCode":5,"sourceCode":"asTestParameter\r\r\t^ ParametrizedTestExpandedParameter new\r\t\tselector: self key;\r\t\tvaluable: self value;\r\t\tyourself"},{"name":"asGlamourTargetIdentifier","linesOfCode":4,"sourceCode":"asGlamourTargetIdentifier\r\t^ GLMPortIdentifier new \r\t\tpaneName: self key;\r\t\tportName: self value"},{"name":"=","linesOfCode":2,"sourceCode":"= anAssociation\r\r\t^ super = anAssociation and: [value = anAssociation value]"},{"name":"analogousCodeTo:","linesOfCode":2,"sourceCode":"analogousCodeTo: anAssociation\r\t^ self = anAssociation"},{"name":"treeNodeTail","linesOfCode":4,"sourceCode":"treeNodeTail\r\r\t^ (key isKindOf: Association)\r\t\tifTrue: [ key treeNodeTail -> value ]\r\t\tifFalse: [ value ]"},{"name":"storeOn:","linesOfCode":7,"sourceCode":"storeOn: aStream\r\t\"Store in the format (key->value)\"\r\taStream nextPut: $(.\r\tkey storeOn: aStream.\r\taStream nextPutAll: '->'.\r\tvalue storeOn: aStream.\r\taStream nextPut: $)"},{"name":"treeNodeHead","linesOfCode":4,"sourceCode":"treeNodeHead\r\r\t^ (key isKindOf: Association)\r\t\tifTrue: [ key treeNodeHead ]\r\t\tifFalse: [ key ]"},{"name":"hasLiteral:","linesOfCode":2,"sourceCode":"hasLiteral: aLiteral\r\t^false"},{"name":"key:value:","linesOfCode":4,"sourceCode":"key: aKey value: anObject \r\t\"Store the arguments as the variables of the receiver.\"\r\r\tkey := aKey.\r\tvalue := anObject"},{"name":"value","linesOfCode":3,"sourceCode":"value\r\t\"Answer the value of the receiver.\"\r\r\t^value"},{"name":"settingFixedDomainValueNodeFrom:","linesOfCode":2,"sourceCode":"settingFixedDomainValueNodeFrom: aSettingNode \r\t^ aSettingNode fixedDomainValueNodeForAssociation: self"},{"name":"isVariableBinding","linesOfCode":3,"sourceCode":"isVariableBinding\r\t\"Can be removed as soon as all bindings are instances of LiteralVariable\"\r\t^true"},{"name":"evaluateMatchedSelectCaseWith:","linesOfCode":2,"sourceCode":"evaluateMatchedSelectCaseWith: matchedElement\r\t^ value evaluateMatchedPatternElement: matchedElement"},{"name":"isAssociation","linesOfCode":2,"sourceCode":"isAssociation\r\t^ true"}],"meta":{"name":"Association class","instanceVariables":[],"methods":[{"name":"key:value:","linesOfCode":4,"sourceCode":"key: newKey value: newValue\r\t\"Answer an instance of me with the arguments as the key and value of \r\tthe association.\"\r\r\t^self basicNew key: newKey value: newValue"}],"meta":null}},{"name":"CharacterSet","instanceVariables":[{"name":"map"}],"methods":[{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\r\tmap atAllPut: 0"},{"name":"findFirstInByteString:startingAt:","linesOfCode":6,"sourceCode":"findFirstInByteString: aByteString startingAt: startIndex\r\t\"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver.\"\r\t^ByteString\r\t\tfindFirstInString: aByteString\r\t\tinSet: self byteArrayMap\r\t\tstartingAt: startIndex"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^map sum"},{"name":"byteComplement","linesOfCode":6,"sourceCode":"byteComplement\r\t\"return a character set containing precisely the single byte characters the receiver does not\"\r\t\r\t| set |\r\tset := self class allCharacters.\r\tself do: [ :c | set remove: c ].\r\t^set"},{"name":"add:","linesOfCode":11,"sourceCode":"add: aCharacter\r\t\"I automatically become a WideCharacterSet if you add a wide character to myself\"\r\t\r\taCharacter asciiValue >= 256\r\t\tifTrue: [| wide |\r\t\t\twide := WideCharacterSet new.\r\t\t\twide addAll: self.\r\t\t\twide add: aCharacter.\r\t\t\tself becomeForward: wide.\r\t\t\t^aCharacter].\r\tmap at: aCharacter asciiValue + 1 put: 1.\r\t^aCharacter"},{"name":"byteArrayMap","linesOfCode":3,"sourceCode":"byteArrayMap\r\t\"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only\"\r\t^map"},{"name":"includes:","linesOfCode":5,"sourceCode":"includes: aCharacter\r\t\"Guard against wide characters\"\r\t^aCharacter asciiValue >= 256\r\t\tifTrue: [ false ]\r\t\tifFalse: [ (map at: aCharacter asciiValue + 1) > 0 ]"},{"name":"initialize","linesOfCode":3,"sourceCode":"initialize\r\tsuper initialize.\r\tmap := ByteArray new: 256 withAll: 0."},{"name":"remove:","linesOfCode":5,"sourceCode":"remove: aCharacter\r\taCharacter asciiValue >= 256\r\t\tifFalse: [\"Guard against wide characters\"\r\t\t\tmap at: aCharacter asciiValue + 1 put: 0].\r\t^aCharacter"},{"name":"=","linesOfCode":3,"sourceCode":"= anObject\r\t^self species == anObject species and: [\r\t\tself byteArrayMap = anObject byteArrayMap ]"},{"name":"asString","linesOfCode":6,"sourceCode":"asString\r\t\"Convert the receiver into a String\"\r\r\t^String \r\t\tnew: self size \r\t\tstreamContents: \r\t\t\t[ :s | self do: [ :ch | s nextPut: ch]]."},{"name":"hasWideCharacters","linesOfCode":2,"sourceCode":"hasWideCharacters\r\t^false"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tmap := map copy"},{"name":"complement","linesOfCode":3,"sourceCode":"complement\r\t\"return a character set containing precisely the characters the receiver does not\"\r\t\r\t^CharacterSetComplement of: self copy"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock\r\t\"evaluate aBlock with each character in the set\"\r\r\tCharacter allByteCharacters do: [ :c |\r\t\t(self includes: c) ifTrue: [ aBlock value: c ] ]\r"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^self byteArrayMap hash"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: aCharacter ifAbsent: aBlock\r\t(self includes: aCharacter) ifFalse: [^aBlock value].\r\t^self remove: aCharacter"},{"name":"wideCharacterMap","linesOfCode":6,"sourceCode":"wideCharacterMap\r\t\"used for comparing with WideCharacterSet\"\r\t\r\t| wide |\r\twide := WideCharacterSet new.\r\twide addAll: self.\r\t^wide wideCharacterMap"}],"meta":{"name":"CharacterSet class","instanceVariables":[],"methods":[{"name":"nonSeparators","linesOfCode":3,"sourceCode":"nonSeparators\r\t\"return a set containing everything but the whitespace characters\"\r\r\t^self separators complement"},{"name":"separators","linesOfCode":6,"sourceCode":"separators\r\t\"return a set containing just the whitespace characters\"\r\r\t| set |\r\tset := self empty.\r\tset addAll: Character separators.\r\t^set"},{"name":"crlf","linesOfCode":3,"sourceCode":"crlf\r\tCrLf ifNil: [CrLf := self with: Character cr with: Character lf].\r\t^CrLf"},{"name":"allCharacters","linesOfCode":6,"sourceCode":"allCharacters\r\t\"return a set containing all characters\"\r\r\t| set |\r\tset := self empty.\r\t0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].\r\t^set"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection\r\t| newCollection |\r\tnewCollection := self new.\r\tnewCollection addAll: aCollection.\r\t^newCollection"}],"meta":null}},{"name":"CharacterSetComplement","instanceVariables":[{"name":"absent"},{"name":"byteArrayMapCache"}],"methods":[{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\tself becomeForward: CharacterSet new"},{"name":"findFirstInByteString:startingAt:","linesOfCode":6,"sourceCode":"findFirstInByteString: aByteString startingAt: startIndex\r\t\"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver.\"\r\t^ByteString\r\t\tfindFirstInString: aByteString\r\t\tinSet: self byteArrayMap\r\t\tstartingAt: startIndex"},{"name":"size","linesOfCode":4,"sourceCode":"size\r\t\"The size is all characters minus those explicitly excluded\"\r\r\t\"Character values include 0, so we need to add 1.\"\r\t^Character maxVal + 1 - absent size"},{"name":"printOn:","linesOfCode":6,"sourceCode":"printOn: aStream\r\t\"Print a description of the complement rather than self.\r\tRationale: self would be too long to print.\"\r\t\r\taStream nextPut: $(.\r\tabsent printOn: aStream.\r\taStream nextPut: $); space; nextPutAll: #complement."},{"name":"add:","linesOfCode":7,"sourceCode":"add: aCharacter \r\t\"a character is present if not absent, so adding a character is removing it from the absent\"\r\t\r\t(absent includes: aCharacter)\r\t\tifTrue:\r\t\t\t[byteArrayMapCache := nil.\r\t\t\tabsent remove: aCharacter].\r\t^ aCharacter"},{"name":"byteArrayMap","linesOfCode":3,"sourceCode":"byteArrayMap\r\t\"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only\"\r\r\t^byteArrayMapCache ifNil: [byteArrayMapCache := absent byteArrayMap collect: [:i | 1 - i]]"},{"name":"includes:","linesOfCode":2,"sourceCode":"includes: aCharacter\r\t^(absent includes: aCharacter) not"},{"name":"remove:","linesOfCode":5,"sourceCode":"remove: aCharacter\r\t\"This means aCharacter is now absent from myself.\r\tIt must be added to my absent.\"\r\t\r\tbyteArrayMapCache := nil.\r\t^absent add: aCharacter"},{"name":"=","linesOfCode":5,"sourceCode":"= anObject\r\t\"Implementation note: we do not test if equal to a WideCharacterSet,\r\tbecause it is unlikely that WideCharacterSet is as complete as self\"\r\t\r\t^self class == anObject class and: [\r\t\tabsent = anObject complement ]"},{"name":"hasWideCharacters","linesOfCode":3,"sourceCode":"hasWideCharacters\r\t\"This is a guess that absent is not holding each and every possible wideCharacter...\"\r\t\r\t^true"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tabsent := absent copy"},{"name":"reject:","linesOfCode":3,"sourceCode":"reject: aBlock\r\t\"Implementation note: rejecting present is selecting absent\"\r\t\r\t^(absent select: aBlock) complement"},{"name":"complement","linesOfCode":3,"sourceCode":"complement\r\t\"return a character set containing precisely the characters the receiver does not\"\r\t\r\t^absent copy"},{"name":"storeOn:","linesOfCode":5,"sourceCode":"storeOn: aStream\r\t\"Store a description of the elements of the complement rather than self.\"\r\t\r\taStream nextPut: $(.\r\tabsent storeOn: aStream.\r\taStream nextPut: $); space; nextPutAll: #complement."},{"name":"gtInspectorItemsIn:","linesOfCode":15,"sourceCode":"gtInspectorItemsIn: composite\r\t\"The default set is huge, inspect the Absent list, which is typically a manageable size\"\r\r\t^ composite fastList\r\t\ttitle: 'Absent';\r\t\tdisplay: [ absent asArray ];\r\t\tbeMultiple;\r\t\tformat: [ :each | GTObjectPrinter asTruncatedTextFrom: each ];\r\t\tsend: [ :result | \r\t\t\t\"withSmalltalkSearch;\t\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'.\"\r\t\t\tresult\r\t\t\t\tifNotNil: [ result size = 1\r\t\t\t\t\t\tifTrue: [ result anyOne ]\r\t\t\t\t\t\tifFalse: [ self species withAll: result ] ] ]"},{"name":"do:","linesOfCode":5,"sourceCode":"do: aBlock\r\t\"evaluate aBlock with each character in the set\"\r\r\t0 to: self size - 1 do: [ :codePoint | | ch |\r\t\tch := Character value: codePoint.\r\t\t(self includes: ch) ifTrue: [ aBlock value: ch ] ]"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^absent hash bitXor: self class hash"},{"name":"complement:","linesOfCode":4,"sourceCode":"complement: aCharacterSet\r\t\"initialize with the complement\"\r\t\r\tbyteArrayMapCache := nil.\r\tabsent := aCharacterSet.\r\t"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: aCharacter ifAbsent: aBlock\r\t(self includes: aCharacter) ifFalse: [^aBlock value].\r\t^self remove: aCharacter"},{"name":"select:","linesOfCode":3,"sourceCode":"select: aBlock\r\t\"Implementation note: selecting present is rejecting absent\"\r\t\r\t^(absent reject: aBlock) complement"}],"meta":{"name":"CharacterSetComplement class","instanceVariables":[],"methods":[{"name":"of:","linesOfCode":3,"sourceCode":"of: aCharacterSet\r\t\"answer the complement of aCharacterSet\"\r\t\r\t^ super new complement: aCharacterSet"}],"meta":null}},{"name":"WideCharacterSet","instanceVariables":[{"name":"map"},{"name":"byteArrayMap"}],"methods":[{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\tmap removeAll.\r\tbyteArrayMap := ByteArray new: 256"},{"name":"findFirstInByteString:startingAt:","linesOfCode":6,"sourceCode":"findFirstInByteString: aByteString startingAt: startIndex\r\t\"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver.\"\r\t^ByteString\r\t\tfindFirstInString: aByteString\r\t\tinSet: self byteArrayMap\r\t\tstartingAt: startIndex"},{"name":"size","linesOfCode":8,"sourceCode":"size\r\t| size |\r\tsize := 0.\r\tmap\r\t\tkeysAndValuesDo: [:high :lowmap | self\r\t\t\t\tbitmap: lowmap\r\t\t\t\tdo: [:low | size := size + 1]].\r\t^ size"},{"name":"add:","linesOfCode":10,"sourceCode":"add: aCharacter \r\t| val high low lowmap |\r\tval := aCharacter asciiValue.\r\tval < 256 ifTrue: [self byteArrayMap at: val + 1 put: 1].\r\thigh := val bitShift: -16.\r\tlow := val bitAnd: 16rFFFF.\r\tlowmap := map at: high ifAbsentPut: [\"create a chunk of 65536=8192*8 bits\"\r\t\tByteArray new: 8192].\r\tself setBitmap: lowmap at: low.\r\t^ aCharacter"},{"name":"byteArrayMap","linesOfCode":11,"sourceCode":"byteArrayMap\r\t\"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.\r\tIntended for use by primitives only. (and comparison)\r\tThis version will answer a subset with only byte characters\"\r\t\r\t| lowmap |\r\tbyteArrayMap ifNil: [\r\t\tbyteArrayMap := ByteArray new: 256.\r\t\tlowmap := map at: 0 ifAbsent: [^byteArrayMap].\r\t\tlowmap := lowmap copyFrom: 1 to: 32. \"Keep first 8*32=256 bits...\"\r\t\tself bitmap: lowmap do: [:code | byteArrayMap at: code + 1 put: 1]].\r\t^byteArrayMap"},{"name":"includes:","linesOfCode":10,"sourceCode":"includes: aCharacter \r\t| val high low |\r\tval := aCharacter asciiValue.\r\thigh := val bitShift: -16.\r\tlow := val bitAnd: 16rFFFF.\r\t^(self\r\t\tbitmap: (map\r\t\t\t\tat: high\r\t\t\t\tifAbsent: [^ false])\r\t\tat: low) isZero not"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\tsuper initialize.\r\tmap := Dictionary new.\r\tbyteArrayMap := ByteArray new: 256"},{"name":"setBitmap:at:","linesOfCode":7,"sourceCode":"setBitmap: aMap at: shortInteger\r\t\"set a single bit in aMap.\r\tshortInteger should be between: 0 and: 16rFFFF\"\r\t\r\t| collecIndex bitIndex |\r\tcollecIndex := shortInteger bitShift: -3.\r\tbitIndex := shortInteger bitAnd: 7.\r\t^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))"},{"name":"remove:","linesOfCode":13,"sourceCode":"remove: aCharacter \r\t| val high low lowmap |\r\tval := aCharacter asciiValue.\r\tval < 256 ifTrue: [self byteArrayMap at: val + 1 put: 0].\r\thigh := val bitShift: -16.\r\tlow := val bitAnd: 16rFFFF.\r\tlowmap := map\r\t\t\t\tat: high\r\t\t\t\tifAbsent: [^ aCharacter].\r\tself clearBitmap: lowmap at: low.\r\t(lowmap allSatisfy: [:e | e = 0])\r\t\tifTrue: [map removeKey: high].\r\t^ aCharacter"},{"name":"=","linesOfCode":3,"sourceCode":"= anObject\r\t^self species == anObject species and: [\r\t\tself wideCharacterMap = anObject wideCharacterMap ]"},{"name":"hasWideCharacters","linesOfCode":4,"sourceCode":"hasWideCharacters\r\t\"Answer true if i contain any wide character\"\r\t\r\tself do: [:e | e asciiValue >= 256 ifTrue: [^true]].\r\t^false"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tmap := map collect: [:each | each copy]"},{"name":"complement","linesOfCode":3,"sourceCode":"complement\r\t\"return a character set containing precisely the characters the receiver does not\"\r\t\r\t^CharacterSetComplement of: self copy"},{"name":"clearBitmap:at:","linesOfCode":7,"sourceCode":"clearBitmap: aMap at: shortInteger\r\t\"clear a single bit in aMap.\r\tshortInteger should be between: 0 and: 16rFFFF\"\r\t\r\t| collecIndex bitIndex |\r\tcollecIndex := shortInteger bitShift: -3.\r\tbitIndex := shortInteger bitAnd: 7.\r\t^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))"},{"name":"do:","linesOfCode":8,"sourceCode":"do: aBlock \r\tmap\r\t\tkeysAndValuesDo: [:index :lowmap |\r\t\t\t| high16Bits |\r\t\t\thigh16Bits := index bitShift: 16.\r\t\t\tself\r\t\t\t\tbitmap: lowmap\r\t\t\t\tdo: [:low16Bits | aBlock value: (Character value: high16Bits + low16Bits)]]"},{"name":"bitmap:at:","linesOfCode":7,"sourceCode":"bitmap: aMap at: shortInteger\r\t\"access a single bit in aMap.\r\tshortInteger should be between: 0 and: 16rFFFF\"\r\t\r\t| collecIndex bitIndex |\r\tcollecIndex := shortInteger bitShift: -3.\r\tbitIndex := shortInteger bitAnd: 7.\r\t^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)"},{"name":"species","linesOfCode":4,"sourceCode":"species\r\t^self hasWideCharacters\r\t\tifTrue: [WideCharacterSet]\r\t\tifFalse: [CharacterSet]"},{"name":"hash","linesOfCode":8,"sourceCode":"hash\r\t\"Answer a hash code aimed at storing and retrieving the receiver in a Set or Dictionary.\r\tTwo equal objects should have equal hash.\r\tNote: as the receiver can be equal to an ordinary CharacterSet,\r\tthe hash code must reflect this\"\r\t\r\t^self hasWideCharacters\r\t\tifTrue: [map hash]\r\t\tifFalse: [self asCharacterSet hash]"},{"name":"remove:ifAbsent:","linesOfCode":3,"sourceCode":"remove: aCharacter ifAbsent: aBlock\r\t(self includes: aCharacter) ifFalse: [^aBlock value].\r\t^self remove: aCharacter"},{"name":"bitmap:do:","linesOfCode":13,"sourceCode":"bitmap: aMap do: aBlock\r\t\"Execute a block with each value (0 based) corresponding to set bits.\r\tImplementation notes: this version works best for sparse maps.\r\tIt has (byte lowBit) inlined for speed.\"\r\t\r\t| byte byteOffset lowBits |\r\tlowBits := #[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]. \"The lowBits table gives a 1-based bitOffset\"\r\t1 to: aMap size do: [:i | \r\t\t(byte := aMap at: i) = 0 ifFalse: [\r\t\t\tbyteOffset := (i bitShift: 3) - 9. \"This byteOffset is -1 based\"\r\t\t\t[\"Evaluate the block with 0-based (byteOffset + bitOffset)\"\r\t\t\taBlock value: (byteOffset + (lowBits at: byte)).\r\t\t\t\"Eliminate the low bit and loop if some bit remain\"\r\t\t\t(byte := byte bitAnd: byte - 1) = 0] whileFalse]]"},{"name":"wideCharacterMap","linesOfCode":2,"sourceCode":"wideCharacterMap\r\t^map"}],"meta":{"name":"WideCharacterSet class","instanceVariables":[],"methods":[{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection\r\t| newCollection |\r\tnewCollection := self new.\r\tnewCollection addAll: aCollection.\r\t^newCollection"}],"meta":null}},{"name":"Link","instanceVariables":[{"name":"nextLink"}],"methods":[{"name":"nextLink:","linesOfCode":4,"sourceCode":"nextLink: aLink \r\t\"Store the argument, aLink, as the link to which the receiver refers. \r\tAnswer aLink.\"\r\r\t^nextLink := aLink"},{"name":"asLink","linesOfCode":2,"sourceCode":"asLink\r\t^self"},{"name":"nextLink","linesOfCode":3,"sourceCode":"nextLink\r\t\"Answer the link to which the receiver points.\"\r\r\t^nextLink"}],"meta":{"name":"Link class","instanceVariables":[],"methods":[{"name":"nextLink:","linesOfCode":3,"sourceCode":"nextLink: aLink \r\t\"Answer an instance of me referring to the argument, aLink.\"\r\r\t^self new nextLink: aLink; yourself"}],"meta":null}},{"name":"WeakValueAssociation","instanceVariables":[],"methods":[{"name":"value:","linesOfCode":3,"sourceCode":"value: anObject\r\t\"Store the argument, anObject, as the value of the receiver.\"\r\r\tself at: 1 put: anObject"},{"name":"key:value:","linesOfCode":4,"sourceCode":"key: aKey value: anObject \r\t\"Store the arguments as the variables of the receiver.\"\r\r\tkey := aKey.\r\tself value: anObject"},{"name":"value","linesOfCode":2,"sourceCode":"value\r\t^ self at: 1"}],"meta":{"name":"WeakValueAssociation class","instanceVariables":[],"methods":[{"name":"key:value:","linesOfCode":2,"sourceCode":"key: anObject value: bObject\r\t^ self new key: anObject value: bObject"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: 1"}],"meta":null}},{"name":"ManifestCollectionsSupport","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsSupport class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'Collections-Streams')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Strings' #'Collections-Native' #'Collections-Unordered' #Kernel #'Collections-Abstract')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Support'"}],"meta":null}},{"name":"CollectionElement","instanceVariables":[{"name":"enclosedElement"}],"methods":[{"name":"=","linesOfCode":4,"sourceCode":"= anObject\r\tsuper = anObject ifTrue: [ ^ true ].\r\tanObject class = self class ifFalse: [ ^ false ].\r\r\t^ enclosedElement = anObject enclosedElement"},{"name":"enclosedElement","linesOfCode":2,"sourceCode":"enclosedElement\r\t^ enclosedElement"},{"name":"enclosedElement:","linesOfCode":2,"sourceCode":"enclosedElement: anObject\r\tenclosedElement := anObject"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^ enclosedElement hash\r"},{"name":"asCollectionElement","linesOfCode":4,"sourceCode":"asCollectionElement\r\t\"A receiver has to be included into a collection needing a wrapper to manage nil elements, as a distinct object.\r\tWe need to wrap receiver in own turn, otherwise #enclosedElement ill return wrong object for that collection\"\r\r\t^ self class with: self"}],"meta":{"name":"CollectionElement class","instanceVariables":[],"methods":[{"name":"initialize","linesOfCode":2,"sourceCode":"initialize\r\tNilElement := self with: nil.\r"},{"name":"with:","linesOfCode":2,"sourceCode":"with: anObject\r\t^ self new enclosedElement: anObject"},{"name":"withNil","linesOfCode":2,"sourceCode":"withNil\r\t^ NilElement\r"}],"meta":null}}]},{"name":"Collections-Tests","classes":[{"name":"WeakValueDictionary","instanceVariables":[],"methods":[{"name":"size","linesOfCode":5,"sourceCode":"size\r\t| count |\r\tcount := 0.\r\tself valuesDo: [ :each | count := count + 1 ].\r\t^ count"},{"name":"clyIncludesCleanedKey:","linesOfCode":3,"sourceCode":"clyIncludesCleanedKey: key\r\t\"Answer whether the receiver has a key which value was collected as garbage\"\r\t\r\t^ (array at: (self scanFor: key)) value == nil"},{"name":"valuesDo:","linesOfCode":7,"sourceCode":"valuesDo: aBlock\r\t\"See comments in Dictionary>>valuesDo:.  The code keeps\r\ta reference to the value to facilitate debugging\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\t1 to: array size do: [ :eachIndex | \r\t\t(array at: eachIndex) value\r\t\t\tifNotNil: [ :assocValue | aBlock value: assocValue enclosedElement ] ]"},{"name":"includesKey:","linesOfCode":5,"sourceCode":"includesKey: key\r\t\"Answer whether the receiver has a key equal to the argument and also that the value associated to this key was not garbage collected.\"\r\r\t^ (array at: (self scanFor: key))\r\t\tifNil: [ false ]\r\t\tifNotNil: [ :value | value value isNotNil ]"},{"name":"add:","linesOfCode":3,"sourceCode":"add: anAssociation\r\tself at: anAssociation key put: anAssociation value.\r\t^ anAssociation"},{"name":"rehash","linesOfCode":5,"sourceCode":"rehash\r\t| newSelf |\r\tnewSelf := self species new: self size.\r\tarray do: [ :each | each value ifNotNil: [ :asso | newSelf noCheckAdd: each ] ].\r\tarray := newSelf array"},{"name":"associationsDo:","linesOfCode":4,"sourceCode":"associationsDo: aBlock\r\t\"Evaluate aBlock for each of the receiver's elements (key/value associations).\"\r\r\ttally = 0 ifTrue: [ ^ self ].\r\tarray do: [ :each | each value ifNotNil: [ :value | aBlock value: each key -> value enclosedElement ] ]"},{"name":"associationAt:ifAbsent:","linesOfCode":6,"sourceCode":"associationAt: key ifAbsent: aBlock\r\t\"Answer the association with the given key.\r\tIf the key is not found, return the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key))\r\t\tifNil: [ aBlock value ]\r\t\tifNotNil: [ :assoc | assoc key -> assoc value enclosedElement ]"},{"name":"at:ifPresent:ifAbsentOrNil:","linesOfCode":8,"sourceCode":"at: key ifPresent: presentBlock ifAbsentOrNil: absentBlock\r\r\t^ self \r\t\tat: key\r\t\tifPresent: [:valueOrNil | \r\t\t\tvalueOrNil\r\t\t\t\tifNotNil: presentBlock\r\t\t\t\tifNil: absentBlock ]\r\t\tifAbsent: absentBlock"},{"name":"clyCleanGarbage","linesOfCode":9,"sourceCode":"clyCleanGarbage\r\r\t| firstFound |\r\tarray withIndexDo: [:ass :index | \r\t\t(ass notNil and: [ass value isNil]) ifTrue: [ \r\t\t\tarray at: index put: nil.\r\t\t\ttally := tally - 1.\r\t\t\tfirstFound ifNil: [firstFound := index]]].\r\t\r\tfirstFound ifNotNil: [ \r\t\tself fixCollisionsFrom: firstFound]"},{"name":"at:ifPresent:","linesOfCode":6,"sourceCode":"at: key ifPresent: aBlock\r\t\"Lookup the given key in the receiver. If it is present, answer the\r\tvalue of evaluating the given block optionally with the value associated\r\twith the key.\r\tOtherwise, answer nil.\"\r\r\t^ (array at: (self findElementOrNil: key)) value ifNotNil: [ :value | aBlock cull: value enclosedElement ]"},{"name":"privateAssociations","linesOfCode":3,"sourceCode":"privateAssociations\r\t\"I am a method used for test to return the WeakValueAssociations instead of Associations.\"\r\r\t^ array select: [ :each | each value isNotNil ]"},{"name":"at:ifAbsent:","linesOfCode":6,"sourceCode":"at: key ifAbsent: aBlock\r\t\"Answer the value associated with the key or, if key isn't found,\r\tanswer the result of evaluating aBlock.\"\r\r\t^ (array at: (self findElementOrNil: key)) value\r\t\t\tifNil: aBlock\r\t\t\tifNotNil: [ :value | value enclosedElement ]"},{"name":"at:put:","linesOfCode":9,"sourceCode":"at: key put: anObject\r\t\"Set the value at key to be anObject.  If key is not found, create a new\r\tentry for key and set is value to anObject. Answer anObject.\"\r\r\t| index |\r\tindex := self findElementOrNil: key.\r\t(array at: index)\r\t\tifNil: [ self atNewIndex: index put: (WeakValueAssociation key: key value: anObject asCollectionElement) ]\r\t\tifNotNil: [ :element | element value: anObject asCollectionElement ].\r\t^ anObject"}],"meta":{"name":"WeakValueDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"NativeArrayTest","instanceVariables":[],"methods":[{"name":"testDoubleArraysHaveCorrectLayout","linesOfCode":5,"sourceCode":"testDoubleArraysHaveCorrectLayout\r\tself skip.\r\t\"this is broken, work in progress see https://github.com/pharo-project/pharo/issues/5956\"\r\tself assert: DoubleWordArray classLayout class equals: DoubleWordLayout.\r\tself assert: DoubleByteArray classLayout class equals: DoubleByteLayout"},{"name":"guineaPigHerd","linesOfCode":5,"sourceCode":"guineaPigHerd\r\t\"Different alignment, different classes\"\r\t^ self guineaPigClasses flatCollect: [ :cls |\r\t\tself alignments collect: [ :align |\r\t\t\tcls newFrom: align ] ]"},{"name":"testAtPutBiggerNumberThrowsException","linesOfCode":9,"sourceCode":"testAtPutBiggerNumberThrowsException\r\t\"Make sure native arrays can contain elements of their slot size\"\r\r\tself guineaPigClasses do: [ :guineaPig | | nativeArray smallerNumber bytesToShift |\r\t\tnativeArray := guineaPig new: 1.\r\t\tbytesToShift := guineaPig classLayout bytesPerSlot * 8 \"bits per byte\".\r\t\tsmallerNumber := 1 << bytesToShift.\r\r\t\tself\r\t\t\tshould: [ nativeArray at: 1 put: smallerNumber ]\r\t\t\traise: Error ]"},{"name":"guineaPigClasses","linesOfCode":2,"sourceCode":"guineaPigClasses\r\t^ { ByteArray . DoubleByteArray . WordArray . DoubleWordArray}"},{"name":"testAtAllPut","linesOfCode":8,"sourceCode":"testAtAllPut\r\t\"Makes sure the primitive works correctly with different data structures\"\r\tself guineaPigHerd do: [ :guineaPig |\r\t\tguineaPig atAllPut: 42.\r\t\t1 to: (self wordSize min: guineaPig size) do: [ :i |\r\t\t\tself assert: (guineaPig at: i) equals: 42 ].\r\t\t(guineaPig size - self wordSize max: 1) to: guineaPig size do: [ :i |\r\t\t\tself assert: (guineaPig at: i) equals: 42 ] ]"},{"name":"testAtAllPutFail","linesOfCode":4,"sourceCode":"testAtAllPutFail\r\t\"Makes sure the primitive works correctly with different data structures\"\r\tself guineaPigHerd do: [ :guineaPig |\r\t\tself should: [guineaPig atAllPut: -1] raise: Error ]"},{"name":"alignments","linesOfCode":12,"sourceCode":"alignments\r\t\"Arrays aligned differently on 8 bytes boundary (when turned into byteArrays)\"\r\t^ #( \r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80) \"aligned\"\r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10) \"+ 1..\"\r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20)\r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30)\r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40)\r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50)\r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60)\r\t(10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70 80 10 20 30 40 50 60 70) \"+ 7 !\"\r\t)"},{"name":"testReplaceFromToWithStartingAt","linesOfCode":10,"sourceCode":"testReplaceFromToWithStartingAt\r\t\"Makes sure the primitive works correctly with different data structures\"\r\tself guineaPigHerd do: [ :guineaPig |\r\t\t| copy |\r\t\tcopy := guineaPig copy.\r\t\t1 to: copy size do: [ :l | copy at: l put: l ]. \r\t\tself alignmentIndexesDo: [ :i :j :k |\r\t\t\t\t\tguineaPig replaceFrom: i to: j + 8 with: copy startingAt: k.\r\t\t\t\t\tself assert: (guineaPig at: i) equals: (copy at: k).\r\t\t\t\t\tself assert: (guineaPig at: j + 8) equals: (copy at: j + 8 - i + k) ] ]"},{"name":"alignmentIndexesDo:","linesOfCode":7,"sourceCode":"alignmentIndexesDo: aBlock\r\t| max |\r\tmax := self wordSize.\r\t1 to: max do: [ :i |\r\t\t1 to: max do: [ :j |\r\t\t\t1 to: max do: [ :k |\r\t\t\t\taBlock value: i value: j value: k ] ] ] "},{"name":"wordSize","linesOfCode":2,"sourceCode":"wordSize\r\t^ Smalltalk wordSize"},{"name":"testAtPutExactSizeNumber","linesOfCode":9,"sourceCode":"testAtPutExactSizeNumber\r\t\"Make sure native arrays can contain elements of their slot size\"\r\r\tself guineaPigClasses do: [ :guineaPig | | nativeArray smallerNumber bytesToShift |\r\t\tnativeArray := guineaPig new: 1.\r\t\tbytesToShift := guineaPig classLayout bytesPerSlot * 8 \"bits per byte\" - 1.\r\t\tsmallerNumber := 1 << bytesToShift.\r\r\t\tnativeArray at: 1 put: smallerNumber.\r\t\tself assert: (nativeArray at: 1) equals: smallerNumber\r\t]"}],"meta":{"name":"NativeArrayTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"FloatArrayTest","instanceVariables":[{"name":"nonEmpty5ElementsNoDuplicate"},{"name":"empty"},{"name":"elementNotIn"},{"name":"elementTwiceIn"},{"name":"collectionWithEqualElements"},{"name":"nonEmpty1Element"},{"name":"collectionWithSameAtEndAndBegining"},{"name":"collectionWith1TimeSubcollection"},{"name":"collectionWith2TimeSubcollection"},{"name":"collectionNotIncluded"},{"name":"nonEmptySubcollection"},{"name":"elementInNonEmpty"},{"name":"replacementCollectionSameSize"},{"name":"sortedCollection"}],"methods":[{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\" return a collection that doesn't includes equal elements' and doesn't include nil elements'\" \r\t^nonEmpty5ElementsNoDuplicate "},{"name":"elementsCopyNonIdenticalWithoutEqualElements","linesOfCode":4,"sourceCode":"elementsCopyNonIdenticalWithoutEqualElements\r\t\" return a collection that does niot incllude equal elements ( classic equality )\r\tall elements included are elements for which copy is not identical to the element  \"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"testSumWithIntegerArray","linesOfCode":7,"sourceCode":"testSumWithIntegerArray\r\t| floatArray integerArray expectedResult actualResult |\r\t\r\tfloatArray := #(1 2) asFloatArray.\r\tintegerArray := #(3 4) asIntegerArray.\r\t\r\texpectedResult := #(4 6) asFloatArray.\r\tactualResult := floatArray + integerArray.\r\t\r\tself assert: actualResult equals: expectedResult."},{"name":"withEqualElements","linesOfCode":2,"sourceCode":"withEqualElements\r\t^ collectionWithEqualElements "},{"name":"subCollectionNotIn","linesOfCode":4,"sourceCode":"subCollectionNotIn\r\" return a collection for which at least one element is not included in 'moreThan4Elements' \"\r\t^ collectionNotIncluded \r\t\tifNil: [ collectionNotIncluded := (FloatArray new: 2) at:1 put: elementNotIn ; at: 2 put: elementNotIn  ; yourself ]."},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"collectionWithElementsToRemove","linesOfCode":4,"sourceCode":"collectionWithElementsToRemove\r\" return a collection of elements included in 'nonEmpty'  \"\r\t^ nonEmptySubcollection \r\tifNil: [ nonEmptySubcollection := (FloatArray new:2 ) at:1 put: self nonEmpty first ; at:2 put: self nonEmpty last ; yourself ]"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"testDotProduct","linesOfCode":5,"sourceCode":"testDotProduct\r\t| a b |\r\ta := #(2.0 3.0 4.0 5.0) asFloatArray.\r\tb := #(2.0 3.0 4.0 5.0) asFloatArray.\r\tself assert: (a dot: b) equals: 54"},{"name":"testSumWithFloatScalar","linesOfCode":7,"sourceCode":"testSumWithFloatScalar\r\t| floatArray scalar expectedResult actualResult |\r\t\r\tfloatArray := #(1 2) asFloatArray.\r\tscalar := 0.1.\r\t\r\texpectedResult := #(1.1 2.1) asFloatArray.\r\tactualResult := floatArray + scalar.\r\t\r\tself assert: actualResult equals: expectedResult."},{"name":"newElement","linesOfCode":3,"sourceCode":"newElement\r\"return an element that will be put in the collection in place of another\"\r\t^ elementNotIn "},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\" return an index between 'collectionWithoutEqualsElements'  bounds\"\r\t^ 2."},{"name":"testArithmeticCoercion","linesOfCode":10,"sourceCode":"testArithmeticCoercion\r\t\"This test is related to http://bugs.squeak.org/view.php?id=6782\"\r\t\r\tself assert: 3.0 / (FloatArray with: 2.0) equals: (FloatArray with: 1.5).\r\tself assert: 3.0 * (FloatArray with: 2.0) equals: (FloatArray with: 6.0).\r\tself assert: 3.0 + (FloatArray with: 2.0) equals: (FloatArray with: 5.0).\r\tself assert: 3.0 - (FloatArray with: 2.0) equals: (FloatArray with: 1.0).\r\tself assert: 3.0 / (FloatArray with: 2.0) equals: (FloatArray with: 1.5).\r\tself assert: 3.0 * (FloatArray with: 2.0) equals: (FloatArray with: 6.0).\r\tself assert: 3.0 + (FloatArray with: 2.0) equals: (FloatArray with: 5.0).\r\tself assert: 3.0 - (FloatArray with: 2.0) equals: (FloatArray with: 1.0)"},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection anyOne"},{"name":"testFloatArrayPluginPrimitiveAt","linesOfCode":20,"sourceCode":"testFloatArrayPluginPrimitiveAt\r\t\"if FloatArrayPlugin primitive are not here, this test is dumb.\r\tOtherwise, it will compare primitive and #fromIEEE32Bit:\"\r\r\t#(2r0.0 2r1.0 2r1.1 2r1.00000000000000000000001 2r1.0e-10 2r1.1e-10 2r1.00000000000000000000001e-10 2r1.0e10 2r1.1e10 2r1.00000000000000000000001e10 2r1.0e-126 2r1.11111111111111111111111e127 2r1.11111111111111111111111e128 2r0.11111111111111111111111e-126 2r0.00000000000000000000001e-126 2r1.0000000000000000000000001 2r1.0000000000000000000000010 2r1.0000000000000000000000011 2r1.0000000000000000000000100 2r1.0000000000000000000000101 2r1.0000000000000000000000110 2r1.0000000000000000000000111 2r1.1111111111111111111111001 2r1.1111111111111111111111010 2r1.1111111111111111111111011 2r1.1111111111111111111111101 2r1.1111111111111111111111110 2r1.1111111111111111111111111 2r1.1111111111111111111111110e127 2r0.1111111111111111111111111e-126 2r0.1111111111111111111111110e-126 2r0.1111111111111111111111101e-126 2r0.1111111111111111111111011e-126 2r0.1111111111111111111111010e-126 2r0.1111111111111111111111001e-126 2r0.0000000000000000000000111e-126 2r0.0000000000000000000000110e-126 2r0.0000000000000000000000101e-126 2r0.0000000000000000000000011e-126 2r0.0000000000000000000000010e-126 2r0.0000000000000000000000001e-126 2r0.0000000000000000000000010000000000000000000000000001e-126)\r\t\tdo: [ :e | \r\t\t\tself assert: ((FloatArray with: e) at: 1) equals: (Float fromIEEE32Bit: ((FloatArray with: e) basicAt: 1)).\r\t\t\tself assert: ((FloatArray with: e negated) at: 1) equals: (Float fromIEEE32Bit: ((FloatArray with: e negated) basicAt: 1)) ].\r\t\"regular numbers no truncation or rounding\"\r\r\t\"smallest float32 before gradual underflow\"\r\r\t\"biggest float32\"\r\r\t\"overflow\"\r\r\t\"gradual underflow\"\r\r\t\"with rounding mode : tests on 25 bits\"\r\r\t\"overflow\"\r\r\t\"gradual underflow\"\r\r\t\"special cases\"\r\t(Array with: Float infinity with: Float infinity negated with: Float negativeZero)\r\t\tdo: [ :e | self assert: ((FloatArray with: e) at: 1) equals: (Float fromIEEE32Bit: ((FloatArray with: e) basicAt: 1)) ].\r\r\t\"Cannot compare NaN\"\r\t(Array with: Float nan) do: [ :e | self assert: (Float fromIEEE32Bit: ((FloatArray with: e) basicAt: 1)) isNaN ]"},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^ 3"},{"name":"collectionWith2TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith2TimeSubcollection\r\" return a collection including 'oldSubCollection'  two or many time \"\r\t^ collectionWith2TimeSubcollection ifNil: [ collectionWith2TimeSubcollection := self collectionWith1TimeSubcollection, self oldSubCollection  ]."},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\"return an element not included in 'nonEmpty' \"\r\r\t^ elementNotIn "},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^ nonEmpty1Element "},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\" return an element not included in 'moreThan4Elements' \"\r\t^ elementNotIn "},{"name":"testSumWithIntegerScalar","linesOfCode":7,"sourceCode":"testSumWithIntegerScalar\r\t| floatArray scalar expectedResult actualResult |\r\t\r\tfloatArray := #(1 2) asFloatArray.\r\tscalar := 3.\r\t\r\texpectedResult := #(4 5) asFloatArray.\r\tactualResult := floatArray + scalar.\r\t\r\tself assert: actualResult equals: expectedResult."},{"name":"elementInForIndexAccessing","linesOfCode":3,"sourceCode":"elementInForIndexAccessing\r\" return an element included in 'collectionMoreThan1NoDuplicates' \"\r\t^ elementInNonEmpty ."},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"elementNotInForIndexAccessing","linesOfCode":3,"sourceCode":"elementNotInForIndexAccessing\r\" return an element not included in 'collectionMoreThan1NoDuplicates' \"\r\t^ elementNotIn "},{"name":"anotherValue","linesOfCode":3,"sourceCode":"anotherValue\r\" return a value ( not eual to 'aValue' ) to put into nonEmpty \"\r\t^ elementInNonEmpty "},{"name":"aValue","linesOfCode":3,"sourceCode":"aValue\r\" return a value to put into nonEmpty\"\r\t^ elementNotIn "},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ empty "},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\t^ collectionWithEqualElements "},{"name":"anIndex","linesOfCode":3,"sourceCode":"anIndex\r\" return an index in nonEmpty bounds\"\r\t^ 2"},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ elementNotIn "},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\r\" return a collection not including equal elements \"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"indexArray","linesOfCode":3,"sourceCode":"indexArray\r\" return a Collection including indexes between bounds of 'nonEmpty' \"\r\r\t^ { 1. 4. 3.}"},{"name":"sizeCollection","linesOfCode":3,"sourceCode":"sizeCollection\r\t\"Answers a collection not empty\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\" return a collection including at least 5 elements\"\r\t\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"secondIndex","linesOfCode":3,"sourceCode":"secondIndex\r\" return an index between 'nonEmpty' bounds that is > to 'first index' \"\r\t^self firstIndex +1"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\" return a collection that will be used to replace 'oldSubcollection' in ' collectionWith1TimeSubcollection'  \" \r\t^ collectionWithSameAtEndAndBegining "},{"name":"collectionWith1TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith1TimeSubcollection\r\" return a collection including 'oldSubCollection'  only one time \"\r\t^ collectionWith1TimeSubcollection ifNil: [ collectionWith1TimeSubcollection := collectionWithSameAtEndAndBegining  , self oldSubCollection , collectionWithSameAtEndAndBegining  ]."},{"name":"replacementCollectionSameSize","linesOfCode":8,"sourceCode":"replacementCollectionSameSize\r\" return a collection of size (secondIndex - firstIndex + 1)\"\r\t^replacementCollectionSameSize \r\t\tifNil: [ \treplacementCollectionSameSize := FloatArray new: (self secondIndex  - self firstIndex  + 1).\r\t\t\t\t 1 to: replacementCollectionSameSize size do:\r\t\t\t\t\t[ :i | replacementCollectionSameSize at:i put: elementInNonEmpty ].\r\t\t\t\treplacementCollectionSameSize.\r\t\t\t\t ]."},{"name":"testSumWithOrderedCollection","linesOfCode":7,"sourceCode":"testSumWithOrderedCollection\r\t| floatArray collection expectedResult actualResult |\r\t\r\tfloatArray := #(1 2) asFloatArray.\r\tcollection := #(3 4) asOrderedCollection.\r\t\r\texpectedResult := #(4 6) asFloatArray.\r\tactualResult := floatArray + collection.\r\t\r\tself assert: actualResult equals: expectedResult."},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\" return a collection with elements at end and begining equals .\r(others elements of the collection are not equal to those elements)\"\r\t^ collectionWithSameAtEndAndBegining "},{"name":"testFloatArrayPluginPrimitiveAtPut","linesOfCode":21,"sourceCode":"testFloatArrayPluginPrimitiveAtPut\r\t\"if FloatArrayPlugin primitive are not here, this test is dumb.\r\tOtherwise, it will compare primitive and #asIEEE32BitWord\"\r\r\t#(2r0.0 2r1.0 2r1.1 2r1.00000000000000000000001 2r1.0e-10 2r1.1e-10 2r1.00000000000000000000001e-10 2r1.0e10 2r1.1e10 2r1.00000000000000000000001e10 2r1.0e-126 2r1.11111111111111111111111e127 2r1.11111111111111111111111e128 2r0.11111111111111111111111e-126 2r0.00000000000000000000001e-126 2r1.0000000000000000000000001 2r1.0000000000000000000000010 2r1.0000000000000000000000011 2r1.0000000000000000000000100 2r1.0000000000000000000000101 2r1.0000000000000000000000110 2r1.0000000000000000000000111 2r1.1111111111111111111111001 2r1.1111111111111111111111010 2r1.1111111111111111111111011 2r1.1111111111111111111111101 2r1.1111111111111111111111110 2r1.1111111111111111111111111 2r1.1111111111111111111111110e127 2r0.1111111111111111111111111e-126 2r0.1111111111111111111111110e-126 2r0.1111111111111111111111101e-126 2r0.1111111111111111111111011e-126 2r0.1111111111111111111111010e-126 2r0.1111111111111111111111001e-126 2r0.0000000000000000000000111e-126 2r0.0000000000000000000000110e-126 2r0.0000000000000000000000101e-126 2r0.0000000000000000000000011e-126 2r0.0000000000000000000000010e-126 2r0.0000000000000000000000001e-126 2r0.0000000000000000000000010000000000000000000000000001e-126)\r\t\tdo: [ :e | \r\t\t\tself assert: ((FloatArray with: e) basicAt: 1) equals: e asIEEE32BitWord.\r\t\t\tself assert: ((FloatArray with: e negated) basicAt: 1) equals: e negated asIEEE32BitWord ].\r\t\"regular numbers no truncation or rounding\"\r\r\t\"smallest float32 before gradual underflow\"\r\r\t\"biggest float32\"\r\r\t\"overflow\"\r\r\t\"gradual underflow\"\r\r\t\"with rounding mode : tests on 25 bits\"\r\r\t\"overflow\"\r\r\t\"gradual underflow\"\r\r\t\"special cases\"\r\t(Array\r\t\twith: Float infinity\r\t\twith: Float infinity negated\r\t\twith: Float negativeZero\r\t\twith: Float nan) do: [ :e | self assert: ((FloatArray with: e) basicAt: 1) equals: e asIEEE32BitWord ]"},{"name":"elementToAdd","linesOfCode":3,"sourceCode":"elementToAdd\r\" return an element of type 'nonEmpy' elements'type'  not  yet included in nonEmpty\" \r\t^ elementNotIn "},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\" return a collection including at leat 4 elements\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"collectionWithNonIdentitySameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithNonIdentitySameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals only with classic equality (they are not the same object).\r(others elements of the collection are not equal to those elements)\"\r\t^ collectionWithSameAtEndAndBegining \t\t"},{"name":"anotherElementNotIn","linesOfCode":3,"sourceCode":"anotherElementNotIn\r\" return an element different of 'elementNotIn'  not included in 'nonEmpty' \"\r\t^ elementNotIn "},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\" return an element inculded in 'moreThan4Elements'\"\r\t^ elementInNonEmpty "},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass \r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ FloatArray"},{"name":"oldSubCollection","linesOfCode":4,"sourceCode":"oldSubCollection\r\" return a subCollection included in collectionWith1TimeSubcollection .\rex :   subCollection := #( 2 3 4) and collectionWith1TimeSubcollection := #(1 2 3 4 5)\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"setUp","linesOfCode":26,"sourceCode":"setUp\r\tsuper setUp.\r\tempty := FloatArray new.\r\telementInNonEmpty := 7.0.\r\tnonEmpty5ElementsNoDuplicate := (FloatArray new: 5)\r\t\tat: 1 put: 1.5;\r\t\tat: 2 put: 2.5;\r\t\tat: 3 put: elementInNonEmpty;\r\t\tat: 4 put: 4.5;\r\t\tat: 5 put: 5.5;\r\t\tyourself.\r\telementNotIn := 999.0.\r\telementTwiceIn := 2.3.\r\tcollectionWithEqualElements := (FloatArray new: 3)\r\t\tat: 1 put: 2.0;\r\t\tat: 2 put: 2.0;\r\t\tat: 3 put: 3.5;\r\t\tyourself.\r\tnonEmpty1Element := (FloatArray new: 1)\r\t\tat: 1 put: 1.2;\r\t\tyourself.\r\tcollectionWithSameAtEndAndBegining := (FloatArray new: 3)\r\t\tat: 1 put: 2.0;\r\t\tat: 2 put: 1.0;\r\t\tat: 3 put: 2.0 copy;\r\t\tyourself"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ FloatArray"},{"name":"firstIndex","linesOfCode":3,"sourceCode":"firstIndex\r\" return an index between 'nonEmpty' bounds that is < to 'second index' \"\r\t^2"},{"name":"sortedInAscendingOrderCollection","linesOfCode":3,"sourceCode":"sortedInAscendingOrderCollection\r\t\"Return a collection sorted in ascending order\"\r\t^ sortedCollection ifNil: [ sortedCollection := ( FloatArray new: 3)at: 1 put: 1.0 ; at: 2 put: 2.0 ; at: 3 put: 3.0 ; yourself ]\r\t"},{"name":"unsortedCollection","linesOfCode":3,"sourceCode":"unsortedCollection\r\" retur a collection that is not yat sorted\"\r\t^nonEmpty5ElementsNoDuplicate "},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size > 1 without equal elements\"\r\t^ nonEmpty5ElementsNoDuplicate "},{"name":"collectionNotIncluded","linesOfCode":4,"sourceCode":"collectionNotIncluded\r\" return a collection for wich each element is not included in 'nonEmpty' \"\r\t^ collectionNotIncluded \r\t\tifNil: [ collectionNotIncluded := (FloatArray new: 2) at:1 put: elementNotIn ; at: 2 put: elementNotIn  ; yourself ]."}],"meta":{"name":"FloatArrayTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ManifestCollectionsTests","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsTests class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'Math-Operations-Extensions')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Streams' #'System-Finalization' #'Collections-Native' #'Collections-Abstract' #'Collections-Weak' #'Collections-Stack' #'Collections-Strings' #'Collections-Sequenceable' #'SUnit-Core' #Kernel #'Graphics-Primitives' #'Collections-Support' #'Collections-Unordered' #'System-Support' #'Collections-Atomic' #'Multilingual-Encodings')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #CollectionsTests"}],"meta":null}},{"name":"ReduceTest","instanceVariables":[],"methods":[{"name":"testReduceLeft2Arguments","linesOfCode":26,"sourceCode":"testReduceLeft2Arguments\r\t| block |\r\tblock := [ :a :b | Array with: a with: b ].\r\tself sequenceableClasses\r\t\tdo: [ :class | \r\t\t\tself should: [ class new reduceLeft: block ] raise: Error.\r\t\t\tself assert: ((class with: #a) reduceLeft: block) equals: #a.\r\t\t\tself assert: ((class with: #a with: #b) reduceLeft: block) equals: #(a b).\r\t\t\tself assert: ((class with: #a with: #b with: #c) reduceLeft: block) equals: #(#(a b) c).\r\t\t\tself\r\t\t\t\tassert:\r\t\t\t\t\t((class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d) reduceLeft: block)\r\t\t\t\tequals: #(#(#(a b) c) d).\r\t\t\tself\r\t\t\t\tassert:\r\t\t\t\t\t((class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d\r\t\t\t\t\t\twith: #e) reduceLeft: block)\r\t\t\t\tequals: #(#(#(#(a b) c) d) e) ]"},{"name":"testReduceRightSpecial","linesOfCode":3,"sourceCode":"testReduceRightSpecial\r\tself assert: ((1 to: 100) reduceRight: [ :a :b | a - b ]) equals: -50.\r\tself assert: ('abc' reduceRight: [ :a :b | Array with: a with: b ]) equals: #($a #($b $c))"},{"name":"testReduceRight2Arguments","linesOfCode":26,"sourceCode":"testReduceRight2Arguments\r\t| block |\r\tblock := [ :a :b | Array with: a with: b ].\r\tself sequenceableClasses\r\t\tdo: [ :class | \r\t\t\tself should: [ class new reduceRight: block ] raise: Error.\r\t\t\tself assert: ((class with: #a) reduceRight: block) equals: #a.\r\t\t\tself assert: ((class with: #a with: #b) reduceRight: block) equals: #(a b).\r\t\t\tself assert: ((class with: #a with: #b with: #c) reduceRight: block) equals: #(a #(b c)).\r\t\t\tself\r\t\t\t\tassert:\r\t\t\t\t\t((class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d) reduceRight: block)\r\t\t\t\tequals: #(a #(b #(c d))).\r\t\t\tself\r\t\t\t\tassert:\r\t\t\t\t\t((class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d\r\t\t\t\t\t\twith: #e) reduceRight: block)\r\t\t\t\tequals: #(a #(b #(c #(d e)))) ]"},{"name":"testReduceRight3Arguments","linesOfCode":25,"sourceCode":"testReduceRight3Arguments\r\t| block |\r\tblock := [ :a :b :c | Array with: a with: b with: c ].\r\tself sequenceableClasses\r\t\tdo: [ :class | \r\t\t\tself should: [ class new reduceRight: block ] raise: Error.\r\t\t\tself assert: ((class with: #a) reduceRight: block) equals: #a.\r\t\t\tself should: [ (class with: #a with: #b) reduceRight: block ] raise: Error.\r\t\t\tself assert: ((class with: #a with: #b with: #c) reduceRight: block) equals: #(a b c).\r\t\t\tself\r\t\t\t\tshould: [ (class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d) reduceRight: block ]\r\t\t\t\traise: Error.\r\t\t\tself\r\t\t\t\tassert:\r\t\t\t\t\t((class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d\r\t\t\t\t\t\twith: #e) reduceRight: block)\r\t\t\t\tequals: #(a b #(c d e)) ]"},{"name":"testReduceLeftSpecial","linesOfCode":3,"sourceCode":"testReduceLeftSpecial\r\tself assert: ((1 to: 100) reduceLeft: [ :a :b | a - b ]) equals: -5048.\r\tself assert: ('abc' reduceLeft: [ :a :b | Array with: a with: b ]) equals: #(#($a $b) $c)"},{"name":"testReduceCollection2Arguments","linesOfCode":17,"sourceCode":"testReduceCollection2Arguments\r\t| block |\r\tblock := [ :a :b | a + b ].\r\tself collectionClasses\r\t\tdo: [ :class | \r\t\t\tself should: [ class new reduce: block ] raise: Error.\r\t\t\tself assert: ((class with: 1) reduce: block) equals: 1.\r\t\t\tself assert: ((class with: 1 with: 2) reduce: block) equals: 3.\r\t\t\tself assert: ((class with: 1 with: 2 with: 3) reduce: block) equals: 6.\r\t\t\tself\r\t\t\t\tassert:\r\t\t\t\t\t((class\r\t\t\t\t\t\twith: 1\r\t\t\t\t\t\twith: 2\r\t\t\t\t\t\twith: 3\r\t\t\t\t\t\twith: 4) reduce: block)\r\t\t\t\tequals: 10 ]"},{"name":"sequenceableClasses","linesOfCode":2,"sourceCode":"sequenceableClasses\r\t^ Array with: Array with: OrderedCollection with: SortedCollection"},{"name":"testReduceLeft3Arguments","linesOfCode":25,"sourceCode":"testReduceLeft3Arguments\r\t| block |\r\tblock := [ :a :b :c | Array with: a with: b with: c ].\r\tself sequenceableClasses\r\t\tdo: [ :class | \r\t\t\tself should: [ class new reduceLeft: block ] raise: Error.\r\t\t\tself assert: ((class with: #a) reduceLeft: block) equals: #a.\r\t\t\tself should: [ (class with: #a with: #b) reduceLeft: block ] raise: Error.\r\t\t\tself assert: ((class with: #a with: #b with: #c) reduceLeft: block) equals: #(a b c).\r\t\t\tself\r\t\t\t\tshould: [ (class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d) reduceLeft: block ]\r\t\t\t\traise: Error.\r\t\t\tself\r\t\t\t\tassert:\r\t\t\t\t\t((class\r\t\t\t\t\t\twith: #a\r\t\t\t\t\t\twith: #b\r\t\t\t\t\t\twith: #c\r\t\t\t\t\t\twith: #d\r\t\t\t\t\t\twith: #e) reduceLeft: block)\r\t\t\t\tequals: #(#(a b c) d e) ]"},{"name":"testReduceCollection3Arguments","linesOfCode":16,"sourceCode":"testReduceCollection3Arguments\r\t| block |\r\tblock := [ :a :b :c | a + b + c ].\r\tself collectionClasses\r\t\tdo: [ :class | \r\t\t\tself should: [ class new reduce: block ] raise: Error.\r\t\t\tself assert: ((class with: 1) reduce: block) equals: 1.\r\t\t\tself should: [ (class with: 1 with: 2) reduce: block ] raise: Error.\r\t\t\tself assert: ((class with: 1 with: 2 with: 3) reduce: block) equals: 6.\r\t\t\tself\r\t\t\t\tshould: [ (class\r\t\t\t\t\t\twith: 1\r\t\t\t\t\t\twith: 2\r\t\t\t\t\t\twith: 3\r\t\t\t\t\t\twith: 4) reduce: block ]\r\t\t\t\traise: Error ]"},{"name":"collectionClasses","linesOfCode":2,"sourceCode":"collectionClasses\r\t^ (Array with: Set with: Bag) , (self sequenceableClasses)"}],"meta":{"name":"ReduceTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ByteArrayTest","instanceVariables":[],"methods":[{"name":"testHex","linesOfCode":11,"sourceCode":"testHex\r\tself assert: #[122 43 213 7] hex equals: '7a2bd507'.\r\tself\r\t\tassert: #[151 193 242 221 249 32 153 72 179 41 49 154 48 193 99 134] hex\r\t\tequals: '97c1f2ddf9209948b329319a30c16386'.\r\tself\r\t\tassert: (ByteArray readHexFrom: '7A2BD507')\r\t\tequals: #[122 43 213 7].\r\tself\r\t\tassert: (ByteArray readHexFrom: '7a2bd507')\r\t\tequals: #[122 43 213 7]"},{"name":"testFallbackReplaceFromToWithForWideString","linesOfCode":14,"sourceCode":"testFallbackReplaceFromToWithForWideString\r\t| testString byteArray stringByteSize |\r\ttestString := 'Test string' asWideString.\r\tstringByteSize := 'Test string' byteSize.\r\tbyteArray := ByteArray new: stringByteSize.\r\t\r\tself\r\t\tshouldnt: [\r\t\t\tbyteArray\r\t\t\t\treplaceFrom: 1\r\t\t\t\tto: stringByteSize\r\t\t\t\twith: testString\r\t\t\t\tstartingAt: 1 ]\r\t\traise: Exception\r\t\tdescription: 'Primitive 105 should be optional for ByteArray'\r"},{"name":"testIsLiteral","linesOfCode":3,"sourceCode":"testIsLiteral\r\tself assert: #[122 43 213 7] isLiteral description: 'ByteArray instances are literal'.\r\tself deny: thisContext method isLiteral description: 'ByteArray sub instances are not literal'"},{"name":"testFallbackReplaceFromToWithForString","linesOfCode":14,"sourceCode":"testFallbackReplaceFromToWithForString\r\t| testString byteArray stringByteSize |\r\ttestString := 'Test string'.\r\tstringByteSize := 'Test string' byteSize.\r\tbyteArray := ByteArray new: stringByteSize.\r\t\r\tself\r\t\tshouldnt: [\r\t\t\tbyteArray\r\t\t\t\treplaceFrom: 1\r\t\t\t\tto: stringByteSize\r\t\t\t\twith: testString\r\t\t\t\tstartingAt: 1 ]\r\t\traise: Exception\r\t\tdescription: 'Primitive 105 should be optional for ByteArray'\r"},{"name":"testHexDumponmax","linesOfCode":9,"sourceCode":"testHexDumponmax\r\r\t| source display expected |\r\r\tsource := '01234567890123456789'.\r\tdisplay := String streamContents: [ :stream |\r\t\tsource asByteArray hexDumpOn: stream max: 1000 ].\r\texpected := '00000000  30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35   |0123456789012345|\r00000010  36 37 38 39                                       |6789            |\r'.\r\tself assert: display equals: expected"},{"name":"testBooleanAt","linesOfCode":7,"sourceCode":"testBooleanAt\r\t\"Checking the result of ByteArray>>#booleanAt on a few instances of ByteArray. It should return false on 0-valued bytes and true on all other bytes (according to the integer to boolean C convention).\"\r\r\tself deny: (#[0] booleanAt: 1).\r\tself assert: (#[1] booleanAt: 1).\r\tself assert: (#[255 2 3] booleanAt: 1).\r\tself deny: (#[0 25] booleanAt: 1).\r\tself assert: (#[255] booleanAt: 1)."},{"name":"testindexOfStartingAt","linesOfCode":5,"sourceCode":"testindexOfStartingAt\r\t|array|\r\tarray := #[1 2 3 4 5 6 7 8 9 10 11 1 2 3 4 5 6 7 8 0 0].\r\tself assert: (array indexOf: 1 startingAt: 10) equals: 12.\r\tself assert: (array indexOf: 17 startingAt: 10) equals: 0.\r\r"},{"name":"testFourthByteArraysReturnTheCorrectValues","linesOfCode":3,"sourceCode":"testFourthByteArraysReturnTheCorrectValues\r\t\r\tself assert: (#[16r3F 16r80 0 0]  floatAt:1 bigEndian: true) equals: 1.0.\r\tself assert: (#[16rC0 0 0 0]  floatAt:1 bigEndian: true) equals: -2.0.\r\r"}],"meta":{"name":"ByteArrayTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"IntegerArrayTest","instanceVariables":[],"methods":[{"name":"testAt","linesOfCode":6,"sourceCode":"testAt\r\t| array |\r\tarray := IntegerArray new: 5 withAll: 2.\r\tself assert: (array at: 3) equals: 2.\r\t\r\tarray at: 3 put: 5.\r\tself assert: (array at: 3) equals: 5\r"},{"name":"testPutNegative","linesOfCode":5,"sourceCode":"testPutNegative\r\t| array |\r\tarray := IntegerArray new: 2.\r\tarray at: 2 put: -1000.\r\tself assert: (array at: 2) equals: -1000"},{"name":"testPutAllNegative","linesOfCode":5,"sourceCode":"testPutAllNegative\r\t| array |\r\tarray := IntegerArray new: 2.\r\tarray  atAllPut: -1000.\r\tself assert: (array at: 2) equals: -1000"}],"meta":{"name":"IntegerArrayTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Support-Tests","classes":[{"name":"CollectionTest","instanceVariables":[],"methods":[{"name":"testCopyWithoutDuplicates","linesOfCode":11,"sourceCode":"testCopyWithoutDuplicates\r \t| a b |\r\ta := #(1 2 3 4 4 5 6 1) copyWithoutDuplicates.\r\tb := #(4 2 3 1 6 5).\r\tself assert: [(a includesAll: b) and: [ b includesAll: a ]].\r\r\ta := #('do' 'la' 'si' 'do' 'la') copyWithoutDuplicates .\r\tb := #('do' 'la' 'si' ).\r\tself assert: [(a includesAll: b) and: [ b includesAll: a ]].\r\r\ta := #(#do #la #si #do #la) copyWithoutDuplicates.\r\tb := #(#si #la #do).\r\tself assert: [(a includesAll: b) and: [ b includesAll: a ]]."},{"name":"testGroupedByGroupsOrderWithSortedCollectionOfDates","linesOfCode":12,"sourceCode":"testGroupedByGroupsOrderWithSortedCollectionOfDates\r\t| dataCollection grouped keys |\r\t\"data collection full of Date instances is sorted ascending\"\r\tdataCollection := OrderedCollection new.\r\t0 to: 10 do: [ :i | 0 to: 5 do: [ :j | dataCollection add: (Date year: 2000 month: 1 day: 1) + i years + j weeks ] ].\r\t\r\t\"group dates collection by year\"\r\tgrouped := dataCollection groupedBy: [ :dateItem | dateItem year ].\r\r\t\"test if groups (Years) order is preserved after groupedBy\"\t\r\tkeys := grouped keys.\r\t1 to: grouped size do: [ :i |\r\t\tself assert: (keys at: i) equals: 2000 + i - 1.\r\t\t].\r"},{"name":"testGroupedByGroupsOrderSimple","linesOfCode":37,"sourceCode":"testGroupedByGroupsOrderSimple\r\t| dataCollection grouped keys |\r\t\"test of preserving groups order according to source collection order\"\r\tdataCollection := OrderedCollection new\r\t\tadd: #('ZZZ' '1');\r\t\tadd: #('ZZZ' '2');\r\t\tadd: #('ZZZ' '3');\r\t\tadd: #('SSS' '4');\r\t\tadd: #('SSS' '5');\r\t\tadd: #('SSS' '6');\r\t\tadd: #('BFLM' 'X');\r\t\tadd: #('AAA' '1');\r\t\tadd: #('AAA' '2');\r\t\tyourself.\r\t\r\tgrouped := dataCollection groupedBy: [ :arrItem | arrItem at: 1 ].\r\tkeys := grouped keys.\r\tself assert: (keys at: 1) equals: 'ZZZ'.\r\tself assert: (keys at: 2) equals: 'SSS'.\r\tself assert: (keys at: 3) equals: 'BFLM'.\r\tself assert: (keys at: 4) equals: 'AAA'.\r\t\r\t\"---\"\r\t\r\tdataCollection := OrderedCollection new\r\t\tadd: #('k' 1);\r\t\tadd: #('f' 2);\r\t\tadd: #('k' 3);\r\t\tadd: #('k' 4);\r\t\tadd: #('k' 5);\r\t\tadd: #('f' 6);\r\t\tadd: #('f' 7);\r\t\tadd: #('k' 8);\r\t\tyourself.\r\tgrouped := dataCollection groupedBy: [ :arrItem | arrItem at: 1 ].\r\tkeys := grouped keys.\r\tself assert: (keys at: 1) equals: 'k'.\r\tself assert: (keys at: 2) equals: 'f'.\r\tself assert: (grouped at: 'k') asArray equals: #(#('k' 1) #('k' 3) #('k' 4) #('k' 5) #('k' 8)).\r\tself assert: (grouped at: 'f') asArray equals: #(#('f' 2) #('f' 6) #('f' 7))."}],"meta":{"name":"CollectionTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WideCharacterSetTest","instanceVariables":[],"methods":[{"name":"testCopy","linesOfCode":6,"sourceCode":"testCopy\r    | theOriginal theCopy |\r    theOriginal := WideCharacterSet newFrom: ('abc' copyWith: 300 asCharacter).\r    theCopy := theOriginal copy.\r    theCopy remove: $a.\r    ^self should: [theOriginal includes: $a] description: 'Changing the copy should not change the original'."},{"name":"testAddingToCharacterSet","linesOfCode":21,"sourceCode":"testAddingToCharacterSet\r\r\t| cs wcs wc |\r\tcs := CharacterSet newFrom: 'aeiouy'.\r\twcs := cs copy.\r\twc := 4452 asCharacter.\r\t\r\t\"adding a WideCharacter to an ordinary CharacterSet should turn it into a WideCharacterSet\"\r\twcs add: wc.\r\r\tself should: [wcs size = (cs size + 1)] description: 'We just added a Character, size should be increased by one'.\r\tself shouldnt: [wcs = cs] description: 'We just added a Character, sets should not be equal'.\r\tself shouldnt: [cs = wcs] description: 'We just added a Character, sets should not be equal'.\r\tself should: [cs allSatisfy: [:char | wcs includes: char]] description: 'Each character of the original CharacterSet should be included in the WideCharacterSet'.\r\tself should: [wcs hasWideCharacters] description: 'We just added a WideCharacter, so this WideCharacterSet definitely has one'.\r\tself should: [wcs includes: wc] description: 'We just added this WideCharacter, so this WideCharacterSet should include it'.\r\t\r\twcs add: wc.\r\tself should: [wcs size = (cs size + 1)] description: 'We just added a Character already included in the set, size should be unchanged'.\r\t\r\twcs remove: wc.\r\tself should: [wcs size = cs size] description: 'We added then removed a Character, now size should be equal to original'.\r\tself shouldnt: [wcs hasWideCharacters] description: 'We just removed the only WideCharacter, so this WideCharacterSet definitely has no WideCharacter'.\r\t\r\tself should: [wcs = cs] description: 'A WideCharacterSet can be equal to an Ordinary CharacterSet'.\r\tself should: [cs = wcs] description: 'An ordinary CharacterSet can be equal to a WideCharacterSet'.\r\tself should: [cs hash = wcs hash] description: 'If some objects are equal, then they should have same hash code'.\r\t\r\t"},{"name":"testCreation","linesOfCode":17,"sourceCode":"testCreation\r\t\"By now, only creation method is newFrom:\"\r\r\t| cs1 wcs1 cs2 wcs2 byteString wideString |\r\tbyteString := 'aeiouy'.\r\twideString := 'aeiouy' copyWith: 340 asCharacter.\r\r\tcs1 := CharacterSet newFrom: byteString.\r\twcs1 := WideCharacterSet newFrom: byteString.\r\tself assert: wcs1 equals: cs1.\r\tself assert: wcs1 size equals: byteString size.\r\t\r\tcs2 := CharacterSet newFrom: wideString.\r\twcs2 := WideCharacterSet newFrom: wideString.\r\tself assert: wcs2 equals: cs2.\r\tself assert: wcs2 size equals: wideString size.\r\t\r\tself should: [(byteString indexOfAnyOf: wcs1) = 1] description: 'This should used optimized byteArrayMap method'.\r\tself should: [(byteString indexOfAnyOf: wcs2) = 1] description: 'This should used optimized byteArrayMap method'.\r\t\r\tself should: [('bcd' indexOfAnyOf: wcs1) = 0] description: 'This should used optimized byteArrayMap method'.\r\tself should: [('bcd' indexOfAnyOf: wcs2) = 0] description: 'This should used optimized byteArrayMap method'."}],"meta":{"name":"WideCharacterSetTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"AssociationTest","instanceVariables":[{"name":"a"},{"name":"b"}],"methods":[{"name":"testHash","linesOfCode":4,"sourceCode":"testHash\r\r\tself \r\t\tassert: a hash equals: a copy hash;\r\t\tassert: a hash equals: b hash"},{"name":"testStoreOnNegativeInteger","linesOfCode":5,"sourceCode":"testStoreOnNegativeInteger\r\t| association storeString |\r\tassociation := 'a'-> -1.\r\t\r\tstoreString := String streamContents: [ :s | association storeOn: s ].\r\t\r\tself assert: storeString equals: '(''a''-> -1)'"},{"name":"testComparison","linesOfCode":2,"sourceCode":"testComparison\r\r\tself assert: ((#a -> 'foo') < (#b -> 'zork'))"},{"name":"testStoreOnPositiveInteger","linesOfCode":5,"sourceCode":"testStoreOnPositiveInteger\r\t| association storeString |\r\tassociation := 'a'-> 1.\r\tstoreString := String streamContents: [ :s | association storeOn: s ].\r\t\r\tself assert: storeString equals: '(''a''->1)'"},{"name":"setUp","linesOfCode":4,"sourceCode":"setUp\r\r\tsuper setUp.\r\ta := 1 -> 'one'.\r\tb := 1 -> 'een'"},{"name":"testIsSelfEvaluating","linesOfCode":8,"sourceCode":"testIsSelfEvaluating\r\t| anotherAssociation |\r\tself assert: a isSelfEvaluating.\r\t\r\tself assert: a printString equals: '1->''one'''.\r\t\r\tanotherAssociation := Object new -> Object new.\r\tanotherAssociation isSelfEvaluating \r\t\tifTrue: [ self assert: (self class compiler evaluate: anotherAssociation printString) = anotherAssociation\r\t\t\t\t\t\t\tdescription: 'a self evaluating should evaluate as self' ]\r"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ Association"},{"name":"testEquality","linesOfCode":5,"sourceCode":"testEquality\r\tself\r\t\tassert: a key equals: b key;\r\t\tdeny: a value equals: b value;\r\t\tdeny: a equals: b"},{"name":"testStoreOnPositiveIntegerRoundtrip","linesOfCode":6,"sourceCode":"testStoreOnPositiveIntegerRoundtrip\r\t| association storeString evaluated |\r\tassociation := 'a'-> 1.\r\tstoreString := String streamContents: [ :s | association storeOn: s ].\r\t\r\tevaluated := Smalltalk compiler evaluate: storeString.\r\t\r\tself assert: association equals: evaluated"},{"name":"testStoreOnNegativeIntegerRoundtrip","linesOfCode":6,"sourceCode":"testStoreOnNegativeIntegerRoundtrip\r\t| association storeString evaluated |\r\tassociation := 'a'-> -1.\r\t\r\tstoreString := String streamContents: [ :s | association storeOn: s ].\r\t\r\tevaluated := Smalltalk compiler evaluate: storeString.\r\t\r\tself assert: association equals: evaluated"}],"meta":{"name":"AssociationTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"CharacterSetTest","instanceVariables":[],"methods":[{"name":"testCopy","linesOfCode":6,"sourceCode":"testCopy\r    | theOriginal theCopy |\r    theOriginal := CharacterSet newFrom: 'abc'.\r    theCopy := theOriginal copy.\r    theCopy remove: $a.\r    ^self should: [theOriginal includes: $a] description: 'Changing the copy should not change the original'."}],"meta":{"name":"CharacterSetTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-DoubleLinkedList-Tests","classes":[{"name":"ManifestCollectionsDoubleLinkedListTests","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsDoubleLinkedListTests class","instanceVariables":[],"methods":[{"name":"ruleReUsesAddRuleV1FalsePositive","linesOfCode":2,"sourceCode":"ruleReUsesAddRuleV1FalsePositive\r\t^ #(#(#(#RGClassDefinition #(#DoubleLinkedListTest)) #'2020-03-27T12:31:42.565385+01:00') )"},{"name":"ruleUsesAddRuleV1FalsePositive","linesOfCode":2,"sourceCode":"ruleUsesAddRuleV1FalsePositive\r\t^ #(#(#(#RGClassDefinition #(#DoubleLinkedListTest)) #'2020-06-12T14:46:39.462891+02:00') )"}],"meta":null}},{"name":"DoubleLinkedListTest","instanceVariables":[],"methods":[{"name":"testDo","linesOfCode":8,"sourceCode":"testDo\r\t| list value |\r\tlist := DoubleLinkedList new.\r\tlist addAll: (1 to: 10).\r\tvalue := 1.\r\tlist do: [ :each |\r\t\tself assert: each equals: value.\r\t\tvalue := value + 1 ]"},{"name":"testAddBeforeLink","linesOfCode":8,"sourceCode":"testAddBeforeLink\r\t| list link |\r\tlist := DoubleLinkedList new.\r\tlist add: 1.\r\tlink := list add: 2.\r\tlist add: 3.\r\tlist add: 0 beforeLink: link.\r\tself assert: list asArray equals: #( 1 0 2 3 )"},{"name":"testIncludes","linesOfCode":6,"sourceCode":"testIncludes\r\t| list |\r\tlist := DoubleLinkedList new.\r\tlist addAll: (1 to: 10).\r\tself assert: (list includes: 5).\r\tself deny: (list includes: 0)"},{"name":"testLinksDo","linesOfCode":11,"sourceCode":"testLinksDo\r\t| list links index |\r\tlist := DoubleLinkedList new.\r\tlinks := OrderedCollection new.\r\t1 to: 10 do: [ :each |\r\t\tlinks add: (list add: each) ].\r\tindex := 1.\r\tlist linksDo: [ :each |\r\t\tself assert: each equals: (links at: index).\r\t\tself assert: each value equals: index.\r\t\tindex := index + 1 ]"},{"name":"testReverseDo","linesOfCode":8,"sourceCode":"testReverseDo\r\t| list value |\r\tlist := DoubleLinkedList new.\r\tlist addAll: (1 to: 10).\r\tvalue := 10.\r\tlist reverseDo: [ :each |\r\t\tself assert: each equals: value.\r\t\tvalue := value - 1 ]"},{"name":"testThreeRemoveLast","linesOfCode":9,"sourceCode":"testThreeRemoveLast\r\t| list link |\r\tlist := DoubleLinkedList new.\r\t1 to: 3 do: [ :each | list add: each ].\r\tlink := list removeLast.\r\tself assert: link value equals: 3.\r\tself assert: list first equals: 1.\r\tself assert: list last equals: 2.\r\tself assert: list asArray equals: #( 1 2 )"},{"name":"testSelect","linesOfCode":6,"sourceCode":"testSelect\r\t| list even |\r\tlist := DoubleLinkedList new.\r\tlist addAll: (1 to: 10).\r\teven := list select: [ :each | each even ].\r\tself assert: even asArray equals: #(2 4 6 8 10)"},{"name":"testThreeRemoveFirst","linesOfCode":9,"sourceCode":"testThreeRemoveFirst\r\t| list link |\r\tlist := DoubleLinkedList new.\r\t1 to: 3 do: [ :each | list add: each ].\r\tlink := list removeFirst.\r\tself assert: link value equals: 1.\r\tself assert: list first equals: 2.\r\tself assert: list last equals: 3.\r\tself assert: list asArray equals: #( 2 3 )"},{"name":"testCollect","linesOfCode":6,"sourceCode":"testCollect\r\t| list doubles |\r\tlist := DoubleLinkedList new.\r\tlist addAll: #(1 2 3).\r\tdoubles := list collect: [ :each | each * 2 ].\r\tself assert: doubles asArray equals: #(2 4 6)"},{"name":"testEmpty","linesOfCode":7,"sourceCode":"testEmpty\r\t| list |\r\tlist := DoubleLinkedList new.\r\tself assertEmpty: list.\r\tself should: [ list first ] raise: CollectionIsEmpty.\r\tself should: [ list last ] raise: CollectionIsEmpty.\r\tlist do: [ :each | self fail ]"},{"name":"testOne","linesOfCode":8,"sourceCode":"testOne\r\t| list |\r\tlist := DoubleLinkedList new.\r\tlist add: #one.\r\tself deny: list isEmpty.\r\tself assert: list first equals: #one.\r\tself assert: list last equals: #one.\r\tself assert: list asArray equals: #( one )"},{"name":"testAddAfterLink","linesOfCode":8,"sourceCode":"testAddAfterLink\r\t| list link |\r\tlist := DoubleLinkedList new.\r\tlist add: 1.\r\tlink := list add: 2.\r\tlist add: 3.\r\tlist add: 0 afterLink: link.\r\tself assert: list asArray equals: #( 1 2 0 3 )"},{"name":"testAddFirst","linesOfCode":9,"sourceCode":"testAddFirst\r\t| list |\r\tlist := DoubleLinkedList new.\r\t1 to: 3 do: [ :each | list add: each ].\r\tlist addFirst: 0.\r\tself deny: list isEmpty.\r\tself assert: list first equals: 0.\r\tself assert: list last equals: 3.\r\tself assert: list asArray equals: #( 0 1 2 3 )"},{"name":"testAddLast","linesOfCode":9,"sourceCode":"testAddLast\r\t| list |\r\tlist := DoubleLinkedList new.\r\t1 to: 3 do: [ :each | list add: each ].\r\tlist addLast: 0.\r\tself deny: list isEmpty.\r\tself assert: list first equals: 1.\r\tself assert: list last equals: 0.\r\tself assert: list asArray equals: #( 1 2 3 0 )"},{"name":"testReject","linesOfCode":6,"sourceCode":"testReject\r\t| list even |\r\tlist := DoubleLinkedList new.\r\tlist addAll: (1 to: 10).\r\teven := list reject: [ :each | each odd ].\r\tself assert: even asArray equals: #(2 4 6 8 10)"},{"name":"testFirstAndLastLink","linesOfCode":19,"sourceCode":"testFirstAndLastLink\r\t| list firstLink secondLink |\r\tlist := DoubleLinkedList new.\r\tself should: [ list firstLink ] raise: CollectionIsEmpty.\r\tself should: [ list lastLink ] raise: CollectionIsEmpty.\r\tself should: [ list first ] raise: CollectionIsEmpty.\r\tself should: [ list last ] raise: CollectionIsEmpty.\r\tfirstLink := list add: #one.\r\tself assert: list firstLink equals: firstLink.\r\tself assert: list first equals: list last.\r\tself assert: list firstLink equals: list lastLink.\r\tself assert: list firstLink value equals: #one.\r\tsecondLink := list add: #two.\r\tself assert: list firstLink equals: firstLink.\r\tself assert: list lastLink equals: secondLink.\r\tself deny: list first equals: list last.\r\tself deny: list firstLink equals: list lastLink.\r\tself assert: list firstLink value equals: #one.\r\tself assert: list lastLink value equals: #two"},{"name":"testReverseLinksDo","linesOfCode":11,"sourceCode":"testReverseLinksDo\r\t| list links index |\r\tlist := DoubleLinkedList new.\r\tlinks := OrderedCollection new.\r\t1 to: 10 do: [ :each |\r\t\tlinks add: (list add: each) ].\r\tindex := 10.\r\tlist reverseLinksDo: [ :each |\r\t\tself assert: each equals: (links at: index).\r\t\tself assert: each value equals: index.\r\t\tindex := index - 1 ]"},{"name":"testThreeRemoveLink","linesOfCode":10,"sourceCode":"testThreeRemoveLink\r\t| list link |\r\tlist := DoubleLinkedList new.\r\tlist add: 1.\r\tlink := list add: 2.\r\tlist add: 3.\r\tlist removeLink: link.\r\tself assert: list first equals: 1.\r\tself assert: list last equals: 3.\r\tself assert: list asArray equals: #( 1 3 )"},{"name":"testThree","linesOfCode":8,"sourceCode":"testThree\r\t| list |\r\tlist := DoubleLinkedList new.\r\t1 to: 3 do: [ :each | list add: each ].\r\tself deny: list isEmpty.\r\tself assert: list first equals: 1.\r\tself assert: list last equals: 3.\r\tself assert: list asArray equals: #( 1 2 3 )"},{"name":"testOneRemoveFirst","linesOfCode":9,"sourceCode":"testOneRemoveFirst\r\t| list |\r\tlist := DoubleLinkedList new.\r\tlist add: #one.\r\tlist removeFirst.\r\tself assertEmpty: list.\r\tlist add: #one.\r\tlist removeLast.\r\tself assertEmpty: list"},{"name":"testOneRemoveLast","linesOfCode":9,"sourceCode":"testOneRemoveLast\r\t| list |\r\tlist := DoubleLinkedList new.\r\tlist add: #one.\r\tlist removeLast.\r\tself assertEmpty: list.\r\tlist add: #one.\r\tlist removeLast.\r\tself assertEmpty: list"}],"meta":{"name":"DoubleLinkedListTest class","instanceVariables":[],"methods":[],"meta":null}}]},{"name":"Collections-Strings-Tests","classes":[{"name":"StringTest","instanceVariables":[{"name":"string"},{"name":"emptyString"},{"name":"elementInNonEmpty"},{"name":"notIn"},{"name":"nonEmpty1element"},{"name":"withoutEqualElements"},{"name":"collectionNotIncluded"},{"name":"indexInNonEmptyArray"},{"name":"sameAtEndAndBegining"},{"name":"nonEmpty5ElementsSorted"},{"name":"unsortedCollection"},{"name":"subcollection3ElementsSorted"},{"name":"arrayWithCharacters"}],"methods":[{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\"Return a collection including at least 3 elements\"\r\t\r\t^ nonEmpty5ElementsSorted"},{"name":"testHasWideCharacterFromTo","linesOfCode":5,"sourceCode":"testHasWideCharacterFromTo\r\r\tself assert: ('test' hasWideCharacterFrom: 1 to: 3).\r\tself deny: ('test' hasWideCharacterFrom: 1 to: 4).  \r\tself assert: ('' hasWideCharacterFrom: 1 to: 2).  \r\tself assert: ('test this string ' hasWideCharacterFrom: 18 to: 19)"},{"name":"testLinesDoWithCrLf","linesOfCode":5,"sourceCode":"testLinesDoWithCrLf\r\r\t| aString |\r\taString := 'This is a test of line breaking', String crlf.\r\taString linesDo: [ :line |\r\t\tself assert: (line size + 2) equals: aString size ]"},{"name":"testUnescapePercents","linesOfCode":14,"sourceCode":"testUnescapePercents\r\tself assert: '' urlDecoded equals: ''.\r\tself assert: 'x' urlDecoded equals: 'x'.\r\r\tself assert: '+' urlDecoded equals: ' '.\r\tself assert: 'x+' urlDecoded equals: 'x '.\r\tself assert: '+x' urlDecoded equals: ' x'.\r\tself assert: 'x+x' urlDecoded equals: 'x x'.\r\r\tself should: [ '%' urlDecoded ] raise: Error.\r\tself should: [ '%3' urlDecoded ] raise: Error.\r\tself assert: '%3C' urlDecoded equals: '<'.\r\r\tself assert: '%3Cx%3E4%3C%2Fx%3E' urlDecoded equals: '<x>4</x>'.\r\r\tself assert: '!@#$%25%5E&*()%7B%7D%5B%5D=:/;?+''%22' urlDecoded equals: '!@#$%^&*(){}[]=:/;? ''\"'.\r\tself assert: '!%40%23%24%25%5E%26*()%7B%7D%5B%5D%3D%3A%2F%3B%3F%2B''%22' urlDecoded equals: '!@#$%^&*(){}[]=:/;?+''\"'.\r\tself assert: '%21@%23%24%25%5E%26*%28%29%7B%7D%5B%5D%3D%3A/%3B%3F+%27%22' urlDecoded equals: '!@#$%^&*(){}[]=:/;? ''\"'"},{"name":"testNumericSuffix","linesOfCode":6,"sourceCode":"testNumericSuffix\r\r\tself assert: 'abc98' numericSuffix equals: 98.\r\tself assert: '98abc' numericSuffix equals: 0.\r\tself assert: '  123abc456' numericSuffix equals: 456.\r\tself assert: 'abc456 789' numericSuffix equals: 789.\r\tself assert: '012  123' numericSuffix equals: 123"},{"name":"testRepeat","linesOfCode":6,"sourceCode":"testRepeat\r\r\tself \r\tassert: ('123' repeat: 1) equals: '123';\r\tassert: ('123' repeat: 2) equals: '123123';\r\tassert: ('123' repeat: 0) equals: '';\r\tshould: [ '123' repeat: -1 ] raise: Error."},{"name":"collectionWithElementsToRemove","linesOfCode":3,"sourceCode":"collectionWithElementsToRemove\r\t\"Return a collection of elements included in 'nonEmpty'\"\r\r\t^ subcollection3ElementsSorted "},{"name":"testFormatExtended","linesOfCode":11,"sourceCode":"testFormatExtended\r\r\tself\r\t\tassert: ('This is {foo} !' format: (Dictionary with: #foo->'a test'))\r\t\tequals: 'This is a test !'.\r\r \t{ \r \t\t[ '\\{ \\} \\\\ foo {foo} bar {bar}' format: { #foo->12. #bar->'string' } asDictionary ] -> '{ } \\ foo 12 bar string'. \r \t\t[ '\\{ \\} \\\\ foo {bar} bar {foo}' format: { 'bar'->12. 'foo'->'string' } asDictionary ] -> '{ } \\ foo 12 bar string'. \r \t\t[ '\\{x}' format: {} ] -> '{x}'. \r \t\t[ '\\{x}{x}' format: { #x->$a } asDictionary ] -> '{x}a'. \r \t} do: [ :each | \r\t\tself assert: each key value equals: each value ]"},{"name":"testPadLeftToWith","linesOfCode":4,"sourceCode":"testPadLeftToWith\r\r\tself assert: ('a' padLeftTo: 3 with: $#) equals: '##a'. \r\tself assert: ('a' padLeftTo: 1 with: $#) equals: 'a'. \r\tself assert: ('a' padLeftTo: 0 with: $#) equals: 'a'"},{"name":"testSubstrings","linesOfCode":28,"sourceCode":"testSubstrings\r\t| allByteCharacters substring separators |\r\r\tallByteCharacters := Character allByteCharacters asString.\r\tsubstring := allByteCharacters select: [:each | each isLetter].\r\tseparators := allByteCharacters reject: [:each | each isLetter].\r\t{'' -> {}.\r\t\tseparators -> {}.\r\t\tsubstring -> {substring}.\r\t\t(substring, separators) -> {substring}.\r\t\t(separators, substring) -> {substring}.\r\t\t(separators, substring, separators) -> {substring}.\r\t\t(substring, separators, substring) -> {substring. substring}.\r\t\t(substring, separators, substring, separators) -> {substring. substring}.\r\t\t(separators, substring, separators, substring) -> {substring. substring}}\r\t\tdo: [:each | self assert: (each key substrings: separators) equals: each value].\r\r\t\"test the unary version\"\r\tsubstring := allByteCharacters reject: [:each | each isSeparator].\r\tseparators := allByteCharacters select: [:each | each isSeparator].\r\t{'' -> {}.\r\t\tseparators -> {}.\r\t\tsubstring -> {substring}.\r\t\t(substring, separators) -> {substring}.\r\t\t(separators, substring) -> {substring}.\r\t\t(separators, substring, separators) -> {substring}.\r\t\t(substring, separators, substring) -> {substring. substring}.\r\t\t(substring, separators, substring, separators) -> {substring. substring}.\r\t\t(separators, substring, separators, substring) -> {substring. substring}}\r\t\tdo: [:each | self assert: each key substrings equals: each value]."},{"name":"testAsSmalltalkComment","linesOfCode":15,"sourceCode":"testAsSmalltalkComment\r\t| exampleStrings |\r\texampleStrings := #('' ' ' '\"' '\"\"' '\"\"\"' 'abc\"abc' 'abc\"\"abc' 'abc\"hello\"abc' 'abc\"' '\"abc').\r\r\t\"check that the result of scanning the comment is empty\"\r\texampleStrings\r\t\tdo: [ :s | \r\t\t\t| tokens |\r\t\t\ttokens := s asComment parseLiterals.\r\t\t\tself assertEmpty: tokens ].\r\r\t\"check that the result has the same non-quote characters as the original\"\r\texampleStrings do: [ :s | self assert: (s copyWithout: $\") equals: (s asComment copyWithout: $\") ].\r\r\t\"finnaly, test for some common kinds of inputs\"\r\tself assert: 'abc' asComment equals: '\"abc\"'.\r\tself assert: 'abc\"abc' asComment equals: '\"abc\"\"abc\"'.\r\tself assert: 'abc\"\"abc' asComment equals: '\"abc\"\"abc\"'"},{"name":"testFindAnySubstringStartingAt","linesOfCode":7,"sourceCode":"testFindAnySubstringStartingAt\r\r\tself assert: ('tester12345' findAnySubstring: #('st' $1) startingAt: 1) equals: 3.\r\tself assert: ('1234' findAnySubstring: #('st' '' '' '123') startingAt:  1) equals: 9.\r\tself assert: ('' findAnySubstring: #('') startingAt: 2) equals: 13.\r\tself assert: ('' findAnySubstring: #('') startingAt: 3) equals: 9.\r\tself assert: ('' findAnySubstring: #() startingAt: 3) equals: 13.\r\tself assert: ('test12345' findAnySubstring: #('\"' '@') startingAt: 12) equals: 10"},{"name":"testFindTokensEscapedBy12","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy12\r\r\t| tokens |\r\tstring := 'one, two# three; four. five'.\r\ttokens := string findTokens: ',#;.' escapedBy: '\"'.\r\tself assert: tokens size equals: 5.\r\tself assert: tokens third equals: ' three'"},{"name":"testWithInternetLineEndings","linesOfCode":16,"sourceCode":"testWithInternetLineEndings\r\r\t{\r\t\t'abc' -> 'abc'.\r\t\t'abc', String cr -> ('abc', String crlf).\r\t\t'abc', String lf -> ('abc', String crlf).\r\t\t'abc', String crlf -> ('abc', String crlf).\r\t\tString cr, 'abc' -> (String crlf, 'abc').\r\t\tString lf, 'abc' -> (String crlf, 'abc').\r\t\tString crlf, 'abc' -> (String crlf, 'abc').\r\t\t'abc', String cr, String cr, 'abc' -> ('abc', String crlf, String crlf, 'abc').\r\t\t'abc', String lf, String lf, 'abc' -> ('abc', String crlf, String crlf, 'abc').\r\t\t'abc', String crlf, String crlf, 'abc' -> ('abc', String crlf, String crlf, 'abc').\r\t\tString cr, 'abc', String cr, String crlf, 'abc', String lf -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).\r\t\tString lf, 'abc', String lf, String crlf, 'abc', String cr -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).\r\t} do: [ :each |\r\t\tself assert: each key withInternetLineEndings equals: each value ]"},{"name":"testCorrectAgainst","linesOfCode":7,"sourceCode":"testCorrectAgainst\r\r\t| coll |\r\tcoll := OrderedCollection new addAll: #('nest' 'temperature' 'text' 'Jupiter' 'denial' 'nest' 'tttt' 'e' 'alpha' 'beautest'); yourself.\r\r\tself assert: ('test' correctAgainst: coll) asArray equals: #('beautest' 'nest' 'text' 'nest' 'tttt' 'temperature').\r\tself assert: ('123' correctAgainst: coll) asArray equals: #('tttt' 'nest' 'text' 'nest').\r\r\tcoll := OrderedCollection new.\r\tself assert: ('test' correctAgainst: coll) asArray equals: #()."},{"name":"testPadRightTo","linesOfCode":4,"sourceCode":"testPadRightTo\r\r\tself assert: ('a' padRightTo: 3) equals: 'a  '. \r\tself assert: ('a' padRightTo: 1) equals: 'a'. \r\tself assert: ('a' padRightTo: 0) equals: 'a'"},{"name":"testWithoutPrefix","linesOfCode":5,"sourceCode":"testWithoutPrefix\r\tself assert: ('UMLClass' withoutPrefix: 'UML') equals: 'Class'.\r\tself assert: ('UMLClass' withoutSuffix: 'Class') equals: 'UML'.\r\t\r\tself assert: ('UMLClass' withoutPrefix: 'Class') equals: 'UMLClass'.\r\tself assert: ('UMLClass' withoutSuffix: 'UML') equals: 'UMLClass'."},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\t\"Return an element not included in 'moreThan4Elements'\"\r\r\t^ notIn "},{"name":"testFindCloseParenthesisFor","linesOfCode":5,"sourceCode":"testFindCloseParenthesisFor\r\r\tself assert: ('(1 + 3(2 * 9) - 15)' findCloseParenthesisFor: 1) equals: 19.\r\tself assert: ('(1+(2-3))-3.14159' findCloseParenthesisFor: 1) equals: 9.\r\tself assert: ('(1+(2-3))-3.14159' findCloseParenthesisFor: 4) equals: 8.\r\tself assert: ('()' findCloseParenthesisFor: 10) equals: 3"},{"name":"testRomanNumber","linesOfCode":10,"sourceCode":"testRomanNumber\r\r\tself assert: 'I' romanNumber equals: 1.\r\tself assert: 'V' romanNumber equals: 5.\r\tself assert: 'XVI' romanNumber equals: 16.\r\tself assert: 'XIV' romanNumber equals: 14.\r\tself assert: 'MDCLXXXVII' romanNumber equals: 1687.\r\tself assert: 'MCMXLII' romanNumber equals: 1942.\r\tself assert: 'DCLXVI' romanNumber equals: 666.\r\tself assert: '-V' romanNumber equals: -5.\r\tself assert: '-MDCCCXCV' romanNumber equals: -1895."},{"name":"elementNotInForIndexAccessing","linesOfCode":3,"sourceCode":"elementNotInForIndexAccessing\r\t\"Return an element not included in 'accessCollection'\"\r\t\r\t^ notIn "},{"name":"testTrimLeft","linesOfCode":9,"sourceCode":"testTrimLeft\r\tself assert: '' trimLeft equals: ''.\r\tself assert: ' ' trimLeft equals: ''.\r\tself assert: '\t' trimLeft equals: ''.\r\tself assert: 'foo' trimLeft equals: 'foo'.\r\tself assert: ' foo ' trimLeft equals: 'foo '.\r\tself assert: '  foo  ' trimLeft equals: 'foo  '.\r\t\r\tself assert: ('aabbaa' trimLeft: [ :each | each = $a ]) equals: 'bbaa'.\r\tself assert: ('bbaabb' trimLeft: [ :each | each = $a ]) equals: 'bbaabb'"},{"name":"testWithUnixLineEndings","linesOfCode":23,"sourceCode":"testWithUnixLineEndings\r\r\t| original newString |\r\t{\r\t\t'abc' -> 'abc'.\r\t\t'abc', String cr -> ('abc', String lf).\r\t\t'abc', String lf -> ('abc', String lf).\r\t\t'abc', String crlf -> ('abc', String lf).\r\t\tString cr, 'abc' -> (String lf, 'abc').\r\t\tString lf, 'abc' -> (String lf, 'abc').\r\t\tString crlf, 'abc' -> (String lf, 'abc').\r\t\t'abc', String cr, String cr, 'abc' -> ('abc', String lf, String lf, 'abc').\r\t\t'abc', String lf, String lf, 'abc' -> ('abc', String lf, String lf, 'abc').\r\t\t'abc', String crlf, String crlf, 'abc' -> ('abc', String lf, String lf, 'abc').\r\t\tString cr, 'abc', String cr, String crlf, 'abc', String lf -> (String lf, 'abc', String lf, String lf, 'abc', String lf).\r\t\tString lf, 'abc', String lf, String crlf, 'abc', String cr -> (String lf, 'abc', String lf, String lf, 'abc', String lf).\r\t\t(WideString with: 403 asCharacter with: Character cr) -> (WideString with: 403 asCharacter with: Character lf).\r\t} do: [ :each |\r\t\tself assert: each key withUnixLineEndings equals: each value ].\r\t\r\toriginal :='asa' , String cr , 'asa'.\r\tself assert: (original at: 4) equals: Character cr.\r\tnewString := original withUnixLineEndings.\r\tself assert: (original at: 4) equals: Character cr.\r\tself assert: (newString at: 4) equals: Character lf."},{"name":"testAsPluralBasedOn","linesOfCode":8,"sourceCode":"testAsPluralBasedOn\r\r\tself assert: ('test' asPluralBasedOn: #(1)) equals: 'test'.\r\tself assert: ('test' asPluralBasedOn: #(1 2 3)) equals: 'tests'.\r\tself assert: ('test' asPluralBasedOn: 1) equals: 'test'.\r\tself assert: ('test' asPluralBasedOn: false) equals: 'tests'.\r\tself assert: ('           ' asPluralBasedOn: 10) equals: '           s'.\r\tself assert: ('' asPluralBasedOn: 1) equals: ''.\r\tself assert: ('%' asPluralBasedOn: 10) equals: '%s'"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ emptyString"},{"name":"testAsUppercase","linesOfCode":4,"sourceCode":"testAsUppercase \r\r\tself assert: ('test' asUppercase) equals: 'TEST'.\r\tself assert: ('123TEST' asUppercase) equals: '123TEST'.\r\tself assert: ('' asUppercase) equals: ''"},{"name":"testLoremIpsum2048","linesOfCode":10,"sourceCode":"testLoremIpsum2048\r\t| fillerText |\r\tfillerText := String loremIpsum: 2048.\r\tself assert: fillerText size equals: 2048.\r\tself assert: (fillerText beginsWith: 'Lorem ipsum').\r\tself assert: (fillerText includesSubstring: 'laborum.').\r\tself assert: (fillerText endsWith: ('.', String cr)).\r\tself assert: fillerText lines size > 2.\r\tself assert: fillerText isAsciiString.\r\tself assert: (Character space split: fillerText) size > 75"},{"name":"testAsClass","linesOfCode":4,"sourceCode":"testAsClass\r\tself \r\t\tassert: 'String' asClass\r\t\tequals: String"},{"name":"testLinesDoWithCrBetween","linesOfCode":5,"sourceCode":"testLinesDoWithCrBetween\r\r\t| aString |\r\taString := ' This is a test ', String cr, 'of line breaking'.\r\taString linesDo: [:line |\r\t\tself assert: line size equals: 16 ]"},{"name":"testFindTokens","linesOfCode":10,"sourceCode":"testFindTokens\r\r\t|s |\r\ts := OrderedCollection withAll: #( 'i' 'd toke' 's').\r\tself assert: ('find tokens' findTokens: #($a $f $n)) equals: s.\r\r\ts := OrderedCollection withAll: #('').\r\tself assert: ('' findTokens: $) equals: s.\r\r\ts := OrderedCollection withAll: #().\r\tself assert: ('' findTokens: '') equals: s.\r\r\ts := OrderedCollection withAll: #('es' ' ' 'his').\r\tself assert: ('test this' findTokens: 't') equals: s"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ notIn "},{"name":"testReadStreamDo","linesOfCode":2,"sourceCode":"testReadStreamDo\r\tstring readStreamDo: [ :stream | self assert: stream contents equals: string ]"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\t\"Returns a collection that already includes what is returned by #element.\"\r\t^ nonEmpty5ElementsSorted"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\t\"Return a collection that doesn't include a nil element and that doesn't include equal elements'\"\r\r\t^ nonEmpty5ElementsSorted"},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\" return a collection including at least 5 elements\"\r\t\r\t^ nonEmpty5ElementsSorted "},{"name":"testUpTo","linesOfCode":5,"sourceCode":"testUpTo\r\t\r\tself assert: #up:to: keywords equals: #(up: to:).\r\tself assert: #copy:from:to: keywords equals: #(copy: from: to:).\r\tself assert: #up keywords equals: #(up).\r\tself assert: #at: keywords equals: #(at:).\r\t"},{"name":"secondIndex","linesOfCode":3,"sourceCode":"secondIndex\r\t\"Return an index between 'nonEmpty' bounds that is > to 'second index'\"\r\t\r\t^ self firstIndex "},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\t\"Return a collection that will be used to replace 'oldSubcollection' in ' \t collectionWith1TimeSubcollection'\" \r\t^ string"},{"name":"collectionWith1TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith1TimeSubcollection\r\t\"Return a collection including 'oldSubCollection' only one time\"\r\t\r\t^ nonEmpty5ElementsSorted"},{"name":"elementInForIncludesTest","linesOfCode":3,"sourceCode":"elementInForIncludesTest\r\t\"Return an element included in nonEmpty\"\r\t\r\t^ elementInNonEmpty "},{"name":"testWithFirstCharacterDownshifted","linesOfCode":10,"sourceCode":"testWithFirstCharacterDownshifted\r\t| uc lc empty |\r\tuc := 'MElViN'.\r\tlc := 'mElViN'.\r\tempty := ' '.\r\tself assert: uc uncapitalized equals: lc.\r\tself assert: lc uncapitalized equals: lc.\r\t\"the string gets copied\"\r\tself deny: lc uncapitalized identicalTo: lc.\r\tself deny: empty uncapitalized identicalTo: empty"},{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotInForOccurrences).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotInForOccurrences)"},{"name":"testAsSymbol","linesOfCode":5,"sourceCode":"testAsSymbol\r\tself assert: 'hel' , 'lo' asSymbol equals: #hello.\r\tself assert: '    ' asSymbol equals: #'    '.\r\tself assert: '' asSymbol equals: #''.\r\tself assert: 'test' asSymbol identicalTo: #test"},{"name":"testFindLastOccurrenceOfStringStartingAt","linesOfCode":6,"sourceCode":"testFindLastOccurrenceOfStringStartingAt\r\r\tself assert: ('Smalltalk' findLastOccurrenceOfString: 'al' startingAt: 2) equals: 7.\r\tself assert: ('aaa' findLastOccurrenceOfString: 'aa' startingAt: 1) equals: 2.\r\tself assert: ('Smalltalk' asWideString findLastOccurrenceOfString: 'al' startingAt: 2) equals: 7.\r\tself assert: ('Smalltalk' asWideString findLastOccurrenceOfString: 'al' asWideString startingAt: 2) equals: 7.\r\tself assert: (('Smalltalk' copyWith: 835 asCharacter) findLastOccurrenceOfString: 'al' asWideString startingAt: 2) equals: 7"},{"name":"testFindWordStartStartingAt","linesOfCode":5,"sourceCode":"testFindWordStartStartingAt\r\r\tself assert: ('test this string' findWordStart: 'th' startingAt: 1) equals: 6.\r\tself assert: ('test this string' findWordStart: 'st' startingAt: 1) equals: 11.\r\tself assert: ('test this string' findWordStart: 'st' startingAt: 12) equals: 0.\r\tself assert: ('test this string' findWordStart: '' startingAt: 1) equals: 0\r"},{"name":"elementToAdd","linesOfCode":2,"sourceCode":"elementToAdd\r\t^ $u"},{"name":"testFindTokensEscapedBy02","linesOfCode":5,"sourceCode":"testFindTokensEscapedBy02\r\t| tokens |\r\tstring := ''.\r\ttokens := string findTokens: ',' escapedBy: '\"'.\r\tself assertEmpty: tokens"},{"name":"testAlike","linesOfCode":6,"sourceCode":"testAlike\r\r\tself assert: ('test' alike: 'test') >= 8.   \"twice second argument size is the best score\"\r\tself assert: ('TEST' alike: 'test') >= 8.   \"case is ignored\"\r\tself assert: ('           ' alike: 'test') equals: 0. \r\tself assert: ('     ' alike: '           ') >= 10. \r\tself assert: ('eeeee' alike: '') <= 1  \"evaluation based on ascii value\""},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t^ $k"},{"name":"testLineNumber","linesOfCode":8,"sourceCode":"testLineNumber\r\t| sampleCRString sampleLFString sampleCRLFString |\r\tsampleCRString := 'Fred', String cr , 'the', String cr, 'Bear'.\r\tsampleLFString := 'Fred', String lf , 'the', String lf, 'Bear'.\r\tsampleCRLFString := 'Fred', String crlf, 'the', String crlf, 'Bear'.\r\t\r\tself assert: (sampleCRString lineNumber: 2) equals: 'the'.\r\tself assert: (sampleLFString lineNumber: 2) equals: 'the'.\r\tself assert: (sampleCRLFString lineNumber: 2) equals: 'the'."},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\r\t^ String"},{"name":"testAsFileLocatorOrReferenceReturnsALocatorWhenStringRefersToAKnownOrigin","linesOfCode":11,"sourceCode":"testAsFileLocatorOrReferenceReturnsALocatorWhenStringRefersToAKnownOrigin\r\t| pathString locator |\r\tpathString := (FileLocator home / 'foo') fullName.\r\t\r\tlocator := pathString asFileLocatorOrReference.\r\t\t\r\tself\r\t\tassert: locator origin\r\t\tequals: #home.\r\tself\r\t\tassert: locator fullName\r\t\tequals: pathString."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t^ String"},{"name":"firstIndex","linesOfCode":3,"sourceCode":"firstIndex\r\t\"Return an index between 'nonEmpty' bounds that is < to 'second index'\"\r\r\t^3"},{"name":"testWithoutTrailingDigits","linesOfCode":11,"sourceCode":"testWithoutTrailingDigits\r\t#( \r\t\t'foo' 'foo'\r\t\t'foo123' 'foo'\r\t\t'bar 123 ' 'bar'\r\t\t'foo.123.txt' 'foo.123.txt'\r\t\t'' ''\r\t\t'1' ''\r\t\t'1 2 3 ' ''\r\t) pairsDo: [ :input :output |\r\t\tself assert: input withoutTrailingDigits equals: output ]\r\t"},{"name":"unsortedCollection","linesOfCode":2,"sourceCode":"unsortedCollection\r\t^ unsortedCollection "},{"name":"testInitialIntegerOrNil","linesOfCode":8,"sourceCode":"testInitialIntegerOrNil\r\r\tself assert: '234Whoopie' initialIntegerOrNil equals: 234.\r\tself assert: 'wimpy' initialIntegerOrNil isNil.\r\tself assert: '234' initialIntegerOrNil equals: 234.\r\tself assert: '2N' initialIntegerOrNil equals: 2.\r\tself assert: '  89Ten ' initialIntegerOrNil isNil.\r\tself assert: '78 92' initialIntegerOrNil equals: 78.\r\tself assert: '123' initialIntegerOrNil equals: 123"},{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\t\"Return a collection that don't includes equal elements'\"\r\t\r\t^ nonEmpty5ElementsSorted"},{"name":"testTrimLineSpaces","linesOfCode":7,"sourceCode":"testTrimLineSpaces\r\tself assert: 'test     \\do' withCRs trimLineSpaces equals: 'test\\do' withCRs.\r\tself assert: 'test     \\  do' withCRs trimLineSpaces equals: 'test\\  do' withCRs.\r\tself assert: 'test \\do\\' withCRs trimLineSpaces equals: 'test\\do' withCRs.\r\tself assert: 'test \\do' withCRs trimLineSpaces equals: 'test\\do' withCRs.\r\tself assert: 'test do' withCRs trimLineSpaces equals: 'test do' withCRs.\r\tself assert: 'test\\ \\ ' withCRs trimLineSpaces equals: 'test\\\\' withCRs."},{"name":"testFindTokensIncludes","linesOfCode":6,"sourceCode":"testFindTokensIncludes\r\r\tself assert: ('test this' findTokens: 't' includes: 'his') equals: 'his'.\r\tself assert: ('test this' findTokens: 's' includes: 'HI') isNil.\r\tself assert: ('test this' findTokens: 's' includes: 'hi') equals: 't thi'.\r\tself assert: ('test that' findTokens: 't' includes: 'that') isNil.\r\tself assert: ('' findTokens: #($ $) includes:'') equals: ''\r"},{"name":"testWithInternalLineEndings","linesOfCode":17,"sourceCode":"testWithInternalLineEndings\r\r\t{\r\t\t'abc' -> 'abc'.\r\t\t'abc', String cr -> ('abc', String cr).\r\t\t'abc', String lf -> ('abc', String cr).\r\t\t'abc', String crlf -> ('abc', String cr).\r\t\tString cr, 'abc' -> (String cr, 'abc').\r\t\tString lf, 'abc' -> (String cr, 'abc').\r\t\tString crlf, 'abc' -> (String cr, 'abc').\r\t\t'abc', String cr, String cr, 'abc' -> ('abc', String cr, String cr, 'abc').\r\t\t'abc', String lf, String lf, 'abc' -> ('abc', String cr, String cr, 'abc').\r\t\t'abc', String crlf, String crlf, 'abc' -> ('abc', String cr, String cr, 'abc').\r\t\tString cr, 'abc', String cr, String crlf, 'abc', String lf -> (String cr, 'abc', String cr, String cr, 'abc', String cr).\r\t\tString lf, 'abc', String lf, String crlf, 'abc', String cr -> (String cr, 'abc', String cr, String cr, 'abc', String cr).\r\t\t(WideString with: 403 asCharacter with: Character lf) -> (WideString with: 403 asCharacter with: Character cr).\r\t} do: [ :each |\r\t\tself assert: each key withInternalLineEndings equals: each value ]"},{"name":"testFindTokensEscapedBy09","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy09\r\r\t| tokens |\r\tstring := 'this, is, ###a, test#'.\r\ttokens := string findTokens: ',' escapedBy: '#'.\r\tself assert: tokens size equals: 3.\r\tself assert: tokens third equals: ' #a, test'"},{"name":"testLessThan","linesOfCode":8,"sourceCode":"testLessThan\r\r\tself assert: ('@' < 'A').\r\tself assert: ('abcd' < '  ').\r\tself assert: ('xyz' < '').\r\tself assert: (' t e s t' < '  ').\r\tself assert: ('' < 'a').\r\tself deny: ('  ' < '  ').\r\tself deny: ('aaa' < 'AAA')\r\r"},{"name":"testWithoutQuoting","linesOfCode":10,"sourceCode":"testWithoutQuoting\r\r \t#( '\"foo\"' 'foo'\r\t\t'''foo''' 'foo'\r\t\t'\"foo''' '\"foo'''\r\t\t'''foo\"' '''foo\"'\r\t\t'\"foo' '\"foo'\r\t\t'foo\"' 'foo\"'\r\t\t'foo' 'foo') \r\tpairsDo: [ :before :after |\r\t\tself assert: before withoutQuoting equals: after ]"},{"name":"testIndexOf","linesOfCode":6,"sourceCode":"testIndexOf\r\r\tself assert: ('test this string' indexOf: $k) equals: 0.\r\tself assert: ('test this string' indexOf: 't') equals: 0.\r\tself assert: ('test this string' indexOf: $t) equals: 1.\r\tself assert: ('123' indexOf: $) equals: 9.\r\tself assert: ('123' indexOf: $E) equals: 0\r "},{"name":"testFindTokensEscapedBy13","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy13\r\r\t| tokens |\r\tstring := 'one, two# three; four. five'.\r\ttokens := string findTokens: ',#;.' escapedBy: nil.\r\tself assert: tokens size equals: 5.\r\tself assert: tokens third equals: ' three'"},{"name":"newElement","linesOfCode":3,"sourceCode":"newElement\r\t\"Return an element that will be put in the collection in place of another\"\r\t\r\t^ elementInNonEmpty "},{"name":"testPadLeftTo","linesOfCode":4,"sourceCode":"testPadLeftTo\r\r\tself assert: ('a' padLeftTo: 3) equals: '  a'. \r\tself assert: ('a' padLeftTo: 1) equals: 'a'. \r\tself assert: ('a' padLeftTo: 0) equals: 'a'"},{"name":"testCapitalized","linesOfCode":10,"sourceCode":"testCapitalized\r\t| uc lc empty |\r\tuc := 'MElViN'.\r\tlc := 'mElViN'.\r\tempty := ' '.\r\tself assert: lc capitalized equals: uc.\r\tself assert: uc capitalized equals: uc.\r\t\"the string gets copied\"\r\tself deny: uc capitalized identicalTo: uc.\r\tself deny: empty capitalized identicalTo: empty"},{"name":"testLinesDoWithCrLfBetween","linesOfCode":5,"sourceCode":"testLinesDoWithCrLfBetween\r\r\t| aString |\r\taString := '-This is a test-', String crlf, 'of line breaking'.\r\taString linesDo: [:line | \r\t\tself assert: line size equals: 16 ]"},{"name":"testAsInteger","linesOfCode":6,"sourceCode":"testAsInteger\r\r\tself assert: '1796exportFixes-tkMX' asInteger equals: 1796.\r\tself assert: 'donald' asInteger isNil.\r\tself assert: 'abc234def567' asInteger equals: 234.\r\tself assert: '-94' asInteger equals: -94.\r\tself assert: 'foo-bar-92' asInteger equals: -92"},{"name":"testExpandMacrosWithArgumentsLongText","linesOfCode":4,"sourceCode":"testExpandMacrosWithArgumentsLongText\r\t\"printString truncates strings\"\r\tself assert: ('<1p>' expandMacrosWith: ('a' repeat: 10)) size equals: 12.\r\tself assert: ('<1p>' expandMacrosWith: ('a' repeat: 100000)) size equals: 100002"},{"name":"testLineCorrespondingToIndex","linesOfCode":23,"sourceCode":"testLineCorrespondingToIndex\r\t| sampleCRString sampleLFString sampleCRLFString anIndex |\r\tsampleCRString := 'Fred', String cr, 'the', String cr, 'Bear'.\r\tsampleLFString := 'Fred', String lf, 'the', String lf, 'Bear'.\r\tsampleCRLFString := 'Fred', String crlf, 'the', String crlf, 'Bear'.\r\t\r\tanIndex := sampleCRString indexOf: $h.\r\tself assert: (sampleCRString lineCorrespondingToIndex: anIndex) equals: 'the'.\r\tanIndex := sampleLFString indexOf: $h.\r\tself assert: (sampleLFString lineCorrespondingToIndex: anIndex) equals: 'the'.\r\tanIndex := sampleCRLFString indexOf: $h.\r\tself assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) equals: 'the'.\r\t\r\tanIndex := sampleCRString indexOf: $B.\r\tself assert: (sampleCRString lineCorrespondingToIndex: anIndex) equals: 'Bear'.\r\tanIndex := sampleLFString indexOf: $B.\r\tself assert: (sampleLFString lineCorrespondingToIndex: anIndex) equals: 'Bear'.\r\tanIndex := sampleCRLFString indexOf: $B.\r\tself assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) equals: 'Bear'.\r\t\r\tanIndex := sampleCRString indexOf: $d.\r\tself assert: (sampleCRString lineCorrespondingToIndex: anIndex) equals: 'Fred'.\r\tanIndex := sampleLFString indexOf: $d.\r\tself assert: (sampleLFString lineCorrespondingToIndex: anIndex) equals: 'Fred'.\r\tanIndex := sampleCRLFString indexOf: $d.\r\tself assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) equals: 'Fred'."},{"name":"testFormatFailures","linesOfCode":8,"sourceCode":"testFormatFailures\r\r\tself\r\t\tshould: [ 'This is {foo} !' format: Dictionary new ]\r\t\traise: KeyNotFound.\r\t\t\r\tself\r\t\tshould: [ 'This is {1} !' format: Array new ]\r\t\traise: SubscriptOutOfBounds.\r"},{"name":"testAsLowercase","linesOfCode":4,"sourceCode":"testAsLowercase \r\r\tself assert: '1 2 3        t e s T' asLowercase equals: '1 2 3        t e s t'.\r\tself assert: '!@#$' asLowercase equals: '!@#$'.\r\tself assert: '' asLowercase equals: ''"},{"name":"testFindTokensEscapedBy05","linesOfCode":7,"sourceCode":"testFindTokensEscapedBy05\r\r\t| tokens |\r\tstring := 'this, /is, a\",\" test/'.\r\ttokens := string findTokens: ',#' escapedBy: '\"/'.\r\tself assert: tokens size equals: 2.\r\tself assert: tokens first equals: 'this'.\r\tself assert: tokens second equals: ' is, a\",\" test'."},{"name":"testEndsWithAnyOf","linesOfCode":4,"sourceCode":"testEndsWithAnyOf\r\r\tself deny: ('' endsWithAnyOf: #('ia' '' '' '')).\r\tself assert: ('' endsWithAnyOf: #('test' '' '')).\r\tself assert: ('test' endsWithAnyOf: #('tests' 'tester' 'testing' 't')).\r"},{"name":"testLastSpacePosition","linesOfCode":7,"sourceCode":"testLastSpacePosition\r\r\tself assert: 'fred the bear' lastSpacePosition equals: 9.\r\tself assert: 'ziggie' lastSpacePosition equals: 0.\r\tself assert: 'elvis ' lastSpacePosition equals: 6.\r\tself assert: 'wimpy  ' lastSpacePosition equals: 7.\r\tself assert: '' lastSpacePosition equals: 0.\r\tself assert: ' 123    ' lastSpacePosition equals: 13"},{"name":"testCompare","linesOfCode":9,"sourceCode":"testCompare\r\r\tself assert: ('EEA' compare: 'fgh') equals: 1.\r\tself assert: ('ABCDEFGH' compare: 'ABCDEFGH') equals: 2.\r\tself assert: ('fgh' compare: 'fg') equals: 3.\r\tself assert: ('' compare: '') equals: 1.\r\tself assert: ('' compare: '') equals: 2.\r\tself assert: ('' compare: '') equals: 1.\r\tself assert: ('eeao' compare: '') equals: 1.\r\tself assert: ('!@#' compare: '123') equals: 1"},{"name":"testOnlyLetters","linesOfCode":6,"sourceCode":"testOnlyLetters\r\r\tself assert: 'abc98def' onlyLetters equals: 'abcdef'.\r\tself assert: 'abc 98 12 def' onlyLetters equals: 'abcdef'.\r\tself assert: '012  345' onlyLetters equals: ''.\r\tself assert: '123 456' onlyLetters equals: ''.\r\tself assert: '' onlyLetters equals: ''\r\r"},{"name":"testAsString","linesOfCode":7,"sourceCode":"testAsString \r\r\tself assert: 123 asString equals: '123'.\r\tself assert: #(1 2 3) asString equals: '#(1 2 3)'.\r\tself assert: (OrderedCollection new) asString equals: 'an OrderedCollection()'.\r\tself assert: (1 < 3) asString equals: 'true'.\r\tself assert: '           ' asString equals: '           '.\r\tself assert: '' asString equals: ''"},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\t\"Return a collection not including equal elements\"\r\t\r\t^ withoutEqualElements "},{"name":"testLines","linesOfCode":12,"sourceCode":"testLines\r\t| sampleCRString sampleLFString sampleCRLFString sampleMixedString sampleMixedString2 |\r\tsampleCRString := 'Fred', String cr, 'the', String cr, 'Bear'.\r\tsampleLFString := 'Fred', String lf, 'the', String lf, 'Bear'.\r\tsampleCRLFString := 'Fred', String crlf, 'the', String crlf, 'Bear'.\r\tsampleMixedString := 'Fred', String lf, 'the', String cr, 'Bear'.\r\tsampleMixedString2 := 'Fred', String crlf, 'the', String cr, 'Bear'.\r\t\r\tself assert: sampleCRString lines equals: #('Fred' 'the' 'Bear').\r\tself assert: sampleLFString lines equals: #('Fred' 'the' 'Bear').\r\tself assert: sampleCRLFString lines equals: #('Fred' 'the' 'Bear').\r\tself assert: sampleMixedString lines equals: #('Fred' 'the' 'Bear').\r\tself assert: sampleMixedString2 lines equals: #('Fred' 'the' 'Bear')."},{"name":"testFindTokensEscapedBy08","linesOfCode":7,"sourceCode":"testFindTokensEscapedBy08\r\r\t| tokens |\r\tstring := 'this, is, ##a, test'.\r\ttokens := string findTokens: ',' escapedBy: '#'.\r\tself assert: tokens size equals: 4.\r\tself assert: tokens third equals: ' a'.\r\tself assert: tokens fourth equals: ' test'"},{"name":"testComparing","linesOfCode":9,"sourceCode":"testComparing\r\tself assert: 'foo' < 'foo:'.\r\tself assert: 'foo' < 'fooBar'.\r\tself assert: 'foo' <= 'foo:'.\r\tself assert: 'foo' <= 'fooBar'.\r\tself assert: 'foo:' > 'foo'.\r\tself assert: 'fooBar' > 'foo'.\r\tself assert: 'foo:' >= 'foo'.\r\tself assert: 'fooBar' >= 'foo'"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ nonEmpty5ElementsSorted"},{"name":"testIsPatternVariable","linesOfCode":8,"sourceCode":"testIsPatternVariable\r\r\tself assert: '`pattern' isPatternVariable.\r\tself assert: '`pattern:' isPatternVariable.\r\tself assert: '`pattern:`varible:' isPatternVariable.\r\tself assert: 'pattern:`varible:' isPatternVariable.\r\t\r\tself deny: 'notAPattern:varible:' isPatternVariable.\r\tself deny: 'notAPattern' isPatternVariable\r\t\t\r"},{"name":"testBeginsWithEmptyCaseSensitive","linesOfCode":10,"sourceCode":"testBeginsWithEmptyCaseSensitive\r\r\tself deny: ('' beginsWithEmpty: '' caseSensitive: true).\r\tself assert: ('' beginsWithEmpty: '' caseSensitive: true).\r\tself assert: ('' beginsWithEmpty: '' caseSensitive: true).\r\tself deny: ('' beginsWithEmpty: '' caseSensitive: true).\r\tself assert: ('' beginsWithEmpty: '' caseSensitive: true).\r\tself assert: ('123test' beginsWithEmpty: '123' caseSensitive: true).\r\tself should: ('aaee' beginsWithEmpty: 'AA' caseSensitive: false).\r\tself should: ('???' beginsWithEmpty: '??' caseSensitive: false)\r\t\"self assert: ('' beginsWithEmpty: '' caseSensitive: false).\""},{"name":"testFindTokensEscapedBy21","linesOfCode":5,"sourceCode":"testFindTokensEscapedBy21\r\r\t| tokens |\r\tstring := 'this, is, \"a, test\"'.\r\ttokens := string findTokens: $, escapedBy: $\".\r\tself assert: tokens size equals: 3"},{"name":"testFindFirstInString","linesOfCode":12,"sourceCode":"testFindFirstInString\t\r\t\"These tests are more specific than those in testIndexOf.\"\r\t\r\t\"more boundary tests\"\r\tself assert: (self findFirstInString: '' fromString: '') equals: 0.\r\tself assert: (self findFirstInString: 'x' fromString: '') equals: 0.\r\tself assert: (self findFirstInString: '' fromString: 'x') equals: 0.\r\t\r\tself assert: (self findFirstInString: 'x' fromString: 'x') equals: 1.\r\t\r\tself assert: (self findFirstInString: 'hello' fromString: 'hello') equals: 1.\r\tself assert: (self findFirstInString: 'hello' fromString: 'ello') equals: 2.\r\tself assert: (self findFirstInString: 'hello' fromString: 'llo') equals: 3.\r\tself assert: (self findFirstInString: 'hello' fromString: 'o') equals: 5.\r\tself assert: (self findFirstInString: 'hello' fromString: 'x') equals: 0.\r"},{"name":"testCopyReplaceAllWithAsTokens","linesOfCode":6,"sourceCode":"testCopyReplaceAllWithAsTokens\r\r\tself assert: ('test te str' copyReplaceAll: 'te' with: 'longone' asTokens: true) equals: 'test longone str'.\r\tself assert: ('test te str' copyReplaceAll: 'te' with: 'longone' asTokens: false) equals: 'longonest longone str'.\r\tself assert: ('123 test xyz' copyReplaceAll: 'st' with: 'mper' asTokens: true) equals: '123 test xyz'.\r\tself assert: ('' copyReplaceAll: '' with: 'A' asTokens: false) equals: 'A'.\r\tself assert: (' t ' copyReplaceAll: ' ' with:  '' asTokens: false) equals: 't'."},{"name":"testEndsWithAColon","linesOfCode":3,"sourceCode":"testEndsWithAColon\r\r\tself assert: 'fred:' endsWithAColon.\r\r\tself deny: 'fred' endsWithAColon"},{"name":"testLinesDo","linesOfCode":23,"sourceCode":"testLinesDo\r\t| sampleCRString sampleLFString sampleCRLFString lines |\r\tsampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.\r\tsampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.\r\tsampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.\r\t\r\tlines := OrderedCollection new.\r\tsampleCRString linesDo: [:aLine |\r\t\tself deny: (aLine includes: Character cr).\r\t\tself deny: (aLine includes: Character lf).\r\t\tlines add: aLine].\r\tself assert: lines asArray equals: #('Fred' 'the' 'Bear').\r\t\r\tlines := OrderedCollection new.\r\tsampleLFString linesDo: [:aLine |\r\t\tself deny: (aLine includes: Character cr).\r\t\tself deny: (aLine includes: Character lf).\r\t\tlines add: aLine].\r\tself assert: lines asArray equals: #('Fred' 'the' 'Bear').\r\r\tlines := OrderedCollection new.\r\tsampleCRLFString linesDo: [:aLine |\r\t\tself deny: (aLine includes: Character cr).\r\t\tself deny: (aLine includes: Character lf).\r\t\tlines add: aLine].\r\tself assert: lines asArray equals: #('Fred' 'the' 'Bear').\r\r"},{"name":"testPadRightToWith","linesOfCode":4,"sourceCode":"testPadRightToWith\r\r\tself assert: ('a' padRightTo: 3 with: $#) equals: 'a##'. \r\tself assert: ('a' padRightTo: 1 with: $#) equals: 'a'. \r\tself assert: ('a' padRightTo: 0 with: $#) equals: 'a'"},{"name":"testTrimmed","linesOfCode":2,"sourceCode":"testTrimmed\r\tself assert: '  a  ' trimmed equals: 'a'."},{"name":"testFormat","linesOfCode":11,"sourceCode":"testFormat\r\r\tself\r\t\tassert: ('This is {1} !' format: #('a test'))\r\t\tequals: 'This is a test !'.\r\r \t{ \r \t\t[ '\\{ \\} \\\\ foo {1} bar {2}' format: { 12. 'string' } ] -> '{ } \\ foo 12 bar string'. \r \t\t[ '\\{ \\} \\\\ foo {2} bar {1}' format: { 'string'. 12 } ] -> '{ } \\ foo 12 bar string'. \r \t\t[ '\\{1}' format: {} ] -> '{1}'. \r \t\t[ '\\{1}{1}' format: { $a } ] -> '{1}a'. \r \t} do: [ :each | \r\t\tself assert: each key value equals: each value ]"},{"name":"testAsDate","linesOfCode":7,"sourceCode":"testAsDate\r\r\tself assert: 'Jan 1 2015' asDate asString equals: '1 January 2015'. \r\tself assert: '1/1/2015' asDate asString equals: '1 January 2015'.\r\tself assert: '1 1 1' asDate asString equals: '1 January 2001'.\r\tself assert: '1 J 1' asDate asString equals: '1 January 2001'.\r\tself should: [ '' asDate ] raise: Error.\r\tself should: [ '1234' asDate ] raise: Error "},{"name":"testEquality","linesOfCode":10,"sourceCode":"testEquality\r\t\r\tself assert: 'abc' equals: 'abc' asWideString.\r\tself assert: 'abc' asWideString equals: 'abc'.\r\tself assert: ( #[97 0 0 0] asString ~= 'a000' asWideString).\r\tself assert: ('a000' asWideString ~=  #[97 0 0 0] asString).\r\r\tself assert: ('abc' sameAs: 'aBc' asWideString).\r\tself assert: ('aBc' asWideString sameAs: 'abc').\r\tself assert: ( #[97 0 0 0] asString \r\t\t\t\t\t\tsameAs: 'Abcd' asWideString) not.\r\tself assert: ('a000' asWideString sameAs: #[97 0 0 0] asString) not."},{"name":"testFindBetweenSubstrings","linesOfCode":5,"sourceCode":"testFindBetweenSubstrings\r \r\tself assert: ('  ' findBetweenSubstrings: #(' ')) asArray equals: #('' '' '').\r\tself assert: ('ieaoftaaka' findBetweenSubstrings: #($a)) asArray equals: #('ie' 'oft' 'k').\r\tself assert: ('this is an issue is it not' findBetweenSubstrings: #('is' 'not')) asArray \r                                               equals: #('th' ' ' ' an ' 'sue ' ' it ')."},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\" return an element included exactly two time in # collectionWithEqualElements\"\r^ sameAtEndAndBegining first ."},{"name":"testWithNoLineLongerThan","linesOfCode":7,"sourceCode":"testWithNoLineLongerThan\r\r\tself assert: ('Hello World' withNoLineLongerThan: 5) equals: ('Hello' , String cr , 'World').\r\r\tself assert: ('Sample text to line break at some point' withNoLineLongerThan: 28)\r\t\t  equals: ('Sample text to line break at' , String cr , 'some point').\r\t\t\r\tself assert: ('Sample text' , String cr , 'to line break' , String cr , 'at some point' withNoLineLongerThan: 28)\r\t\t  equals: ('Sample text' , String cr , 'to line break' , String cr , 'at some point')"},{"name":"testWthNoLineLongerThan","linesOfCode":24,"sourceCode":"testWthNoLineLongerThan\r\t| phrases |\r\tphrases := {\r\t\t'Fred the bear went down to the brook to read his book in silence'.\r\t\t'Fred the bear went down' , String cr , ' to the brook to ' , String cr , 'read his book in silence'.\r\t\t'Fred the bear went down' , String lf , '  to the brook to ' , String lf , 'read his book in silence'.\r\t\t'Fred the bear went down' , String crlf , '  to the brook to ' , String crlf , 'read his book in silence'.\r\t\t}.\r\t#(5 7 9) do: [:length |\r\t\tphrases do: [:phrase |\r\t\t\t| split |\r\t\t\tsplit := phrase withNoLineLongerThan: length.\r\t\t\tself\r\t\t\t\tassert: (split copyWithoutAll: CharacterSet separators) = (phrase copyWithoutAll: CharacterSet separators)\r\t\t\t\tdescription: 'no information should be lost'.\r\t\t\tsplit linesDo: [:line |\r\t\t\t\tself assert: line size <= length description: 'lines should not be longer than prescribed'].\r\t\t\tphrase lineCount = 1 ifTrue: [| lastLineSize |\r\t\t\t\tlastLineSize := length.\r\t\t\t\tsplit linesDo: [:line |\r\t\t\t\t\tline isEmpty ifFalse: [| firstWordSize |\r\t\t\t\t\t\tfirstWordSize := line indexOfAnyOf: CharacterSet separators startingAt: 1 ifAbsent: [line size + 1].\r\t\t\t\t\t\tself assert: (lastLineSize + firstWordSize) > length description: 'split was too short'.\r\t\t\t\t\t\tlastLineSize := line size]]]]]"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":4,"sourceCode":"integerCollectionWithoutEqualElements\r\t\"Return a collection of integer without equal elements\"\t\r\t\t\r\t^ nonEmpty5ElementsSorted"},{"name":"testCharactersExactlyMatching","linesOfCode":5,"sourceCode":"testCharactersExactlyMatching\r\r\tself assert: 5 equals: ('voiture' charactersExactlyMatching: 'voituze').\r\tself assert: 0 equals: ('voiture' charactersExactlyMatching: '').\r\tself assert: 1 equals: ('voiture' charactersExactlyMatching: 'v').\r\tself assert: 0 equals: ('voiture' charactersExactlyMatching: 'abcdef')"},{"name":"testAsClassIfPresent","linesOfCode":4,"sourceCode":"testAsClassIfPresent\r\t\r\t'String' asClassIfPresent: [ :class | \r\t\tself assert: class equals: String ].\r\t\r\t'+' asClassIfPresent: [ ^ self fail ]."},{"name":"subCollectionNotIn","linesOfCode":3,"sourceCode":"subCollectionNotIn\r\t\"Return a collection for which at least one element is not included in 'moreThan4Elements'\"\r\t\r\t^ collectionNotIncluded "},{"name":"testCopyUpToSubstring","linesOfCode":11,"sourceCode":"testCopyUpToSubstring \r\r\tself assert: ('abcdef' copyUpToSubstring: '') equals: ''.\r\tself assert: ('abcdef' copyUpToSubstring: 'a') equals: ''.\r\tself assert: ('abcdef' copyUpToSubstring: 'b') equals: 'a'.\r\tself assert: ('abcdef' copyUpToSubstring: 'de') equals: 'abc'.\r\tself assert: ('abcdef' copyUpToSubstring: 'ef') equals: 'abcd'.\r\tself assert: ('abcdef' copyUpToSubstring: 'f') equals: 'abcde'.\r\tself assert: ('abcdef' copyUpToSubstring: 'fg') equals: 'abcdef'.\r\tself assert: ('' copyUpToSubstring: 'abc') equals: ''.\r\tself assert: ('abcdef' copyUpToSubstring: 'g') equals: 'abcdef'.\r\tself assert: ('abcdef' copyUpToSubstring: 'gh') equals: 'abcdef'.\r"},{"name":"testindexOfstartingAt","linesOfCode":3,"sourceCode":"testindexOfstartingAt\r\r\tself assert: ('aa aa  aa aa' indexOf: $a startingAt: 8) equals: 10.\r\tself assert: ('aa aa  aa aa' indexOf: $z startingAt: 8) equals: 0."},{"name":"testFindTokensEscapedBy06","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy06\r\r\t| tokens |\r\tstring := 'this, is, \"a, test'.\r\ttokens := string findTokens: ',' escapedBy: '\"'.\r\tself assert: tokens size equals: 3.\r\tself assert: tokens third equals: ' a, test'"},{"name":"testAsCamelCase","linesOfCode":3,"sourceCode":"testAsCamelCase\r\r\tself assert: 'A man, a plan, a canal, panama' asCamelCase equals: 'AMan,APlan,ACanal,Panama'.\r\tself assert: 'Here 123should % be 6 the name6 of the method' asCamelCase equals: 'Here123should%Be6TheName6OfTheMethod'.\r "},{"name":"testFindTokensEscapedBy16","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy16\r\r\t| tokens |\r\tstring := 'one, \"two# three\"; &four. five&'.\r\ttokens := string findTokens: nil escapedBy: nil.\r\tself assert: tokens size equals: 1.\r\tself assert: tokens first equals: string"},{"name":"testFindSelector","linesOfCode":7,"sourceCode":"testFindSelector\r\tself assert: #isSymbol equals: 'isSymbol' findSelector.\r\tself assert: #between:and: equals: 'between:and:' findSelector .\r\tself assert: #+ equals: '+' findSelector .\r\tself assert: #isSymbol equals: '#isSymbol' findSelector.\r\tself assert: #between:and: equals: '#between:and:' findSelector .\r\tself assert:#+ equals: '#+' findSelector\r"},{"name":"testIsAllDigits","linesOfCode":6,"sourceCode":"testIsAllDigits\r\r\tself assert: '' isAllDigits equals: false.\r\tself assert: '1.23' isAllDigits equals: false.\r\tself assert: '12 3' isAllDigits equals: false.\r\tself assert: '-123' isAllDigits equals: false.\r\tself assert: '0123456789' isAllDigits equals: true"},{"name":"testUnescapePercentsWithTextEncoding","linesOfCode":14,"sourceCode":"testUnescapePercentsWithTextEncoding\r\t| leading kataTe kataSu kataTo |\r\tleading := JapaneseEnvironment leadingChar.\r\t\"Katakana letter Te\"\r\tkataTe := (Character leadingChar: leading code: 12486) asString.\r\t\"Katakana letter Su\"\r\tkataSu := (Character leadingChar: leading code: 12473) asString.\r\t\"Katakana letter To\"\r\tkataTo := (Character leadingChar: leading code: 12488) asString.\r\t\"This could be reactivated when/if Zinc-Character-Encoding supports shift_jis\"\r\t\"self assert: ('%83e%83X%83g' unescapePercentsWithTextEncoding: 'shift_jis')\r\t\t\t= (kataTe , kataSu , kataTo).\r\tself assert: ('%83e%83X%83g%20and%20%83e%83X%83g' unescapePercentsWithTextEncoding: 'shift_jis')\r\t\t\t= (kataTe , kataSu , kataTo , ' and ' , kataTe , kataSu , kataTo)\""},{"name":"testAsHTMLString","linesOfCode":5,"sourceCode":"testAsHTMLString\r\r\tself assert: '<a>' asHTMLString equals: '&lt;a&gt;'.\r\tself assert: '<!DOCTYPE html>' asHTMLString equals: '&lt;!DOCTYPE html&gt;'. \r\tself assert: '           ' asHTMLString equals: '           '.\r\tself assert: '' asHTMLString equals: ''"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ $z"},{"name":"testAsSignedInteger","linesOfCode":7,"sourceCode":"testAsSignedInteger\r\r\tself assert: 'test' asSignedInteger isNil.\r\tself assert: '           ' asSignedInteger isNil.\r\tself assert: 'test-10test' asSignedInteger equals: -10.\r\tself assert: ('' asSignedInteger) equals: nil.\r\tself assert: '1234567890-1234567890' asSignedInteger equals: 1234567890.\r\tself assert: '--12345' asSignedInteger equals: -12345"},{"name":"collectionWith2TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith2TimeSubcollection\r\t\"Return a collection including 'oldSubCollection' two or many time\"\r\t\r\t^ nonEmpty5ElementsSorted, subcollection3ElementsSorted "},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\t\"Return a collection of size 1 including one element\"\r\t\r\t^ nonEmpty1element "},{"name":"testFindTokensEscapedBy26","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy26\r\r\t| tokens |\r\tstring := 'this, is, \"a, test'.\r\ttokens := string findTokens: $, escapedBy: $\".\r\tself assert: tokens size equals: 3.\r\tself assert: tokens third equals: ' a, test'"},{"name":"otherCollection","linesOfCode":3,"sourceCode":"otherCollection\r\t\"Returns a collection that does not include what is returned by #element.\"\r\t\r\t^ collectionNotIncluded "},{"name":"testTrimRight","linesOfCode":9,"sourceCode":"testTrimRight\r\tself assert: '' trimRight equals: ''.\r\tself assert: ' ' trimRight equals: ''.\r\tself assert: '\t' trimRight equals: ''.\r\tself assert: 'foo' trimRight equals: 'foo'.\r\tself assert: ' foo ' trimRight equals: ' foo'.\r\tself assert: '  foo  ' trimRight equals: '  foo'.\r\t\r\tself assert: ('aabbaa' trimRight: [ :each | each = $a ]) equals: 'aabb'.\r\tself assert: ('bbaabb' trimRight: [ :each | each = $a ]) equals: 'bbaabb'"},{"name":"testLinesDoWithCr","linesOfCode":5,"sourceCode":"testLinesDoWithCr\r\r\t| myString  |\r\tmyString := 'This is a test of line breaking', String cr.\r\tmyString linesDo: [ :line |\r\t\tself assert: (line size + 1) equals: myString size]"},{"name":"elementInForIndexAccessing","linesOfCode":3,"sourceCode":"elementInForIndexAccessing\r\" return an element included in 'accessCollection' \"\r\t^ withoutEqualElements anyOne"},{"name":"testFindTokensEscapedBy01","linesOfCode":5,"sourceCode":"testFindTokensEscapedBy01\r\r\t| tokens |\r\tstring := 'this, is, \"a, test\"'.\r\ttokens := string findTokens: ',' escapedBy: '\"'.\r\tself assert: tokens size equals: 3"},{"name":"testUncapitalized","linesOfCode":10,"sourceCode":"testUncapitalized\r\t| uc lc empty |\r\tuc := 'MElViN'.\r\tlc := 'mElViN'.\r\tempty := ' '.\r\tself assert: uc uncapitalized equals: lc.\r\tself assert: lc uncapitalized equals: lc.\r\t\"the string gets copied\"\r\tself deny: lc uncapitalized identicalTo: lc.\r\tself deny: empty uncapitalized identicalTo: empty"},{"name":"testWriteStreamConvertsToWideString","linesOfCode":10,"sourceCode":"testWriteStreamConvertsToWideString\r\t| oldWideString newString ws |\r\t\"test that a write stream on a ByteString is autoconverted into a WideString if a Wide character is inserted into it\"\r\toldWideString := (WideString new: 1) wordAt: 1 \r\t\t\t\t\t\t\t\t\t\tput: 20984060; \r\t\t\t\t\t\t\t\t\t\tyourself.\r\tnewString := (String new: oldWideString size).\r\tws := newString writeStream.\r\toldWideString do: [:each | ws nextPut: each].\r\tself assert: newString equals: oldWideString."},{"name":"testAsFileLocatorOrReferenceReturnsAReferenceWhenStringDoesNotReferToAKnownOrigin","linesOfCode":7,"sourceCode":"testAsFileLocatorOrReferenceReturnsAReferenceWhenStringDoesNotReferToAKnownOrigin\r\t| fileRef result |\r\tfileRef := '/foo' asFileReference.\r\t\r\tresult := fileRef fullName asFileLocatorOrReference.\r\t\r\tself\r\t\tassert: result\r\t\tequals: fileRef."},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\t^ 'ghj'"},{"name":"testFindDelimitersStartingAt","linesOfCode":5,"sourceCode":"testFindDelimitersStartingAt\r\r\tself assert: ('this is a string' findDelimiters: ' ' startingAt: 1) equals: 5.\r\tself assert: ('this is a string' findDelimiters: 'i' startingAt: 1) equals: 3.\r\tself assert: ('this is a string' findDelimiters: #($a $e $s) startingAt: 5) equals: 7.\r\tself assert: (' ' findDelimiters: '' startingAt: 2) equals: 7"},{"name":"anotherValue","linesOfCode":3,"sourceCode":"anotherValue\r\t\"Return a value (not equal to 'aValue') to put into nonEmpty\"\r\t\r\t^ self nonEmpty anyOne"},{"name":"aValue","linesOfCode":3,"sourceCode":"aValue\r\t\"Return a value to put into nonEmpty\"\r\t\r\t^ elementInNonEmpty "},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\t\"Return a collection that will be the second part of the concatenation\"\r\t\r\t^ nonEmpty1element "},{"name":"anIndex","linesOfCode":3,"sourceCode":"anIndex\r\t\"Return an index in nonEmpty bounds\"\r\t\r\t^ 2"},{"name":"testEndsWithDigit","linesOfCode":5,"sourceCode":"testEndsWithDigit\r\r\tself deny: ('' endsWithDigit).\r\tself assert: ('9' endsWithDigit).\r\tself deny: ('99test' endsWithDigit).\r\tself assert: ('  999' endsWithDigit)."},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\t\"Return a collection that will be the first part of the concatenation\"\r\t\r\t^ nonEmpty5ElementsSorted"},{"name":"testFindTokensEscapedBy11","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy11\r\r\t| tokens |\r\tstring := 'this, is, \"\"\"a, test\"'.\r\ttokens := string findTokens: ',' escapedBy: '\"'.\r\tself assert: tokens size equals: 3.\r\tself assert: tokens third equals: ' \"a, test'"},{"name":"testIncludesSubstringCaseSensitive","linesOfCode":6,"sourceCode":"testIncludesSubstringCaseSensitive\r\r\tself deny: ('test this string' includesSubstring: 'Ring' caseSensitive: true ). \r\tself assert: ('test this string' includesSubstring: 'Ring' caseSensitive: false). \r\tself deny: ('123' includesSubstring: '' caseSensitive: false). \r\tself assert: ('123' includesSubstring: '' caseSensitive: true).\r\tself assert: ('123' includesSubstring: '' caseSensitive: false)\r\r"},{"name":"element","linesOfCode":3,"sourceCode":"element\r\t\"Returns an object that can be added to the collection returned by #collection.\"\r\t\r\t^ elementInNonEmpty "},{"name":"indexArray","linesOfCode":3,"sourceCode":"indexArray\r\t\"Return a Collection including indexes between bounds of 'nonEmpty'\"\r\r\t^ indexInNonEmptyArray "},{"name":"sizeCollection","linesOfCode":3,"sourceCode":"sizeCollection\r\t\"Answers a collection whose #size is 4\"\r\t^ 'abcd'"},{"name":"testCopyNonEmptyWithoutAllNotIncluded","linesOfCode":1,"sourceCode":"testCopyNonEmptyWithoutAllNotIncluded\r\t"},{"name":"testFindTokensEscapedBy04","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy04\r\r\t| tokens |\r\tstring := 'this, is, a\",\" test'.\r\ttokens := string findTokens: ',' escapedBy: '\"'.\r\tself assert: tokens size equals: 3.\r\tself assert: tokens third equals: ' a, test'"},{"name":"testWriteStreamDo","linesOfCode":6,"sourceCode":"testWriteStreamDo\r\temptyString\r\t\twriteStreamDo: [ :stream | \r\t\t\tstream nextPutAll: string.\r\t\t\tself assert: stream contents equals: string ].\r\tself assert: (emptyString writeStreamDo: [ :stream | true ])"},{"name":"testAt","linesOfCode":2,"sourceCode":"testAt\r\tself assert: (string at: 1) equals: $H."},{"name":"testAsTime","linesOfCode":5,"sourceCode":"testAsTime \r\r\tself assert: '1:00:00' asTime asString equals: '1:00 am'.\r\tself assert: '1:00' asTime asString equals: '1:00 am'.\r\tself assert: '1' asTime asString equals: '1:00 am'.\r\tself assert: '13' asTime asString equals: '1:00 pm'\r"},{"name":"testNumArgs","linesOfCode":45,"sourceCode":"testNumArgs\r\t\"This is about http://code.google.com/p/pharo/issues/detail?id=237\"\r\t\r\t| binary |\r\tbinary := '*+-/\\~=<>&@%,|'.\r\tself assert: (binary allSatisfy: [:char1 |\r\t\t\t(String with: char1) numArgs = 1 and: [binary allSatisfy: [:char2 |\r\t\t\t\t(String with: char1 with: char2) numArgs = 1 and: [binary allSatisfy: [:char3 |\r\t\t\t\t\t(String with: char1 with: char2 with: char3) numArgs = 1]]]]])\r\t\tdescription: 'binary selectors have 1 argument'.\r\t\t\r\tself assert: 'x' numArgs = 0\r\t\tdescription: 'unary selectors have 0 arguments'.\r\tself assert: 'x0' numArgs = 0\r\t\tdescription: 'unary selectors have 0 arguments'.\r\tself assert: 'yourself' numArgs = 0\r\t\tdescription: 'unary selectors have 0 arguments'.\r\t\t\r\tself assert: 'x:' numArgs = 1\r\t\tdescription: 'keyword selectors have as many elements as colons characters'.\r\tself assert: 'x:y:' numArgs = 2\r\t\tdescription: 'keyword selectors have as many elements as colons characters'.\r\tself assert: 'at:put:' numArgs = 2\r\t\tdescription: 'keyword selectors have as many elements as colons characters'.\r\t\t\t\r\tself assert: 'x_y_z' numArgs = 0\r\t\tdescription: 'selectors can contain underscores'.\r\tself assert: '_x' numArgs = 0\r\t\tdescription: 'selectors can begin with an underscore'.\r\tself assert: '_:_:' numArgs = 2\r\t\tdescription: 'keyword selectors can contain underscores'.\r\t\t\r\tself assert: 'at:withoutTrailingColon' numArgs = -1\r\t\tdescription: 'keyword selectors should have a trailing colon character'.\r\t\t\r\tself assert: ':x' numArgs = -1\r\t\tdescription: 'keyword selectors cannot begin with a colon character'.\r\t\t\r\tself assert: 'x::y:' numArgs = -1\r\t\tdescription: 'keyword selectors cannot have two consecutive colon characters'.\r\t\t\r\tself assert: '0x' numArgs = -1\r\t\tdescription: 'selectors cannot begin with a digit'.\r\t\t\r\tself assert: 'x::0y:' numArgs = -1\r\t\tdescription: 'keyword selectors cannot have any key beginning with a digit'.\r\t\r\t"},{"name":"testIsAllAlphaNumerics","linesOfCode":7,"sourceCode":"testIsAllAlphaNumerics\r\r\tself assert: '123dwef890' isAllAlphaNumerics.\r\tself deny: '12 34 top &^' isAllAlphaNumerics. \r\tself assert: '' isAllAlphaNumerics.\r\tself deny: ' 234 ' isAllAlphaNumerics.\r\tself deny: '()' isAllAlphaNumerics. \r\tself assert: '123' isAllAlphaNumerics"},{"name":"testExpandMacrosTernary","linesOfCode":3,"sourceCode":"testExpandMacrosTernary\r\tself assert: ('<1?success:error>' expandMacrosWith: true) equals: 'success'.\r\tself assert: ('<1?success:error>' expandMacrosWith: false) equals: 'error'"},{"name":"testCaseInsensitiveLessOrEqual","linesOfCode":6,"sourceCode":"testCaseInsensitiveLessOrEqual\r\r\tself assert: ('EEA' caseInsensitiveLessOrEqual: 'fgh').\r\tself deny: ('' caseInsensitiveLessOrEqual: '').\r\tself assert: ('' caseInsensitiveLessOrEqual: '').\r\tself deny: ('' caseInsensitiveLessOrEqual: '').\r\tself assert: ('eea' caseInsensitiveLessOrEqual: '')"},{"name":"testFindTokensEscapedBy07","linesOfCode":9,"sourceCode":"testFindTokensEscapedBy07\r\r\t| tokens |\r\tstring := 'a:b::c'.\r\ttokens := string findTokens: ':' escapedBy: '\"'.\r\tself assert: tokens size equals: 4.\r\tself assert: tokens first equals: 'a'.\r\tself assert: tokens second equals: 'b'.\r\tself assert: tokens third equals: ''.\r\tself assert: tokens fourth equals: 'c'"},{"name":"testIsLiteralSymbol","linesOfCode":6,"sourceCode":"testIsLiteralSymbol\r\r\tself assert: ('*+-/\\~=<>&@%,|' allSatisfy: [:char | (Symbol with: char) isLiteralSymbol])\r\t\tdescription: 'single letter binary symbols can be printed without string quotes'.\r\t\t\r\tself assert: (#('x' 'x:' 'x:y:' 'from:to:by:' 'yourself') allSatisfy: [:str | str asSymbol isLiteralSymbol])\r\t\tdescription: 'valid ascii selector symbols can be printed without string quotes'"},{"name":"testAsClassIfAbsent","linesOfCode":6,"sourceCode":"testAsClassIfAbsent\r\r\tself \r\t\tassert: ('String' asClassIfAbsent: [ self fail ])\r\t\tequals: String.\r\t\r\t'+' asClassIfAbsent: [ ^ self \"success\" ].\r\tself fail."},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\t\"Return a collection with elements at end and begining equals\r\t (other elements of the collection are not equal to those elements)\"\r\r\t^ sameAtEndAndBegining "},{"name":"testComparingCaseInsensitiveLatin1","linesOfCode":16,"sourceCode":"testComparingCaseInsensitiveLatin1\r\r\t\"ascii-letter\"\r\tself assert: ('e' compare: 'E' caseSensitive: false) equals: 2.\r\tself assert: ('E' compare: 'e' caseSensitive: false) equals: 2.\r\tself assert: ('e' compare: 'E' caseSensitive: true) equals: 3.\r\tself assert: ('E' compare: 'e' caseSensitive: true) equals: 1.\r\t\r\t\"ascii-number (no difference between number chars and number chars asUppercase \"\r\tself assert: ('1' compare: '1' asUppercase caseSensitive: false) equals: 2.\r\tself assert: ('1' asUppercase compare: '1' caseSensitive: false) equals: 2.\r\tself assert: ('1' compare: '1' asUppercase caseSensitive: true) equals: 2.\r\tself assert: ('1' asUppercase compare: '1' caseSensitive: true) equals: 2.\r\t\r\t\"non-ascii\"\r\tself assert: ('' compare: '' caseSensitive: false) equals: 2.\r\tself assert: ('' compare: '' caseSensitive: false) equals: 2.\r\tself assert: ('' compare: '' caseSensitive: true) equals: 3.\r\tself assert: ('' compare: '' caseSensitive: true) equals: 1\r"},{"name":"testLeadingCharRunLengthAt","linesOfCode":7,"sourceCode":"testLeadingCharRunLengthAt\r\r\tself assert: ('test' leadingCharRunLengthAt: 1) equals: 4.\r\tself assert: ('  ' leadingCharRunLengthAt: 2) equals: 7.\r\tself assert: ('123ea slkj jfek' leadingCharRunLengthAt: 1) equals: 15.\r\tself assert: ('test this string' leadingCharRunLengthAt: 1) equals: 17.\r\tself assert: (' ' leadingCharRunLengthAt: 1) equals: 1.\r\tself assert: ('test this string' leadingCharRunLengthAt: 10) equals: 8"},{"name":"testFindTokensEscapedBy25","linesOfCode":7,"sourceCode":"testFindTokensEscapedBy25\r\r\t| tokens |\r\tstring := 'this, /is, a\",\" test/'.\r\ttokens := string findTokens: $, escapedBy: $/.\r\tself assert: tokens size equals: 2.\r\tself assert: tokens first equals: 'this'.\r\tself assert: tokens second equals: ' is, a\",\" test'."},{"name":"testDisplayString","linesOfCode":4,"sourceCode":"testDisplayString\r\r\t| actual |\r\tactual := 'some string' displayString.\r\tself assert: actual equals: 'some string'"},{"name":"testLoremIpsum","linesOfCode":9,"sourceCode":"testLoremIpsum\r\t| fillerText |\r\tfillerText := String loremIpsum.\r\tself denyEmpty: fillerText.\r\tself assert: (fillerText beginsWith: 'Lorem ipsum').\r\tself assert: (fillerText endsWith: 'laborum.').\r\tself assert: fillerText lines first equals: fillerText.\r\tself assert: fillerText isAsciiString.\r\tself assert: (Character space split: fillerText) size > 10"},{"name":"testCopyReplaceAllWith","linesOfCode":14,"sourceCode":"testCopyReplaceAllWith\r\tself assert: ('--A--' copyReplaceAll: 'A' with: 'ABC') equals: '--ABC--'.\r\tself assert: ('--A--' copyReplaceAll: 'A' with: 'X') equals: '--X--'.\r\tself assert: ('--ABC--' copyReplaceAll: 'ABC' with: 'X') equals: '--X--'.\r\tself assert: ('--A--' copyReplaceAll: 'A' with: '') equals: '----'.\r\tself assert: ('' copyReplaceAll: 'A' with: 'ABC') equals: ''.\r\tself assert: ('A--A--A' copyReplaceAll: 'A' with: 'ABC') equals: 'ABC--ABC--ABC'.\r\tself assert: ('A--A--A' copyReplaceAll: 'A' with: 'X') equals: 'X--X--X'.\r\tself assert: ('ABC--ABC--ABC' copyReplaceAll: 'ABC' with: 'X') equals: 'X--X--X'.\r\tself assert: ('A--A--A' copyReplaceAll: 'A' with: '') equals: '----'.\r\tself assert: ('A--ABC--A' copyReplaceAll: 'ABC' with: 'X') equals: 'A--X--A'.\r\tself assert: ('AB--ABC--AB' copyReplaceAll: 'ABC' with: 'X') equals: 'AB--X--AB'.\r\tself assert: ('--A--' copyReplaceAll: '' with: '') equals: '--A--'.\r\tself assert: ('AAAA-' copyReplaceAll: 'AA' with: 'X') equals: 'XX-'"},{"name":"testFindTokensEscapedBy15","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy15\r\r\t| tokens |\r\tstring := 'one, \"two# three\"; &four. five&'.\r\ttokens := string findTokens: nil escapedBy: '\"&'.\r\tself assert: tokens size equals: 1.\r\tself assert: tokens first equals: 'one, two# three; four. five'"},{"name":"testIndexOfFirstUppercaseCharacter","linesOfCode":5,"sourceCode":"testIndexOfFirstUppercaseCharacter\r\r\tself assert: 'test thiS strIng' indexOfFirstUppercaseCharacter equals: 9.\r\tself assert: 'test this string' indexOfFirstUppercaseCharacter equals: 0.\r\tself assert: '123' indexOfFirstUppercaseCharacter equals: 0.\r\tself assert: '123' indexOfFirstUppercaseCharacter equals: 8\r "},{"name":"testTranslateToUppercase","linesOfCode":6,"sourceCode":"testTranslateToUppercase\r\r\tself assert: 'test this string' copy translateToUppercase equals: 'TEST THIS STRING'.\r\tself assert: ' Test THIS sTRing' copy translateToUppercase equals: ' TEST THIS STRING'.\r\tself assert: '' copy translateToUppercase equals: ''.\r\tself assert: '' copy translateToUppercase equals: ''.\r\tself assert: '123' copy translateToUppercase equals: '123'"},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\t\"Return an element included in 'moreThan4Elements'\"\r\t\r\t^ self moreThan4Elements anyOne"},{"name":"sortedInAscendingOrderCollection","linesOfCode":3,"sourceCode":"sortedInAscendingOrderCollection\r\" return a collection sorted in an acsending order\"\r\t^nonEmpty5ElementsSorted \r\t"},{"name":"testFindTokensEscapedBy10","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy10\r\r\t| tokens |\r\tstring := 'this, is, ###a, test'.\r\ttokens := string findTokens: ',' escapedBy: '#'.\r\tself assert: tokens size equals: 3.\r\tself assert: tokens third equals: ' #a, test'"},{"name":"testFindString","linesOfCode":6,"sourceCode":"testFindString\r\r\tself assert: ('' findString: '') equals: 0.\r\tself assert: ('' findString: '') equals: 1.\r\tself assert: ('salkjsdlkgfee' findString: 'EE') equals: 0.\r\tself assert: ('salkjsdlkgfee' findString: 'ee') equals: 12.\r\tself assert: (' ' findString: '') equals: 0"},{"name":"testIsWideString","linesOfCode":7,"sourceCode":"testIsWideString\r\r\tself assert: '' isWideString.\r\tself deny: 'test this string' isWideString. \r\tself assert: ' test ' isWideString.\r\tself deny: '' isWideString. \r\tself assert: '' isWideString.\r\tself deny: '' isWideString "},{"name":"testFindTokensEscapedBy","linesOfCode":10,"sourceCode":"testFindTokensEscapedBy\r\r\t|s|\r\ts := OrderedCollection withAll: #('' '' '').\r\tself assert: ('' findTokens: #($ $) escapedBy:'') equals: s.\r\r\ts := OrderedCollection withAll: #('ths,').\r\tself assert: ('this,is' findTokens: ',' escapedBy: 'is' ) equals: s.\r\r\ts := OrderedCollection withAll: #('this,is').\r\tself assert: ('this , is' findTokens: ',' escapedBy: ' ') equals: s.\r\r\ts := OrderedCollection withAll: #('ths , s').\r\tself assert: ('this , is' findTokens: ' ' escapedBy: $i) equals: s"},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\" return a collection  including equal elements (classic equality)\"\r\t^ sameAtEndAndBegining \t"},{"name":"testFindTokensEscapedBy22","linesOfCode":5,"sourceCode":"testFindTokensEscapedBy22\r\r\t| tokens |\r\tstring := ''.\r\ttokens := string findTokens: $, escapedBy: $\".\r\tself assert: tokens size equals: 0"},{"name":"testStoreOn","linesOfCode":2,"sourceCode":"testStoreOn\r\tself assert: (String streamContents: [ :s | 'Foo''Bar' storeOn: s ]) equals: '''Foo''''Bar'''"},{"name":"testExpandMacrosWithArguments","linesOfCode":4,"sourceCode":"testExpandMacrosWithArguments\r\tself assert: ('<1s>' expandMacrosWithArguments: {'str''ing'}) equals: 'str''ing'.\r\tself assert: ('<1p>' expandMacrosWithArguments: {'str''ing'}) equals: '''str''''ing'''.\r\tself assert: ('<1p>: <2p>' expandMacrosWith: 'Number' with: 5) equals: '''Number'': 5'"},{"name":"testFindStringStartingAtCaseSensitive","linesOfCode":6,"sourceCode":"testFindStringStartingAtCaseSensitive\r\r\tself assert: ('' findString: '' startingAt: 1 caseSensitive: false) equals: 12.\r\tself assert: ('' findString: '' startingAt: 1 caseSensitive: true) equals: 0.\r\tself assert: ('suiehl5tlr' findString: 'r' startingAt:  5 caseSensitive: true) equals: 10.\r\tself assert: ('test' findString: 'T' startingAt: 3 caseSensitive: false) equals: 4.\r\tself assert: ('test' findString: '' startingAt: 1 caseSensitive: false) equals: 0"},{"name":"testIndexOfWideCharacterFromTo","linesOfCode":5,"sourceCode":"testIndexOfWideCharacterFromTo\r\r\tself assert: ('123' indexOfWideCharacterFrom: 1 to: 9) equals: 9.\r\tself assert: ('test' indexOfWideCharacterFrom: 1 to: 5) equals: 3.\r\tself assert: ('test this string' indexOfWideCharacterFrom: 4 to: 10) equals: 0.\r\tself assert: ('' indexOfWideCharacterFrom: 1 to: 2) equals: 1"},{"name":"testExpandMacrosSkip","linesOfCode":2,"sourceCode":"testExpandMacrosSkip\r\tself assert: '%<' expandMacros equals: '<'"},{"name":"testTrimBoth","linesOfCode":10,"sourceCode":"testTrimBoth\r\tself assert: '' trimBoth equals: ''.\r\tself assert: ' ' trimBoth equals: ''.\r\tself assert: '\t' trimBoth equals: ''.\r\tself assert: 'foo' trimBoth equals: 'foo'.\r\tself assert: ' foo ' trimBoth equals: 'foo'.\r\tself assert: '  foo  ' trimBoth equals: 'foo'.\r\tself assert: ((String with: Character cr), '   foo  ') trimBoth equals: 'foo'.\r\t\r\tself assert: ('aabbaa' trimBoth: [ :each | each = $a ]) equals: 'bb'.\r\tself assert: ('bbaabb' trimBoth: [ :each | each = $a ]) equals: 'bbaabb'"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\t\"Return a collection only including elements that can be sorted (understanding '<')\"\r\r\t^ nonEmpty5ElementsSorted"},{"name":"testIncludesSubstring","linesOfCode":6,"sourceCode":"testIncludesSubstring\r\r\tself assert: ('testing this string' includesSubstring: 'ring'). \r\tself assert: ('' includesSubstring: '').\r\tself deny: ('' includesSubstring: 'a'). \r\tself assert: ('' includesSubstring: '').\r\tself deny: ('kjdsnlksjdf' includesSubstring: 'K') \r"},{"name":"testIsValidSelector","linesOfCode":3,"sourceCode":"testIsValidSelector\r\tself assert: 'class' isValidSelector.\r\tself deny: '0class' isValidSelector"},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\t\"Return an index between 'collectionWithoutEqualsElements' bounds\"\r\t\r\t^ 2"},{"name":"testWithBlanksCondensed","linesOfCode":13,"sourceCode":"testWithBlanksCondensed\r\t#( \r\t\t'foo' 'foo'\r\t\t'foo bar' 'foo bar'\r\t\t'' ''\r\t\t' ' ''\r\t\t'foo  bar  !' 'foo bar !'\r\t\t' foo  bar  ! ' 'foo bar !'\r\t\t'  foo  bar  !  ' 'foo bar !'\r\t\t'\t\ttabs\t\ttabs\t!\t\t' 'tabs\ttabs\t!'\r\t\t'space followed by tab \t!' 'space followed by tab !'\r\t) pairsDo: [ :input :output |\r\t\tself assert: input withBlanksCondensed equals: output ]\r\t"},{"name":"testReadFrom","linesOfCode":13,"sourceCode":"testReadFrom\r\tself \r\t\tassert: (String readFrom: ($' asString, 'foo', $' asString) readStream)\r\t\tequals: 'foo'.\r\tself \r\t\tassert: (String readFrom: ($' asString, 'this ', $' asString, $' asString, ' is embedded', $' asString) readStream)\r\t\tequals: 'this '' is embedded'.\r\tself \r\t\tassert: (String readFrom: ('<whitespace>', $' asString, 'foo', $' asString, '<whitespace>') readStream)\r\t\tequals: 'foo'.\r\tself\r\t\tassert: (String readFrom: 'this '' is embedded' printString readStream)\r\t\tequals: 'this '' is embedded'"},{"name":"collectionWithEqualElements","linesOfCode":3,"sourceCode":"collectionWithEqualElements\r\t\"Return a collecition including atLeast two elements equal\"\r\r\t^ sameAtEndAndBegining "},{"name":"findFirstInString:fromString:","linesOfCode":2,"sourceCode":"findFirstInString: aString fromString: searchString\r\r\t^ String findFirstInString: aString inSet: (CharacterSet newFrom: searchString) byteArrayMap startingAt: 1"},{"name":"testFindTokensEscapedBy14","linesOfCode":7,"sourceCode":"testFindTokensEscapedBy14\r\r\t| tokens |\r\tstring := 'one, \"two# three\"; &four. five&'.\r\ttokens := string findTokens: ',#;.' escapedBy: '\"&'.\r\tself assert: tokens size equals: 3.\r\tself assert: tokens second equals: ' two# three'.\r\tself assert: tokens third equals: ' four. five'"},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection  anyOne"},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^ 2"},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\t\"Return an element not included in 'nonEmpty'\"\r\r\t^notIn "},{"name":"testFindTokensEscapedBy03","linesOfCode":5,"sourceCode":"testFindTokensEscapedBy03\r\r\t| tokens |\r\tstring := 'this, is, a, test'.\r\ttokens := string findTokens: ',' escapedBy: '\"'.\r\tself assert: tokens size equals: 4"},{"name":"testIsAsciiString","linesOfCode":5,"sourceCode":"testIsAsciiString\r\t\"Non-regression for https://pharo.manuscript.com/f/cases/15232 \"\r\t\r\tself assert: '' isAsciiString equals: true.\r\tself assert: 'abcdefGHIJKL 98765,./@#%$' isAsciiString equals: true.\r\tself assert: '' isAsciiString equals: false"},{"name":"testTranslateToLowercase","linesOfCode":6,"sourceCode":"testTranslateToLowercase\r\t\r\tself assert: 'test this string' copy translateToLowercase equals: 'test this string'.\r\tself assert: ' Test THIS sTRing' copy translateToLowercase equals: ' test this string'.\r\tself assert: '' copy translateToLowercase equals: ''.\r\tself assert: '' copy translateToLowercase equals: ''.\r\tself assert: '123' copy translateToLowercase equals: '123'"},{"name":"testSpace","linesOfCode":7,"sourceCode":"testSpace\r\t\t\r\tstring := String new.\r\tself assert: string size equals: 0. \r\t\r\tstring := String space.\r\tself assert: string size equals: 1.\r\tself assert: string equals: ' '"},{"name":"testLineCount","linesOfCode":8,"sourceCode":"testLineCount\r\t| sampleCRString sampleLFString sampleCRLFString |\r\tsampleCRString := 'Fred', String cr, 'the', String cr, 'Bear'.\r\tsampleLFString := 'Fred', String lf, 'the', String lf, 'Bear'.\r\tsampleCRLFString := 'Fred', String crlf, 'the', String crlf, 'Bear'.\r\t\r\tself assert: sampleCRString lineCount equals: 3.\r\tself assert: sampleLFString lineCount equals: 3.\r\tself assert: sampleCRLFString lineCount equals: 3."},{"name":"testWithoutPeriodSuffix","linesOfCode":10,"sourceCode":"testWithoutPeriodSuffix\r\t#( \r\t\t'foo' 'foo'\r\t\t'foo.' 'foo'\r\t\t'foo.bar' 'foo'\r\t\t'foo.bar.txt' 'foo'\r\t\t'' ''\r\t\t'.' '.'\r\t) pairsDo: [ :input :output |\r\t\tself assert: input withoutPeriodSuffix equals: output ]\r\t"},{"name":"testCompareCaseSensitive","linesOfCode":7,"sourceCode":"testCompareCaseSensitive\r\r\tself assert: ('EEA' compare: 'fgh' caseSensitive: true) equals: 1.\r\tself assert: ('ABCDEFGH' compare: 'abcdefgh' caseSensitive: false) equals: 2.\r\tself assert: ('fgh' compare: 'fg' caseSensitive: false) equals: 3.\r\tself assert: ('' compare: '' caseSensitive: false) equals: 2.\r\tself assert: ('' compare: '' caseSensitive: true) equals: 1.\r\tself assert: ('' compare: '' caseSensitive: false) equals: 1"},{"name":"testWithoutTrailingNewlines","linesOfCode":4,"sourceCode":"testWithoutTrailingNewlines\r\r\tself assert: ('123',String cr) withoutTrailingNewlines equals: '123'.\r\tself assert: ('123',String lf) withoutTrailingNewlines equals: '123'.\r\tself assert: ('123',String cr, String lf) withoutTrailingNewlines equals: '123'."},{"name":"testFindTokensEscapedBy23","linesOfCode":5,"sourceCode":"testFindTokensEscapedBy23\r\r\t| tokens |\r\tstring := 'this, is, a, test'.\r\ttokens := string findTokens: $, escapedBy: $\".\r\tself assert: tokens size equals: 4"},{"name":"replacementCollectionSameSize","linesOfCode":3,"sourceCode":"replacementCollectionSameSize\r\t\"Return a collection of size (secondIndex - firstIndex + 1)\"\r\t\r\t^nonEmpty1element "},{"name":"testFindTokensEscapedBy24","linesOfCode":6,"sourceCode":"testFindTokensEscapedBy24\r\r\t| tokens |\r\tstring := 'this, is, a\",\" test'.\r\ttokens := string findTokens: $, escapedBy: $\".\r\tself assert: tokens size equals: 3.\r\tself assert: tokens third equals: ' a, test'"},{"name":"testWithSeparatorsCompacted","linesOfCode":13,"sourceCode":"testWithSeparatorsCompacted\r\t#( \r\t\t'foo' 'foo'\r\t\t'foo bar' 'foo bar'\r\t\t'' ''\r\t\t' ' ' '\r\t\t'foo  bar  !' 'foo bar !'\r\t\t' foo  bar  ! ' ' foo bar ! '\r\t\t'  foo  bar  !  ' ' foo bar ! '\r\t\t'\t\ttabs\t\ttabs\t!\t\t' ' tabs tabs ! '\r\t\t'space followed by tab \t!' 'space followed by tab !'\r\t) pairsDo: [ :input :output |\r\t\tself assert: input withSeparatorsCompacted equals: output ]\r\t"},{"name":"testAllRangesOfSubstring","linesOfCode":4,"sourceCode":"testAllRangesOfSubstring\r\r\tself assert: ('aabbccbb' allRangesOfSubstring: 'bb' ) equals: {(3 to: 4). (7 to: 8)}.\r\tself assert: ('           ' allRangesOfSubstring: '  ') equals: {(11 to: 15)}.\r\tself assert: ('test' allRangesOfSubstring: '') equals: #()"},{"name":"testMatch","linesOfCode":5,"sourceCode":"testMatch\r\r\t#('**' 'f**'  'f**o' 'f*' '*f*' 'f#*' 'f##' '*oo' '#oo' '*o*' '#o#' '#o*' '*o#' 'fo*' 'fo#' '*foo*' '###' '*#'  'f*#' 'f*#o')\r\t\tdo: [ :each | self assert: (each match: 'foo') ].\r\t#('bar' 'foo#' '#foo' '*foo#' '#foo*' '*bar*') do: [ :each |\r\t\tself deny: (each match: 'foo') ]"},{"name":"testFindStringStartingAt","linesOfCode":7,"sourceCode":"testFindStringStartingAt\r\r\tself assert: ('' findString: '' startingAt: 1) equals: 0.\r\tself assert: ('' findString: '' startingAt: 10) equals: 0.\r\tself assert: ('' findString: '' startingAt: 5) equals: 7.\r\tself assert: ('salkjsdlkgfee' findString: 'lke' startingAt: 1) equals: 0.\r\tself assert: ('salkjsdlkgfee' findString: 'ee'startingAt: 3) equals: 12.\r\tself assert: (' ' findString: '' startingAt: 1) equals: 0"},{"name":"testExpandMacros","linesOfCode":11,"sourceCode":"testExpandMacros\r\r\tself\r\t\tassert: '<t><n><r><l>' expandMacros\r\t\tequals:\r\t\t\t(String\r\t\t\t\tstreamContents: [ :stream | \r\t\t\t\t\tstream\r\t\t\t\t\t\tnextPut: Character tab;\r\t\t\t\t\t\tnextPutAll: OSPlatform current lineEnding;\r\t\t\t\t\t\tnextPut: Character cr;\r\t\t\t\t\t\tnextPut: Character lf ])"},{"name":"testWithoutLeadingDigits","linesOfCode":12,"sourceCode":"testWithoutLeadingDigits\r\t#( \r\t\t'foo' 'foo'\r\t\t'123foo' 'foo'\r\t\t'123 bar7' 'bar7'\r\t\t' 123 \tbar7' 'bar7'\r\t\t'foo.123.txt' 'foo.123.txt'\r\t\t'' ''\r\t\t'1' ''\r\t\t'1 2 3 ' ''\r\t) pairsDo: [ :input :output |\r\t\tself assert: input withoutLeadingDigits equals: output ]\r\t"},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\t\"Return a collection including at least 4 elements\"\r\r\t^ nonEmpty5ElementsSorted"},{"name":"testEndsWith","linesOfCode":8,"sourceCode":"testEndsWith \r\r\tself deny: ('' endsWith: 'ia').\r\tself deny: ('' endsWith: '').\r\tself assert: ('' endsWith: '').\r\tself deny: ('test' endsWith: 'ST').\r\tself assert: ('test' endsWith: 'st').\r\tself deny: ('' endsWith: '').\r\tself deny: ('test' endsWith: 'tester').\r"},{"name":"setUp","linesOfCode":15,"sourceCode":"setUp\r\tsuper setUp.\r\tstring := 'Hi, I am a String'.\r\temptyString := ''.\r\tsubcollection3ElementsSorted := 'bcd'.\r\tnonEmpty5ElementsSorted := 'a' , subcollection3ElementsSorted , 'e'.\r\tunsortedCollection := 'azsbe' copy.\r\tindexInNonEmptyArray := #(1 3 2 ).\r\tarrayWithCharacters := #($a $b $c ).\r\tnonEmpty1element := 'a'.\r\twithoutEqualElements := 'abcde'.\r\t\r\tsameAtEndAndBegining := 'abca'.\r\telementInNonEmpty := $c.\r\tcollectionNotIncluded := notIn asString , notIn asString.\r\tnotIn := $z"},{"name":"oldSubCollection","linesOfCode":5,"sourceCode":"oldSubCollection\r\t\"Return a subCollection included in collectionWith1TimeSubcollection.\r\t\tExample:  subCollection := #( 2 3 4) and collectionWith1TimeSubcollection := #(1 2 3 4 5)\"\r\t\t\r\t^ subcollection3ElementsSorted  "},{"name":"testCaseSensitiveLessOrEqual","linesOfCode":6,"sourceCode":"testCaseSensitiveLessOrEqual\r\r\tself assert: ('EEA' caseSensitiveLessOrEqual: 'fgh').\r\tself deny: ('' caseSensitiveLessOrEqual: ''). \r\tself assert: ('' caseSensitiveLessOrEqual: '').\r\tself assert: ('' caseSensitiveLessOrEqual: '').\r\tself assert: ('eea' caseSensitiveLessOrEqual: '')"},{"name":"testOccursInWithEmptyCaseSensitive","linesOfCode":6,"sourceCode":"testOccursInWithEmptyCaseSensitive\r\r\tself assert: ('abc98def' occursInWithEmpty: 'abc' caseSensitive: true). \r\tself deny: ('abc98def' occursInWithEmpty: 'Abc' caseSensitive: true). \r\tself assert: ('abc98def' occursInWithEmpty: 'Abc' caseSensitive: false).\r\tself assert: ('012  345' occursInWithEmpty: '012' caseSensitive: true).\r\tself deny: ('012 345' occursInWithEmpty: '' caseSensitive: true)\r"},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size > 1 without equal elements\"\r\t^ withoutEqualElements "},{"name":"collectionNotIncluded","linesOfCode":3,"sourceCode":"collectionNotIncluded\r\t\"Return a collection for wich each element is not included in 'nonEmpty'\"\r\r\t^ collectionNotIncluded  "}],"meta":{"name":"StringTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"WideStringTest","instanceVariables":[],"methods":[{"name":"testCompare","linesOfCode":46,"sourceCode":"testCompare\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\r\tself assert: ('abc' compare: 'abc') equals: 2.\r\tself assert: ('abc' compare: 'abd') equals: 1.\r\tself assert: ('abd' compare: 'abc') equals: 3.\r\tself assert: ('abc' compare: 'abC') equals: 2.\r\tself assert: ('abc' compare: 'abD') equals: 1.\r\tself assert: ('abd' compare: 'abC') equals: 3.\r\tself assert: ('aBc' compare: 'abC') equals: 2.\r\tself assert: ('aBc' compare: 'abD') equals: 1.\r\tself assert: ('aDd' compare: 'abC') equals: 3.\r\r\r\tself assert: ('abc' compare: 'abc' asWideString) equals: 2.\r\tself assert: ('abc' compare: 'abd' asWideString) equals: 1.\r\tself assert: ('abd' compare: 'abc' asWideString) equals: 3.\r\tself assert: ('abc' compare: 'abC' asWideString) equals: 2.\r\tself assert: ('abc' compare: 'abD' asWideString) equals: 1.\r\tself assert: ('abd' compare: 'abC' asWideString) equals: 3.\r\tself assert: ('aBc' compare: 'abC' asWideString) equals: 2.\r\tself assert: ('aBc' compare: 'abD' asWideString) equals: 1.\r\tself assert: ('aDd' compare: 'abC' asWideString) equals: 3.\r\r\tself assert: ('abc' asWideString compare: 'abc') equals: 2.\r\tself assert: ('abc' asWideString compare: 'abd') equals: 1.\r\tself assert: ('abd' asWideString compare: 'abc') equals: 3.\r\tself assert: ('abc' asWideString compare: 'abC') equals: 2.\r\tself assert: ('abc' asWideString compare: 'abD') equals: 1.\r\tself assert: ('abd' asWideString compare: 'abC') equals: 3.\r\tself assert: ('aBc' asWideString compare: 'abC') equals: 2.\r\tself assert: ('aBc' asWideString compare: 'abD') equals: 1.\r\tself assert: ('aDd' asWideString compare: 'abC') equals: 3.\r\r\tself assert: ('abc' asWideString compare: 'abc' asWideString) equals: 2.\r\tself assert: ('abc' asWideString compare: 'abd' asWideString) equals: 1.\r\tself assert: ('abd' asWideString compare: 'abc' asWideString) equals: 3.\r\tself assert: ('abc' asWideString compare: 'abC' asWideString) equals: 2.\r\tself assert: ('abc' asWideString compare: 'abD' asWideString) equals: 1.\r\tself assert: ('abd' asWideString compare: 'abC' asWideString) equals: 3.\r\tself assert: ('aBc' asWideString compare: 'abC' asWideString) equals: 2.\r\tself assert: ('aBc' asWideString compare: 'abD' asWideString) equals: 1.\r\tself assert: ('aDd' asWideString compare: 'abC' asWideString) equals: 3.\r\r\tself assert: ('abc' compare: 'abc' caseSensitive: true) equals: 2.\r\tself assert: ('abc' compare: 'abC' caseSensitive: false) equals: 2.\r\tself assert: ('abc' compare: 'abc' asWideString caseSensitive: true) equals: 2.\r\tself assert: ('abc' compare: 'abC' asWideString caseSensitive: false) equals: 2.\r\tself assert: ('abc' asWideString compare: 'abc' caseSensitive: true) equals: 2.\r\tself assert: ('abc' asWideString compare: 'abC' caseSensitive: false) equals: 2.\r\tself assert: ('abc' asWideString compare: 'abc' asWideString caseSensitive: true) equals: 2.\r\tself assert: ('abc' asWideString compare: 'abC' asWideString caseSensitive: false) equals: 2"},{"name":"testCharactersExactlyMatching","linesOfCode":11,"sourceCode":"testCharactersExactlyMatching\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\r\tself assert: ('abc' charactersExactlyMatching: 'abc') equals: 3.\r\tself assert: ('abd' charactersExactlyMatching: 'abc') equals: 2.\r\tself assert: ('abc' charactersExactlyMatching: 'abc' asWideString) equals: 3.\r\tself assert: ('abd' charactersExactlyMatching: 'abc' asWideString) equals: 2.\r\tself assert: ('abc' asWideString charactersExactlyMatching: 'abc') equals: 3.\r\tself assert: ('abd' asWideString charactersExactlyMatching: 'abc') equals: 2.\r\tself assert: ('abc' asWideString charactersExactlyMatching: 'abc' asWideString) equals: 3.\r\tself assert: ('abd' asWideString charactersExactlyMatching: 'abc' asWideString) equals: 2.\r\tself assert: ('abc' charactersExactlyMatching: 'ABC') equals: 0"},{"name":"testAtPut","linesOfCode":5,"sourceCode":"testAtPut\r\t\"Non regression test for http://bugs.squeak.org/view.php?id=6998\"\r\t\r\t| w1 |\r\tw1 := WideString with: (Unicode value: 402) with: $a with: (Unicode value: 400) with: $b.\r\tself assert: (w1 at: 2 put: $b) = $b description: 'at:put: should return the put-object'\r"},{"name":"testBeginsWith","linesOfCode":13,"sourceCode":"testBeginsWith\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\t\r\t| w1 w2 |\r\tself assert: ('abc' beginsWith: 'ab').\r\tself assert: ('abc' beginsWith: 'ab' asWideString).\r\tself assert: ('abc' asWideString beginsWith: 'ab').\r\tself assert: ('abc' beginsWith: 'aX') not .\r\tself assert: ('abc' beginsWith: 'AB') not.\r\tself assert: ('abc' beginsWith: 'AB' asWideString) not .\r\tself assert: ('ABC' asWideString beginsWith: 'ab') not.\r\r\tw1 := WideString with: (Unicode value: 402) with: $a with: (Unicode value: 400) with: $b.\r\tw2 := WideString with: (Unicode value: 402).\r\tw1 beginsWith: w2.\r"},{"name":"testMatch","linesOfCode":18,"sourceCode":"testMatch\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\t\r\tself assert: ('*baz' match: 'mobaz' ).\r\tself assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' ).\r\tself assert: ('*baz' match: 'mobaz' ).\r\tself assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' ).\r\t\r\tself assert: ('*baz' match: 'mobaz' asWideString).\r\tself assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' asWideString).\r\tself assert: ('*baz' match: 'mobaz' asWideString).\r\tself assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' asWideString).\r\t\r\tself assert: ('*baz' asWideString match: 'mobaz' ).\r\tself assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' ).\r\tself assert: ('*baz' asWideString match: 'mobaz' ).\r\tself assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' ).\r\t\r\tself assert: ('*baz' asWideString match: 'mobaz' asWideString).\r\tself assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' asWideString).\r\tself assert: ('*baz' asWideString match: 'mobaz' asWideString).\r\tself assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' asWideString)."},{"name":"testAsInteger","linesOfCode":16,"sourceCode":"testAsInteger\r\tself assert: '1796exportFixes-tkMX' asWideString asInteger equals: 1796.\r\tself assert: 'donald' asWideString asInteger isNil.\r\tself assert: 'abc234def567' asWideString asInteger equals: 234.\r\tself assert: '-94' asWideString asInteger equals: -94.\r\tself assert: 'foo-bar-92' asWideString asInteger equals: -92.\r\r\tself assert: '1796exportFixes-tkMX' asWideString asSignedInteger equals: 1796.\r\tself assert: 'donald' asWideString asSignedInteger isNil.\r\tself assert: 'abc234def567' asWideString asSignedInteger equals: 234.\r\tself assert: '-94' asWideString asSignedInteger equals: -94.\r\tself assert: 'foo-bar-92' asWideString asSignedInteger equals: -92.\r\r\tself assert: '1796exportFixes-tkMX' asWideString asUnsignedInteger equals: 1796.\r\tself assert: 'donald' asWideString asUnsignedInteger isNil.\r\tself assert: 'abc234def567' asWideString asUnsignedInteger equals: 234.\r\tself assert: '-94' asWideString asUnsignedInteger equals: 94.\r\tself assert: 'foo-bar-92' asWideString asUnsignedInteger equals: 92"},{"name":"testRelationOrder","linesOfCode":26,"sourceCode":"testRelationOrder\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\r\tself assert: ('aa' < 'ab').\r\tself assert: ('aa' <= 'ab').\r\tself assert: ('aa' <= 'aa').\r\tself assert: ('ab' > 'aa').\r\tself assert: ('ab' >= 'aa').\r\tself assert: ('aa' >= 'aa').\r\t\r\tself assert: ('aa' < 'ab' asWideString).\r\tself assert: ('aa' <= 'ab' asWideString).\r\tself assert: ('aa' <= 'aa' asWideString).\r\tself assert: ('ab' > 'aa' asWideString).\r\tself assert: ('ab' >= 'aa' asWideString).\r\tself assert: ('aa' >= 'aa' asWideString).\r\t\r\tself assert: ('aa' asWideString < 'ab').\r\tself assert: ('aa' asWideString <= 'ab').\r\tself assert: ('aa' asWideString <= 'aa').\r\tself assert: ('ab' asWideString > 'aa').\r\tself assert: ('ab' asWideString >= 'aa').\r\tself assert: ('aa' asWideString >= 'aa').\r\t\r\tself assert: ('aa' asWideString< 'ab' asWideString).\r\tself assert: ('aa' asWideString<= 'ab' asWideString).\r\tself assert: ('aa' asWideString<= 'aa' asWideString).\r\tself assert: ('ab' asWideString> 'aa' asWideString).\r\tself assert: ('ab' asWideString >= 'aa' asWideString).\r\tself assert: ('aa' asWideString>= 'aa' asWideString)."},{"name":"testSameAs","linesOfCode":6,"sourceCode":"testSameAs\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\r\tself assert: ('abc' sameAs: 'aBc' asWideString).\r\tself assert: ('aBc' asWideString sameAs: 'abc').\r\tself assert: ( #[97 0 0 0] asString sameAs: 'Abcd' asWideString) not.\r\tself assert: ('a000' asWideString sameAs:  #[97 0 0 0] asString) not.\r\t"},{"name":"testEqual","linesOfCode":12,"sourceCode":"testEqual\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\r\tself assert: 'abc' equals: 'abc'.\r\tself assert: 'abc' equals: 'abc' asWideString.\r\tself assert: 'abc' asWideString equals: 'abc'.\r\tself assert: 'abc' asWideString equals: 'abc' asWideString.\r\tself assert: ('abc' = 'ABC') not.\r\tself assert: ('abc' = 'ABC' asWideString) not.\r\tself assert: ('abc' asWideString = 'ABC') not.\r\tself assert: 'abc' asWideString equals: 'abc' asWideString.\r\tself assert: #[97 0 0 0] asString ~= 'a000' asWideString.\r\tself assert: 'a000' asWideString ~= #[97 0 0 0] asString"},{"name":"testFindSubstring","linesOfCode":16,"sourceCode":"testFindSubstring\r\t\"This is related to http://bugs.squeak.org/view.php?id=6366\r\tfinding substring in a WideString was broken because matchTable are byte-wise\"\r\r\t| ws1 ws2 |\r\tself assert: ('abcd' findString: 'bc' startingAt: 1) equals: 2.\r\tself assert: ('abcd' asWideString findString: 'bc' startingAt: 1) equals: 2.\r\tself assert: ('abcd' findString: 'bc' asWideString startingAt: 1) equals: 2.\r\tself assert: ('abcd' asWideString findString: 'bc' asWideString startingAt: 1) equals: 2.\r\r\tws1 := 'A' , (WideString with: (Unicode value: 530)) , 'BCD'.\r\tself assert: (ws1 findString: 'bc' startingAt: 1 caseSensitive: true) equals: 0.\r\tself assert: (ws1 findString: 'bc' startingAt: 1 caseSensitive: false) equals: 3.\r\r\tws2 := (WideString with: (Unicode value: 530)) , 'b'.\r\tself assert: (ws1 findString: ws2 startingAt: 1 caseSensitive: true) equals: 0.\r\tself assert: (ws1 findString: ws2 startingAt: 1 caseSensitive: false) equals: 2.\r\r\tself assert: ('abc' findString: ws2 startingAt: 1 caseSensitive: true) equals: 0.\r\tself assert: ('abc' findString: ws2 startingAt: 1 caseSensitive: false) equals: 0"},{"name":"testSubstrings","linesOfCode":12,"sourceCode":"testSubstrings\r\t\"this is related to http://bugs.squeak.org/view.php?id=6367\"\r\r\t| w1 w2 |\r\tw1 := WideString\r\t\twith: 401 asCharacter\r\t\twith: $a\r\t\twith: 402 asCharacter\r\t\twith: $b.\r\tw2 := WideString with: 403 asCharacter with: 404 asCharacter.\r\r\tself assert: w1 substrings first equals: w1.\r\tself assert: (w1 , ' ' , w2) substrings size equals: 2.\r\tself assert: (w1 , ' ' , w2) substrings last equals: w2"},{"name":"testIsAsciiString","linesOfCode":5,"sourceCode":"testIsAsciiString\r\t\"Non-regression for https://pharo.manuscript.com/f/cases/15232 \"\r\r\tself assert: '' asWideString isAsciiString equals: true.\r\tself assert: 'abcdefGHIJKL 98765,./@#%$' asWideString isAsciiString equals: true.\r\r\tself assert: '' asWideString isAsciiString equals: false"},{"name":"testEndsWith","linesOfCode":9,"sourceCode":"testEndsWith\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\t\r\tself assert: ('abc' endsWith: 'bc').\r\tself assert: ('abc' endsWith: 'bc' asWideString).\r\tself assert: ('abc' asWideString endsWith: 'bc').\r\tself assert: ('abc' endsWith: 'bX') not .\r\tself assert: ('abc' endsWith: 'BC') not.\r\tself assert: ('abc' endsWith: 'BC' asWideString) not .\r\tself assert: ('ABC' asWideString endsWith: 'bc') not.\r\r"},{"name":"testRelationOrderWithCase","linesOfCode":25,"sourceCode":"testRelationOrderWithCase\r\t\"from johnmci at http://bugs.squeak.org/view.php?id=5331\"\r\t\t\r\tself assert: ('ABC' caseInsensitiveLessOrEqual: 'abc').\r\tself assert: ('ABC' caseInsensitiveLessOrEqual: 'abd').\r\tself assert: ('ABD' caseInsensitiveLessOrEqual: 'abc') not.\r\tself assert: ('ABC' caseInsensitiveLessOrEqual: 'abc' asWideString).\r\tself assert: ('ABC' caseInsensitiveLessOrEqual: 'abd' asWideString).\r\tself assert: ('ABD' caseInsensitiveLessOrEqual: 'abc' asWideString) not.\r\tself assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abc').\r\tself assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abd').\r\tself assert: ('ABD' asWideString caseInsensitiveLessOrEqual: 'abc') not.\r\tself assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abc' asWideString).\r\tself assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abd' asWideString).\r\tself assert: ('ABD' asWideString caseInsensitiveLessOrEqual: 'abc' asWideString) not.\r\t\r\t\r\tself assert: ('abc' caseSensitiveLessOrEqual: 'abc').\r\tself assert: ('abc' caseSensitiveLessOrEqual: 'abd').\r\tself assert: ('abd' caseSensitiveLessOrEqual: 'abc') not.\r\tself assert: ('abc' caseSensitiveLessOrEqual: 'abc' asWideString).\r\tself assert: ('abc' caseSensitiveLessOrEqual: 'abd' asWideString).\r\tself assert: ('abd' caseSensitiveLessOrEqual: 'abc' asWideString) not.\r\tself assert: ('abc' asWideString caseSensitiveLessOrEqual: 'abc').\r\tself assert: ('abc' asWideString caseSensitiveLessOrEqual: 'abd').\r\tself assert: ('abd' asWideString caseSensitiveLessOrEqual: 'abc') not.\r\tself assert: ('abc' caseSensitiveLessOrEqual: 'ABC') not.\r\t"},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^  WideString"}],"meta":{"name":"WideStringTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SymbolTest","instanceVariables":[{"name":"emptySymbol"},{"name":"nonEmptySymbol5ElementsNoDuplicates"},{"name":"notIn"},{"name":"collectionNotIncluded"},{"name":"collectionSize4"},{"name":"collection1Element"},{"name":"sameAtEndAndBegining"},{"name":"with2timeSubcollection"},{"name":"subcollection3ElementsSorted"}],"methods":[{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\" return a collection that don't includes equal elements'\" \r\t^nonEmptySymbol5ElementsNoDuplicates "},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\" return an element included exactly two time in # collectionWithEqualElements\"\r^ sameAtEndAndBegining first"},{"name":"testCopyNotSame","linesOfCode":5,"sourceCode":"testCopyNotSame\r\t\"There is only one symbol, the copy is the same\"\r\r\t| copy |\r\tcopy := self nonEmpty copy.\r\tself assert: copy identicalTo: self nonEmpty"},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\" return a collection  including equal elements (classic equality)\"\r\t^ sameAtEndAndBegining "},{"name":"testNumArgsBinary","linesOfCode":12,"sourceCode":"testNumArgsBinary\r\tself assert: '-' numArgs equals: 1.\r\tself assert: '++' numArgs equals: 1.\r\tself assert: '*&@' numArgs equals: 1.\r\r\tself assert: ' ++' numArgs equals: -1.\r\tself assert: '+ +' numArgs equals: -1.\r\tself assert: '++ ' numArgs equals: -1.\r\r\tself assert: '_++' numArgs equals: -1.\r\tself assert: '+_+' numArgs equals: -1.\r\tself assert: '++_' numArgs equals: -1.\r\r\tself assert: '1' numArgs equals: -1.\r\tself assert: '*a' numArgs equals: -1"},{"name":"testAsClassIfPresent","linesOfCode":4,"sourceCode":"testAsClassIfPresent\r\t\r\t#Symbol asClassIfPresent: [ :class | \r\t\tself assert: class equals: Symbol ].\r\t\r\t#'+' asClassIfPresent: [ ^ self fail ]."},{"name":"subCollectionNotIn","linesOfCode":3,"sourceCode":"subCollectionNotIn\r\" return a collection for which at least one element is not included in 'moreThan4Elements' \"\r\t^ collectionNotIncluded "},{"name":"collectionWithElementsToRemove","linesOfCode":3,"sourceCode":"collectionWithElementsToRemove\r\" return a collection of elements included in 'nonEmpty'  \"\r\t^ subcollection3ElementsSorted  "},{"name":"testAsMutator","linesOfCode":5,"sourceCode":"testAsMutator\r\tself assert: #x asMutator equals: #x:.\r\t\"return receiver if it is already a mutator\"\r\tself assert: #x: asMutator equals: #x:.\r\tself assert: #x asMutator isSymbol"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\t\" return a collection only including elements that can be sorted (understanding '<' )\"\r\t^ nonEmptySymbol5ElementsNoDuplicates ."},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\" return an index between 'collectionWithoutEqualsElements'  bounds\"\r\t^ 2"},{"name":"testCapitalized","linesOfCode":6,"sourceCode":"testCapitalized\r\t| uc lc |\r\tuc := #MElViN.\r\tlc := #mElViN.\r\tself assert: lc capitalized equals: uc.\r\tself assert: uc capitalized equals: uc"},{"name":"testReadFrom","linesOfCode":2,"sourceCode":"testReadFrom\r\tself expectedBehavior do: [ :association | self assert: association key value identicalTo: association value ]"},{"name":"collectionWithEqualElements","linesOfCode":3,"sourceCode":"collectionWithEqualElements\r\" return a collecition including atLeast two elements equal\"\r\r^ sameAtEndAndBegining ."},{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self collection anyOne"},{"name":"elementNotInForOccurrences","linesOfCode":2,"sourceCode":"elementNotInForOccurrences\r\t^ notIn "},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^ 2"},{"name":"collectionWith2TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith2TimeSubcollection\r\" return a collection including 'oldSubCollection'  two or many time \"\r\t^ with2timeSubcollection "},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\"return an element not included in 'nonEmpty' \"\r\r\t^ notIn "},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^collection1Element "},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\" return an element not included in 'moreThan4Elements' \"\r\t^ notIn "},{"name":"elementInForIndexAccessing","linesOfCode":3,"sourceCode":"elementInForIndexAccessing\r\" return an element included in 'collectionMoreThan1NoDuplicates' \"\r\t^ self collectionMoreThan1NoDuplicates anyOne."},{"name":"testUncapitalized","linesOfCode":6,"sourceCode":"testUncapitalized\r\t| uc lc |\r\tuc := #MElViN.\r\tlc := #mElViN.\r\tself assert: uc uncapitalized equals: lc.\r\tself assert: lc uncapitalized equals: lc"},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"elementNotInForIndexAccessing","linesOfCode":3,"sourceCode":"elementNotInForIndexAccessing\r\" return an element not included in 'collectionMoreThan1NoDuplicates' \"\r\t^ notIn "},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\t^ collectionSize4 "},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ emptySymbol "},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"testAsClass","linesOfCode":4,"sourceCode":"testAsClass\r\tself \r\t\tassert: #Symbol asClass\r\t\tequals: Symbol"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ notIn "},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\r\" return a collection not including equal elements \"\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"sizeCollection","linesOfCode":3,"sourceCode":"sizeCollection\r\t\"Answers a collection whose #size is 4\"\r\t^ collectionSize4 "},{"name":"testCopyNonEmptyWithoutAllNotIncluded","linesOfCode":1,"sourceCode":"testCopyNonEmptyWithoutAllNotIncluded\r\t"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\t^nonEmptySymbol5ElementsNoDuplicates "},{"name":"testConcatenationIsSymbol","linesOfCode":18,"sourceCode":"testConcatenationIsSymbol\r\t\"Concatenating 2 symbols results in another symbol\"\r\r\tself assert: (#foo , #bar) isSymbol.\r\tself assert: #foo , #bar identicalTo: #foobar.\r\r\t\"Concatenating the empty Symbol does not change a Symbol\"\r\tself assert: #foo , emptySymbol identicalTo: #foo.\r\tself assert: emptySymbol , #foo identicalTo: #foo.\r\r\t\"Strings and Symbols can still be mixed, the receiver determines the result type\"\r\t\"Symbol receiver gives Symbol result\"\r\tself assert: (#foo , 'bar') isSymbol.\r\tself assert: #foo , 'bar' identicalTo: #foobar.\r\t\"String receiver gives String result\"\r\tself assert: ('foo' , #bar) isString.\r\tself assert: 'foo' , #bar equals: 'foobar'.\r\t\"Strings and Symbols still compare content-wise\"\r\tself assert: 'foo' , #bar equals: #foobar.\r\t\"But Strings and Symbols are not identical\"\r\tself deny: 'foo' , #bar identicalTo: #foobar"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\" return a collection that will be used to replace 'oldSubcollection' in ' collectionWith1TimeSubcollection'  \" \r\t^ collection1Element "},{"name":"collectionWith1TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith1TimeSubcollection\r\" return a collection including 'oldSubCollection'  only one time \"\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"testNumArgsKeyword1","linesOfCode":14,"sourceCode":"testNumArgsKeyword1\r\tself assert: 'name:' numArgs equals: 1.\r\r\tself assert: 'name_:' numArgs equals: 1.\r\tself assert: '_name:' numArgs equals: 1.\r\tself assert: 'na_me:' numArgs equals: 1.\r\r\tself assert: 'name: ' numArgs equals: -1.\r\tself assert: ' name:' numArgs equals: -1.\r\tself assert: 'na me:' numArgs equals: -1.\r\r\tself assert: 'name+:' numArgs equals: -1.\r\tself assert: '+name:' numArgs equals: -1.\r\tself assert: 'na+me:' numArgs equals: -1.\r\r\tself assert: 'name123:' numArgs equals: 1.\r\tself assert: 'na123me:' numArgs equals: 1.\r\tself assert: '123name:' numArgs equals: -1"},{"name":"testNumArgs2","linesOfCode":20,"sourceCode":"testNumArgs2\r\t\"TODO: need to be extended to support shrinking and for selectors like #+ \"\r\r\tself assert: (#test numArgs: 0) equals: #test.\r\tself assert: (#test numArgs: 1) equals: #test:.\r\tself assert: (#test numArgs: 2) equals: #test:with:.\r\tself assert: (#test numArgs: 3) equals: #test:with:with:.\r\r\r\tself assert: (#test: numArgs: 0) equals: #test:.\r\tself assert: (#test: numArgs: 1) equals: #test:.\r\tself assert: (#test: numArgs: 2) equals: #test:with:.\r\tself assert: (#test: numArgs: 3) equals: #test:with:with:.\r\r\tself assert: (#test:with: numArgs: 0) equals: #test:with:.\r\tself assert: (#test:with: numArgs: 1) equals: #test:with:.\r\tself assert: (#test:with: numArgs: 2) equals: #test:with:.\r\tself assert: (#test:with: numArgs: 3) equals: #test:with:with:.\r\tself assert: (#test:with: numArgs: 4) equals: #test:with:with:with:.\r\r\tself assert: (#test:with:with: numArgs: 0) equals: #test:with:with:.\r\tself assert: (#test:with:with: numArgs: 1) equals: #test:with:with:.\r\tself assert: (#test:with:with: numArgs: 2) equals: #test:with:with:.\r\tself assert: (#test:with:with: numArgs: 3) equals: #test:with:with:.\r\tself assert: (#test:with:with: numArgs: 4) equals: #test:with:with:with:"},{"name":"testIsLiteralSymbol","linesOfCode":6,"sourceCode":"testIsLiteralSymbol\r\r\tself assert: ('*+-/\\~=<>&@%,|' allSatisfy: [:char | (Symbol with: char) isLiteralSymbol])\r\t\tdescription: 'single letter binary symbols can be printed without string quotes'.\r\t\t\r\tself assert: (#('x' 'x:' 'x:y:' 'from:to:by:' 'yourself') allSatisfy: [:str | str asSymbol isLiteralSymbol])\r\t\tdescription: 'valid ascii selector symbols can be printed without string quotes'."},{"name":"testAsClassIfAbsent","linesOfCode":7,"sourceCode":"testAsClassIfAbsent\r\r\tself \r\t\tassert: (#Symbol asClassIfAbsent: [ self fail ])\r\t\tequals: Symbol.\r\t\t\r\t#+ asClassIfAbsent: [ ^ self \"success\" ].\r\tself fail."},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals .\r(others elements of the collection are not equal to those elements)\"\r\t^ sameAtEndAndBegining "},{"name":"testNumArgsKeyword2","linesOfCode":18,"sourceCode":"testNumArgsKeyword2\r\tself assert: 'name:with:' numArgs equals: 2.\r\r\tself assert: '_name:with:' numArgs equals: 2.\r\tself assert: 'na_me:with:' numArgs equals: 2.\r\tself assert: 'name_:with:' numArgs equals: 2.\r\r\tself assert: 'name:_with:' numArgs equals: 2.\r\tself assert: 'name:wi_th:' numArgs equals: 2.\r\tself assert: 'name:with_:' numArgs equals: 2.\r\r\tself assert: 'name:with: ' numArgs equals: -1.\r\tself assert: 'name: with:' numArgs equals: -1.\r\tself assert: ' name:with:' numArgs equals: -1.\r\r\tself assert: 'name+:with:' numArgs equals: -1.\r\tself assert: '+name:with:' numArgs equals: -1.\r\tself assert: 'na+me:with:' numArgs equals: -1.\r\r\tself assert: '123name:with:' numArgs equals: -1.\r\tself assert: 'name123:with:' numArgs equals: 2.\r\tself assert: 'name:123with:' numArgs equals: -1.\r\tself assert: 'name:with123:' numArgs equals: 2"},{"name":"testNumArgsUnary","linesOfCode":14,"sourceCode":"testNumArgsUnary\r\tself assert: 'name' numArgs equals: 0.\r\r\tself assert: 'name_' numArgs equals: 0.\r\tself assert: '_name' numArgs equals: 0.\r\tself assert: 'na_me' numArgs equals: 0.\r\r\tself assert: 'name ' numArgs equals: -1.\r\tself assert: ' name' numArgs equals: -1.\r\tself assert: 'na me' numArgs equals: -1.\r\r\tself assert: 'name+' numArgs equals: -1.\r\tself assert: '+name' numArgs equals: -1.\r\tself assert: 'na+me' numArgs equals: -1.\r\r\tself assert: 'name123' numArgs equals: 0.\r\tself assert: 'na123me' numArgs equals: 0.\r\tself assert: '123name' numArgs equals: -1"},{"name":"testDisplayString","linesOfCode":4,"sourceCode":"testDisplayString\r\r\t| actual |\r\tactual := #'some symbol' displayString.\r\tself assert: actual equals: 'some symbol'"},{"name":"elementToAdd","linesOfCode":2,"sourceCode":"elementToAdd\r\t^ $u"},{"name":"testEndsWithAColon","linesOfCode":5,"sourceCode":"testEndsWithAColon\r\t \r\tself assert: #fred: endsWithAColon.\r\r\tself deny: #'fred' endsWithAColon.\r\r\tself deny: #fred endsWithAColon. "},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\" return a collection including at leat 4 elements\"\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"anotherElementNotIn","linesOfCode":2,"sourceCode":"anotherElementNotIn\r\t^ notIn "},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\" return an element inculded in 'moreThan4Elements'\"\r\t^ self moreThan4Elements anyOne"},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ Symbol"},{"name":"oldSubCollection","linesOfCode":4,"sourceCode":"oldSubCollection\r\" return a subCollection included in collectionWith1TimeSubcollection .\rex :   subCollection := #( 2 3 4) and collectionWith1TimeSubcollection := #(1 2 3 4 5)\"\r\t^ subcollection3ElementsSorted  "},{"name":"setUp","linesOfCode":11,"sourceCode":"setUp\r\tsuper setUp.\r\temptySymbol := #''.\r\tcollectionSize4 := #abcd.\r\tcollection1Element := #a.\r\tsubcollection3ElementsSorted := #bcd.\r\twith2timeSubcollection := #abcdebcda.\r\tnonEmptySymbol5ElementsNoDuplicates := #abcde.\r\tsameAtEndAndBegining := #abcda.\r\tnotIn := $z.\r\tcollectionNotIncluded := #zz."},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ Symbol"},{"name":"sortedInAscendingOrderCollection","linesOfCode":3,"sourceCode":"sortedInAscendingOrderCollection\r\t\"Return a collection sorted in ascending order\"\r\t^ collectionSize4\r\t"},{"name":"testNew","linesOfCode":2,"sourceCode":"testNew\r\t\r\tself should: [Symbol new: 5 ] raise: self defaultTestError. "},{"name":"expectedBehavior","linesOfCode":6,"sourceCode":"expectedBehavior\r\t^ { \r\t\t  ([ Symbol readFromString: '#''abc''' ] -> #abc).\r\t\t  ([ Symbol readFromString: '#ab-C' ] -> #ab).\r\t\t  ([ Symbol readFromString: '#abC' ] -> #abC).\r\t\t  ([ Symbol readFromString: '#ab@c' ] -> #ab) }"},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size > 1 without equal elements\"\r\t^ nonEmptySymbol5ElementsNoDuplicates "},{"name":"unsortedCollection","linesOfCode":3,"sourceCode":"unsortedCollection\r\" retur a collection that is not yat sorted\"\r\t^ with2timeSubcollection"},{"name":"collectionNotIncluded","linesOfCode":3,"sourceCode":"collectionNotIncluded\r\" return a collection for wich each element is not included in 'nonEmpty' \"\r\t^ collectionNotIncluded "}],"meta":{"name":"SymbolTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"CharacterTest","instanceVariables":[],"methods":[{"name":"testCodePoint","linesOfCode":4,"sourceCode":"testCodePoint\r\r\tself assert: $A codePoint equals: 65.\r\tself assert: (Character codePoint: $a codePoint) equals: $a.\r\tself assert: (Character codePoint: 97) codePoint equals: 97."},{"name":"testHex","linesOfCode":3,"sourceCode":"testHex\r\tself assert: $a hex equals: '16r61'.\r\tself assert: Character space hex equals: '16r20'"},{"name":"testInstanceCreation","linesOfCode":4,"sourceCode":"testInstanceCreation\r\tself should: [ Character value: -1 ] raise: Error.\r\tCharacter value: 0.\r\tCharacter value: 256"},{"name":"testDigitValue","linesOfCode":8,"sourceCode":"testDigitValue\r\t\t\r\t'0123456789ABCDEF' with: #(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)\r\t\tdo: [:char :value | self assert: char digitValue equals: value].\r\t\r\t'0123456789' with: #(0 1 2 3 4 5 6 7 8 9)\r\t\tdo: [:char :value | self assert: char digitValue equals: value].\r\t\t\r\t "},{"name":"testMaxVal","linesOfCode":8,"sourceCode":"testMaxVal\r\t\"Check that Character class>>maxVal is returning the correct value:\r\t- A character created with the value has the same code point\r\t- Attempting to create a character with maxVal+1 fails\"\r\r\tself assert: (Character value: Character maxVal) codePoint \r\t\t\tequals: Character maxVal.\r\tself should: [ Character value: Character maxVal + 1 ]\r\t\t\traise: PrimitiveFailed"},{"name":"testPrintString","linesOfCode":9,"sourceCode":"testPrintString\r\tself assert: $a printString equals: '$a'.\r\tself assert: $5 printString equals: '$5'.\r\tself assert: $@ printString equals: '$@'.\r\r\tself assert: Character cr printString equals: 'Character cr'.\r\tself assert: Character lf printString equals: 'Character lf'.\r\tself assert: Character space printString equals: 'Character space'.\r\r\tself assert: (Character value: 0) printString equals: 'Character null'.\r\tself assert: (Character value: 17) printString equals: 'Character value: 17'."},{"name":"testIsSeparator","linesOfCode":7,"sourceCode":"testIsSeparator\r    {Character space.\r    Character cr.\r    Character lf.\r    Character newPage.\r    Character tab} do: [ :each | self assert: each isSeparator ].\r    Character alphabet do: [ :each | self deny: each isSeparator ]"},{"name":"testAsUppercaseBasicAsciiRange","linesOfCode":6,"sourceCode":"testAsUppercaseBasicAsciiRange\r\t| lowercase uppercase |\r\tlowercase  := 'abcdefghijklmnopqrstuvwxyz123456789'.\r\tuppercase := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789'.\r\tlowercase withIndexDo: [ :char :index |\r\t\tself assert: char asUppercase equals: (uppercase at: index)]"},{"name":"testStoreString","linesOfCode":9,"sourceCode":"testStoreString\r\tself assert: $a storeString equals: '$a'.\r\tself assert: $5 storeString equals: '$5'.\r\tself assert: $@ storeString equals: '$@'.\r\r\tself assert: Character cr storeString equals: 'Character cr'.\r\tself assert: Character lf storeString equals: 'Character lf'.\r\tself assert: Character space storeString equals: 'Character space'.\r\tself assert: (Character value: 0) storeString equals: 'Character null'.\r\t\r\tself assert: (Character value: 17) storeString equals: '(Character value: 17)'."},{"name":"testPrintStringAll","linesOfCode":3,"sourceCode":"testPrintStringAll\r\tCharacter allCharacters\r\t\tdo: [ :each | self assert: (self class compiler evaluate: each printString) equals: each ]"},{"name":"testCharacterSeparators","linesOfCode":5,"sourceCode":"testCharacterSeparators\r\t\"Regression test\"\r\r\t| result |\r\tresult := '/' , Character separators.\r\tself assert: result size equals: Character separators size + 1 "},{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ Character"},{"name":"testStoreStringAll","linesOfCode":3,"sourceCode":"testStoreStringAll\r\tCharacter allCharacters\r\t\tdo: [ :each | self assert: (self class compiler evaluate: each storeString) equals: each ]"},{"name":"testAsLowercaseBasicAsciiRange","linesOfCode":6,"sourceCode":"testAsLowercaseBasicAsciiRange\r\t| lowercase uppercase |\r\tlowercase  := 'abcdefghijklmnopqrstuvwxyz123456789'.\r\tuppercase := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789'.\r\tuppercase withIndexDo: [ :char :index |\r\t\tself assert: char asLowercase equals: (lowercase at: index)]"},{"name":"testNew","linesOfCode":2,"sourceCode":"testNew\r\r\tself should: [Character new] raise: Error."},{"name":"testPrintStringHex","linesOfCode":3,"sourceCode":"testPrintStringHex\r\tself assert: $a printStringHex equals: '61'.\r\tself assert: Character space printStringHex equals: '20'"}],"meta":{"name":"CharacterTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ByteSymbolTest","instanceVariables":[],"methods":[{"name":"classToBeTested","linesOfCode":2,"sourceCode":"classToBeTested\r\t\r\t^ ByteSymbol"},{"name":"testReadFromString","linesOfCode":14,"sourceCode":"testReadFromString\r\t| str strWithPound |\r\tSmalltalk garbageCollect.\r\tstr := 'notYetExisting'.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = str ]) size equals: 0.\r\tself assert: (ByteSymbol allInstances select: [ :e | e asString = str ]) size equals: 0.\r\tstrWithPound := '#' , str.\r\tByteSymbol readFromString: strWithPound.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = str ]) size equals: 1.\r\tself assert: (ByteSymbol allInstances select: [ :e | e = str ]) size equals: 1.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = str ]) equals: (ByteSymbol allInstances select: [ :e | e = str ]).\r\tByteSymbol readFromString: strWithPound.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = str ]) size equals: 1.\r\tself assert: (ByteSymbol allInstances select: [ :e | e = str ]) size equals: 1"},{"name":"testNew","linesOfCode":2,"sourceCode":"testNew\r\t\r\tself should: [ByteSymbol new: 5 ] raise: self defaultTestError. "},{"name":"testNewFrom","linesOfCode":10,"sourceCode":"testNewFrom\r\t| dt |\r\tdt := DateAndTime now asString.\r\tByteSymbol newFrom: dt.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = dt ]) size equals: 1.\r\tself assert: (ByteSymbol allInstances select: [ :e | e = dt ]) size equals: 1.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = dt ]) equals: (ByteSymbol allInstances select: [ :e | e = dt ]).\r\tByteSymbol newFrom: dt.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = dt ]) size equals: 1.\r\tself assert: (ByteSymbol allInstances select: [ :e | e = dt ]) size equals: 1"},{"name":"testAs","linesOfCode":10,"sourceCode":"testAs\r\t| tStr |\r\ttStr := DateAndTime now asString.\r\ttStr as: ByteSymbol.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = tStr ]) size equals: 1.\r\tself assert: (ByteSymbol allInstances select: [ :e | e asString = tStr ]) size equals: 1.\r\tself assert: (ByteSymbol allInstances select: [ :e | e asString = tStr ]) equals: (Symbol allSymbols select: [ :e | e asString = tStr ]).\r\ttStr as: ByteSymbol.\r\tself assert: (Symbol allSymbols select: [ :e | e asString = tStr ]) size equals: 1.\r\tself assert: (ByteSymbol allInstances select: [ :e | e asString = tStr ]) size equals: 1"}],"meta":{"name":"ByteSymbolTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"StringInitializationTest","instanceVariables":[],"methods":[{"name":"testCaseInsensitiveOrder","linesOfCode":4,"sourceCode":"testCaseInsensitiveOrder\r\tself\r\t\tassert: String newCaseInsensitiveOrder\r\t\tequals:  #[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 247 216 217 218 219 220 221 222 255]"},{"name":"testLowercasingTable","linesOfCode":4,"sourceCode":"testLowercasingTable\r\tself\r\t\tassert: (String newLowercasingTable collect: #codePoint as: Array)\r\t\tequals:   #(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 215 248 249 250 251 252 253 254 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255)"},{"name":"testCSLineEnders","linesOfCode":4,"sourceCode":"testCSLineEnders\r\tself\r\t\tassert: String newCSLineEnders asArray\r\t\tequals: { Character lf . Character cr }"},{"name":"testTokenish","linesOfCode":4,"sourceCode":"testTokenish\r\tself\r\t\tassert: (String newTokenish collect: #codePoint as: Array)\r\t\tequals:  #(126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 48 49 50 51 52 53 54 55 56 57 58 126 126 126 126 126 126 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 126 126 126 126 95 126 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 126 170 126 126 126 126 126 126 126 126 126 126 181 126 126 126 126 186 126 126 126 126 126 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 126 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 126 248 249 250 251 252 253 254 255)"},{"name":"testAsciiOrder","linesOfCode":4,"sourceCode":"testAsciiOrder\r\tself\r\t\tassert: String newAsciiOrder\r\t\tequals: #[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255]"},{"name":"testUppercasingTable","linesOfCode":4,"sourceCode":"testUppercasingTable\r\tself\r\t\tassert: (String newUppercasingTable collect: #codePoint as: Array)\r\t\tequals: #(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 924 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 7838 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 247 216 217 218 219 220 221 222 376)"}],"meta":{"name":"StringInitializationTest class","instanceVariables":[],"methods":[],"meta":null}},{"name":"StringLineEndingsTest","instanceVariables":[{"name":"targetLineEnding"},{"name":"originLineEnding"},{"name":"testingSubjectWithTargetLineEnding"},{"name":"testingSubjectWithOriginLineEnding"},{"name":"templateString"}],"methods":[{"name":"templateString:","linesOfCode":2,"sourceCode":"templateString: aString\r\ttemplateString := aString"},{"name":"originLineEnding:","linesOfCode":2,"sourceCode":"originLineEnding: aString \r\toriginLineEnding := aString"},{"name":"newTestingSubject","linesOfCode":2,"sourceCode":"newTestingSubject\r\t^ templateString format: {originLineEnding}"},{"name":"setUp","linesOfCode":4,"sourceCode":"setUp\r\t\r\tsuper setUp.\r\ttestingSubjectWithOriginLineEnding := self newTestingSubject. \r\ttestingSubjectWithTargetLineEnding := testingSubjectWithOriginLineEnding withLineEndings: targetLineEnding."},{"name":"targetLineEnding:","linesOfCode":2,"sourceCode":"targetLineEnding: aString \r\ttargetLineEnding := aString"},{"name":"testTargetLineEndingStringWithoutOriginLineEnding","linesOfCode":6,"sourceCode":"testTargetLineEndingStringWithoutOriginLineEnding\r\tself\r\t\tassert:\r\t\t\t((targetLineEnding includesSubstring: originLineEnding) \r\t\t\t\txor: [ (testingSubjectWithTargetLineEnding\r\t\t\t\t\t\tincludesSubstring: originLineEnding) not ])"},{"name":"testLineEndinglessStringShouldBeEquals","linesOfCode":7,"sourceCode":"testLineEndinglessStringShouldBeEquals\r\t| originWithoutLineEnding targetWithoutLineEnding |\r\toriginWithoutLineEnding := testingSubjectWithOriginLineEnding\r\t\tcopyReplaceAll: originLineEnding with: ''.\r\ttargetWithoutLineEnding := testingSubjectWithTargetLineEnding\r\t\tcopyReplaceAll: targetLineEnding with: ''.\r\tself assert: originWithoutLineEnding equals: targetWithoutLineEnding"},{"name":"testOriginStringCanBeProducedFromTargetStringAndOriginalLineEnding","linesOfCode":5,"sourceCode":"testOriginStringCanBeProducedFromTargetStringAndOriginalLineEnding\r\t\r\t\" This test is for testing that we can tranform a string with certain line ending to a another line ending, and then transform it back to the original line ending. \"\r\t\r\t| testingSubjectWithTargetLineEndingTransformedWithOriginalLineEnding |\r\ttestingSubjectWithTargetLineEndingTransformedWithOriginalLineEnding := testingSubjectWithTargetLineEnding withLineEndings: originLineEnding .\r\tself assert: testingSubjectWithTargetLineEndingTransformedWithOriginalLineEnding equals: testingSubjectWithOriginLineEnding \r\t\r\t"}],"meta":{"name":"StringLineEndingsTest class","instanceVariables":[],"methods":[{"name":"testParameters","linesOfCode":17,"sourceCode":"testParameters\r\t^ ParametrizedTestMatrix new\r\t\tforSelector: #targetLineEnding\r\t\t\taddOptions:\r\t\t\t{String cr.\r\t\t\tString lf.\r\t\t\tString crlf};\r\t\tforSelector: #originLineEnding\r\t\t\taddOptions:\r\t\t\t{String cr.\r\t\t\tString lf.\r\t\t\tString crlf};\r\t\tforSelector: #templateString\r\t\t\taddOptions:\r\t\t\t{'I am a String{1}' . '{1}I am a String' . 'I am a{1}String'.\r\t\t\t'{1}I am{1}a String{1}'};\r\t\tyourself"}],"meta":null}}]},{"name":"Collections-Stack","classes":[{"name":"Stack","instanceVariables":[],"methods":[{"name":"top","linesOfCode":3,"sourceCode":"top\r\t\"Answer the first element of the stack without removing it.\"\r\t\r\t^ self first"},{"name":"push:","linesOfCode":4,"sourceCode":"push: anObject \r\t\"Adds a new object of any kind on top of the stack.\"\r\t\r\tself addFirst: anObject.\r\t^ anObject"},{"name":"pop","linesOfCode":3,"sourceCode":"pop\r\t\"Returns the first element and remove it from the stack.\"\r\r\t^self removeFirst "}],"meta":{"name":"Stack class","instanceVariables":[],"methods":[],"meta":null}},{"name":"ManifestCollectionsStack","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsStack class","instanceVariables":[],"methods":[{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Sequenceable')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Stack'"}],"meta":null}}]},{"name":"Collections-Sequenceable","classes":[{"name":"LinkedList","instanceVariables":[{"name":"firstLink"},{"name":"lastLink"}],"methods":[{"name":"select:","linesOfCode":9,"sourceCode":"select: aBlock \r\t\"Reimplemennt #select: for speedup on linked lists. \r\tThe super implemention accesses the linkes by index, thus causing an O(n^2)\"\r\t\r\t| newCollection |\r\tnewCollection := self class new.\r\tself do: [ :each | \r\t\t(aBlock value: each) \r\t\t\tifTrue: [ newCollection add: each ]].\r\t^newCollection"},{"name":"copyWith:","linesOfCode":2,"sourceCode":"copyWith: newElement\r\t^self copy add: newElement; yourself"},{"name":"isEmpty","linesOfCode":2,"sourceCode":"isEmpty\r\r\t^firstLink isNil"},{"name":"linkAt:ifAbsent:","linesOfCode":6,"sourceCode":"linkAt: index ifAbsent: errorBlock\r\r\t| i |\r\ti := 0.\r\tself linksDo: [:link |\r\t\t(i := i + 1) = index ifTrue: [^ link]].\r\t^ errorBlock value"},{"name":"linksDo:","linesOfCode":7,"sourceCode":"linksDo: aBlock\r\r\t| aLink |\r\taLink := firstLink.\r\t[aLink == nil ] whileFalse:\r\t\t[\r\t\taBlock value: aLink.\r\t\taLink := aLink nextLink]"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: index put: anObject\r\r\t^self at: index putLink: (self linkOf: anObject ifAbsent: [anObject asLink])"},{"name":"reject:thenCollect:","linesOfCode":9,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r\t\"Optimized version of SequenceableCollection>>#reject:thenCollect:\"\r\r\t| newCollection |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\t(rejectBlock value: each)\r\t\t\t\tifFalse: [ newCollection add: (collectBlock value: each) ] ].\r\t^ newCollection"},{"name":"swap:with:","linesOfCode":25,"sourceCode":"swap: ix1 with: ix2\r\t\"Reimplemented, super would create an infinite loop\"\r\t| minIx maxIx link1Prev link2Prev link1 link2 link1Next link2Next newLink2Next |\r\t((self validIndex: ix1) and: [self validIndex: ix2])\tifFalse: [^ self errorOutOfBounds].\r\t\r\t\"Get edge case out of the way\"\r\tix1 = ix2 ifTrue: [^ self ].\r\t\r\t\"Sort indexes to make boundary-checks easier\" \r\tminIx := ix1 min: ix2.\r\tmaxIx := ix2 max: ix1.\r\t\r\tlink1Prev := (minIx = 1) ifFalse: [self linkAt: minIx -1].\r\tlink1 := link1Prev ifNotNil: [ link1Prev nextLink]\r\t\t\t\tifNil: [self linkAt: minIx].\r\tlink1Next := link1 nextLink.\r\tlink2Prev := self linkAt: maxIx -1.\r\tlink2 := link2Prev nextLink.\r\tlink2Next := link2 nextLink.\r\t\r\t\"Link at start being swapped\"\r\tlink1 = firstLink ifTrue: [firstLink := link2.] ifFalse: [link1Prev nextLink: link2].\r\t\"Link at end being swapped\"\r\tlink2 = lastLink ifTrue: [lastLink := link1] ifFalse: [].\r\t\"Links  being swapped adjacent\"\r\tnewLink2Next := (link1 nextLink = link2) ifTrue: [link1] ifFalse: [link2Prev nextLink: link1.\r\t\tlink1Next].\r\tlink1 nextLink: link2Next.\r\tlink2 nextLink: newLink2Next.\r\t"},{"name":"add:","linesOfCode":3,"sourceCode":"add: aLinkOrObject\r\t\"Add aLink to the end of the receiver's list. Answer aLink.\"\r\r\t^self addLast: aLinkOrObject"},{"name":"removeLink:ifAbsent:","linesOfCode":18,"sourceCode":"removeLink: aLink ifAbsent: aBlock  \r\t\"Remove aLink from the receiver. If it is not there, answer the result of\r\tevaluating aBlock.\"\r\r\t| tempLink |\r\taLink == firstLink\r\t\tifTrue: [firstLink := aLink nextLink.\r\t\t\t\taLink == lastLink\r\t\t\t\t\tifTrue: [lastLink := nil]]\r\t\tifFalse: [tempLink := firstLink.\r\t\t\t\t[tempLink == nil ifTrue: [^aBlock value].\r\t\t\t\t tempLink nextLink == aLink]\r\t\t\t\t\twhileFalse: [tempLink := tempLink nextLink].\r\t\t\t\ttempLink nextLink: aLink nextLink.\r\t\t\t\taLink == lastLink\r\t\t\t\t\tifTrue: [lastLink := tempLink]].\r\t\"Not nilling the link enables us to delete while iterating\"\r\t\"aLink nextLink: nil.\"\r\t^aLink"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":13,"sourceCode":"indexOf: anElement startingAt: start ifAbsent: exceptionBlock\r\t\"Answer the index of the first occurrence of anElement after start\r\twithin the receiver. If the receiver does not contain anElement, \r\tanswer the \tresult of evaluating the argument, exceptionBlock.\"\r\t\t\t\r\t|currentLink index|\t\t\r\tcurrentLink := self linkAt: start ifAbsent: [nil].\r\tindex := start.\r\t[currentLink isNil ] \r\t\twhileFalse: [currentLink value = anElement value ifTrue: [^index].\r\t\t\t\t\tcurrentLink := currentLink nextLink.\r\t\t\t\t\tindex := index +1].\r\t^exceptionBlock value"},{"name":"collect:","linesOfCode":11,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of the receiver's elements as the argument.  \r\tCollect the resulting values into a collection like the receiver. Answer  \r\tthe new collection.\"\r\r\t| aLink newCollection |\r\tnewCollection := self class new.\r\taLink := firstLink.\r\t[aLink == nil] whileFalse:\r\t\t[newCollection add: (aBlock value: aLink value).\r\t\t aLink := aLink nextLink].\r\t^ newCollection"},{"name":"last","linesOfCode":4,"sourceCode":"last\r\t\"Answer the last link. Create an error notification if the receiver is \r\tempty.\"\r\r\r\t^self lastLink value"},{"name":"firstLink","linesOfCode":5,"sourceCode":"firstLink\r\t\"Answer the first link. Create an error notification if the receiver is \r\tempty.\"\r\r\tself emptyCheck.\r\t^firstLink "},{"name":"removeAllSuchThat:","linesOfCode":4,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Evaluate aBlock for each element and remove all that elements from\r\tthe receiver for that aBlock evaluates to true.  For LinkedLists, it's safe to use do:.\"\r\r\tself do: [:each | (aBlock value: each) ifTrue: [self remove: each]]"},{"name":"postCopy","linesOfCode":7,"sourceCode":"postCopy\r\t| aLink |\r\tsuper postCopy.\r\tfirstLink ifNotNil: [\r\t\taLink := firstLink := firstLink copy.\r\t\t[aLink nextLink isNil] whileFalse: [aLink nextLink: (aLink := aLink nextLink copy)].\r\t\tlastLink := aLink]."},{"name":"reject:","linesOfCode":9,"sourceCode":"reject: rejectBlock\r\t\"Optimized version of SequenceableCollection>>#reject:\"\r\r\t| newCollection |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\t(rejectBlock value: each)\r\t\t\t\tifFalse: [ newCollection add: each ] ].\r\t^ newCollection"},{"name":"validIndex:","linesOfCode":3,"sourceCode":"validIndex: index\r\t ^index > 0\r\t\t\tand: [index <= self size]"},{"name":"at:putLink:","linesOfCode":23,"sourceCode":"at: index putLink: aLink \r\t| previousLink nextLink |\r\t\"Please don't put a link which is already in the list, or you will create an infinite loop\"\r\t(self validIndex: index)\r\t\tifFalse: [^ self errorOutOfBounds].\r\tindex = 1\r\t\tifTrue: [aLink nextLink: self firstLink nextLink.\r\t\t\tfirstLink := aLink.\r\t\t\taLink nextLink ifNil: [lastLink := aLink].\r\t\t\t^ aLink].\r\tpreviousLink := self linkAt: index - 1.\r\tnextLink := previousLink nextLink nextLink.\r\t\r\tnextLink ifNil: [\r\t\taLink nextLink: self lastLink\r\t] ifNotNil: [\r\t\taLink nextLink: nextLink.\r\t].\r\r\tpreviousLink nextLink: aLink.\r\r\tnextLink ifNil: [\r\t\tlastLink := aLink.\r\t\taLink nextLink: nil.\r\t].\r\r\t^ aLink"},{"name":"do:","linesOfCode":6,"sourceCode":"do: aBlock\r\r\t| aLink |\r\taLink := firstLink.\r\t[aLink == nil] whileFalse:\r\t\t[aBlock value: aLink value.\r\t\t aLink := aLink nextLink]"},{"name":"species","linesOfCode":2,"sourceCode":"species\r\r\t^ Array"},{"name":"remove:ifAbsent:","linesOfCode":6,"sourceCode":"remove: aLinkOrObject ifAbsent: aBlock \r\t\"Remove aLink from the receiver. If it is not there, answer the result of evaluating aBlock.\"\r\t\r\t| link |\r\tlink := self linkOf: aLinkOrObject ifAbsent: [^aBlock value].\r\tself removeLink: link ifAbsent: [^aBlock value].\r\t^aLinkOrObject"},{"name":"removeLink:","linesOfCode":2,"sourceCode":"removeLink: aLink\r\t^self removeLink: aLink ifAbsent: [self error: 'no such method!']"},{"name":"select:thenDo:","linesOfCode":6,"sourceCode":"select: selectBlock thenDo: doBlock\r\t\"Optimized version of SequenceableCollection>>#select:thenDo:\"\r\r\tself\r\t\tdo: [ :each | \r\t\t\t\t(selectBlock value: each)\r\t\t\t\t\tifTrue: [ doBlock value: each ] ]"},{"name":"add:after:","linesOfCode":5,"sourceCode":"add: link after: otherLinkOrObject\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| otherLink |\r\totherLink := self linkAt: (self indexOf: otherLinkOrObject).\r\t^ self add: link afterLink: otherLink"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\t\"Implementation note: this has to be fast\"\r\r\tfirstLink := lastLink := nil"},{"name":"size","linesOfCode":6,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t| tally |\r\ttally := 0.\r\tself do: [:each | tally := tally + 1].\r\t^ tally"},{"name":"first","linesOfCode":4,"sourceCode":"first\r\t\"Answer the first link. Create an error notification if the receiver is \r\tempty.\"\r^self firstLink value"},{"name":"add:beforeLink:","linesOfCode":15,"sourceCode":"add: aLinkOrObject beforeLink: otherLink\r\r\t| currentLink|\r\r\tfirstLink == otherLink ifTrue: [^ self addFirst: aLinkOrObject].\r\t\r\tcurrentLink := firstLink.\r\t[currentLink == nil] whileFalse: [\r\t\tcurrentLink nextLink == otherLink ifTrue: [\r\t\t\t| aLink |\r\t\t\taLink := aLinkOrObject asLink.\r\t\t\taLink nextLink: currentLink nextLink.\r\t\t\tcurrentLink nextLink: aLink.\r\t\t\t^ aLink\r\t\t].\r\t\t currentLink := currentLink nextLink.\r\t].\r\t^ self errorNotFound: otherLink"},{"name":"addFirst:","linesOfCode":8,"sourceCode":"addFirst: aLinkOrObject \r\t\"Add aLink to the beginning of the receiver's list. Answer aLink.\"\r\t|aLink|\r\taLink := aLinkOrObject asLink.\r\tself isEmpty ifTrue: [lastLink := aLink].\r\taLink nextLink: firstLink.\r\tfirstLink := aLink.\r\t^aLink"},{"name":"copyWithout:","linesOfCode":5,"sourceCode":"copyWithout: oldElement\r\t|newInst| \r\tnewInst := self class new.\r\tself do: [:each | each = oldElement ifFalse: [newInst add: each]].\r\t^newInst"},{"name":"add:before:","linesOfCode":5,"sourceCode":"add: link before: otherLinkOrObject\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| otherLink |\r\totherLink := self linkAt: (self indexOf: otherLinkOrObject).\r\t^ self add: link beforeLink: otherLink"},{"name":"removeLast","linesOfCode":15,"sourceCode":"removeLast\r\t\"Remove the receiver's last element and answer it. If the receiver is \r\tempty, create an error notification.\"\r\r\t| oldLink aLink |\r\tself emptyCheck.\r\toldLink := lastLink.\r\tfirstLink == lastLink\r\t\tifTrue: [firstLink := nil. lastLink := nil]\r\t\tifFalse: [aLink := firstLink.\r\t\t\t\t[aLink nextLink == oldLink] whileFalse:\r\t\t\t\t\t[aLink := aLink nextLink].\r\t\t\t\t aLink nextLink: nil.\r\t\t\t\t lastLink := aLink].\r\toldLink nextLink: nil.\r\t^oldLink value"},{"name":"add:afterLink:","linesOfCode":9,"sourceCode":"add: aLinkOrObject afterLink: otherLink\r\r\t\"Add otherLink  after link in the list. Answer aLink.\"\r\r\t| savedLink aLink |\r\tlastLink == otherLink ifTrue: [^ self addLast: aLinkOrObject].\r\tsavedLink := otherLink nextLink.\r\taLink := aLinkOrObject asLink.\r\totherLink nextLink: aLink.\r\taLink nextLink:  savedLink.\r\t^aLink."},{"name":"sort:","linesOfCode":6,"sourceCode":"sort: aBlock\r\t|aLinkedList|\r\tself isEmpty ifTrue: [ ^self ].\r\taLinkedList := LinkedList newFrom: (self asArray sort: aBlock).\r\tfirstLink := aLinkedList firstLink.\r\tlastLink := aLinkedList lastLink."},{"name":"collect:thenReject:","linesOfCode":10,"sourceCode":"collect: collectBlock thenReject: rejectBlock\r\t\"Optimized version of SequenceableCollection>>#collect:#thenReject:\"\r\r\t| newCollection newElement |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\tnewElement := collectBlock value: each.\r\t\t\t(rejectBlock value: newElement)\r\t\t\t\tifFalse: [ newCollection add: newElement ] ].\r\t^ newCollection"},{"name":"at:","linesOfCode":2,"sourceCode":"at: index\r\r\t^(self linkAt: index) value"},{"name":"addLast:","linesOfCode":9,"sourceCode":"addLast: aLinkOrObject\r\t\"Add aLink to the end of the receiver's list. Answer aLink.\"\r\t|aLink|\r\taLink := aLinkOrObject asLink.\r\tself isEmpty\r\t\tifTrue: [firstLink := aLink]\r\t\tifFalse: [lastLink nextLink: aLink].\r\tlastLink := aLink.\r\t^aLink"},{"name":"lastLink","linesOfCode":5,"sourceCode":"lastLink\r\t\"Answer the last link. Create an error notification if the receiver is \r\tempty.\"\r\r\tself emptyCheck.\r\t^lastLink"},{"name":"linkOf:","linesOfCode":4,"sourceCode":"linkOf: anObject \r\t^ self\r\t\tlinkOf: anObject\r\t\tifAbsent: [self error: 'No such element']"},{"name":"linkAt:","linesOfCode":2,"sourceCode":"linkAt: index\r\r\t^self linkAt: index ifAbsent: [ self errorSubscriptBounds: index]"},{"name":"removeFirst","linesOfCode":11,"sourceCode":"removeFirst\r\t\"Remove the first element and answer it. If the receiver is empty, create \r\tan error notification.\"\r\r\t| oldLink |\r\tself emptyCheck.\r\toldLink := firstLink.\r\tfirstLink == lastLink\r\t\tifTrue: [firstLink := nil. lastLink := nil]\r\t\tifFalse: [firstLink := oldLink nextLink].\r\toldLink nextLink: nil.\r\t^oldLink value"},{"name":"collect:thenSelect:","linesOfCode":10,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r\t\"Optimized version of SequenceableCollection>>#collect:#thenSelect:\"\r\r\t| newCollection newElement |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\tnewElement := collectBlock value: each.\r\t\t\t(selectBlock value: newElement)\r\t\t\t\tifTrue: [ newCollection add: newElement ] ].\r\t^ newCollection"},{"name":"linkOf:ifAbsent:","linesOfCode":5,"sourceCode":"linkOf: anObject ifAbsent: errorBlock \r\t\r\tself\r\t\tlinksDo: [:el | el value = anObject\r\t\t\t\tifTrue: [^ el]].\r\t^ errorBlock value"},{"name":"select:thenCollect:","linesOfCode":9,"sourceCode":"select: selectBlock thenCollect: collectBlock\r\t\"Optimized version of SequenceableCollection>>#select:thenCollect:\"\r\r\t| newCollection |\r\tnewCollection := self class new.\r\tself\r\t\tdo: [ :each | \r\t\t\t(selectBlock value: each)\r\t\t\t\tifTrue: [ newCollection add: (collectBlock value: each) ] ].\r\t^ newCollection"}],"meta":{"name":"LinkedList class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: anInt\r\t\"LinkedList don't need capacity\"\r\t^self new"},{"name":"new:streamContents:","linesOfCode":2,"sourceCode":"new: size streamContents: aBlock\r\t^ self withAll: (super new: size streamContents: aBlock)"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ Array"},{"name":"newFrom:","linesOfCode":5,"sourceCode":"newFrom: aCollection\r\t\"Answer an instance with same elements as aCollection.\"\r\t^self new\r\t\taddAll: aCollection;\r\t\tyourself"}],"meta":null}},{"name":"SparseLargeArray","instanceVariables":[{"name":"arrayClass"}],"methods":[{"name":"noCheckAt:","linesOfCode":4,"sourceCode":"noCheckAt: index\r      ^(self basicAt: index - base // chunkSize + 1)\r               ifNil: [defaultValue]\r               ifNotNil: [:chunk| chunk at: index - base \\\\ chunkSize + 1]"},{"name":"atAllPut:","linesOfCode":6,"sourceCode":"atAllPut: anObject\r       \"Put anObject at every one of the receiver's indices.\"\r\r       1 to: self basicSize do:\r               [:i|\r               self basicAt: i put: nil].\r       defaultValue := anObject"},{"name":"analyzeSpaceSaving","linesOfCode":22,"sourceCode":"analyzeSpaceSaving\r\r      | elems tablesTotal nonNilTables lastPage lastChunkSize |\r      elems := 0.\r       tablesTotal := self basicSize.\r       nonNilTables := 0.\r       lastPage := self basicAt: self basicSize.\r       (lastChunkSize := size \\\\ chunkSize) = 0 ifTrue:\r               [lastChunkSize := chunkSize].\r       1 to: self basicSize do:\r               [:i | | page |\r               (page := self basicAt: i) ifNotNil:\r                       [nonNilTables := nonNilTables + 1.\r                        1 to: (page == lastPage ifTrue: [lastChunkSize] ifFalse: [chunkSize]) do:\r                               [:j|\r                               (page at: j) ~= defaultValue ifTrue:\r                                       [elems := elems + 1]]]].\r\r       ^String streamContents:\r               [:strm |\r               strm nextPutAll: 'total: '; print: size.\r               strm nextPutAll: ' elements: '; print: elems.\r               strm nextPutAll: ' tables: '; print: tablesTotal.\r               strm nextPutAll: ' non-nil: '; print: nonNilTables]"},{"name":"initChunkSize:size:arrayClass:base:defaultValue:","linesOfCode":6,"sourceCode":"initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d\r       chunkSize := aChunkSize.\r       size := aSize.\r       base := b.\r       defaultValue := d.\r       arrayClass := aClass"},{"name":"noCheckAt:put:","linesOfCode":14,"sourceCode":"noCheckAt: index put: value\r       | chunkIndex chunk lastChunkSize |\r       chunkIndex := index - base // chunkSize + 1.\r       (chunk := self basicAt: chunkIndex) ifNil:\r               [value = defaultValue ifTrue:\r                       [^value].\r               chunk := arrayClass\r                                       new: ((chunkIndex == self basicSize\r                                                  and: [(lastChunkSize := size \\\\ chunkSize) > 0])\r                                                       ifTrue: [lastChunkSize]\r                                                       ifFalse: [chunkSize])\r                                       withAll: defaultValue.\r               self basicAt: chunkIndex put: chunk].\r       ^chunk at: index - base \\\\ chunkSize + 1 put: value"}],"meta":{"name":"SparseLargeArray class","instanceVariables":[],"methods":[],"meta":null}},{"name":"OrderedDictionary","instanceVariables":[{"name":"dictionary"},{"name":"orderedKeys"}],"methods":[{"name":"at:ifPresent:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: aKey ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock\r\t^ dictionary\r\t\tat: aKey\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: [ self at: aKey put: anAbsentBlock value ]"},{"name":"at:ifAbsentPut:","linesOfCode":2,"sourceCode":"at: aKey ifAbsentPut: aBlock\r\t^ self at: aKey ifAbsent: [self at: aKey put: aBlock value]"},{"name":"associationAt:ifPresent:","linesOfCode":2,"sourceCode":"associationAt: aKey ifPresent: aBlock\r\t^ dictionary associationAt: aKey ifPresent: aBlock"},{"name":"includesKey:","linesOfCode":2,"sourceCode":"includesKey: aKey\r\t^ dictionary includesKey: aKey"},{"name":"includes:","linesOfCode":2,"sourceCode":"includes: anObject\r\t^ dictionary includes: anObject"},{"name":"printElementsOn:","linesOfCode":15,"sourceCode":"printElementsOn: aStream\r\taStream nextPut: $(.\r\tself size > 100\r\t\tifTrue: [\r\t\t\taStream nextPutAll: 'size '.\r\t\t\tself size printOn: aStream]\r\t\tifFalse: [\r\t\t\tself associations withIndexDo: [:each :i |\r\t\t\t\taStream\r\t\t\t\t\tprint: each key;\r\t\t\t\t\tnextPutAll: '->';\r\t\t\t\t\tprint: each value.\r\t\t\t\t(i < self size)\r\t\t\t\t\tifTrue: [aStream space]]].\r\taStream nextPut: $)."},{"name":"hasBindingThatBeginsWith:","linesOfCode":2,"sourceCode":"hasBindingThatBeginsWith: aString\r\t^ dictionary hasBindingThatBeginsWith: aString"},{"name":"stonOn:","linesOfCode":10,"sourceCode":"stonOn: stonWriter\r\t\"I store my instances as maps. When in JSON mode, \r\tencode me directly, without a class tag, keeping the order.\"\r\t\r\tstonWriter jsonMode \r\t\tifTrue: [ \r\t\t\tstonWriter encodeMap: self ] \r\t\tifFalse: [ \r\t\t\tstonWriter \r\t\t\t\twriteObject: self \r\t\t\t\tdo: [ stonWriter encodeMap: self ] ]\r"},{"name":"at:update:initial:","linesOfCode":10,"sourceCode":"at: key update: updateBlock initial: initBlocktOrValue\r\t\"I am used to update the value at a given key. The updateBlock is passed \r\tthe existing value, and the result of the block is stored back.\r\tIf the key does not exist, store the value of the initBlocktOrValue.\r\tinitBlocktOrValue can be a block in case the initial value is expencive to compute.\"\r\t| val |\r\tval := self at: key ifAbsent: [ nil ].\r\tval \r\t\tifNil: [ self at: key put: (initBlocktOrValue value) ] \r\t\tifNotNil: [ self at: key put: (updateBlock value: val) ]"},{"name":"collect:","linesOfCode":4,"sourceCode":"collect: aBlock\r\t^ self species newFrom:\r\t\t(self associations collect: [:each |\r\t\t\teach key -> (aBlock value: each value)])"},{"name":"=","linesOfCode":10,"sourceCode":"= anObject\r\tself == anObject\r\t\tifTrue: [^ true].\r\r\t(self species == anObject species\r\t\tand: [self size = anObject size])\r\t\tifFalse: [^ false].\r\r\tdictionary associationsDo: [:each |\r\t\t(anObject at: each key ifAbsent: [^ false]) = each value\r\t\t\tifFalse: [^ false]].\r\t^ true."},{"name":"indexOfKey:ifAbsent:","linesOfCode":5,"sourceCode":"indexOfKey: aKey ifAbsent: aBlock\r\t1 to: self size do: [:i |\r\t\t(orderedKeys at: i) = aKey\r\t\t\tifTrue: [^ i]].\r\t^ aBlock value."},{"name":"addAll:","linesOfCode":5,"sourceCode":"addAll: anAssociationCollection\r\t\"Since Collection implements #associationsDo:, this method can accept\r\tany collection of associations including Arrays and OrderedCollections\"\r\r\tanAssociationCollection associationsDo: [:each | self add: each].\r\t^ anAssociationCollection."},{"name":"associationAt:","linesOfCode":2,"sourceCode":"associationAt: aKey\r\t^ dictionary associationAt: aKey"},{"name":"do:","linesOfCode":2,"sourceCode":"do: aBlock\r\tself valuesDo: aBlock"},{"name":"removeKey:ifAbsent:","linesOfCode":7,"sourceCode":"removeKey: aKey ifAbsent: aBlock\r\t| oldSize value |\r\r\toldSize := dictionary size.\r\tvalue := dictionary removeKey: aKey ifAbsent: aBlock.\r\tdictionary size < oldSize\r\t\tifTrue: [self orderedKeysRemove: aKey].\r\t^ value."},{"name":"includesIdentity:","linesOfCode":2,"sourceCode":"includesIdentity: anObject\r\t^ dictionary includesIdentity: anObject"},{"name":"keyAtIdentityValue:","linesOfCode":2,"sourceCode":"keyAtIdentityValue: aValue\r\t^ dictionary keyAtIdentityValue: aValue"},{"name":"dictionary","linesOfCode":2,"sourceCode":"dictionary\r\t^ dictionary"},{"name":"isDictionary","linesOfCode":2,"sourceCode":"isDictionary\r\t^ true"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ dictionary size"},{"name":"at:at:ifAbsentPut:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey ifAbsentPut: aZeroArgBlock\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. If firstKey is not defined, set a new dictionary for the second key and set the value of aZeroArgBlock execution. If firstKey is defined and not second key set the value of aZeroArgBlock execution. See NestedDictionaryTest for examples.\"\r\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey ifAbsentPut: aZeroArgBlock"},{"name":"at:ifPresent:ifAbsent:","linesOfCode":5,"sourceCode":"at: aKey ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t^ dictionary\r\t\tat: aKey\r\t\tifPresent: aPresentBlock\r\t\tifAbsent: anAbsentBlock"},{"name":"atRandom:","linesOfCode":3,"sourceCode":"atRandom: aGenerator\r\tself emptyCheck.\r\t^ self at: (self orderedKeys at: (aGenerator nextInteger: self size)) "},{"name":"keyForIdentity:","linesOfCode":2,"sourceCode":"keyForIdentity: anObject\r\t^ dictionary keyForIdentity: anObject"},{"name":"growOrderedKeys","linesOfCode":7,"sourceCode":"growOrderedKeys\r\torderedKeys :=\r\t\t(Array new: ((orderedKeys size * 1.5) asInteger max: 10))\r\t\t\treplaceFrom: 1\r\t\t\tto: orderedKeys size\r\t\t\twith: orderedKeys\r\t\t\tstartingAt: 1."},{"name":"capacity","linesOfCode":2,"sourceCode":"capacity\r\t^ dictionary capacity"},{"name":"associationAt:ifAbsent:","linesOfCode":2,"sourceCode":"associationAt: aKey ifAbsent: aBlock\r\t^ dictionary associationAt: aKey ifAbsent: aBlock"},{"name":"errorInvalidIndex:","linesOfCode":2,"sourceCode":"errorInvalidIndex: anIndex\r\tSubscriptOutOfBounds signalFor: anIndex"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeMap: self"},{"name":"dictionaryClass","linesOfCode":2,"sourceCode":"dictionaryClass\r\t^ Dictionary"},{"name":"at:","linesOfCode":2,"sourceCode":"at: aKey\r\t^ dictionary at: aKey"},{"name":"keysAndValuesRemove:","linesOfCode":7,"sourceCode":"keysAndValuesRemove: aTwoArgumentBlock\r\t| removedAssociations |\r\r\tremovedAssociations := OrderedCollection new.\r\tself associationsDo: [:each |\r\t\t(aTwoArgumentBlock value: each key value: each value)\r\t\t\tifTrue: [removedAssociations add: each]].\r\tremovedAssociations do: [:each | self removeKey: each key]."},{"name":"orderedKeysIndexOf:","linesOfCode":2,"sourceCode":"orderedKeysIndexOf: aKey\r\t^ orderedKeys indexOf: aKey"},{"name":"gtInspectorItemsIn:","linesOfCode":26,"sourceCode":"gtInspectorItemsIn: composite\r\t^ composite fastTable\r\t\ttitle: 'Items';\r\t\tdisplay: [ self associations ];\r\t\t\"children: [ :each | \r\t\t\t(each value isDictionary) \r\t\t\t\tifTrue: [ each value associations ] \r\t\t\t\tifFalse: [ (each value isArray and: [ each value allSatisfy: #isDictionary ])\r\t\t\t\t\t\tifTrue: [ each value collectWithIndex: [:x :i | i -> x ] ]\r\t\t\t\t\t\tifFalse: [ #() ] ] ];\"\r\t\t\tcolumn: 'Key' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each key ];\r\t\tcolumn: 'Value' evaluated: [ :each | GTObjectPrinter asTruncatedTextFrom: each value ];\r\t\tselectionAct: [ :table | \r\t\t\ttable rawSelection do: [ :assoc | self removeKey: assoc key ].\r\t\t\ttable update ]\r\t\t\tentitled: 'Remove item(s)';\r\t\tselectionPopulate: #selection entitled: 'Open key' with: [ :table | (table rawSelection collect: [:each | each key]) gtInspectorInterestingObject ];\r\t\tbeMultiple;\r\t\tsend: [ :selection | \r\t\t\t\"withSmalltalkSearch;\r\t\tshowOnly: 50;\r\t\thelpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'\"\r\t\t\tselection\r\t\t\t\tifNotNil: [ selection size = 1\r\t\t\t\t\t\tifTrue: [ selection anyOne value ]\r\t\t\t\t\t\tifFalse: [ selection collect: #value ] ] ]"},{"name":"at:ifAbsent:","linesOfCode":2,"sourceCode":"at: aKey ifAbsent: aBlock\r\t^ dictionary at: aKey ifAbsent: aBlock"},{"name":"keyAtValue:ifAbsent:","linesOfCode":2,"sourceCode":"keyAtValue: aValue ifAbsent: aBlock\r\t^ dictionary keyAtValue: aValue ifAbsent: aBlock"},{"name":"removeKey:","linesOfCode":5,"sourceCode":"removeKey: aKey\r\t| value |\r\r\tvalue := dictionary removeKey: aKey.\r\tself orderedKeysRemove: aKey.\r\t^ value."},{"name":"associations","linesOfCode":8,"sourceCode":"associations\r\t| associations i |\r\r\tassociations := Array new: self size.\r\ti := 1.\r\tself associationsDo: [:each |\r\t\tassociations at: i put: each.\r\t\ti := i + 1].\r\t^ associations."},{"name":"orderedKeysRemove:","linesOfCode":14,"sourceCode":"orderedKeysRemove: aRemovedKey\r\t| index |\r\r\tindex := self orderedKeysIndexOf: aRemovedKey.\r\r\t\"shift every remaining key after to the left by one\"\r\torderedKeys\r\t\treplaceFrom: index\r\t\tto: self size\r\t\twith: orderedKeys\r\t\tstartingAt: index + 1.\r\r\t\"one key was removed and the rest shifted, so nil what was the last\r\tkey slot before removing and shifting\"\r\torderedKeys\r\t\tat: self size + 1\r\t\tput: nil."},{"name":"orderedKeys","linesOfCode":2,"sourceCode":"orderedKeys\r\t^ orderedKeys"},{"name":"removeKeys:","linesOfCode":27,"sourceCode":"removeKeys: aKeyCollection\r\t\"Fast removal of multiple keys; returns self to avoid\r\thaving to create a removed value collection and does not\r\traise errors.\"\r\r\taKeyCollection\tsize > 1\r\t\tifTrue: [| oldSize newOrderedKeys newOrderedKeysIndex |\r\t\t\toldSize := self size.\r\t\t\taKeyCollection do: [:each |\r\t\t\t\tdictionary\r\t\t\t\t\tremoveKey: each\r\t\t\t\t\tifAbsent: [nil]].\r\r\t\t\tnewOrderedKeys := Array new: oldSize.\r\t\t\tnewOrderedKeysIndex := 0.\r\t\t\t1 to: oldSize do: [:i | | key |\r\t\t\t\t(dictionary includesKey: (key := orderedKeys at: i))\r\t\t\t\t\tifTrue: [\r\t\t\t\t\t\tnewOrderedKeys\r\t\t\t\t\t\t\tat: (newOrderedKeysIndex := newOrderedKeysIndex + 1)\r\t\t\t\t\t\t\tput: key]].\r\r\t\t\torderedKeys := newOrderedKeys]\r\t\tifFalse: [\r\t\t\taKeyCollection size = 1\r\t\t\t\tifTrue: [\r\t\t\t\t\t\"use #anyOne, because it can be a Set\"\r\t\t\t\t\tself\r\t\t\t\t\t\tremoveKey: aKeyCollection anyOne\r\t\t\t\t\t\tifAbsent: [nil]]]"},{"name":"valuesDo:","linesOfCode":2,"sourceCode":"valuesDo: aBlock\r\tself keysDo: [:each | aBlock value: (self at: each)]"},{"name":"asValueHolder","linesOfCode":2,"sourceCode":"asValueHolder\r\r\t^ DictionaryValueHolder value: self\r"},{"name":"add:","linesOfCode":10,"sourceCode":"add: anAssociation\r\t| oldSize |\r\r\toldSize := dictionary size.\r\tdictionary add: anAssociation.\r\tdictionary size > oldSize\r\t\tifTrue: [\r\t\t\torderedKeys size > oldSize\r\t\t\t\tifFalse: [self growOrderedKeys].\r\t\t\torderedKeys at: oldSize + 1 put: anAssociation key].\r\t^ anAssociation."},{"name":"at:at:ifAbsent:","linesOfCode":6,"sourceCode":"at: firstKey at: secondKey ifAbsent: aZeroArgBlock\r\t\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey. Execute aZeroArgBlock in case one of the key is wrong.\"\r\t\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsent: [ ^ aZeroArgBlock value ].\r\t^ subDictionary at: secondKey ifAbsent: aZeroArgBlock"},{"name":"associationsDo:","linesOfCode":2,"sourceCode":"associationsDo: aBlock\r\tself keysDo: [:each | aBlock value: (self associationAt: each)]"},{"name":"bindingsDo:","linesOfCode":2,"sourceCode":"bindingsDo: aBlock\r\tself associationsDo: aBlock"},{"name":"declare:from:","linesOfCode":8,"sourceCode":"declare: aKey from: aDictionary\r\t(self includesKey: aKey)\r\t\tifTrue: [^ self].\r\r\t(aDictionary includesKey: aKey)\r\t\tifTrue: [\r\t\t\tself add: (aDictionary associationAt: aKey).\r\t\t\taDictionary removeKey: aKey]\r\t\tifFalse: [self add: aKey -> nil]"},{"name":"keyAtValue:","linesOfCode":2,"sourceCode":"keyAtValue: aValue\r\t^ dictionary keyAtValue: aValue"},{"name":"keysAndValuesDo:","linesOfCode":2,"sourceCode":"keysAndValuesDo: aBlock\r\tself keysDo: [:each | aBlock value: each value: (self at: each)]"},{"name":"at:update:","linesOfCode":3,"sourceCode":"at: key update: updateBlock \r\t\"I am used to update the value at a given key, or if the key does not exist, to throw an error\"\r\tself at: key update: updateBlock initial: [ KeyNotFound signalFor: key ]."},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\torderedKeys := orderedKeys copy.\r\tdictionary := dictionary copy."},{"name":"includesAssociation:","linesOfCode":2,"sourceCode":"includesAssociation: anAssociation\r\t^ dictionary includesAssociation: anAssociation"},{"name":"isHealthy","linesOfCode":2,"sourceCode":"isHealthy\r\t^ dictionary isHealthy"},{"name":"indexOfKey:","linesOfCode":2,"sourceCode":"indexOfKey: aKey\r\t^ self indexOfKey: aKey ifAbsent: [0]"},{"name":"at:at:","linesOfCode":10,"sourceCode":"at: firstKey at: secondKey\r\t\"Return the object stored in the second dictionary at secondKey. The second dictionary is accessed via the key firstKey.\"\r\r\t\"\r\t(Dictionary new\r\t\tat: #top at: #below1 put: 1;\r\t\tat: #top at: #below1 put: 2;\r\t\tat: #top at: #below1)\r\t>>>\r\t2\"\r\r\t^ self at: firstKey at: secondKey ifAbsent: [ self errorKeyNotFound: secondKey ]"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":9,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #OrderedDictionary earlyFields: self size fields: [\r\t\tArray streamContents: [ :out |\r\t\t\tself keysDo: [ :key |\r\t\t\t\tout nextPut: (key encodeGraphForMessagePackWith: graphEncoder);\r\t\t\t\t\tnextPut: ((self at: key) encodeGraphForMessagePackWith: graphEncoder)\r\t\t\t]\r\t\t]\r\t]"},{"name":"hash","linesOfCode":2,"sourceCode":"hash\r\t^ dictionary hash"},{"name":"remove:ifAbsent:","linesOfCode":2,"sourceCode":"remove: anObject ifAbsent: aBlock\r\tself shouldNotImplement"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self"},{"name":"keyAtIdentityValue:ifAbsent:","linesOfCode":2,"sourceCode":"keyAtIdentityValue: aValue ifAbsent: aBlock\r\t^ dictionary keyAtIdentityValue: aValue ifAbsent: aBlock"},{"name":"keysDo:","linesOfCode":2,"sourceCode":"keysDo: aBlock\r\t1 to: self size do: [:i | aBlock value: (orderedKeys at: i)]"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\t1 to: self size do: [:i | orderedKeys at: i put: nil].\r\tdictionary removeAll."},{"name":"initialize:","linesOfCode":3,"sourceCode":"initialize: aCapacity\r\tdictionary := self dictionaryClass new: aCapacity.\r\torderedKeys := Array new: aCapacity."},{"name":"keys","linesOfCode":2,"sourceCode":"keys\r\t^ orderedKeys copyFrom: 1 to: self size"},{"name":"identityIndexOfKey:","linesOfCode":2,"sourceCode":"identityIndexOfKey: aKey\r\t^ self identityIndexOfKey: aKey ifAbsent: [0]"},{"name":"replaceKey:with:","linesOfCode":7,"sourceCode":"replaceKey: aKey with: otherKey\r\t| value index |\r\t\r\tvalue := self at: aKey.\r\tindex := orderedKeys indexOf: aKey.\r\tdictionary removeKey: aKey.\r\tdictionary at: otherKey put: value.\r\torderedKeys at: index put: otherKey\r\t"},{"name":"values","linesOfCode":2,"sourceCode":"values\r\t^ self associations collect: [:each | each value]"},{"name":"at:at:put:","linesOfCode":5,"sourceCode":"at: firstKey at: secondKey put: aValue\r\t\"Set a value at secondKey in the dictionary returned by firstKey.\"\r\t\r\t| subDictionary |\r\tsubDictionary := self at: firstKey ifAbsentPut: [ self species new ].\r\t^ subDictionary at: secondKey put: aValue\r"},{"name":"keysSortedSafely","linesOfCode":2,"sourceCode":"keysSortedSafely\r\t^ dictionary keysSortedSafely"},{"name":"slvmMessagePackEncodeWith:","linesOfCode":2,"sourceCode":"slvmMessagePackEncodeWith: encoder\r\tencoder encodeMap: self"},{"name":"keyAtIndex:","linesOfCode":2,"sourceCode":"keyAtIndex: anIndex\r\t^ self keyAtIndex: anIndex ifAbsent: [self errorInvalidIndex: anIndex]"},{"name":"identityIndexOfKey:ifAbsent:","linesOfCode":5,"sourceCode":"identityIndexOfKey: aKey ifAbsent: aBlock\r\t1 to: self size do: [:i |\r\t\t(orderedKeys at: i) == aKey\r\t\t\tifTrue: [^ i]].\r\t^ aBlock value."},{"name":"associationsSelect:","linesOfCode":2,"sourceCode":"associationsSelect: aBlock\r\t^ self species newFrom: (self associations select: aBlock)"},{"name":"at:ifPresent:","linesOfCode":2,"sourceCode":"at: aKey ifPresent: aBlock\r\t^ dictionary at: aKey ifPresent: aBlock"},{"name":"storeOn:","linesOfCode":12,"sourceCode":"storeOn: aStream\r\taStream << '((' << self class name << ' new)'.\r\tself associations\r\t\tifNotEmpty: [ :assos | \r\t\t\tassos\r\t\t\t\tdo: [ :each | \r\t\t\t\t\taStream\r\t\t\t\t\t\t<< ' add: ';\r\t\t\t\t\t\tstore: each ]\r\t\t\t\tseparatedBy: [ aStream << ';' ].\r\t\t\taStream << '; yourself' ].\r\taStream << ')'"},{"name":"associationAt:ifPresent:ifAbsent:","linesOfCode":2,"sourceCode":"associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock\r\t^ dictionary associationAt: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock"},{"name":"keyAtIndex:ifAbsent:","linesOfCode":4,"sourceCode":"keyAtIndex: anIndex ifAbsent: aBlock\r\t^ (anIndex > 0 and: [ anIndex <= self size ])\r\t\tifTrue: [ orderedKeys at: anIndex ]\r\t\tifFalse: [ aBlock value ]"},{"name":"select:","linesOfCode":3,"sourceCode":"select: aBlock\r\t^ self species newFrom:\r\t\t(self associations select: [:each | aBlock value: each value])"},{"name":"at:put:","linesOfCode":10,"sourceCode":"at: aKey put: aValue\r\t| oldSize |\r\r\toldSize := dictionary size.\r\tdictionary at: aKey put: aValue.\r\tdictionary size > oldSize\r\t\tifTrue: [\r\t\t\torderedKeys size > oldSize\r\t\t\t\tifFalse: [self growOrderedKeys].\r\t\t\torderedKeys at: oldSize + 1 put: aKey].\r\t^ aValue."},{"name":"bindingOf:","linesOfCode":2,"sourceCode":"bindingOf: varName\r\t^ self associationAt: varName ifAbsent: [nil]"}],"meta":{"name":"OrderedDictionary class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: aCapacity\r\t^ self basicNew initialize: aCapacity"},{"name":"newFromPairs:","linesOfCode":8,"sourceCode":"newFromPairs: aSequenceableCollection\r\t| newDictionary |\r\r\tnewDictionary := self new: (aSequenceableCollection size / 2) floor.\r\t1 to: aSequenceableCollection size - 1 by: 2 do: [:i |\r\t\tnewDictionary\r\t\t\tat: (aSequenceableCollection at: i)\r\t\t\tput: (aSequenceableCollection at: i + 1)].\r\t^ newDictionary."},{"name":"inspectorClass","linesOfCode":2,"sourceCode":"inspectorClass\r\t^ Dictionary inspectorClass"},{"name":"fromSton:","linesOfCode":7,"sourceCode":"fromSton: stonReader\r\t\"My instances are stored as maps.\"\r\t\r\t| dictionary |\r\tdictionary := self new.\r\tstonReader parseMapDo: [ :key :value |\r\t\tdictionary at: key put: value ].\r\t^ dictionary"},{"name":"newFromKeys:andValues:","linesOfCode":7,"sourceCode":"newFromKeys: keys andValues: values\r\t\"Create a dictionary from the keys and values arguments which should have the same length.\"\r\t\r\t\"(OrderedDictionary newFromKeys: #(#x #y) andValues: #(3 6)) >>> (OrderedDictionary new at: #x put: 3; at: #y put: 6 ;yourself)\"\r\t\r\t| dict |\r\tdict := self new.\r\tkeys with: values do: [ :k :v | dict at: k put: v ].\r\t^ dict"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: 10"},{"name":"newFrom:","linesOfCode":8,"sourceCode":"newFrom: anAssociationCollection\r\t| newDictionary |\r\r\tnewDictionary := self new: anAssociationCollection size.\r\tanAssociationCollection associationsDo: [:each |\r\t\tnewDictionary\r\t\t\tat: each key\r\t\t\tput: each value].\r\t^ newDictionary."},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #OrderedDictionary ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext pairsDo: [ :key :value |\r\t\t\tresult at: key put: value\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"}],"meta":null}},{"name":"OrderedCollection","instanceVariables":[{"name":"array"},{"name":"firstIndex"},{"name":"lastIndex"}],"methods":[{"name":"at:ifAbsentPut:","linesOfCode":10,"sourceCode":"at: index ifAbsentPut: block\r\t\"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)\"\r\r\t| v |\r\tindex <= self size ifTrue: [\r\t\t^ (v := self at: index)\r\t\t\tifNotNil: [v]\r\t\t\tifNil: [self at: index put: block value]\r\t].\r\t[self size < index] whileTrue: [self add: nil].\r\t^ self at: index put: block value"},{"name":"copyWith:","linesOfCode":7,"sourceCode":"copyWith: newElement \r\t\"Answer a copy of the receiver that is 1 bigger than the receiver and \r\tincludes the argument, newElement, at the end.\"\r\r\t| newCollection |\r\tnewCollection := self copy.\r\tnewCollection add: newElement.\r\t^newCollection"},{"name":"makeRoomAtFirst","linesOfCode":15,"sourceCode":"makeRoomAtFirst\r\t\"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1\"\r\t\r\t\"#(1 2 3) asOrderedCollection capacity >>> 3\"\r\t\"#(1 2 3) asOrderedCollection makeRoomAtFirst capacity >>> 6\"\r\t\r\t| tally newFirstIndex newLastIndex |\r\ttally := self size.\r\ttally * 2 >= array size ifTrue: [ ^self growAtFirst ].\r\ttally = 0 ifTrue: [ ^self resetTo: array size + 1 ].\r\tnewFirstIndex := array size // 2 + 1.\r\tnewLastIndex := newFirstIndex - firstIndex + lastIndex.\r\t0 to: tally - 1 do: [ :offset |\r\t\tarray at: newLastIndex - offset put: (array at: lastIndex - offset) ].\r\tarray from: firstIndex to: newFirstIndex - 1 put: nil.\r\tfirstIndex := newFirstIndex.\r\tlastIndex := newLastIndex"},{"name":"copyReplaceFrom:to:with:","linesOfCode":28,"sourceCode":"copyReplaceFrom: start to: stop with: replacementCollection \r\t\"Answer a copy of the receiver with replacementCollection's elements in\r\tplace of the receiver's start'th to stop'th elements. This does not expect\r\ta 1-1 map from replacementCollection to the start to stop elements, so it\r\twill do an insert or append.\"\r\r\t| newOrderedCollection delta startIndex stopIndex |\r\t\"if start is less than 1, ignore stop and assume this is inserting at the front. \r\tif start greater than self size, ignore stop and assume this is appending. \r\totherwise, it is replacing part of me and start and stop have to be within my \r\tbounds. \"\r\tdelta := 0.\r\tstartIndex := start.\r\tstopIndex := stop.\r\tstart < 1\r\t\tifTrue: [startIndex := stopIndex := 0]\r\t\tifFalse: [startIndex > self size\r\t\t\t\tifTrue: [startIndex := stopIndex := self size + 1]\r\t\t\t\tifFalse: \r\t\t\t\t\t[(stopIndex < (startIndex - 1) or: [stopIndex > self size])\r\t\t\t\t\t\tifTrue: [self errorOutOfBounds].\r\t\t\t\t\tdelta := stopIndex - startIndex + 1]].\r\tnewOrderedCollection := \r\t\tself species new: self size + replacementCollection size - delta.\r\t1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].\r\t1 to: replacementCollection size do: \r\t\t[:index | newOrderedCollection add: (replacementCollection at: index)].\r\tstopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].\r\t^newOrderedCollection"},{"name":"addAllFirstUnlessAlreadyPresent:","linesOfCode":5,"sourceCode":"addAllFirstUnlessAlreadyPresent: anOrderedCollection \r\t\"Add each element of anOrderedCollection at the beginning of the receiver, preserving the order, but do not add any items that are already in the receiver.  Answer anOrderedCollection.\"\r\r\tanOrderedCollection reverseDo:\r\t\t[:each | (self includes: each) ifFalse: [self addFirst: each]].\r\t^ anOrderedCollection"},{"name":"reject:thenCollect:","linesOfCode":10,"sourceCode":"reject: rejectBlock thenCollect: collectBlock\r    \" Optimized version of Collection>>#reject:thenCollect: \"\r\r\t| newCollection |\r\r    newCollection := self copyEmpty.\r\r    firstIndex to: lastIndex do: [ :index |\r\t\t| element |\r\t\telement := array at: index.\r\t\t(rejectBlock value: element) \r\t\t\tifFalse: [ newCollection addLast: (collectBlock value: element) ]].\r\r    ^ newCollection"},{"name":"collect:","linesOfCode":12,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my elements as the argument. Collect the \r\tresulting values into a collection that is like me. Answer the new \r\tcollection. Override superclass in order to use addLast:, not at:put:.\"\r\r\t\"(#(1 2 3) asOrderedCollection collect: [ :v | v * 10 ]) asArray >>> #(10 20 30)\"\r\t\"(#(1 2 3) asOrderedCollection collect: [ :v | 10 ]) asArray >>> #(10 10 10)\"\r\t\r\t| newCollection |\r\tnewCollection := self species new: self size.\r\tfirstIndex to: lastIndex do:\r\t\t[:index |\r\t\tnewCollection addLast: (aBlock value: (array at: index))].\r\t^ newCollection"},{"name":"removeAllSuchThat:","linesOfCode":11,"sourceCode":"removeAllSuchThat: aBlock \r\t\"Remove each element of the receiver for which aBlock evaluates to true.\r\tThe method in Collection is O(N^2), this is O(N).\"\r\r\t| n |\r\tn := firstIndex.\r\tfirstIndex to: lastIndex do: [:index |\r\t    (aBlock value: (array at: index)) ifFalse: [\r\t\t\tarray at: n put: (array at: index).\r\t\t\tn := n + 1]].\r\tarray from: n to: lastIndex put: nil.\r\tlastIndex := n - 1"},{"name":"errorConditionNotSatisfied","linesOfCode":2,"sourceCode":"errorConditionNotSatisfied\r\r\tself error: 'no element satisfies condition'"},{"name":"asArray","linesOfCode":7,"sourceCode":"asArray\r\t\"Convert an OrderedCollection into an Array.\"\r\t\"#(a b c) asOrderedCollection asArray >>> #(a b c)\"\r\t\"OrderedCollection new class >>> OrderedCollection\"\r\t\"OrderedCollection new asArray class >>> Array\"\r\t\"(OrderedCollection new add: 42; add: 43; yourself) asArray >>> #(42 43)\"\r\t\r\t^ (Array new: self size) replaceFrom: 1 to: self size with: array startingAt: firstIndex."},{"name":"addAll:","linesOfCode":4,"sourceCode":"addAll: aCollection \r\t\"Add each element of aCollection at my end. Answer aCollection.\"\r\r\t\"(OrderedCollection new addAll: #(41 42); yourself) asArray >>> #(41 42)\"\r\r\r\t^ self addAllLast: aCollection"},{"name":"makeRoomAtLast","linesOfCode":16,"sourceCode":"makeRoomAtLast\r\t\"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size\"\r\t\r\t| tally newFirstIndex newLastIndex |\r\ttally := self size.\r\ttally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].\r\ttally = 0 ifTrue: [ ^self resetTo: 1 ].\r\tnewLastIndex := lastIndex // 2.\r\tnewFirstIndex := newLastIndex - lastIndex + firstIndex.\r\tarray \r\t\treplaceFrom: newFirstIndex\r\t\tto: newLastIndex\r\t\twith: array\r\t\tstartingAt: firstIndex.\r\tarray from: newLastIndex + 1 to: lastIndex put: nil.\r\tfirstIndex := newFirstIndex.\r\tlastIndex := newLastIndex"},{"name":"reject:","linesOfCode":9,"sourceCode":"reject: rejectBlock \r\t\"Optimized version of Collection>>#reject:\"\r\r\t| newCollection element |\r\t\r\tnewCollection := self copyEmpty.\r\t\r\tfirstIndex to: lastIndex do: [ :index |\r\t\t(rejectBlock value: (element := array at: index))\r\t\t\tifFalse: [ newCollection addLast: element ]].\r\t\t\r\t^ newCollection"},{"name":"withIndexCollect:","linesOfCode":10,"sourceCode":"withIndexCollect: elementAndIndexBlock \r\t\"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:.\"\r\r\t| newCollection |\r\tnewCollection := self species new: self size.\r\tfirstIndex to: lastIndex do:\r\t\t[:index |\r\t\tnewCollection addLast: (elementAndIndexBlock\r\t\t\tvalue: (array at: index)\r\t\t\tvalue: index - firstIndex + 1)].\r\t^ newCollection"},{"name":"insert:before:","linesOfCode":27,"sourceCode":"insert: anObject before: spot\r\r  \"  spot is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection. \r     Never use this method in your code, it is meant for private use by OrderedCollection only.\r     The methods for use are:\r        #add:before:   to insert an object before another object\r        #add:beforeIndex:   to insert an object before a given position. \"\r\t| \"index\" delta spotIndex|\r\tspotIndex := spot.\r\tdelta := spotIndex - firstIndex.\r\tfirstIndex = 1\r\t\tifTrue: \r\t\t\t[self makeRoomAtFirst.\r\t\t\tspotIndex := firstIndex + delta].\r\tfirstIndex := firstIndex - 1.\r\tarray\r\t\treplaceFrom: firstIndex\r\t\tto: spotIndex - 2\r\t\twith: array\r\t\tstartingAt: firstIndex + 1.\r\tarray at: spotIndex - 1 put: anObject.\r\"\tindex := firstIndex := firstIndex - 1.\r\t[index < (spotIndex - 1)]\r\t\twhileTrue: \r\t\t\t[array at: index put: (array at: index + 1).\r\t\t\tindex := index + 1].\r\tarray at: index put: anObject.\"\r\t^ anObject"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver that contains no elements.\"\r\r\t^self species new"},{"name":"do:","linesOfCode":4,"sourceCode":"do: aBlock\r\t\"Override the superclass for performance reasons.\"\r\r\tfirstIndex to: lastIndex do: [ :index | \r\t\taBlock value: (array at: index) ]"},{"name":"add:beforeIndex:","linesOfCode":6,"sourceCode":"add: newObject beforeIndex: index \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just before index. Answer newObject.\"\r\t(index between: 1 and: self size+1) ifFalse:[^self errorSubscriptBounds: index].\r\tself insert: newObject before: firstIndex + index - 1.\r\t^ newObject"},{"name":"compact","linesOfCode":10,"sourceCode":"compact\r\t\"remove all empty slots to the end of array, while keeping the empty slots at the front.\"\r\r    | newArray |\r    newArray := self class arrayType new: lastIndex.\r    newArray \r        replaceFrom: firstIndex\r        to: lastIndex\r        with: array\r        startingAt: firstIndex.\r    array := newArray"},{"name":"asOrderedCollection","linesOfCode":3,"sourceCode":"asOrderedCollection \r\r\tself species == OrderedCollection ifTrue: [ ^self ].\r\t^super asOrderedCollection "},{"name":"find:","linesOfCode":12,"sourceCode":"find: oldObject\r  \"  This method answers an index in the range firstIndex .. lastIndex, which is meant for internal use only.\r     Never use this method in your code, the methods for public use are:\r        #indexOf:\r        #indexOf:ifAbsent: \"\r\r\t| index |\r\tindex := firstIndex.\r\t[index <= lastIndex]\r\t\twhileTrue:\r\t\t\t[(array at: index) = oldObject ifTrue: [^ index].\r\t\t\tindex := index + 1].\r\tself errorNotFound: oldObject"},{"name":"resetTo:","linesOfCode":3,"sourceCode":"resetTo: index\r\tfirstIndex := index.\r\tlastIndex := firstIndex - 1"},{"name":"reversed","linesOfCode":8,"sourceCode":"reversed\r\t\"Answer a copy of the receiver with element order reversed.  \"\r\t\"#(2 3 4 'fred') asOrderedCollection reversed >>> #('fred' 4 3 2) asOrderedCollection\"\r\t| newCol |\r\tnewCol := self species new.\r\tself reverseDo:\r\t\t[:elem | newCol addLast: elem].\r\t^ newCol\r\r"},{"name":"add:after:","linesOfCode":11,"sourceCode":"add: newObject after: oldObject \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just succeeding oldObject. Answer newObject.\r\tRaises an error if oldObject is not found\"\r\t\r\t\"(OrderedCollection new add: 41; add: 42 after: 41; yourself) asArray >>>  #(41 42)\"\r\t\"(OrderedCollection new add: 41; add: 42 after: 41; add: 43 after: 41; yourself) asArray >>>  #(41 43 42)\"\r\t\t\r\t| index |\r\tindex := self find: oldObject.\r\tself insert: newObject before: index + 1.\r\t^newObject"},{"name":"with:collect:","linesOfCode":10,"sourceCode":"with: otherCollection collect: twoArgBlock \r\t\"Collect and return the result of evaluating twoArgBlock with \r\tcorresponding elements from this collection and otherCollection.\"\r\t| result |\r\totherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].\r\tresult := self species new: self size.\r\t1 to: self size do:\r\t\t[:index | result addLast: (twoArgBlock value: (self at: index)\r\t\t\t\t\t\t\t\t\tvalue: (otherCollection at: index))].\r\t^ result"},{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t^ lastIndex - firstIndex + 1"},{"name":"collect:from:to:","linesOfCode":8,"sourceCode":"collect: aBlock from: fromIndex to: toIndex\r\t\"Override superclass in order to use addLast:, not at:put:.\"\r\t| result |\r\tself ensureBoundsFrom: fromIndex to: toIndex.\r\tresult := self species new: toIndex - fromIndex + 1.\r\tfirstIndex + fromIndex - 1 to: firstIndex + toIndex - 1 do:\r\t\t[:index | result addLast: (aBlock value: (array at: index))].\r\t^ result\r"},{"name":"reverseDo:","linesOfCode":4,"sourceCode":"reverseDo: aBlock\r\t\"Override the superclass for performance reasons.\"\r\r\tlastIndex to: firstIndex by: -1 do: [ :index | \r\t\taBlock value: (array at: index) ]"},{"name":"reset","linesOfCode":3,"sourceCode":"reset\r\t\"Quickly remove all elements. The objects will be still referenced, but will not be \taccessible.\"\r\t\r\tself resetTo: 1"},{"name":"withIndexSelect:select:","linesOfCode":9,"sourceCode":"withIndexSelect: elementAndIndexBlock select: selectBlock\r\t\"Optimized version of SequenceableCollection>>#withIndexSelect: \"\r\r\t\"(#('We' 'love' 'pharo!') asOrderedCollection withIndexSelect: [:value :index | value size - 1 <= index]) >>> (OrderedCollection with: 'We')\"\r\r\t| newCollection element |\r\tnewCollection := self copyEmpty.\r\tfirstIndex to: lastIndex do: [ :index | \r\t\t(selectBlock value: (element := array at: index) value: index)\r\t\t\tifTrue: [ newCollection addLast: element ] ].\r\t^ newCollection"},{"name":"capacity","linesOfCode":5,"sourceCode":"capacity\r\t\"Answer the current capacity of the receiver.\"\r\r\t\"OrderedCollection new capacity >>> 10\"\r\t\"(OrderedCollection new addAll: (1 to: 15); yourself) capacity >>> 20\"\r\t\r\t^ array size"},{"name":"add:before:","linesOfCode":8,"sourceCode":"add: newObject before: oldObject \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just preceding oldObject. Answer newObject.\"\r\t\r\t\"(OrderedCollection new add: 42; add: 41 before: 42; yourself) asArray >>> #(41 42)\"\r\t\r\t| index |\r\tindex := self find: oldObject.\r\tself insert: newObject before: index.\r\t^newObject"},{"name":"removeDuplicates","linesOfCode":15,"sourceCode":"removeDuplicates\r\t\"Remove the copies of elements, but keep the same order\"\r\t\r\t\"#(7 42 7 42 9) asOrderedCollection removeDuplicates asArray >>> #(7 42 9)\"\r\t\"#(1 2 3) asOrderedCollection removeDuplicates asArray >>> #(1 2 3)\"\r\r\t| iterator seen |\r\tself ifEmpty: [ ^ self ].\r\titerator := 1.\r\tseen := Set new.\r\t[ iterator <= self size ]\r\t\twhileTrue: [ | each |\r\t\t\teach := self at: iterator.\r\t\t\t(seen includes: each)\r\t\t\t\tifTrue: [ self removeAt: iterator ]\r\t\t\t\tifFalse: [ seen add: each. iterator := iterator + 1. ].\r\t ]"},{"name":"setContents:","linesOfCode":4,"sourceCode":"setContents: anArray\r\tarray := anArray.\r\tfirstIndex := 1.\r\tlastIndex := array size."},{"name":"at:","linesOfCode":13,"sourceCode":"at: anInteger\r\t\"Answer my element at index anInteger. at: is used by a knowledgeable\r\tclient to access an existing element.\"\r\t\"((OrderedCollection new add: 34; yourself) at: 1) >>> 34\"\r\t\"(#(40 41 42) asOrderedCollection at: 1) >>> 40\"\r\t\"(#(40 41 42) asOrderedCollection at: 2) >>> 41\"\r\t\"(#(40 41 42) asOrderedCollection at: 3) >>> 42\"\r\r\t| index |\r\tanInteger < 1\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t(index := anInteger + firstIndex - 1) > lastIndex\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t^ array at: index"},{"name":"setCollection:","linesOfCode":3,"sourceCode":"setCollection: anArray\r\tarray := anArray.\r\tself reset"},{"name":"join:","linesOfCode":8,"sourceCode":"join: aCollection \r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\r\t| result |\r\tresult := self class new.\r\taCollection\r\t\tdo: [:each | each appendTo: result]\r\t\tseparatedBy: [self appendTo: result].\r\t^ result"},{"name":"collect:thenSelect:","linesOfCode":9,"sourceCode":"collect: collectBlock thenSelect: selectBlock\r    \"Optimized version Collection>>#collect:thenSelect:\"\r\r    | newCollection newElement |\r\r    newCollection := self copyEmpty.\r    firstIndex to: lastIndex do: [ :index | \r\t\tnewElement := collectBlock value: (array at: index).\r\t\t(selectBlock value: newElement) \r\t\t\tifTrue: [ newCollection addLast: newElement ]].\r    ^ newCollection"},{"name":"select:thenCollect:","linesOfCode":9,"sourceCode":"select: selectBlock thenCollect: collectBlock\r    \" Optimized version Collection>>#select:thenCollect: \"\r\r\t| newCollection element |\r\r    newCollection := self copyEmpty.\r\r    firstIndex to: lastIndex do: [ :index |\r\t\telement := array at: index.\r\t\t(selectBlock value: element) \r\t\t\tifTrue: [ newCollection addLast: (collectBlock value: element) ]].\r\r    ^ newCollection"},{"name":"postCopyFrom:to:","linesOfCode":12,"sourceCode":"postCopyFrom: startIndex to: endIndex \r\t\"finish copying the array in a certain range.\"\r\r\tendIndex < startIndex ifFalse: [\r\t\t\"Because actual size of the array may be greater than used size,\r\t\tpostCopyFrom:to: may fail to fail and answer an incorrect result\r\t\tif this sanity check were not applied.\"\r\t\t(startIndex between: 1 and: self size) ifFalse: [^SubscriptOutOfBounds signalFor: startIndex lowerBound: (1 min: self size) upperBound: self size in: self].\r\t\t(endIndex between: 1 and: self size) ifFalse: [^SubscriptOutOfBounds signalFor: endIndex lowerBound: (1 min: self size) upperBound: self size in: self]].\r\t\r\t\"Add a protection that lacks in Array>>postcopy\"\r\tarray := array copyFrom: startIndex + firstIndex - 1 to: (endIndex max: startIndex - 1) + firstIndex - 1.\r\tfirstIndex := 1.\r\tlastIndex := array size"},{"name":"addAllFirst:","linesOfCode":6,"sourceCode":"addAllFirst: anOrderedCollection \r\t\"Add each element of anOrderedCollection at the beginning of the \r\treceiver. Answer anOrderedCollection.\"\r\t\r\t\"((OrderedCollection new add: 40; addAllFirst: #(41 42); yourself) asArray) >>  #(41 42 40)\"\r\r\tanOrderedCollection reverseDo: [:each | self addFirst: each].\r\t^anOrderedCollection"},{"name":"add:","linesOfCode":9,"sourceCode":"add: newObject\r\t\"Add a new object at the end of the collection, and returns the object itself\"\r\t\"((OrderedCollection new add: 42; yourself) add: 43; yourself) asArray >>> #(42 43)\"\r\t\r\t\"Add returns the object itself\"\r\t\"(OrderedCollection new add: 42) >>> 42\"\r\t\r\t\"You may want to use yourself to return the collection itself\"\r\t\"(OrderedCollection new add: 42; yourself) class >>> OrderedCollection\"\r\t\"(OrderedCollection new add: 42; yourself) size >>> 1\"\r\t^self addLast: newObject"},{"name":"collector","linesOfCode":2,"sourceCode":"collector  \"Private\"\r\t^ array"},{"name":"removeIndex:","linesOfCode":12,"sourceCode":"removeIndex: removedIndex\r  \"  removedIndex is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.\r    Never use this method in your code, it is meant for private use by OrderedCollection only.\r     The method for public use is:\r        #removeAt: \"\r\r\tarray \r\t\treplaceFrom: removedIndex \r\t\tto: lastIndex - 1 \r\t\twith: array \r\t\tstartingAt: removedIndex+1.\r\tarray at: lastIndex put: nil.\r\tlastIndex := lastIndex - 1."},{"name":"postCopy","linesOfCode":2,"sourceCode":"postCopy\r\tarray := array copy"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #OrderedCollection earlyFields: self size fields: [self collect: [:each | each encodeGraphForMessagePackWith: graphEncoder] as: Array]"},{"name":"remove:ifAbsent:","linesOfCode":11,"sourceCode":"remove: oldObject ifAbsent: absentBlock\r\r\t| index |\r\tindex := firstIndex.\r\t[index <= lastIndex]\r\t\twhileTrue: \r\t\t\t[oldObject = (array at: index)\r\t\t\t\tifTrue: \r\t\t\t\t\t[self removeIndex: index.\r\t\t\t\t\t^ oldObject]\r\t\t\t\tifFalse: [index := index + 1]].\r\t^ absentBlock value"},{"name":"removeAt:","linesOfCode":5,"sourceCode":"removeAt: index\r\t| removed |\r\tremoved := self at: index.\r\tself removeIndex: index + firstIndex - 1.\r\t^removed"},{"name":"addAllLast:","linesOfCode":5,"sourceCode":"addAllLast: aCollection \r\t\"Add each element of aCollection at the end of the receiver. \r\tAnswer aCollection.\"\r\r\taCollection do: [:each | self addLast: each].\r\t^aCollection"},{"name":"removeAll","linesOfCode":4,"sourceCode":"removeAll\r\t\"remove all the elements from this collection.\r\tKeep same amount of storage\"\r\t\r\tself setCollection: (self class arrayType new: array size)"},{"name":"removeLast:","linesOfCode":12,"sourceCode":"removeLast: n \r\t\"Remove last n object into an array with last in last position\"\r\t| list |\r\tlist := self class arrayType new: n.\r\tn\r\t\tto: 1\r\t\tby: -1\r\t\tdo:\r\t\t\t[ : i | list\r\t\t\t\tat: i\r\t\t\t\tput: self removeLast ].\r\t^ list"},{"name":"addFirst:","linesOfCode":6,"sourceCode":"addFirst: newObject \r\t\"Add newObject to the beginning of the receiver. Answer newObject.\"\r\r\tfirstIndex = 1 ifTrue: [self makeRoomAtFirst].\r\tfirstIndex := firstIndex - 1.\r\tarray at: firstIndex put: newObject.\r\t^ newObject"},{"name":"removeLast","linesOfCode":9,"sourceCode":"removeLast\r\t\"Remove the last element of the receiver and answer it. If the receiver is \r\tempty, create an error notification.\"\r\t| lastObject |\r\tself emptyCheck.\r\tlastObject := array at: lastIndex.\r\tarray at: lastIndex put: nil.\r\tlastIndex := lastIndex - 1.\r\t^ lastObject"},{"name":"growAtFirst","linesOfCode":16,"sourceCode":"growAtFirst\r\t\"Add new empty slots to the front of array, while keeping the empty slots at the end.\"\r\t\r\t\"OrderedCollection new capacity >>> 10\"\r\t\"(OrderedCollection new growAtFirst; capacity) >>> 20\"\r\t\r\r\t| newArray newFirstIndex newLastIndex |\r\tnewArray := self class arrayType new: (array size * 2 max: 1).\r\tnewFirstIndex := newArray size - array size + firstIndex.\r\tnewLastIndex := newFirstIndex + lastIndex - firstIndex.\r\tnewArray \r\t\treplaceFrom: newFirstIndex\r\t\tto: newLastIndex\r\t\twith: array\r\t\tstartingAt: firstIndex.\r\tarray := newArray.\r\tfirstIndex := newFirstIndex.\r\tlastIndex := newLastIndex"},{"name":"sort:","linesOfCode":10,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tarray\r\t\tmergeSortFrom: firstIndex\r\t\tto: lastIndex \r\t\tsrc: array shallowCopy \r\t\tdst: array \r\t\tby: aSortBlock"},{"name":"ensureBoundsFrom:to:","linesOfCode":5,"sourceCode":"ensureBoundsFrom: fromIndex to: toIndex\r\t(fromIndex < 1)\r\t\tifTrue: [^self errorSubscriptBounds: fromIndex].\r\t(toIndex + firstIndex - 1 > lastIndex)\r\t\tifTrue: [^self errorSubscriptBounds: toIndex]."},{"name":"copyFrom:to:","linesOfCode":4,"sourceCode":"copyFrom: startIndex to: endIndex \r\t\"Answer a copy of the receiver that contains elements from position\r\tstartIndex to endIndex.\"\r\r\t^self shallowCopy postCopyFrom: startIndex to: endIndex"},{"name":"fuelAccept:","linesOfCode":5,"sourceCode":"fuelAccept: aGeneralMapper\r\t\"Since we have subclasses of OrderedCollection that behave differently, we cannot use the visitSimpleCollection: for all of them.\"\r\t^ (self class == OrderedCollection ) \r\t\tifTrue: [ aGeneralMapper visitSimpleCollection: self ]\r\t\tifFalse: [ super fuelAccept: aGeneralMapper ] \r\t"},{"name":"addLast:","linesOfCode":6,"sourceCode":"addLast: newObject \r\t\"Add newObject to the end of the receiver. Answer newObject.\"\r\r\tlastIndex = array size ifTrue: [self makeRoomAtLast].\r\tlastIndex := lastIndex + 1.\r\tarray at: lastIndex put: newObject.\r\t^ newObject"},{"name":"growAtLast","linesOfCode":12,"sourceCode":"growAtLast\r\t\"Add new empty slots to the end of array, while keeping the empty slots at the front.\"\r\r\t\"OrderedCollection new capacity >>> 10\"\r\t\"(OrderedCollection new growAtLast; capacity) >>> 20\"\r\r\t| newArray |\r\tnewArray := self class arrayType new: (array size * 2 max: 1).\r\tnewArray \r\t\treplaceFrom: firstIndex\r\t\tto: lastIndex\r\t\twith: array\r\t\tstartingAt: firstIndex.\r\tarray := newArray"},{"name":"removeFirst:","linesOfCode":11,"sourceCode":"removeFirst: n \r\t\"Remove first n object into an array\"\r\t| list |\r\tlist := self class arrayType new: n.\r\t1\r\t\tto: n\r\t\tdo:\r\t\t\t[ : i | list\r\t\t\t\tat: i\r\t\t\t\tput: self removeFirst ].\r\t^ list"},{"name":"add:afterIndex:","linesOfCode":6,"sourceCode":"add: newObject afterIndex: index \r\t\"Add the argument, newObject, as an element of the receiver. Put it in \r\tthe sequence just after index. Answer newObject.\"\r\t(index between: 0 and: self size) ifFalse:[^self errorSubscriptBounds: index].\r\tself insert: newObject before: firstIndex + index.\r\t^ newObject"},{"name":"removeFirst","linesOfCode":9,"sourceCode":"removeFirst\r\t\"Remove the first element of the receiver and answer it. If the receiver is \r\tempty, create an error notification.\"\r\t| firstObject |\r\tself emptyCheck.\r\tfirstObject := array at: firstIndex.\r\tarray at: firstIndex put: nil.\r\tfirstIndex := firstIndex + 1.\r\t^ firstObject"},{"name":"select:","linesOfCode":9,"sourceCode":"select: selectBlock \r\t\"Optimized version of Collection>>#select: \"\r\r\t| newCollection element |\r\t\r\tnewCollection := self copyEmpty.\r\t\r\tfirstIndex to: lastIndex do: [ :index |\r\t\t(selectBlock value: (element := array at: index))\r\t\t\tifTrue: [ newCollection addLast: element ]].\r\t\t\r\t^ newCollection"},{"name":"at:put:","linesOfCode":10,"sourceCode":"at: anInteger put: anObject\r\t\"Put anObject at element index anInteger. at:put: cannot be used to\r\tappend, front or back, to an ordered collection; it is used by a\r\tknowledgeable client to replace an element.\"\r\r\t| index |\r\tanInteger < 1\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t(index := anInteger + firstIndex - 1) > lastIndex\r\t\tifTrue: [ self errorSubscriptBounds: anInteger ].\r\t^ array at: index put: anObject"}],"meta":{"name":"OrderedCollection class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: anInteger \r\t^ self basicNew setCollection: (self arrayType new: anInteger)"},{"name":"new:streamContents:","linesOfCode":2,"sourceCode":"new: size streamContents: aBlock\r\t^ self withAll: (super new: size streamContents: aBlock)"},{"name":"arrayType","linesOfCode":2,"sourceCode":"arrayType\r\t^ Array"},{"name":"ofSize:","linesOfCode":8,"sourceCode":"ofSize: n\r\t\"Create a new collection of size n with nil as its elements.\r\tThis method exists because OrderedCollection new: n creates an\r\tempty collection,  not one of size n.\"\r\t| collection |\r\tcollection := self new: n.\r\tcollection setContents: (collection collector).\r\t^ collection\r"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ Array"},{"name":"new:withAll:","linesOfCode":2,"sourceCode":"new: anInteger withAll: anObject\r\t^ self basicNew setContents: (self arrayType new: anInteger withAll: anObject)"},{"name":"compactAllInstances","linesOfCode":2,"sourceCode":"compactAllInstances\r\tself allInstances do: #compact"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^ self new: 10"},{"name":"newFrom:","linesOfCode":9,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r\t| newCollection |\r\tnewCollection := self new: aCollection size.\r\tnewCollection addAll: aCollection.\r\t^newCollection\r\r\"\tOrderedCollection newFrom: {1. 2. 3}\r\t{1. 2. 3} as: OrderedCollection\r\t{4. 2. 7} as: SortedCollection\r\""},{"name":"cleanUp:","linesOfCode":3,"sourceCode":"cleanUp: aggressive\r\t\"Rehash all instances when cleaning aggressively\"\r\r\taggressive ifTrue: [self compactAll]."},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #OrderedCollection ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext do: [ :eachValue |\r\t\t\tresult add: eachValue\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"},{"name":"compactAll","linesOfCode":4,"sourceCode":"compactAll\r\t\"OrderedCollection compactAll\"\t\r\t\t\r\tself allSubclassesDo: #compactAllInstances"}],"meta":null}},{"name":"Heap","instanceVariables":[{"name":"array"},{"name":"tally"},{"name":"sortBlock"},{"name":"indexUpdateBlock"}],"methods":[{"name":"removeFirstOrNil","linesOfCode":4,"sourceCode":"removeFirstOrNil\r\t\"Remove the first element from the receiver\"\r\tself isEmpty ifTrue:  [ ^nil ].\r\t^self privateRemoveAt: 1"},{"name":"growTo:","linesOfCode":6,"sourceCode":"growTo: newSize\r\t\"Grow to the requested size.\"\r\t| newArray |\r\tnewArray := Array new: (newSize max: tally).\r\tnewArray replaceFrom: 1 to: array size with: array startingAt: 1.\r\tarray := newArray"},{"name":"fullySort","linesOfCode":5,"sourceCode":"fullySort\r\t\"Fully sort the heap.\r\tThis method preserves the heap invariants and can thus be sent safely\"\r\tself privateReverseSort.\r\t1 to: tally // 2 do: [:i | array swap: i with: 1 + tally - i]"},{"name":"indexUpdateBlock:","linesOfCode":2,"sourceCode":"indexUpdateBlock: aBlockOrNil\r\r\tindexUpdateBlock := aBlockOrNil.\r\r"},{"name":"grow","linesOfCode":3,"sourceCode":"grow\r\t\"Become larger.\"\r\tself growTo: self size + self growSize."},{"name":"isEmpty","linesOfCode":3,"sourceCode":"isEmpty\r\t\"Answer whether the receiver contains any elements.\"\r\t^tally = 0"},{"name":"sort","linesOfCode":3,"sourceCode":"sort\r\t\"Sort this collection into ascending order using the '<=' operator.\"\r\r\tself sort: [:a :b | a <= b]"},{"name":"add:","linesOfCode":7,"sourceCode":"add: anObject\r\t\"Include newObject as one of the receiver's elements. Answer newObject.\"\r\ttally = array size ifTrue:[self grow].\r\tarray at: (tally := tally + 1) put: anObject.\r\tself updateObjectIndex: tally.\r\tself upHeap: tally.\r\t^anObject"},{"name":"sorts:before:","linesOfCode":6,"sourceCode":"sorts: element1 before: element2\r\t\"Return true if element1 should be sorted before element2.\r\tThis method defines the sort order in the receiver\"\r\t^sortBlock == nil\r\t\tifTrue:[element1 <= element2]\r\t\tifFalse:[sortBlock value: element1 value: element2]."},{"name":"trim","linesOfCode":3,"sourceCode":"trim\r\t\"Remove any empty slots in the receiver.\"\r\tself growTo: self size."},{"name":"updateObjectIndex:","linesOfCode":4,"sourceCode":"updateObjectIndex: index\r\t\"If indexUpdateBlock is not nil, notify the object at index of its new position in the heap array.\"\r\tindexUpdateBlock ifNotNil: [\r\t\tindexUpdateBlock value: (array at: index) value: index]"},{"name":"collect:","linesOfCode":2,"sourceCode":"collect: aBlock\r\t^self collect: aBlock as: Array"},{"name":"=","linesOfCode":7,"sourceCode":"= anObject\r\t\"Heap are considered equals only if they have same sort order and same elements.\"\r\r\tself == anObject ifTrue: [^true].\r\tanObject isHeap ifFalse: [^false].\r\tself sortBlock = anObject sortBlock ifFalse: [^false].\r\tself size = anObject size ifFalse: [^false].\r\t^(self asArray sort: sortBlock) = (anObject asArray sort: sortBlock)"},{"name":"privateReverseSort","linesOfCode":10,"sourceCode":"privateReverseSort\r\t\"Arrange to have the array sorted in reverse order.\r\tWARNING: this method breaks the heap invariants. It's up to the sender to restore them afterwards.\"\r\t| oldTally |\r\toldTally := tally.\r\t[tally > 1] whileTrue:\r\t\t [array swap: 1 with: tally.\r\t\ttally := tally - 1.\r\t\t self downHeapSingle: 1].\r\ttally := oldTally"},{"name":"growSize","linesOfCode":3,"sourceCode":"growSize\r\t\"Return the size by which the receiver should grow if there are no empty slots left.\"\r\t^array size max: 5"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tarray := array copy"},{"name":"upHeap:","linesOfCode":14,"sourceCode":"upHeap: anIndex\r\t\"Check the heap upwards for correctness starting at anIndex.\r\t Everything below anIndex is ok.\"\r\t| value k kDiv2 tmp |\r\tanIndex = 0 ifTrue:[^self].\r\tk := anIndex.\r\tvalue := array at: anIndex.\r\t[ (k > 1) and:[self sorts: value before: (tmp := array at: (kDiv2 := k bitShift: -1))] ] \r\t\twhileTrue:[\r\t\t\tarray at: k put: tmp.\r\t\t\tself updateObjectIndex: k.\r\t\t\tk := kDiv2].\r\tarray at: k put: value.\r\tself updateObjectIndex: k."},{"name":"downHeap:","linesOfCode":24,"sourceCode":"downHeap: anIndex\r\t\"Check the heap downwards for correctness starting at anIndex.\r\t Everything above (i.e. left of) anIndex is ok.\"\r\t| value k n j |\r\tanIndex = 0 ifTrue:[^self].\r\tn := tally bitShift: -1.\r\tk := anIndex.\r\tvalue := array at: anIndex.\r\t[k <= n] whileTrue:[\r\t\tj := k + k.\r\t\t\"use max(j,j+1)\"\r\t\t(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])\r\t\t\t\tifTrue:[ j := j + 1].\r\t\t\"check if position k is ok\"\r\t\t(self sorts: value before: (array at: j)) \r\t\t\tifTrue:[\t\"yes -> break loop\"\r\t\t\t\t\tn := k - 1]\r\t\t\tifFalse:[\t\"no -> make room at j by moving j-th element to k-th position\"\r\t\t\t\t\tarray at: k put: (array at: j).\r\t\t\t\t\tself updateObjectIndex: k.\r\t\t\t\t\t\"and try again with j\"\r\t\t\t\t\tk := j]].\r\tarray at: k put: value.\r\tself updateObjectIndex: k."},{"name":"privateRemoveAt:","linesOfCode":11,"sourceCode":"privateRemoveAt: index\r\t\"Remove the element at the given index and make sure the sorting order is okay\"\r\t| removed |\r\tremoved := array at: index.\r\tarray at: index put: (array at: tally).\r\tarray at: tally put: nil.\r\ttally := tally - 1.\r\tindex > tally ifFalse:[\r\t\t\"Use #downHeapSingle: since only one element has been removed\"\r\t\tself downHeapSingle: index].\r\t^removed"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver without any of the receiver's elements.\"\r\r\t^self class sortBlock: sortBlock"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock\r\t\"Evaluate aBlock with each of the receiver's elements as the argument.\"\r\t1 to: tally do:[:i| aBlock value: (array at: i)]"},{"name":"sortBlock","linesOfCode":2,"sourceCode":"sortBlock\r\t^ sortBlock ifNil: [ sortBlock := self defaultSortBlock ]"},{"name":"remove:ifAbsent:","linesOfCode":8,"sourceCode":"remove: oldObject ifAbsent: aBlock\r\t\"Remove oldObject as one of the receiver's elements. If several of the \r\telements are equal to oldObject, only one is removed. If no element is \r\tequal to oldObject, answer the result of evaluating anExceptionBlock. \r\tOtherwise, answer the argument, oldObject.\"\r\t1 to: tally do:[:i| \r\t\t(array at: i) = oldObject ifTrue:[^self privateRemoveAt: i]].\r\t^aBlock value"},{"name":"sortBlock:","linesOfCode":3,"sourceCode":"sortBlock: aBlock\r\tsortBlock := aBlock.\r\tself reSort."},{"name":"sorted:","linesOfCode":6,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted by aSortBlockOrNil. The block should take two arguments and return true if \rthe first element should preceed the second one. If aSortBlock is nil then <= is used for \rcomparison.\"\r\t\r\t^self copy sort: aSortBlockOrNil"},{"name":"defaultSortBlock","linesOfCode":2,"sourceCode":"defaultSortBlock\r\t^ self class defaultSortBlock"},{"name":"isHeap","linesOfCode":2,"sourceCode":"isHeap\r\r\t^ true"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r\r\tarray atAllPut: nil.\r\ttally := 0"},{"name":"size","linesOfCode":3,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t^ tally"},{"name":"downHeapSingle:","linesOfCode":19,"sourceCode":"downHeapSingle: anIndex\r\t\"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster.\"\r\t| value k n j |\r\tanIndex = 0 ifTrue:[^self].\r\tn := tally bitShift: -1.\r\tk := anIndex.\r\tvalue := array at: anIndex.\r\t[k <= n] whileTrue:[\r\t\tj := k + k.\r\t\t\"use max(j,j+1)\"\r\t\t(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])\r\t\t\t\tifTrue:[\tj := j + 1].\r\t\tarray at: k put: (array at: j).\r\t\tself updateObjectIndex: k.\r\t\t\"and try again with j\"\r\t\tk := j].\r\tarray at: k put: value.\r\tself updateObjectIndex: k.\r\tself upHeap: k"},{"name":"first","linesOfCode":3,"sourceCode":"first\r\t\"Return the first element in the receiver\"\r\t^array at: 1"},{"name":"mergeFirst:middle:last:into:by:","linesOfCode":21,"sourceCode":"mergeFirst: first middle: middle last: last into: dst by: aBlock\r\t\"Private. Merge the sorted ranges [first..middle] and [middle+1..last] \r\tof the receiver into the range [first..last] of dst.\"\r\r\t| i1 i2 val1 val2 out |\r\ti1 := first.\r\ti2 := middle + 1.\r\tval1 := self at: i1.\r\tval2 := self at: i2.\r\tout := first - 1.  \"will be pre-incremented\"\r\r\t\"select 'lower' half of the elements based on comparator\"\r\t[(i1 <= middle) and: [i2 <= last]] whileTrue:\r\t\t[(aBlock value: val1 value: val2)\r\t\t\tifTrue: [dst at: (out := out + 1) put: val1.\r\t\t\t\t\tval1 := self at: (i1 := i1 + 1)]\r\t\t\tifFalse: [dst at: (out := out + 1) put: val2.\r\t\t\t\t\ti2 := i2 + 1.\r\t\t\t\t\ti2 <= last ifTrue: [val2 := self at: i2]]].\r\r\t\"copy the remaining elements\"\r\ti1 <= middle\r\t\tifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]\r\t\tifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]"},{"name":"mergeSortFrom:to:by:","linesOfCode":20,"sourceCode":"mergeSortFrom: startIndex to: stopIndex by: aBlock\r\t\"Sort the given range of indices using the mergesort algorithm.\r\tMergesort is a worst-case O(N log N) sorting algorithm that usually\r\tdoes only half as many comparisons as heapsort or quicksort.\"\r\r\t\"Details: recursively split the range to be sorted into two halves,\r\tmergesort each half, then merge the two halves together. An extra \r\tcopy of the data is used as temporary storage and successive merge \r\tphases copy data back and forth between the receiver and this copy.\r\tThe recursion is set up so that the final merge is performed into the\r\treceiver, resulting in the receiver being completely sorted.\"\r\r\tself size <= 1 ifTrue: [^ self].  \"nothing to do\"\r\tstartIndex = stopIndex ifTrue: [^ self].\r\t[startIndex >= 1 and: [startIndex < stopIndex]] assert. \"bad start index\"\r\t[stopIndex <= self size] assert. \"bad stop index\"\r\tself\r\t\tmergeSortFrom: startIndex\r\t\tto: stopIndex \r\t\tsrc: self copy \r\t\tdst: self \r\t\tby: aBlock"},{"name":"isSortedBy:","linesOfCode":11,"sourceCode":"isSortedBy: aBlock\r\t\"Return true if the receiver is sorted by the given criterion.\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\t(aBlock value: lastElm value: elm) ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"array","linesOfCode":2,"sourceCode":"array\r\t^array"},{"name":"isSorted","linesOfCode":12,"sourceCode":"isSorted\r\t\"Return true if the receiver is sorted by the given criterion.\r\tOptimization for isSortedBy: [:a :b | a <= b].\"\r\r\t| lastElm elm |\r\tself isEmpty ifTrue: [^ true].\r\tlastElm := self first.\r\t2 to: self size do: \r\t\t[:index | \r\t\telm := self at: index.\r\t\tlastElm <= elm ifFalse: [^ false].\r\t\tlastElm := elm].\r\t^ true"},{"name":"sort:","linesOfCode":7,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r\r\tself\r\t\tmergeSortFrom: 1\r\t\tto: self size\r\t\tby: aSortBlock"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index\r\t\"Heap are not designed to be accessed sequentially.\"\r\t\r\tself shouldNotImplement."},{"name":"mergeSortFrom:to:src:dst:by:","linesOfCode":9,"sourceCode":"mergeSortFrom: first to: last src: src dst: dst by: aBlock\r\t\"Private. Split the range to be sorted in half, sort each half, and \r\tmerge the two half-ranges into dst.\"\r\r\t| middle |\r\tfirst = last ifTrue: [^ self].\r\tmiddle := (first + last) // 2.\r\tself mergeSortFrom: first to: middle src: dst dst: src by: aBlock.\r\tself mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.\r\tsrc mergeFirst: first middle: middle last: last into: dst by: aBlock"},{"name":"reSort","linesOfCode":4,"sourceCode":"reSort\r\t\"Resort the entire heap\"\r\tself isEmpty ifTrue:[^self].\r\ttally // 2 to: 1 by: -1 do:[:i| self downHeap: i]."},{"name":"setCollection:","linesOfCode":3,"sourceCode":"setCollection: aCollection\r\tarray := aCollection.\r\ttally := 0."},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t\"Return a new sequenceable collection which contains the same elements as self but its \relements are sorted in ascending order using the #'<=' operator.\"\r\t\r\t^self sorted: [ :a :b| a <= b ]"},{"name":"removeFirst","linesOfCode":4,"sourceCode":"removeFirst\r\t\"Remove the first element from the receiver\"\r\tself emptyCheck.\r\t^self privateRemoveAt: 1"},{"name":"at:put:","linesOfCode":4,"sourceCode":"at: index put: newObject\r\t\"Heap are not designed to be accessed sequentially.\r\tPlease consider using #add: instead.\"\r\t\r\tself shouldNotImplement."},{"name":"setCollection:tally:","linesOfCode":3,"sourceCode":"setCollection: aCollection tally: newTally\r\tarray := aCollection.\r\ttally := newTally."}],"meta":{"name":"Heap class","instanceVariables":[{"name":"sortBlock"}],"methods":[{"name":"defaultSortBlock","linesOfCode":5,"sourceCode":"defaultSortBlock\r\t\"Cache the default sort block here. Since the sortBlock is used to compare instances, a single instance \r\t for the default block helps us.\"\r\t^ sortBlock ifNil: [ \r\t\tsortBlock := [ :a :b | a <= b]]"},{"name":"new:","linesOfCode":2,"sourceCode":"new: n\r\t^super new setCollection: (Array new: n)"},{"name":"heapExample","linesOfCode":26,"sourceCode":"heapExample\t\r\t\"self heapExample\"\r\t\"Create a sorted collection of numbers, remove the elements\r\tsequentially and add new objects randomly.\r\tNote: This is the kind of benchmark a heap is designed for.\"\r\t\r\t^ String streamContents: [ :str | \r\t\t| n rnd array time sorted |\r\t\tn := 5000. \"# of elements to sort\"\r\t\trnd := Random new.\r\t\tarray := (1 to: n) collect:[:i| rnd next].\r\t\t\"First, the heap version\"\r\t\ttime := Time millisecondsToRun:[\r\t\tsorted := self withAll: array.\r\t\t\t1 to: n do:[:i| \r\t\t\t\tsorted removeFirst.\r\t\t\t\tsorted add: rnd next].\r\t].\r\tstr << 'Time for Heap: ' << time printString <<' msecs '; cr.\r\t\"The quicksort version\"\r\ttime := Time millisecondsToRun:[\r\t\tsorted := SortedCollection withAll: array.\r\t\t1 to: n do:[:i| \r\t\t\tsorted removeFirst.\r\t\t\tsorted add: rnd next].\r\t].\r\tstr << 'Time for SortedCollection: '<< time printString << ' msecs'.]\r"},{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^self new: 10"},{"name":"sortBlock:","linesOfCode":3,"sourceCode":"sortBlock: aBlock\r\t\"Create a new heap sorted by the given block\"\r\t^self new sortBlock: aBlock"},{"name":"heapSortExample","linesOfCode":27,"sourceCode":"heapSortExample\t\r\t\"self heapSortExample\"\r\t\"Sort a random collection of Floats and compare the results with\r\tSortedCollection (using the quick-sort algorithm) and \r\tArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm).\"\r\t\r\t^ String streamContents: [ :str | \r\t\t| n rnd array  time sorted |\r\t\tn := 10000. \"# of elements to sort\"\r\t\trnd := Random new.\r\t\tarray := (1 to: n) collect:[:i| rnd next].\r\t\t\"First, the heap version\"\r\t\ttime := Time millisecondsToRun:[\r\t\t\tsorted := Heap withAll: array.\r\t\t\t1 to: n do:[:i| sorted removeFirst].\r\t\t].\r\tstr << 'Time for heap-sort: ' << time printString << ' msecs ';cr.\r\t\"The quicksort version\"\r\ttime := Time millisecondsToRun:[\r\t\tsorted := SortedCollection withAll: array.\r\t].\r\tstr << 'Time for quick-sort: ' << time printString <<' msecs '; cr.\r\t\"The merge-sort version\"\r\ttime := Time millisecondsToRun:[\r\t\tarray mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].\r\t].\r\tstr << 'Time for merge-sort: ' << time printString  << ' msecs'; cr.\r\t]"},{"name":"withAll:","linesOfCode":6,"sourceCode":"withAll: aCollection\r\t\"Create a new heap with all the elements from aCollection\"\r\t^(self basicNew)\r\t\tsetCollection: aCollection asArray copy tally: aCollection size;\r\t\treSort;\r\t\tyourself"},{"name":"withAll:sortBlock:","linesOfCode":6,"sourceCode":"withAll: aCollection sortBlock: aBlock\r\t\"Create a new heap with all the elements from aCollection\"\r\t^(self basicNew)\r\t\tsetCollection: aCollection asArray copy tally: aCollection size;\r\t\tsortBlock: aBlock;\r\t\tyourself"}],"meta":null}},{"name":"SparseLargeTable","instanceVariables":[{"name":"base"},{"name":"size"},{"name":"chunkSize"},{"name":"defaultValue"}],"methods":[{"name":"noCheckAt:","linesOfCode":7,"sourceCode":"noCheckAt: index\r\t| chunkIndex t |\r\r\tchunkIndex := index - base // chunkSize + 1.\r\t(chunkIndex > self basicSize or: [chunkIndex < 1]) ifTrue: [^ defaultValue].\r\tt := self basicAt: chunkIndex.\r\tt ifNil: [^ defaultValue].\r\t^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize))\r"},{"name":"printElementsOn:","linesOfCode":6,"sourceCode":"printElementsOn: aStream\r\t| element |\r\taStream nextPut: $(.\r\tbase to: size do: [:index | element := self at: index. aStream print: element; space].\r\tself isEmpty ifFalse: [aStream skip: -1].\r\taStream nextPut: $)\r"},{"name":"arrayClass","linesOfCode":2,"sourceCode":"arrayClass\r\r\t^(self basicAt: 1) class\r"},{"name":"chunkSize","linesOfCode":2,"sourceCode":"chunkSize\r\r\t^chunkSize\r"},{"name":"allDefaultValueSubtableAt:","linesOfCode":8,"sourceCode":"allDefaultValueSubtableAt: index\r\r\t| t |\r\tt := self basicAt: index.\r\tt ifNil: [^ true].\r\tt do: [:e |\r\t\te ~= defaultValue ifTrue: [^ false].\r\t].\r\t^ true.\r"},{"name":"base","linesOfCode":2,"sourceCode":"base\r\r\t^ base.\r"},{"name":"noCheckAt:put:","linesOfCode":7,"sourceCode":"noCheckAt: index put: value\r\r\t| chunkIndex t |\r\tchunkIndex := index - base // chunkSize + 1.\r\tchunkIndex > self basicSize ifTrue: [^ value].\r\tt :=  self basicAt: chunkIndex.\r\tt ifNil: [^ value].\r\t^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize)) put: value\r"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\t1 to: self basicSize do: [:i | self basicAt: i put: (self basicAt: i) copy]"},{"name":"similarInstance:","linesOfCode":5,"sourceCode":"similarInstance: newSize\r\r\t^self class\r\t\tnew: newSize \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"privateSize:","linesOfCode":2,"sourceCode":"privateSize: s\r\r\tsize := s.\r"},{"name":"speciesNew","linesOfCode":5,"sourceCode":"speciesNew\r\r\t^self species\r\t\tnew: self size \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver that contains no elements.\"\r\t^self speciesNew: 0\r"},{"name":"similarSpeciesInstance","linesOfCode":2,"sourceCode":"similarSpeciesInstance\r\r\t^self similarInstance\r"},{"name":"speciesNew:","linesOfCode":5,"sourceCode":"speciesNew: newSize\r\r\t^self species\r\t\tnew: newSize \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"similarSpeciesInstance:","linesOfCode":2,"sourceCode":"similarSpeciesInstance: newSize\r\r\t^self similarInstance: newSize\r"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\r\t^size\r"},{"name":"analyzeSpaceSaving","linesOfCode":18,"sourceCode":"analyzeSpaceSaving\r\r\t| total elems tablesTotal nonNilTables |\r\ttotal := size - base + 1.\r\telems := 0.\r\tbase to: size do: [:i | (self at: i) ~= defaultValue ifTrue: [elems := elems + 1]].\r\ttablesTotal := self basicSize.\r\tnonNilTables := 0.\r\t1 to: self basicSize do: [:i | (self basicAt: i) ifNotNil: [nonNilTables := nonNilTables + 1]].\r\r\t^ String streamContents: [:strm |\r\t\tstrm nextPutAll: 'total: '.\r\t\tstrm nextPutAll: total printString.\r\t\tstrm nextPutAll: ' elements: '.\r\t\tstrm nextPutAll: elems printString.\r\t\tstrm nextPutAll: ' tables: '.\r\t\tstrm nextPutAll: tablesTotal printString.\r\t\tstrm nextPutAll: ' non-nil: '.\r\t\tstrm nextPutAll: nonNilTables printString.\r\t].\r\r"},{"name":"initChunkSize:size:arrayClass:base:defaultValue:","linesOfCode":12,"sourceCode":"initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d\r\r\t| lastChunkSize |\r\tchunkSize := aChunkSize.\r\tsize := aSize.\r\tbase := b.\r\tdefaultValue := d.\r\t1 to: (self basicSize - 1) do: [ :in | self basicAt: in put: (aClass new: chunkSize withAll: defaultValue) ].\r\tlastChunkSize := size \\\\ chunkSize.\r\tlastChunkSize = 0 ifTrue: [lastChunkSize := chunkSize].\r\tsize = 0 \r\t\tifTrue: [self basicAt: 1 put: (aClass new: 0)]\r\t\tifFalse: [self basicAt: self basicSize put: (aClass new: lastChunkSize withAll: defaultValue)].\r"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\r\t(#(String) includes: self arrayClass name) \r\t\tifTrue: [^self storeOn: aStream].\r\t^super printOn: aStream\r"},{"name":"zapDefaultOnlyEntries","linesOfCode":4,"sourceCode":"zapDefaultOnlyEntries\r\r\t1 to: self basicSize do: [:i |\r\t\t(self allDefaultValueSubtableAt: i) ifTrue: [self basicAt: i put: nil].\r\t].\r"},{"name":"similarInstance","linesOfCode":5,"sourceCode":"similarInstance\r\r\t^self class\r\t\tnew: self size \r\t\tchunkSize: self chunkSize \r\t\tarrayClass: self arrayClass\r"},{"name":"at:","linesOfCode":3,"sourceCode":"at: index\r\r\tself pvtCheckIndex: index.\r\t^self noCheckAt: index.\r"},{"name":"storeOn:","linesOfCode":12,"sourceCode":"storeOn: aStream\r\r\t| x |\r\t(#(String) includes: self arrayClass name) ifTrue: \r\t\t[aStream nextPut: $'.\r\t\t1 to: self size do:\r\t\t\t[:i |\r\t\t\taStream nextPut: (x := self at: i).\r\t\t\tx == $' ifTrue: [aStream nextPut: x]].\r\t\taStream nextPutAll: ''' asLargeArrayChunkSize: '.\r\t\taStream nextPutAll: self chunkSize asString.\r\t\t^self].\r\t^super storeOn: aStream\r"},{"name":"pvtCheckIndex:","linesOfCode":4,"sourceCode":"pvtCheckIndex: index \r\r\tindex isInteger ifFalse: [self errorNonIntegerIndex].\r\tindex < 1 ifTrue: [self errorSubscriptBounds: index].\r\tindex > size ifTrue: [self errorSubscriptBounds: index].\r"},{"name":"at:put:","linesOfCode":3,"sourceCode":"at: index put: value\r\t\r\tself pvtCheckIndex: index.\r\t^self noCheckAt: index put: value\r"}],"meta":{"name":"SparseLargeTable class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":2,"sourceCode":"new: size\r\r\t^self new: size chunkSize: self defaultChunkSize\r"},{"name":"new:chunkSize:arrayClass:base:defaultValue:","linesOfCode":7,"sourceCode":"new: size chunkSize: chunkSize arrayClass: aClass base: b defaultValue: d\r\r\t| basicSize |\r\t(basicSize := ((size - 1) // chunkSize) + 1) = 0\r\t\tifTrue: [basicSize := 1].\r\t^(self basicNew: basicSize)\r\t\tinitChunkSize: chunkSize size: size arrayClass: aClass base: b defaultValue: d;\r\t\tyourself\r"},{"name":"new:chunkSize:arrayClass:base:","linesOfCode":2,"sourceCode":"new: size chunkSize: chunkSize arrayClass: aClass base: b\r\r\t^self new: size chunkSize: chunkSize arrayClass: Array base: 1 defaultValue: nil.\r"},{"name":"new:chunkSize:arrayClass:","linesOfCode":2,"sourceCode":"new: size chunkSize: chunkSize arrayClass: aClass\r\r\t^self new: size chunkSize: chunkSize arrayClass: Array base: 1.\r"},{"name":"new:chunkSize:","linesOfCode":2,"sourceCode":"new: size chunkSize: chunkSize\r\r\t^self new: size chunkSize: chunkSize arrayClass: Array\r"},{"name":"defaultChunkSize","linesOfCode":2,"sourceCode":"defaultChunkSize\r\r\t^100"},{"name":"defaultChunkSizeForFiles","linesOfCode":2,"sourceCode":"defaultChunkSizeForFiles\r\r\t^8000"}],"meta":null}},{"name":"OrderedIdentityDictionary","instanceVariables":[],"methods":[{"name":"indexOfKey:ifAbsent:","linesOfCode":2,"sourceCode":"indexOfKey: aKey ifAbsent: aBlock\r\t^ self identityIndexOfKey: aKey ifAbsent: aBlock"},{"name":"orderedKeysIndexOf:","linesOfCode":2,"sourceCode":"orderedKeysIndexOf: aKey\r\t^ orderedKeys identityIndexOf: aKey"},{"name":"dictionaryClass","linesOfCode":2,"sourceCode":"dictionaryClass\r\t^ IdentityDictionary"}],"meta":{"name":"OrderedIdentityDictionary class","instanceVariables":[],"methods":[],"meta":null}},{"name":"SharedQueue","instanceVariables":[{"name":"monitor"},{"name":"items"}],"methods":[{"name":"nextPut:","linesOfCode":5,"sourceCode":"nextPut: anObject\r\tmonitor critical: [\r\t\titems addLast: anObject.\r\t\tmonitor signal].\r\t^ anObject\r"},{"name":"isEmpty","linesOfCode":2,"sourceCode":"isEmpty\r\t^monitor critical: [ items isEmpty ]"},{"name":"removeAll","linesOfCode":3,"sourceCode":"removeAll\r       monitor critical: [\r\t\titems removeAll ]."},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^monitor critical: [ items size ]"},{"name":"printOn:","linesOfCode":6,"sourceCode":"printOn: aStream\r\taStream \r\t\tnextPutAll: self class name;\r\t\tnextPutAll: ' with ';\r\t\tprint: items size;\r\t \tnextPutAll: ' items'."},{"name":"nextOrNilSuchThat:","linesOfCode":11,"sourceCode":"nextOrNilSuchThat: aBlock\r\t\"Answer the next object that satisfies aBlock, skipping any intermediate objects.\r\tIf no object has been sent, answer <nil> and leave me intact.\r\tNOTA BENE:  aBlock MUST NOT contain a non-local return (^).\"\r\r\t^monitor critical: [\r\t\t| index |\r\t\tindex := items findFirst: aBlock.\r\t\tindex = 0\r\t\t\tifTrue: [nil]\r\t\t\tifFalse: [items removeAt: index]\r\t]"},{"name":"initialize","linesOfCode":4,"sourceCode":"initialize\r\tsuper initialize.\r\tmonitor := Monitor new.\r\titems := OrderedCollection new.\r"},{"name":"flush","linesOfCode":4,"sourceCode":"flush\r\t\"Remove from the queue all objects\"\r\tmonitor critical: [\r\t\titems := items removeAll].\r"},{"name":"flushAllSuchThat:","linesOfCode":4,"sourceCode":"flushAllSuchThat: aBlock\r\t\"Remove from the queue all objects that satisfy aBlock.\"\r\tmonitor critical: [\r\t\titems := items reject: aBlock].\r"},{"name":"contents","linesOfCode":4,"sourceCode":"contents\r\t\" To be compliant with stream API but is really needed? \"\r\t^ monitor critical:\r\t\t[ items copy ]"},{"name":"next","linesOfCode":4,"sourceCode":"next\r\t^monitor critical: [\r\t\tmonitor waitWhile: [ items isEmpty ].\r\t\titems removeFirst ]\r"},{"name":"nextOrNil","linesOfCode":3,"sourceCode":"nextOrNil\r\t^monitor critical: [\r\t\titems isEmpty ifTrue: [ nil ] ifFalse: [ items removeFirst ] ]"},{"name":"postCopy","linesOfCode":5,"sourceCode":"postCopy\r\tsuper postCopy.\r\tmonitor critical:\r\t\t[items := items copy.\r\t\tmonitor := Monitor new]"},{"name":"gtInspectorItemsIn:","linesOfCode":6,"sourceCode":"gtInspectorItemsIn: composite\r\t<gtInspectorPresentationOrder: 0>\r\tcomposite fastList\r\t\ttitle: 'Items';\r\t\tdisplay: [ items copy ];\r\t\tformat: [ :each | each gtDisplayString ]"},{"name":"fixedSize:nextPut:","linesOfCode":7,"sourceCode":"fixedSize: aSize nextPut: anObject\r\tmonitor\r\t\tcritical:\r\t\t\t[ [ aSize - items size < 1 ] whileTrue: [ items removeFirst ].\r\t\t\titems addLast: anObject.\r\t\t\tmonitor signal ].\r\t^ anObject"},{"name":"atEnd","linesOfCode":2,"sourceCode":"atEnd\r\t^ self isEmpty"},{"name":"findFirst:","linesOfCode":9,"sourceCode":"findFirst: aBlock\r\t\"Answer the next object that satisfies aBlock, skipping any intermediate objects.\r\tIf no such object has been queued, answer <nil> and leave me intact.\"\r\r\t\r\t^monitor critical: [ | index |\r\t\tindex := items findFirst: aBlock.\r\t\tindex = 0 ifTrue: [\r\t\t\tnil ]\r\t\tifFalse: [\r\t\t\titems removeAt: index ] ].\r"},{"name":"peek","linesOfCode":6,"sourceCode":"peek\r\t\"Answer the object that was sent through the receiver first and has not \r\tyet been received by anyone but do not remove it from the receiver. If \r\tno object has been sent, return nil\"\r\t^monitor critical: [\r\t\titems isEmpty ifTrue: [ nil ] ifFalse: [ items first ] ]\r"}],"meta":{"name":"SharedQueue class","instanceVariables":[],"methods":[{"name":"new","linesOfCode":2,"sourceCode":"new\r\t^self basicNew initialize"}],"meta":null}},{"name":"ManifestCollectionsSequenceable","instanceVariables":[],"methods":[],"meta":{"name":"ManifestCollectionsSequenceable class","instanceVariables":[],"methods":[{"name":"manuallyResolvedDependencies","linesOfCode":2,"sourceCode":"manuallyResolvedDependencies\r\t^ #(#'Collections-Support' #'System-Support')"},{"name":"dependencies","linesOfCode":2,"sourceCode":"dependencies\r\t^ #(#'Collections-Strings' #'Collections-Streams' #'Collections-Unordered' #Kernel #'Collections-Abstract')"},{"name":"packageName","linesOfCode":2,"sourceCode":"packageName\r\t^ #'Collections-Sequenceable'"}],"meta":null}},{"name":"Interval","instanceVariables":[{"name":"start"},{"name":"stop"},{"name":"step"}],"methods":[{"name":"asOpenInterval","linesOfCode":7,"sourceCode":"asOpenInterval\r\t\"Return a new interval representing the open version of the receiver.\r\tIn other words, the new inteval does not contain the upper and lower boundaries of the receiver\r\t\"\r\t\r\t\"(1 to: 10) asOpenInterval >>> (2 to: 9)\"\r\t\"(10 to: 1 by: -1) asOpenInterval >>> (9 to: 2)\"\r\r\t^ start + step to: stop - step"},{"name":"isInterval","linesOfCode":2,"sourceCode":"isInterval\r\r\t^ true"},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ self class == Interval"},{"name":"asParser","linesOfCode":10,"sourceCode":"asParser    \r\t\"Create a range of characters between start and stop.\"\r\r    self assert:start isCharacter.\r    self assert:stop isCharacter.\r    self assert:step == 1.\r    ^ PPPredicateObjectParser between: start and: stop\r\r    \"\r\t\t($a to: $f) asParser parse: 'a'\r\t\t($a to: $f) asParser parse: 'g'\r    \""},{"name":"anyOne","linesOfCode":4,"sourceCode":"anyOne\r\t\"This message will fail for an empty Interval, super would not.\r\t(2 to: 1) anyOne should fail because empty.\"\r\r\t^self at: 1"},{"name":"add:","linesOfCode":3,"sourceCode":"add: newObject \r\t\"Adding to an Interval is not allowed.\"\r\r\tself shouldNotImplement"},{"name":"setFrom:to:by:","linesOfCode":5,"sourceCode":"setFrom: startInteger to: stopInteger by: stepInteger\r\r\tstart := startInteger.\r\tstop := stopInteger.\r\tstep := stepInteger.\r\tstep isZero ifTrue: [ ^ DomainError signal: 'Zero size steps not allowed' ]"},{"name":"fromSton:","linesOfCode":3,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\tstonReader parseNamedInstVarsFor: self"},{"name":"stonOn:","linesOfCode":3,"sourceCode":"stonOn: stonWriter\r\t\"Overwritten to get back the standard object behavior\"\r\r\tstonWriter writeObject: self"},{"name":"remove:","linesOfCode":3,"sourceCode":"remove: newObject \r\t\"Removing from an Interval is not allowed.\"\r\r\tself error: 'elements cannot be removed from an Interval'"},{"name":"collect:","linesOfCode":9,"sourceCode":"collect: aBlock\r\t| nextValue result |\r\tresult := self species new: self size.\r\tnextValue := start.\r\t1 to: result size do:\r\t\t[:i |\r\t\tresult at: i put: (aBlock value: nextValue).\r\t\tnextValue := nextValue + step].\r\t^ result"},{"name":"last","linesOfCode":3,"sourceCode":"last \r\t\"Refer to the comment in SequenceableCollection|last.\"\r\r\t^stop - (stop - start \\\\ step)"},{"name":"=","linesOfCode":8,"sourceCode":"= anObject\r\r\t^ self == anObject\r\t\tifTrue: [true]\r\t\tifFalse: [anObject isInterval\r\t\t\tifTrue: [start = anObject first\r\t\t\t\tand: [step = anObject increment\r\t\t\t\t\tand: [self last = anObject last]]]\r\t\t\tifFalse: [super = anObject]]"},{"name":"-","linesOfCode":2,"sourceCode":"- number\r\r\t^ start - number to: stop - number by: step"},{"name":"do:","linesOfCode":16,"sourceCode":"do: aBlock\r\t\"Evaluate aBlock for each value of the interval.\r\tImplementation note: instead of repeatedly incrementing the value\r\t\taValue := aValue + step.\r\tuntil stop is reached,\r\tWe prefer to recompute value from start\r\t\taValue := start + (index * step).\r\tThis is better for floating points accuracy, while not degrading Integer and Fraction speed too much.\r\tMoreover, this is consistent with methods #at: and #size\"\r\r\t| aValue index size |\r\tindex := 0.\r\tsize := self size.\r\t[index < size]\r\t\twhileTrue: [aValue := start + (index * step).\r\t\t\tindex := index + 1.\r\t\t\taBlock value: aValue]"},{"name":"sorted:","linesOfCode":3,"sourceCode":"sorted: aSortBlockOrNil\r\t\"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then <= is used for comparison. We convert the interval to an array because intervals can't be changed.\"\r\t\r\t^self asArray sort: aSortBlockOrNil"},{"name":"hash","linesOfCode":6,"sourceCode":"hash\r\t\"Hash is reimplemented because = is implemented.\"\r\r\t^(((start hash bitShift: 2)\r\t\tbitOr: stop hash)\r\t\tbitShift: 1)\r\t\tbitOr: self size"},{"name":"rangeIncludes:","linesOfCode":8,"sourceCode":"rangeIncludes: aNumber\r\t\"Return true if aNumber lies anywhere between the interval bounds.\r\tThis is a fast O(1) bounds check.\r\t\r\tBeware: because #rangeIncludes: only considers the sign of the step, not its magnitude, it also returns true for values that are not actual elements of the interval.\r\tFor precise element inclusion with arbitrary step, use #includes:.\"\r\r\t^ step >= 0\r\t\tifTrue: [ aNumber between: start and: stop ]\r\t\tifFalse: [ aNumber between: stop and: start ]"},{"name":"species","linesOfCode":2,"sourceCode":"species\r\r\t^Array"},{"name":"asGPUArrayOfType:","linesOfCode":2,"sourceCode":"asGPUArrayOfType: type\r\t^ SGPUCompilationEnvironment current constructArrayOfType: type withInterval: self"},{"name":"sum","linesOfCode":5,"sourceCode":"sum\r\t\"Optimized version. Use the sum(n * i - k, i=a..b) = -1/2 * (a - b - 1) * (n * (a + b) - 2 * k) equation with a = 1, n = step, b = self size and k = step - start.\"\r\r\t| b |\r\tb := self size.\r\t^b * ((b - 1) * step + (start * 2)) / 2"},{"name":"size","linesOfCode":9,"sourceCode":"size\r\t\"Answer how many elements the receiver contains.\"\r\r\t^ step < 0\r\t\tifTrue: [ start < stop\r\t\t\t\tifTrue: [ 0 ]\r\t\t\t\tifFalse: [ (stop - start) // step + 1 ] ]\r\t\tifFalse: [ stop < start\r\t\t\t\tifTrue: [ 0 ]\r\t\t\t\tifFalse: [ (stop - start) // step + 1 ] ]"},{"name":"printOn:","linesOfCode":7,"sourceCode":"printOn: aStream\r\taStream nextPut: $(;\r\t print: start;\r\t nextPutAll: ' to: ';\r\t print: stop.\r\tstep ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: step].\r\taStream nextPut: $)"},{"name":"+","linesOfCode":2,"sourceCode":"+ number\r\r\t^ start + number to: stop + number by: step"},{"name":"reverseDo:","linesOfCode":10,"sourceCode":"reverseDo: aBlock \r\t\"Evaluate aBlock for each element of my interval, in reverse order.\r\tImplementation notes: see do: for an explanation on loop detail\"\r\r\t| aValue index |\r\tindex := self size.\r\t[index > 0]\r\t\twhileTrue: [\r\t\t\tindex := index - 1.\r\t\t\taValue := start + (index * step).\r\t\t\taBlock value: aValue]"},{"name":"shuffled","linesOfCode":3,"sourceCode":"shuffled\r\t\"Return an array that contains my elements shuffled in a random order\"\r\t^ self asArray shuffle"},{"name":"first","linesOfCode":3,"sourceCode":"first \r\t\"Refer to the comment in SequenceableCollection|first.\"\r\r\t^start"},{"name":"permutationsDo:","linesOfCode":5,"sourceCode":"permutationsDo: aBlock\r\t\"Repeatly value aBlock with a single copy of the receiver. Reorder the copy\r\tso that aBlock is presented all (self size factorial) possible permutations.\"\r\t\"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]\"\r\r\tself asArray permutationsDo: aBlock\r"},{"name":"sort:","linesOfCode":3,"sourceCode":"sort: aBlock\r\t\"What sorting an Interval means is not clear.\"\r\r\tself shouldNotImplement."},{"name":"at:","linesOfCode":5,"sourceCode":"at: anInteger\r\t\"Answer the anInteger'th element.\"\r\r\t(anInteger between: 1 and: self size)\r\t\tifTrue: [ ^ start + (step * (anInteger - 1)) ]\r\t\tifFalse: [ self errorSubscriptBounds: anInteger ]"},{"name":"storeOn:","linesOfCode":7,"sourceCode":"storeOn: aStream \r\taStream nextPut: $(;\r\t \tstore: start;\r\t \tnextPutAll: ' to: ';\r\t \tstore: stop.\r\tstep ~= 1 ifTrue: [aStream nextPutAll: ' by: '; store: step].\r\taStream nextPut: $)"},{"name":"increment","linesOfCode":3,"sourceCode":"increment\r\t\"Answer the receiver's interval increment.\"\r\r\t^step"},{"name":"extent","linesOfCode":4,"sourceCode":"extent \r\t\"Answer the max - min of the receiver interval.\"\r\t\"(10 to: 50) extent\"\r\r\t^stop - start"},{"name":"sorted","linesOfCode":4,"sourceCode":"sorted\r\t^ self increment >= 0\r\t\tifTrue: [ self copy ]\r\t\tifFalse: [ self last to: self first by: self increment negated ]"},{"name":"at:put:","linesOfCode":3,"sourceCode":"at: anInteger put: anObject \r\t\"Storing into an Interval is not allowed.\"\r\r\tself error: 'you can not store into an interval'"},{"name":"indexOf:startingAt:ifAbsent:","linesOfCode":18,"sourceCode":"indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock\r\t\"startIndex is an positive integer, the collection index where the search is started.\"\r\t\"during the computation of val , floats are only used when the receiver contains floats\"\r\r\t| index val |\r\t(anElement isNumber and:[self rangeIncludes: anElement])\r\t\tifFalse: [^ exceptionBlock value].\r\tval := anElement - self first / self increment.\r\tval isFloat\r\t\tifTrue: [(val - val rounded) abs * 100000000 < 1\r\t\t\t\t\tifTrue: [index := val rounded + 1]\r\t\t\t\t\tifFalse: [^ exceptionBlock value]]\r\t\tifFalse: [val isInteger\r\t\t\t\t\tifTrue: [index := val + 1]\r\t\t\t\t\tifFalse: [^ exceptionBlock value]].\r\t\"finally, the value of startIndex comes into play:\"\r\t^ (index between: startIndex and: self size)\r\t\tifTrue: [index]\r\t\tifFalse: [exceptionBlock value]"}],"meta":{"name":"Interval class","instanceVariables":[],"methods":[{"name":"from:to:","linesOfCode":7,"sourceCode":"from: startInteger to: stopInteger \r\t\"Answer an instance of me, starting at startNumber, ending at \r\tstopNumber, and with an interval increment of 1.\"\r\r\t^self new\r\t\tsetFrom: startInteger\r\t\tto: stopInteger\r\t\tby: 1"},{"name":"streamSpecies","linesOfCode":2,"sourceCode":"streamSpecies\r\t^ Array"},{"name":"new","linesOfCode":10,"sourceCode":"new\r\t\"Primitive. Create and answer with a new instance of the receiver\r\t(a class) with no indexable fields. Fail if the class is indexable. Override\r\tSequenceableCollection new. Essential. See Object documentation\r\twhatIsAPrimitive.\"\r\r\t<primitive: 70>\r\tself isVariable ifTrue: [ ^ self new: 0 ].\r\t\"space must be low\"\r\tOutOfMemory signal.\r\t^ self new  \"retry if user proceeds\"\r"},{"name":"newFrom:","linesOfCode":19,"sourceCode":"newFrom: aCollection \r\t\"Answer an instance of me containing the same elements as aCollection.\"\r\r    | newInterval n |\r\r    (n := aCollection size) <= 1 ifTrue: [\r\t\tn = 0 ifTrue: [^self from: 1 to: 0].\r\t\t^self from: aCollection first to: aCollection last].\r    \tnewInterval := self from: aCollection first to: aCollection last\r\tby: (aCollection last - aCollection first) // (n - 1).\r\taCollection ~= newInterval\r\t\tifTrue: [\r\t\t\t\"Give a second chance, because progression might be arithmetic, but = answer false\"\r\t\t\t(newInterval hasEqualElements: aCollection) ifFalse: [\r\t\t\t\tself error: 'The argument is not an arithmetic progression']].\r\t^newInterval\r\r\"\tInterval newFrom: {1. 2. 3}\r\t{33. 5. -23} as: Interval\r\t{33. 5. -22} as: Interval    (an error)\r\t(-4 to: -12 by: -1) as: Interval\r\t#(2 4 6) asByteArray as: Interval.\r\""},{"name":"from:to:by:","linesOfCode":7,"sourceCode":"from: startInteger to: stopInteger by: stepInteger \r\t\"Answer an instance of me, starting at startNumber, ending at \r\tstopNumber, and with an interval increment of stepNumber.\"\r\r\t^self new\r\t\tsetFrom: startInteger\r\t\tto: stopInteger\r\t\tby: stepInteger"},{"name":"fromSton:","linesOfCode":5,"sourceCode":"fromSton: stonReader\r\t\"Overwritten to get back the standard object behavior\"\r\t\r\t^ self new\r\t\tfromSton: stonReader;\r\t\tyourself"}],"meta":null}},{"name":"Array","instanceVariables":[],"methods":[{"name":"asTraitComposition","linesOfCode":4,"sourceCode":"asTraitComposition\r\t^ self isEmpty\r\t\tifTrue: [ TaEmptyComposition new ]\r\t\tifFalse: [ TaSequence withAll: (self collect: [:each | each asTraitComposition]) ]"},{"name":"atWrap:","linesOfCode":12,"sourceCode":"atWrap: index \r\r    \"Answer the index'th element of the receiver.  If index is out of bounds,\r    let it wrap around from the end to the beginning until it is in bounds.\"\r    \r    \"Optimized to go through the primitive if possible\"\r    \r    \"(#(11 22 33) atWrap: 3) >>> 33\"\r    \"(#(11 22 33) atWrap: 2) >>> 22\"\r    \"(#(11 22 33) atWrap: 4) >>> 11\"\r    \r    <primitive: 60>\r    ^ self at: index - 1 \\\\ self size + 1 "},{"name":"isSelfEvaluating","linesOfCode":2,"sourceCode":"isSelfEvaluating\r\t^ (self allSatisfy: [:each | each isSelfEvaluating]) and: [self class == Array]"},{"name":"literalEqual:","linesOfCode":6,"sourceCode":"literalEqual: other\r\r\tself class == other class ifFalse: [^ false].\r\tself size = other size ifFalse: [^ false].\r\tself with: other do: [:e1 :e2 |\r\t\t(e1 literalEqual: e2) ifFalse: [^ false]].\r\t^ true"},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ { #array . self collect: [ :each | each slvmEncodeAsSExpression ]  }"},{"name":"preMultiplyByArray:","linesOfCode":5,"sourceCode":"preMultiplyByArray: a\r\t\"Answer a+*self where a is an Array.  Arrays are always understood as column vectors,\r\t so an n element Array is an n*1 Array.  This multiplication is legal iff self size = 1.\"\r\r\tself size = 1 ifFalse: [self error: 'dimensions do not conform'].\r\t^a * self first"},{"name":"createNonInlineLiteralObjectForMbndObjectModel:","linesOfCode":2,"sourceCode":"createNonInlineLiteralObjectForMbndObjectModel: objectModel\r\t^ objectModel createArray: self class: objectModel arrayClass"},{"name":"elementsForwardIdentityTo:","linesOfCode":8,"sourceCode":"elementsForwardIdentityTo: otherArray\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t The identityHashes remain with the pointers rather than with the objects so that\r\t the objects in this array should still be properly indexed in any existing hashed\r\t structures after the mutation.\"\r\t<primitive: 72 error: ec>\r\tself primitiveFailed"},{"name":"asMapArgument","linesOfCode":2,"sourceCode":"asMapArgument\r\t^ self"},{"name":"asArray","linesOfCode":3,"sourceCode":"asArray\r\t\"Answer with the receiver itself.\"\r\r\t^ self"},{"name":"gtDisplayString","linesOfCode":2,"sourceCode":"gtDisplayString\r\r\t^ super gtDisplayString contractTo: 200"},{"name":"preMultiplyByMatrix:","linesOfCode":8,"sourceCode":"preMultiplyByMatrix: m\r\t\"Answer m+*self where m is a Matrix.\"\r\r\tm numberOfColumns = self size ifFalse: [self error: 'dimensions do not conform'].\r\t^ (1 to: m numberOfRows) collect: [ :row | \r\t\t\t| s |\r\t\t\ts := 0.\r\t\t\t1 to: self size do: [:k | s := (m at: row at: k) * (self at: k) + s].\r\t\ts ]"},{"name":"isArray","linesOfCode":2,"sourceCode":"isArray\r\t^true"},{"name":"hasLiteral:","linesOfCode":10,"sourceCode":"hasLiteral: literal\r\t\"Answer true if literal is identical to any literal in this array, even \r\tif imbedded in further array structure. This method is only intended \r\tfor private use by CompiledMethod hasLiteralSymbol:\"\r\r\t| lit |\r\t1 to: self size do: \r\t\t[:index | \r\t\t((lit := self at: index) literalEqual: literal) ifTrue: [^true].\r\t\t(Array == lit class and: [lit hasLiteral: literal]) ifTrue: [^true]].\r\t^false"},{"name":"settingStoreOn:","linesOfCode":11,"sourceCode":"settingStoreOn: aStream \r\t\"Use the literal form if possible.\"\r\r\tself isLiteral\r\t\tifTrue: \r\t\t\t[aStream nextPut: $#; nextPut: $(.\r\t\t\tself do: \r\t\t\t\t[:element | \r\t\t\t\telement settingStoreOn: aStream.\r\t\t\t\taStream space].\r\t\t\taStream nextPut: $)]\r\t\tifFalse: [super settingStoreOn: aStream]"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: graphEncoder\r\t^ graphEncoder encodeObject: self type: #Array earlyFields: self size fields: [self collect: [:each | each encodeGraphForMessagePackWith: graphEncoder]]"},{"name":"atWrap:put:","linesOfCode":4,"sourceCode":"atWrap: index put: anObject\r\t\"Optimized to go through the primitive if possible\"\r\t<primitive: 61>\r\t^ self at: index - 1 \\\\ self size + 1 put: anObject"},{"name":"hasLiteralSuchThat:","linesOfCode":7,"sourceCode":"hasLiteralSuchThat: testBlock\r\t\"Answer true if testBlock returns true for any literal in this array, even if imbedded in \tfurther Arrays or CompiledMethods.  This method is only intended for private use by \tCompiledMethod \thasLiteralSuchThat:\"\r\t| lit |\r\t1 to: self size do: [:index |\r\t\t(testBlock value: (lit := self at: index)) ifTrue: [^ true].\r\t\t(lit hasLiteralSuchThat: testBlock) ifTrue: [^ true]].\r\t^ false"},{"name":"printAsLiteralFormOn:","linesOfCode":3,"sourceCode":"printAsLiteralFormOn: aStream\r\taStream nextPut: $#.\r\tself printElementsOn: aStream\r"},{"name":"elementsForwardIdentityTo:copyHash:","linesOfCode":10,"sourceCode":"elementsForwardIdentityTo: otherArray copyHash: copyHash\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t If copyHash is true, the identityHashes remain with the pointers rather than with the\r\t objects so that the objects in the receiver should still be properly indexed in any\r\t existing hashed structures after the mutation.  If copyHash is false, then the hashes\r\t of the objects in otherArray remain unchanged.  If you know what you're doing this\r\t may indeed be what you want.\"\r\t<primitive: 249 error: ec>\r\tself primitiveFailed"},{"name":"generateSpec","linesOfCode":9,"sourceCode":"generateSpec\r\t| str spec |\r\tstr := self readStream.\t\r\t\r\tspec :=  OrderedCollection with: #SpecLayoutFrame.\r\t\t\r\t#( leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset: ) do: [:sel |\r\t\tspec add: sel.\r\t\tstr next ifNil: [ spec add: 0 ] ifNotNil: [:value | spec add: value ]].\r\t^ spec asArray"},{"name":"printOn:","linesOfCode":4,"sourceCode":"printOn: aStream\r\tself shouldBePrintedAsLiteral ifTrue: [self printAsLiteralFormOn: aStream. ^ self].\r\tself isSelfEvaluating ifTrue: [self printAsSelfEvaluatingFormOn: aStream. ^ self].\r\r\tsuper printOn: aStream"},{"name":"asTestMatrix","linesOfCode":5,"sourceCode":"asTestMatrix\r\r\t| matrix |\r\tmatrix := ParametrizedTestMatrix new.\r\tself do: [ :e | matrix addCase: e ].\r\t^ matrix"},{"name":"asLayoutFrame","linesOfCode":2,"sourceCode":"asLayoutFrame\r\t ^ LayoutFrame new fromArray: self"},{"name":"isLiteral","linesOfCode":2,"sourceCode":"isLiteral\r\t^self class == Array and: [self allSatisfy: [:each | each isLiteral]]"},{"name":"replaceFrom:to:with:startingAt:","linesOfCode":4,"sourceCode":"replaceFrom: start to: stop with: replacement startingAt: repStart \r\t\"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive.\"\r\t<primitive: 105>\r\tsuper replaceFrom: start to: stop with: replacement startingAt: repStart"},{"name":"shouldBePrintedAsLiteral","linesOfCode":2,"sourceCode":"shouldBePrintedAsLiteral\r\r\t^self class == Array and: [ self allSatisfy: [ :each | each shouldBePrintedAsLiteral ] ]"},{"name":"+*","linesOfCode":4,"sourceCode":"+* aCollection\r\t\"Premultiply aCollection by self.  aCollection should be an Array or Matrix.\r\t The name of this method is APL's +.x squished into Smalltalk syntax.\"\r\r\t^aCollection preMultiplyByArray: self\r"},{"name":"refersToLiteral:","linesOfCode":3,"sourceCode":"refersToLiteral: literal\r\t^ (self literalEqual: literal) \r\t\tor: [ self hasLiteral: literal ]"},{"name":"fuelReplacement","linesOfCode":4,"sourceCode":"fuelReplacement\r\t^ self == Smalltalk specialObjectsArray\r\t\tifTrue: [ nil ]\r\t\tifFalse: [ self ]"},{"name":"copyWithDependent:","linesOfCode":3,"sourceCode":"copyWithDependent: newElement\r\tself size = 0 ifTrue:[^DependentsArray with: newElement].\r\t^self copyWith: newElement"},{"name":"printAsSelfEvaluatingFormOn:","linesOfCode":4,"sourceCode":"printAsSelfEvaluatingFormOn: aStream\r\r\taStream nextPut: ${.\r\tself do: [:el | el printOn: aStream] separatedBy: [ aStream nextPutAll: '. '].\r\taStream nextPut: $}"},{"name":"gtInspectorFastPrintOn:","linesOfCode":9,"sourceCode":"gtInspectorFastPrintOn: aStream\r\t\"Only scan through a limited number of elements to determine how to print the Array.\"\r\t((1 to: (self size min: self gtCollectionSizeThreshold)) allSatisfy: [ :anIndex | \r\t\t\t(self at: anIndex) shouldBePrintedAsLiteral ]) ifTrue: [\r\t\tself printAsLiteralFormOn: aStream.  ^ self].\r\t((1 to: (self size min: self gtCollectionSizeThreshold)) allSatisfy: [ :anIndex | \r\t\t\t(self at: anIndex) isSelfEvaluating ])  ifTrue: [\r\t\tself printAsSelfEvaluatingFormOn: aStream. ^ self].\r\r\tsuper printOn: aStream"},{"name":"fuelAccept:","linesOfCode":6,"sourceCode":"fuelAccept: aGeneralMapper\r\t\r\t\"This IF is because there are subclasses of Array that are weak. If we do not put this IF, all subclasses fuel be using the #visitVariableObject:, loosing the capability of the weak\r\tHowever, this method is just to optimize the method lookup of the message #fuelAccept:. If this method is removed, the default behavior of Object shuld work as well. If the performance is not that different, then we can remove this method which has an ugly if.\"\r\t^ self class isWeak\r\t\tifTrue: [ aGeneralMapper visitWeakObject: self ]\r\t\tifFalse: [ aGeneralMapper visitVariableObject: self ]\r\t\r\t"},{"name":"storeOn:","linesOfCode":11,"sourceCode":"storeOn: aStream \r\t\"Use the literal form if possible.\"\r\r\tself shouldBePrintedAsLiteral\r\t\tifTrue: \r\t\t\t[aStream nextPut: $#; nextPut: $(.\r\t\t\tself do: \r\t\t\t\t[:element | \r\t\t\t\telement storeOn: aStream.\r\t\t\t\taStream space].\r\t\t\taStream nextPut: $)]\r\t\tifFalse: [super storeOn: aStream]"},{"name":"closureDescriptionForCaching","linesOfCode":11,"sourceCode":"closureDescriptionForCaching\r\t^ ByteString streamContents: [ :out |\r\t\tout << ${.\r\t\tself doWithIndex: [ :element :index |\r\t\t\tindex > 1 ifTrue: [ \r\t\t\t\tout nextPut: $|\r\t\t\t].\r\t\t\tout nextPutAll: element closureDescriptionForCaching\r\t\t].\r\t\tout << $}.\r\t]"},{"name":"elementsExchangeIdentityWith:","linesOfCode":33,"sourceCode":"elementsExchangeIdentityWith: otherArray\r\t\"This primitive performs a bulk mutation, causing all pointers to the elements of the\r\t receiver to be replaced by pointers to the corresponding elements of otherArray.\r\t At the same time, all pointers to the elements of otherArray are replaced by\r\t pointers to the corresponding elements of this array.  The identityHashes remain\r\t with the pointers rather than with the objects so that objects in hashed structures\r\t should still be properly indexed after the mutation.\"\r\r\t<primitive: 128 error: ec>\r\t| minimalRequiredSize |\r\tec == #'bad receiver' ifTrue:\r\t\t[^self error: 'receiver must be of class Array'].\r\tec == #'bad argument' ifTrue:\r\t\t[^self error: (otherArray class == Array\r\t\t\t\t\t\tifTrue: ['arg must be of class Array']\r\t\t\t\t\t\tifFalse: ['receiver and argument must have the same size'])].\r\tec == #'inappropriate operation' ifTrue:\r\t\t[^self error: 'can''t become immediates such as SmallIntegers or Characters'].\r\tec == #'no modification' ifTrue:\r\t\t[^self error: 'can''t become immutable objects'].\r\tec == #'object is pinned' ifTrue:\r\t\t[^self error: 'can''t become pinned objects'].\r\tec == #'insufficient object memory' ifTrue:\r\t\t[\r\t\t\tminimalRequiredSize := \r\t\t\t\t(self sumNumbers: [ :anElement | anElement sizeInMemory ]) \r\t\t\t\t+ (otherArray sumNumbers: [ :anElement | anElement sizeInMemory ]).\r\t\t\t\r\t\t\tSmalltalk garbageCollect < minimalRequiredSize ifTrue:\r\t\t\t\t[ (Smalltalk growMemoryByAtLeast: minimalRequiredSize) < minimalRequiredSize ifTrue:[\r\t\t\t\t\tself error: 'Could not allocate enought memory for two way become']].\r\t\t\r\t\t ^self elementsExchangeIdentityWith: otherArray].\r\tself primitiveFailed"}],"meta":{"name":"Array class","instanceVariables":[],"methods":[{"name":"braceWith:","linesOfCode":7,"sourceCode":"braceWith: a\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 1.\r\tarray at: 1 put: a.\r\t^ array"},{"name":"braceWith:with:with:with:","linesOfCode":10,"sourceCode":"braceWith: a with: b with: c with: d\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 4.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\tarray at: 3 put: c.\r\tarray at: 4 put: d.\r\t^ array"},{"name":"new:","linesOfCode":6,"sourceCode":"new: sizeRequested \r\t\"Answer an instance of this class with the number of indexable\r\tvariables specified by the argument, sizeRequested.\r\t\r\tThis is a shortcut (direct call of primitive, no #initialize, for performance\"\r\r\t<primitive: 71>  \"This method runs primitively if successful\"\r\t^ self basicNew: sizeRequested  \"Exceptional conditions will be handled in basicNew:\"\r"},{"name":"braceWith:with:","linesOfCode":8,"sourceCode":"braceWith: a with: b \r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 2.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\t^ array"},{"name":"braceWithNone","linesOfCode":4,"sourceCode":"braceWithNone\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t^ self new: 0"},{"name":"braceStream:","linesOfCode":4,"sourceCode":"braceStream: nElements\r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t^ WriteStream basicNew braceArray: (self new: nElements)\r"},{"name":"braceWith:with:with:","linesOfCode":9,"sourceCode":"braceWith: a with: b with: c \r\t\"This method is used in compilation of brace constructs.\r\tIt MUST NOT be deleted or altered.\"\r\r\t| array |\r\tarray := self new: 3.\r\tarray at: 1 put: a.\r\tarray at: 2 put: b.\r\tarray at: 3 put: c.\r\t^ array"},{"name":"materializeObjectWithType:earlyFields:withMessagePackGraphDecoder:","linesOfCode":11,"sourceCode":"materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder\r\tobjectType == #Array ifTrue: [\r\t\t| result |\r\t\tresult := self new: earlyFields.\r\t\tgraphDecoder registerObjectInstance: result.\r\t\tgraphDecoder decodeNext doWithIndex: [ :eachValue :index |\r\t\t\tresult at: index put: eachValue\r\t\t].\r\t\t^ result\r\t].\r\r\t^ super materializeObjectWithType: objectType earlyFields: earlyFields withMessagePackGraphDecoder: graphDecoder"},{"name":"empty","linesOfCode":3,"sourceCode":"empty\r\t\"A canonicalized empty Array instance.\"\r\t^ #()"}],"meta":null}},{"name":"SortedCollection","instanceVariables":[{"name":"sortBlock"}],"methods":[{"name":"add:","linesOfCode":2,"sourceCode":"add: newObject\r\t^ super insert: newObject before: (self indexForInserting: newObject)"},{"name":"intersection:","linesOfCode":4,"sourceCode":"intersection: aCollection\r\t^ (self class sortBlock: sortBlock)\r\t\taddAll: (self asSet intersection: aCollection);\r\t\tyourself."},{"name":",","linesOfCode":5,"sourceCode":", otherCollection\r\t| newSortedCollection |\r\tnewSortedCollection := super , otherCollection.\r\tnewSortedCollection sortBlock: self sortBlock .\r\t^newSortedCollection "},{"name":"addFirst:","linesOfCode":2,"sourceCode":"addFirst: newObject\r\tself shouldNotImplement"},{"name":"indexForInserting:","linesOfCode":16,"sourceCode":"indexForInserting: newObject\r\r\t| index low high |\r\tlow := firstIndex.\r\thigh := lastIndex.\r\tsortBlock \r\t\tifNil: [[index := high + low // 2.  low > high]\r\t\t\twhileFalse: \r\t\t\t\t[((array at: index) <= newObject)\r\t\t\t\t\tifTrue: [low := index + 1]\r\t\t\t\t\tifFalse: [high := index - 1]]]\r\t\tifNotNil: [[index := high + low // 2.  low > high]\r\t\t\twhileFalse: \r\t\t\t\t[(sortBlock value: (array at: index) value: newObject)\r\t\t\t\t\tifTrue: [low := index + 1]\r\t\t\t\t\tifFalse: [high := index - 1]]].\r\t^low"},{"name":"defaultSort:to:","linesOfCode":45,"sourceCode":"defaultSort: i to: j \r\t\"Sort elements i through j of self to be nondescending according to\r\tsortBlock.\"\t\"Assume the default sort block ([:x :y | x <= y]).\"\r\r\t| di dij dj tt ij k l n |\r\t\"The prefix d means the data at that index.\"\r\t(n := j + 1  - i) <= 1 ifTrue: [^self].\t\"Nothing to sort.\" \r\t \"Sort di,dj.\"\r\tdi := array at: i.\r\tdj := array at: j.\r\t(di <= dj) \"i.e., should di precede dj?\"\r\t\tifFalse: \r\t\t\t[array swap: i with: j.\r\t\t\t tt := di.\r\t\t\t di := dj.\r\t\t\t dj := tt].\r\tn > 2\r\t\tifTrue:  \"More than two elements.\"\r\t\t\t[ij := (i + j) // 2.  \"ij is the midpoint of i and j.\"\r\t\t\t dij := array at: ij.  \"Sort di,dij,dj.  Make dij be their median.\"\r\t\t\t (di <= dij) \"i.e. should di precede dij?\"\r\t\t\t   ifTrue: \r\t\t\t\t[(dij <= dj) \"i.e., should dij precede dj?\"\r\t\t\t\t  ifFalse: \r\t\t\t\t\t[array swap: j with: ij.\r\t\t\t\t\t dij := dj]]\r\t\t\t   ifFalse:  \"i.e. di should come after dij\"\r\t\t\t\t[array swap: i with: ij.\r\t\t\t\t dij := di].\r\t\t\tn > 3\r\t\t\t  ifTrue:  \"More than three elements.\"\r\t\t\t\t[\"Find k>i and l<j such that dk,dij,dl are in reverse order.\r\t\t\t\tSwap k and l.  Repeat this procedure until k and l pass each other.\"\r\t\t\t\t k := i.\r\t\t\t\t l := j.\r\t\t\t\t [[l := l - 1.  k <= l and: [dij <= (array at: l)]]\r\t\t\t\t   whileTrue.  \"i.e. while dl succeeds dij\"\r\t\t\t\t  [k := k + 1.  k < j and: [(array at: k) <= dij]]\r\t\t\t\t   whileTrue.  \"i.e. while dij succeeds dk\"\r\t\t\t\t  k <= l]\r\t\t\t\t   whileTrue:\r\t\t\t\t\t[array swap: k with: l]. \r\t\"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk\r\tthrough dj.  Sort those two segments.\"\r\t\t\t\tself defaultSort: i to: l.\r\t\t\t\tself defaultSort: k to: j]]"},{"name":"collect:","linesOfCode":10,"sourceCode":"collect: aBlock \r\t\"Evaluate aBlock with each of my elements as the argument. Collect the \r\tresulting values into an OrderedCollection. Answer the new collection.\r\tWe cannot assume that the result is sorted, because aBlock can transform the \r\telements in arbitrary ways.  Thus, we must override the superclass in order\r\tto produce an OrderedCollection instead of a SortedCollection.\"\r\r\t| newCollection | \r\tnewCollection := OrderedCollection new: self size.\r\tself do: [:each | newCollection addLast: (aBlock value: each)].\r\t^ newCollection"},{"name":"flatCollect:","linesOfCode":5,"sourceCode":"flatCollect: aBlock \r\t\"Evaluate aBlock for each of the receiver's elements and answer the\r\tlist of all resulting values flatten one level. Assumes that aBlock returns some kind\r\tof collection for each element. Equivalent to the lisp's mapcan\"\r\t\r\t^ self flatCollect: aBlock as: OrderedCollection"},{"name":"=","linesOfCode":7,"sourceCode":"= aSortedCollection\r\t\"Answer true if my and aSortedCollection's species are the same,\r\tand if our blocks are the same, and if our elements are the same.\"\r\r\tself species = aSortedCollection species ifFalse: [ ^ false ].\r\t^ sortBlock = aSortedCollection sortBlock\r\t\tifTrue: [ super = aSortedCollection ]\r\t\tifFalse: [ false ]"},{"name":"median","linesOfCode":9,"sourceCode":"median\r\t\"Return the middle element, or as close as we can get.\"\r\t\"{1 . 2 . 3 . 4 . 5} asSortedCollection  median >>> 3\"\r\t\r\t| size middle |\r \tsize := self size.\r \tmiddle := (size + 1) // 2.\r \t^ size even\r\t\t\tifTrue: [ ((self at: middle) + (self at: middle + 1)) / 2 ]\r\t\t\tifFalse: [ self at: middle ]"},{"name":"sort:","linesOfCode":5,"sourceCode":"sort: aSortBlock \r\t\"Sort this array using aSortBlock. The block should take two arguments\r\tand return true if the first element should preceed the second one.\"\r \r \tsuper sort: aSortBlock.\r \tsortBlock := aSortBlock"},{"name":"addAll:","linesOfCode":7,"sourceCode":"addAll: aCollection\r\taCollection size > (self size // 3)\r\t\tifTrue:\r\t\t\t[aCollection do: [:each | self addLast: each].\r\t\t\tself reSort]\r\t\tifFalse: [aCollection do: [:each | self add: each]].\r\t^ aCollection"},{"name":"groupedBy:","linesOfCode":10,"sourceCode":"groupedBy: aBlock\r\t\"Answer a dictionary whose keys are the result of evaluating aBlock for all my elements, and the value for each key is the selection of my elements that evaluated to that key. Uses species.\"\r\t| groups |\r\tgroups := OrderedDictionary new.\r\tself do: [ :each |\r\t\t(groups at: (aBlock value: each) ifAbsentPut: [ OrderedCollection new ]) add: each ].\r\tgroups associationsDo: [ :association |\r\t\t\t\"need to make sure to create the collection with the same sortblock\"\r\t\t\tassociation value: (self copyEmpty addAll: association value ; yourself) ].\r\t^ groups"},{"name":"reSort","linesOfCode":2,"sourceCode":"reSort\r\tself sort: firstIndex to: lastIndex"},{"name":"sort:to:","linesOfCode":46,"sourceCode":"sort: i to: j \r\t\"Sort elements i through j of self to be nondescending according to\r\tsortBlock.\"\r\r\t| di dij dj tt ij k l n |\r\tsortBlock ifNil: [^self defaultSort: i to: j].\r\t\"The prefix d means the data at that index.\"\r\t(n := j + 1  - i) <= 1 ifTrue: [^self].\t\"Nothing to sort.\" \r\t \"Sort di,dj.\"\r\tdi := array at: i.\r\tdj := array at: j.\r\t(sortBlock value: di value: dj) \"i.e., should di precede dj?\"\r\t\tifFalse: \r\t\t\t[array swap: i with: j.\r\t\t\t tt := di.\r\t\t\t di := dj.\r\t\t\t dj := tt].\r\tn > 2\r\t\tifTrue:  \"More than two elements.\"\r\t\t\t[ij := (i + j) // 2.  \"ij is the midpoint of i and j.\"\r\t\t\t dij := array at: ij.  \"Sort di,dij,dj.  Make dij be their median.\"\r\t\t\t (sortBlock value: di value: dij) \"i.e. should di precede dij?\"\r\t\t\t   ifTrue: \r\t\t\t\t[(sortBlock value: dij value: dj) \"i.e., should dij precede dj?\"\r\t\t\t\t  ifFalse: \r\t\t\t\t\t[array swap: j with: ij.\r\t\t\t\t\t dij := dj]]\r\t\t\t   ifFalse:  \"i.e. di should come after dij\"\r\t\t\t\t[array swap: i with: ij.\r\t\t\t\t dij := di].\r\t\t\tn > 3\r\t\t\t  ifTrue:  \"More than three elements.\"\r\t\t\t\t[\"Find k>i and l<j such that dk,dij,dl are in reverse order.\r\t\t\t\tSwap k and l.  Repeat this procedure until k and l pass each other.\"\r\t\t\t\t k := i.\r\t\t\t\t l := j.\r\t\t\t\t [[l := l - 1.  k <= l and: [sortBlock value: dij value: (array at: l)]]\r\t\t\t\t   whileTrue.  \"i.e. while dl succeeds dij\"\r\t\t\t\t  [k := k + 1.  k < j and: [sortBlock value: (array at: k) value: dij]]\r\t\t\t\t   whileTrue.  \"i.e. while dij succeeds dk\"\r\t\t\t\t  k <= l]\r\t\t\t\t   whileTrue:\r\t\t\t\t\t[array swap: k with: l]. \r\t\"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk\r\tthrough dj.  Sort those two segments.\"\r\t\t\t\tself sort: i to: l.\r\t\t\t\tself sort: k to: j]]"},{"name":"insert:before:","linesOfCode":2,"sourceCode":"insert: anObject before: spot\r\tself shouldNotImplement"},{"name":"copyEmpty","linesOfCode":3,"sourceCode":"copyEmpty\r\t\"Answer a copy of the receiver without any of the receiver's elements.\"\r\r\t^self species sortBlock: sortBlock"},{"name":"sortBlock","linesOfCode":4,"sourceCode":"sortBlock\r\t\"Answer the blockContext which is the criterion for sorting elements of \r\tthe receiver.\"\r\r\t^sortBlock"},{"name":"join:","linesOfCode":4,"sourceCode":"join: aCollection \r\t\"Append the elements of the argument, aSequenceableCollection, separating them by the receiver.\"\r\t\"Curiously addAllLast: does not trigger a reSort, so we must do it here.\"\r\t^ (super join: aCollection) reSort; yourself\r"},{"name":"sortBlock:","linesOfCode":6,"sourceCode":"sortBlock: aBlock \r\t\"Make the argument, aBlock, be the criterion for ordering elements of the \r\treceiver.\"\r\r\tsortBlock := aBlock.\r\t\"sortBlocks with side effects may not work right\"\r\tself size > 0 ifTrue: [self reSort]"},{"name":"at:put:","linesOfCode":2,"sourceCode":"at: anInteger put: anObject\r\tself shouldNotImplement"}],"meta":{"name":"SortedCollection class","instanceVariables":[],"methods":[{"name":"sortBlock:","linesOfCode":3,"sourceCode":"sortBlock: aBlock \r\t\"Answer an instance of me such that its elements are sorted according to the criterion specified in aBlock.\"\r\r\t^ self sortUsing: aBlock"},{"name":"sortUsing:","linesOfCode":3,"sourceCode":"sortUsing: aBlockOrSortFunction\r\t\"Answer an instance of me such that its elements are sorted according to the criterion specified by the block or sort function.\"\r\r\t^ self new sortBlock: aBlockOrSortFunction"}],"meta":null}},{"name":"Array2D","instanceVariables":[{"name":"contents"},{"name":"numberOfColumns"},{"name":"numberOfRows"}],"methods":[{"name":"includes:","linesOfCode":2,"sourceCode":"includes: anObject\r\t^ contents includes: anObject"},{"name":"intersection:","linesOfCode":5,"sourceCode":"intersection: aCollection\r\t\"Union is in because the result is always a Set.\r\t Difference and intersection are out because the result is like the receiver,\r\t and with irregular seleection that cannot be.\"\r\tself shouldNotImplement"},{"name":"occurrencesOf:","linesOfCode":2,"sourceCode":"occurrencesOf: anObject\r\t^ contents occurrencesOf: anObject"},{"name":"preMultiplyByArray:","linesOfCode":5,"sourceCode":"preMultiplyByArray: a\r\t\"Answer a +* self where a is an Array.\"\r\r\tnumberOfRows = 1 ifFalse: [self error: 'dimensions do not conform'].\r\t^Array2D rows: a size columns: numberOfColumns tabulate: [:row :col |\r\t\t(a at: row) * (contents at: col)]\r"},{"name":"rows:columns:contents:","linesOfCode":8,"sourceCode":"rows: rows columns: columns contents: anArray\r\t[rows isInteger and: [rows >= 0]] assert.\r\t[columns isInteger and: [columns >= 0]] assert.\r\t[rows * columns = anArray size] assert.\r\tnumberOfRows := rows.\r\tnumberOfColumns := columns.\r\tcontents := anArray.\r\t^self"},{"name":"asFloatArray","linesOfCode":2,"sourceCode":"asFloatArray\r\t^ contents asFloatArray"},{"name":"collect:","linesOfCode":6,"sourceCode":"collect: aBlock\r\t\"Answer a new matrix with transformed elements; transformations should be independent.\"\r\r\t^self class \r\t\trows: numberOfRows \r\t\tcolumns: numberOfColumns \r\t\tcontents: (contents collect: aBlock)"},{"name":"numberOfRows","linesOfCode":2,"sourceCode":"numberOfRows\r\t^ numberOfRows"},{"name":"=","linesOfCode":5,"sourceCode":"= aMatrix\r\t^ aMatrix class == self class\r\t\tand: [ aMatrix numberOfRows = numberOfRows\r\t\t\t\tand: [ aMatrix numberOfColumns = numberOfColumns \r\t\t\t\t\tand: [ aMatrix privateContents = contents ] ] ]"},{"name":"atRows:to:columns:to:ifInvalid:","linesOfCode":7,"sourceCode":"atRows: r1 to: r2 columns: c1 to: c2 ifInvalid: element\r\t\"Answer a submatrix [r1..r2][c1..c2] of the receiver.\r\t Portions of the result outside the bounds of the original matrix are filled in with element.\"\r\t|rd cd|\r\trd := r1 - 1.\r\tcd := c1 - 1.\r\t^self class rows: r2-rd columns: c2-cd tabulate: [ :r :c| self at: r+rd at: c+cd ifInvalid: element]\r"},{"name":"asArray","linesOfCode":2,"sourceCode":"asArray\r\t^ contents shallowCopy"},{"name":"asCharacterSet","linesOfCode":2,"sourceCode":"asCharacterSet\r\t^ contents asCharacterSet"},{"name":"asSet","linesOfCode":2,"sourceCode":"asSet\r\t^ contents asSet"},{"name":"at:at:ifInvalid:","linesOfCode":5,"sourceCode":"at: rowNumber at: columnNumber ifInvalid: value\r\t\"If rowNumber,columnNumber is a valid index for the receiver, answer the corresponding element. Otherwise, answer value.\"\r\r\t(rowNumber between: 1 and: numberOfRows) ifFalse: [ ^ value ].\r\t(columnNumber between: 1 and: numberOfColumns) ifFalse: [ ^ value ].\r\t^contents at: (rowNumber - 1) * numberOfColumns + columnNumber\r"},{"name":"reject:","linesOfCode":2,"sourceCode":"reject: aBlock\r\tself shouldNotImplement"},{"name":"replaceAll:with:","linesOfCode":3,"sourceCode":"replaceAll: oldObject with: newObject\r\t\"Replace all occurrences of oldObject with newObject in the receiver.\"\r\tcontents replaceAll: oldObject with: newObject"},{"name":"do:","linesOfCode":3,"sourceCode":"do: aBlock\r\t\"Pass elements to aBlock one at a time in row-major order.\"\r\tcontents do: aBlock"},{"name":"with:do:","linesOfCode":4,"sourceCode":"with: aCollection do: aBlock\r\t\"aCollection must support #at:at: and be at least as large as the receiver.\"\r\r\tself withIndicesDo: [:each :row :column |\r\t\taBlock value: each value: (aCollection at: row at: column)].\r"},{"name":"withIndicesDo:","linesOfCode":6,"sourceCode":"withIndicesDo: aBlock\r\t\r\t| i |\r\ti := 0.\r\t1 to: numberOfRows do: [:row |\r\t\t1 to: numberOfColumns do: [:column |\r\t\t\taBlock value: (contents at: (i := i+1)) value: row value: column]].\r"},{"name":",,","linesOfCode":8,"sourceCode":",, aMatrix\r\t\"Answer a new matrix having the same number of columns as the receiver and aMatrix,\r\t its rows being the rows of the receiver followed by the rows of aMatrix.\"\r\r\t[numberOfColumns = aMatrix numberOfColumns] assert.\r\t^self class \r\t\t\trows: numberOfRows + aMatrix numberOfRows \r\t\t\tcolumns: numberOfColumns\r\t\t\tcontents: contents , aMatrix privateContents\r"},{"name":"asOrderedCollection","linesOfCode":2,"sourceCode":"asOrderedCollection\r\t^ contents asOrderedCollection"},{"name":"with:collect:","linesOfCode":4,"sourceCode":"with: aCollection collect: aBlock\r\t\"aCollection must support #at:at: and be at least as large as the receiver.\"\r\r\t^self withIndicesCollect: [:each :row :column |\r\t\taBlock value: each value: (aCollection at: row at: column)]\r"},{"name":"rowCount","linesOfCode":2,"sourceCode":"rowCount\r\t^numberOfRows"},{"name":"size","linesOfCode":2,"sourceCode":"size\r\t^ contents size"},{"name":"swapColumn:withColumn:","linesOfCode":8,"sourceCode":"swapColumn: anIndex withColumn: anotherIndex\r\t|a b|\r\r\ta := self indexForRow: 1 andColumn: anIndex.\r\tb := self indexForRow: 1 andColumn: anotherIndex.\r\tnumberOfRows timesRepeat: [\r\t\tcontents swap: a with: b.\r\t\ta := a + numberOfColumns.\r\t\tb := b + numberOfColumns].\r"},{"name":"atRandom:","linesOfCode":2,"sourceCode":"atRandom: aGenerator\r\t^ contents atRandom: aGenerator"},{"name":"identityIncludes:","linesOfCode":2,"sourceCode":"identityIncludes: anObject\r\t^ contents identityIncludes: anObject"},{"name":"atRow:","linesOfCode":6,"sourceCode":"atRow: rowNumber\r\t(rowNumber between: 1 and: numberOfRows)\r\t\tifFalse: [self error: '1st subscript out of range'].\r\t^ contents \r\t\t\tcopyFrom: (rowNumber - 1) * numberOfColumns + 1 \r\t\t\tto: rowNumber*numberOfColumns"},{"name":"asIntegerArray","linesOfCode":2,"sourceCode":"asIntegerArray\r\t^ contents asIntegerArray"},{"name":"printOn:","linesOfCode":9,"sourceCode":"printOn: aStream\r\r\taStream nextPutAll: '('.\r\t(1 to: self numberOfRows) \r\t\tdo: [ :r | \r\t\t\t\t(self atRow: r) \r\t\t\t\t\tdo: [ :each | aStream print: each ] \r\t\t\t\t\tseparatedBy: [ aStream space ]]\r\t\tseparatedBy: [ aStream cr ].\r\taStream nextPutAll: ' )'."},{"name":"shuffledBy:","linesOfCode":2,"sourceCode":"shuffledBy: aRandom\r\t^self class rows: numberOfRows columns: numberOfColumns contents: (contents copy shuffleBy: aRandom)"},{"name":"atRows:to:columns:to:","linesOfCode":6,"sourceCode":"atRows: r1 to: r2 columns: c1 to: c2\r\t\"Answer a submatrix [r1..r2][c1..c2] of the receiver.\"\r\t|rd cd|\r\r\trd := r1 - 1.\r\tcd := c1 - 1.\r\t^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd]\r"},{"name":"withIndicesInject:into:","linesOfCode":11,"sourceCode":"withIndicesInject: start into: aBlock\r\t\r\t| i current |\r\ti := 0.\r\tcurrent := start.\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\tcurrent := aBlock \r\t\t\t\t\t\t\t\tvalue: current \r\t\t\t\t\t\t\t\tvalue: (contents at: (i := i+1)) \r\t\t\t\t\t\t\t\tvalue: row value: column ] ].\r\t^ current"},{"name":"swapRow:withRow:","linesOfCode":8,"sourceCode":"swapRow: anIndex withRow: anotherIndex\r\t| a b |\r\ta := self indexForRow: anIndex andColumn: 1.\r\tb := self indexForRow: anotherIndex andColumn: 1.\r\tnumberOfColumns timesRepeat: [\r\t\tcontents swap: a with: b.\r\t\ta := a + 1.\r\t\tb := b + 1].\r"},{"name":"at:at:incrementBy:","linesOfCode":3,"sourceCode":"at: rowNumber at: columnNumber incrementBy: value\r\t\"Add a value to the element available at rowNumber,columNumber.\"\r\r\t^ contents at: (self indexForRow: rowNumber andColumn: columnNumber) incrementBy: value"},{"name":"indicesInject:into:","linesOfCode":7,"sourceCode":"indicesInject: start into: aBlock\r\r\t|current|\r\tcurrent := start.\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\tcurrent := aBlock value: current value: row value: column ] ].\r\t^ current"},{"name":"indicesCollect:","linesOfCode":8,"sourceCode":"indicesCollect: aBlock\r\t\r\t| r i |\r\tr := Array new: numberOfRows * numberOfColumns.\r\ti := 0.\r\t1 to: numberOfRows do: [:row |\r\t\t1 to: numberOfColumns do: [:column |\r\t\t\tr at: (i := i+1) put: (aBlock value: row value: column)]].\r\t^ self class rows: numberOfRows columns: numberOfColumns contents: r"},{"name":"atRandom","linesOfCode":3,"sourceCode":"atRandom\r\t\"Return the contents of the receiver in a random order.\"\r\t^ contents atRandom\r"},{"name":"diagonal","linesOfCode":5,"sourceCode":"diagonal\r\t\"Answer (1 to: (numberOfRows min: numberOfColumns)) collect: [:i | self at: i at: i]\"\r\t|i|\r\ti := numberOfColumns negated.\r\t^ (1 to: (numberOfRows min: numberOfColumns)) collect: [:j | contents at: (i := i + numberOfColumns + 1)]"},{"name":"with:inject:into:","linesOfCode":4,"sourceCode":"with: aCollection inject: startingValue into: aBlock\r\t\"aCollection must support #at:at: and be at least as large as the receiver.\"\r\r\t^ self withIndicesInject: startingValue into: [:value :each :row :column |\r\t\t\taBlock value: value value: each value: (aCollection at: row at: column)]"},{"name":"includesAll:","linesOfCode":2,"sourceCode":"includesAll: aCollection\r\t^ contents includesAll: aCollection"},{"name":"atRow:put:","linesOfCode":6,"sourceCode":"atRow: row put: aCollection\r\t|p|\r\r\taCollection size = numberOfColumns ifFalse: [self error: 'wrong row size'].\r\tp := (self indexForRow: row andColumn: 1)-1.\r\taCollection do: [:each | contents at: (p := p+1) put: each].\r\t^aCollection"},{"name":"numberOfColumns:","linesOfCode":2,"sourceCode":"numberOfColumns: anObject\r\tnumberOfColumns := anObject"},{"name":"asByteArray","linesOfCode":2,"sourceCode":"asByteArray\r\t^ contents asByteArray"},{"name":"indexOf:ifAbsent:","linesOfCode":4,"sourceCode":"indexOf: anElement ifAbsent: anExceptionBlock\r\t\"If there are integers r, c such that (self at: r at: c) = anElement, answer some such r@c, otherwise answer the result of anExceptionBlock.\"\r\r\t^self rowAndColumnForIndex:\r\t\t (contents indexOf: anElement ifAbsent: [^ anExceptionBlock value])\r"},{"name":"atRows:columns:","linesOfCode":5,"sourceCode":"atRows: rs columns: cs\r\t\"Answer a Matrix obtained by slicing the receiver.\r\t rs and cs should be sequenceable collections of positive integers.\"\r\r\t^self class rows: rs size columns: cs size tabulate: [:r :c |\r\t\tself at: (rs at: r) at: (cs at: c)]"},{"name":"anyOne","linesOfCode":3,"sourceCode":"anyOne\r\t\"Return one element from the receiver\"\r\t^ contents anyOne"},{"name":"add:","linesOfCode":2,"sourceCode":"add: newObject\r\tself shouldNotImplement"},{"name":",","linesOfCode":18,"sourceCode":", aMatrix\r\t\"Answer a new matrix having the same number of rows as the receiver and aMatrix,\r\t its columns being the columns of the receiver followed by the columns of aMatrix.\"\r\t|newCont newCols anArray oldCols a b c|\r\r\t[numberOfRows = aMatrix numberOfRows] assert.\r\tnewCont := Array new: self size + aMatrix size.\r\tanArray := aMatrix privateContents.\r\toldCols := aMatrix numberOfColumns.\r\tnewCols := numberOfColumns + oldCols.\r\ta := b := c := 1.\r\t1 to: numberOfRows do: [:r |\r\t\tnewCont replaceFrom: a to: a + numberOfColumns - 1 with: contents startingAt: b.\r\t\tnewCont replaceFrom: a+numberOfColumns to: a + newCols - 1 with: anArray startingAt: c.\r\t\ta := a + newCols.\r\t\tb := b + numberOfColumns.\r\t\tc := c + oldCols].\r\t^self class rows: numberOfRows columns: newCols contents: newCont\r\t\t\r"},{"name":"difference:","linesOfCode":5,"sourceCode":"difference: aCollection\r\t\"Union is in because the result is always a Set.\r\t Difference and intersection are out because the result is like the receiver,\r\t and with irregular seleection that cannot be.\"\r\tself shouldNotImplement"},{"name":"numberOfRows:","linesOfCode":2,"sourceCode":"numberOfRows: anObject\r\tnumberOfRows := anObject"},{"name":"asSortedCollection:","linesOfCode":2,"sourceCode":"asSortedCollection: aBlock\r\t^ contents asSortedCollection: aBlock"},{"name":"includesAny:","linesOfCode":2,"sourceCode":"includesAny: aCollection\r\t^ contents includesAny: aCollection"},{"name":"postCopy","linesOfCode":3,"sourceCode":"postCopy\r\tsuper postCopy.\r\tcontents := contents copy"},{"name":"asBag","linesOfCode":2,"sourceCode":"asBag\r\t^ contents asBag"},{"name":"preMultiplyByMatrix:","linesOfCode":11,"sourceCode":"preMultiplyByMatrix: m\r\t\"Answer m +* self where m is a Matrix.\"\r\t|s|\r\tnumberOfRows = m numberOfColumns ifFalse: [self error: 'dimensions do not conform'].\r\t^ Array2D \r\t\trows: m numberOfRows \r\t\tcolumns: numberOfColumns \r\t\ttabulate: [:row :col |\r\t\t\ts := 0.\r\t\t\t1 to: numberOfRows do: [:k | s := (m at: row at: k) * (self at: k at: col) + s].\r\t\t\ts ]"},{"name":"indexForRow:andColumn:","linesOfCode":6,"sourceCode":"indexForRow: row andColumn: column\r\t(row between: 1 and: numberOfRows)\r\t\tifFalse: [self error: '1st subscript out of range'].\r\t(column between: 1 and: numberOfColumns)\r\t\tifFalse: [self error: '2nd subscript out of range'].\r\t^(row-1) * numberOfColumns + column"},{"name":"at:at:","linesOfCode":2,"sourceCode":"at: rowNumber at: columnNumber\r\t^ contents at: (self indexForRow: rowNumber andColumn: columnNumber)"},{"name":"atColumn:put:","linesOfCode":6,"sourceCode":"atColumn: column put: aCollection\r\t| p |\r\taCollection size = numberOfRows ifFalse: [ self error: 'wrong column size' ].\r\tp := (self indexForRow: 1 andColumn: column) - numberOfColumns.\r\taCollection do: [ :each | contents at: (p := p + numberOfColumns) put: each ].\r\t^ aCollection\r"},{"name":"hash","linesOfCode":5,"sourceCode":"hash\r\t\"I'm really not sure what would be a good hash function here.\r\t The essential thing is that it must be compatible with #=, and\r\t this satisfies that requirement.\"\r\r\t^contents hash"},{"name":"remove:ifAbsent:","linesOfCode":2,"sourceCode":"remove: anObject ifAbsent: anExceptionBlock\r\tself shouldNotImplement"},{"name":"rowAndColumnForIndex:","linesOfCode":4,"sourceCode":"rowAndColumnForIndex: index\r\t|t|\r\r\tt := index - 1.\r\t^(t // numberOfColumns + 1)@(t \\\\ numberOfColumns + 1)"},{"name":"atAllPut:","linesOfCode":3,"sourceCode":"atAllPut: value\r\t\"Put value as value of all the receiver elements.\"\r\tcontents atAllPut: value"},{"name":"removeAll","linesOfCode":2,"sourceCode":"removeAll\r\r\tself shouldNotImplement"},{"name":"identityIndexOf:ifAbsent:","linesOfCode":3,"sourceCode":"identityIndexOf: anElement ifAbsent: anExceptionBlock\r\t^self rowAndColumnForIndex:\r\t\t (contents identityIndexOf: anElement ifAbsent: [^anExceptionBlock value])\r"},{"name":"isSequenceable","linesOfCode":6,"sourceCode":"isSequenceable\r\t\"LIE so that arithmetic on matrices will work.\r\t What matters for arithmetic is not that there should be random indexing\r\t but that the structure should be stable and independent of the values of\r\t the elements.  #isSequenceable is simply the wrong question to ask.\"\r\t^ true"},{"name":"numberOfColumns","linesOfCode":2,"sourceCode":"numberOfColumns\r\t^ numberOfColumns"},{"name":"asWordArray","linesOfCode":2,"sourceCode":"asWordArray\r\t^ contents asWordArray"},{"name":"atRows:to:columns:to:put:","linesOfCode":12,"sourceCode":"atRows: r1 to: r2 columns: c1 to: c2 put: aMatrix\r\t\"Set the [r1..r2][c1..c2] submatrix of the receiver\r\t from the [1..r2-r1+1][1..c2-c1+1] submatrix of aMatrix.\r\t As long as aMatrix responds to at:at: and accepts arguments in the range shown,\r\t we don't care if it is bigger or even if it is a Matrix at all.\"\r\t|rd cd|\r\r\trd := r1 - 1.\r\tcd := c1 - 1.\r\tr1 to: r2 do: [:r |\r\t\tc1 to: c2 do: [:c |\r\t\t\tself at: r at: c put: (aMatrix at: r-rd at: c-cd)]].\r\t^aMatrix\r"},{"name":"shuffled","linesOfCode":2,"sourceCode":"shuffled\r\t^self class rows: numberOfRows columns: numberOfColumns contents: (contents shuffled)"},{"name":"asSortedCollection","linesOfCode":2,"sourceCode":"asSortedCollection\r\t^ contents asSortedCollection"},{"name":"+*","linesOfCode":4,"sourceCode":"+* aCollection\r\t\"Premultiply aCollection by self.  aCollection should be an Array or Matrix.\r\t The name of this method is APL's +.x squished into Smalltalk syntax.\"\r\r\t^aCollection preMultiplyByMatrix: self\r"},{"name":"indexOf:","linesOfCode":3,"sourceCode":"indexOf: anElement\r\t\"If there are integers r, c such that (self at: r at: c) = anElement, answer some such r@c, otherwise answer 0@0. The order in which the receiver are searched is UNSPECIFIED except that it is the same as the order used by #indexOf:ifAbsent: and #readStream.\"\r\r\t^self indexOf: anElement ifAbsent: [0@0]\r"},{"name":"transposed","linesOfCode":3,"sourceCode":"transposed\r\t[numberOfRows = numberOfColumns] assert.\r\t^ self indicesCollect: [ :row :column | self at: column at: row ]"},{"name":"at:at:put:","linesOfCode":3,"sourceCode":"at: rowNumber at: columnNumber put: value\r\t\"Put value at rowNumber,columnNumber\"\r\t^ contents at: (self indexForRow: rowNumber andColumn: columnNumber) put: value"},{"name":"columnCount","linesOfCode":2,"sourceCode":"columnCount\r\t^ numberOfColumns"},{"name":"identityIndexOf:","linesOfCode":2,"sourceCode":"identityIndexOf: anElement\r\t\r\t^ self identityIndexOf: anElement ifAbsent: [ 0@0 ]\r"},{"name":"readStream","linesOfCode":3,"sourceCode":"readStream\r\t\"Answer a ReadStream that returns all the elements of the receiver in some UNSPECIFIED order.\"\r\t^ contents readStream"},{"name":"withIndicesCollect:","linesOfCode":9,"sourceCode":"withIndicesCollect: aBlock\r\t\r\t|i r|\r\ti := 0.\r\tr := contents shallowCopy.\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\ti := i+1.\r\t\t\tr at: i put: (aBlock value: (r at: i) value: row value: column)]].\r\t^ self class rows: numberOfRows columns: numberOfColumns contents: r\r"},{"name":"storeOn:","linesOfCode":6,"sourceCode":"storeOn: aStream\r\taStream nextPut: $(; nextPutAll: self class name;\r\t\tnextPutAll: ' rows: '; store: numberOfRows;\r\t\tnextPutAll: ' columns: '; store: numberOfColumns;\r\t\tnextPutAll: ' contents: '; store: contents;\r\t\tnextPut: $)"},{"name":"swap:at:with:at:","linesOfCode":3,"sourceCode":"swap: r1 at: c1 with: r2 at: c2\r\tcontents swap: (self indexForRow: r1 andColumn: c1)\r\t\t\t with: (self indexForRow: r2 andColumn: c2)"},{"name":"extent","linesOfCode":3,"sourceCode":"extent\r    \"Answer the receiver's dimensions as point.\"\r\r    ^ self numberOfColumns @ self numberOfRows"},{"name":"privateContents","linesOfCode":4,"sourceCode":"privateContents\r\t\"Only used in #, #,, and #= so far.\r\t It used to be called #contents, but that clashes with Collection>>contents.\"\r\r\t^ contents"},{"name":"select:","linesOfCode":2,"sourceCode":"select: aBlock\r\tself shouldNotImplement"},{"name":"atColumn:","linesOfCode":4,"sourceCode":"atColumn: column\r\r\t|p|\r\tp := (self indexForRow: 1 andColumn: column)-numberOfColumns.\r\t^(1 to: numberOfRows) collect: [:row | contents at: (p := p+numberOfColumns)]\r"},{"name":"indicesDo:","linesOfCode":4,"sourceCode":"indicesDo: aBlock\r\t1 to: numberOfRows do: [ :row |\r\t\t1 to: numberOfColumns do: [ :column |\r\t\t\taBlock value: row value: column]]."},{"name":"asIdentitySet","linesOfCode":2,"sourceCode":"asIdentitySet\r\t^ contents asIdentitySet"}],"meta":{"name":"Array2D class","instanceVariables":[],"methods":[{"name":"new:","linesOfCode":3,"sourceCode":"new: dimension\r\t\"Answer a dimension*dimension matrix.\"\r\t^ self rows: dimension columns: dimension"},{"name":"rows:columns:tabulate:","linesOfCode":10,"sourceCode":"rows: rowNumber columns: columnNumber tabulate: aTwoArgumentBlock\r\t\"Answer a new Matrix of the given dimensions where\r\t result at: i at: j is aTwoArgumentBlock value: i value: j\"\r\t|a i|\r\ta := Array new: rowNumber*columnNumber.\r\ti := 0.\r\t1 to: rowNumber do: [:row |\r\t\t1 to: columnNumber do: [:column |\r\t\t\ta at: (i := i + 1) put: (aTwoArgumentBlock value: row value: column)]].\r\t^ self rows: rowNumber columns: columnNumber contents: a\r"},{"name":"columnVector:","linesOfCode":3,"sourceCode":"columnVector: aCollection\r\t\"Create a matrix of one column having aCollection as contents\"\r\r\t^ self rows: aCollection size columns: 1 contents: aCollection asArray shallowCopy"},{"name":"zeros:","linesOfCode":3,"sourceCode":"zeros: dimension\r\t\"Create a Matrix of dimensionxdimemsion\"\r\t^ self new: dimension element: 0"},{"name":"rows:columns:contents:","linesOfCode":3,"sourceCode":"rows: rowNumber columns: columnNumber contents: contents\r\t\"Private! Creates a Matrix of the given size with an adequate contents.\"\r\t^ self new rows: rowNumber columns: columnNumber contents: contents"},{"name":"new:tabulate:","linesOfCode":3,"sourceCode":"new: dimension tabulate: aTwoArgumentBlock\r\t\"Answer a dimension*dimension matrix where it at: i at: j is aBlock value: i value: j.\"\r\t^ self rows: dimension columns: dimension tabulate: aTwoArgumentBlock"},{"name":"identity:","linesOfCode":5,"sourceCode":"identity: n\r\t| r |\r\tr := self zeros: n.\r\t1 to: n do: [ :i | r at: i at: i put: 1 ].\r\t^ r"},{"name":"new:element:","linesOfCode":3,"sourceCode":"new: dimemsion element: element\r\t\"Answer a dimemsion*dimemsion matrix with all elements set to element.\"\r\r\t^ self rows: dimemsion columns: dimemsion element: element"},{"name":"diagonal:","linesOfCode":6,"sourceCode":"diagonal: aCollection\r\t|r i|\r\tr := self zeros: aCollection size.\r\ti := 0.\r\taCollection do: [:each | i := i+1. r at: i at: i put: each].\r\t^r"},{"name":"rows:columns:","linesOfCode":6,"sourceCode":"rows: rowNumber columns: columnNumber\r\t\"Create a Matrix of rowNUmber rows and columnNumber columns.\"\r\t^ self \r\t\trows: rowNumber \r\t\tcolumns: columnNumber \r\t\tcontents: (Array new: rowNumber*columnNumber)"},{"name":"rows:columns:element:","linesOfCode":6,"sourceCode":"rows: rowNumber columns: columnNumber element: element\r\t\"Create a Matrix of rowNumber rows and columnNumber columns filled with element.\"\r\t^ self \r\t\trows: rowNumber \r\t\tcolumns: columnNumber\r\t\tcontents: ((Array new: rowNumber * columnNumber) atAllPut: element; yourself)"},{"name":"rowVector:","linesOfCode":3,"sourceCode":"rowVector: aCollection\r\t\"Create a matrix of one row having aCollection as contents\"\r\r\t^self rows: 1 columns: aCollection size contents: aCollection asArray shallowCopy"},{"name":"ones:","linesOfCode":3,"sourceCode":"ones: dimension\r\t\"Create a squared matrix of dimension full of 1\"\r\t^ self new: dimension element: 1\r"}],"meta":null}},{"name":"Number","instanceVariables":[],"methods":[{"name":"printString","linesOfCode":2,"sourceCode":"printString\r\t^self printStringBase: 10"},{"name":"roundDownTo:","linesOfCode":9,"sourceCode":"roundDownTo: aNumber\r\t\"Answer the next multiple of aNumber toward negative infinity that is nearest the receiver. \r\tExamples:\r               3.1479 roundDownTo: 0.01 -> 3.14\r               3.1479 roundDownTo: 0.1 -> 3.1\r               1923 roundDownTo: 10 -> 1920\r               3.1479 roundDownTo: 0.005 -> 3.145\r               -3.1479 roundDownTo: 0.01 -> -3.15\"\r\t\r\t^(self / aNumber) floor * aNumber"},{"name":"strictlyPositive","linesOfCode":3,"sourceCode":"strictlyPositive\r\t\"Answer whether the receiver is mathematically positive.\"\r\r\t^ self > 0"},{"name":"arcSin","linesOfCode":4,"sourceCode":"arcSin\r\t\"The receiver is the sine of an angle. Answer the angle measured in \r\tradians.\"\r\r\t^self asFloat arcSin"},{"name":"signedGradientNoise","linesOfCode":5,"sourceCode":"signedGradientNoise\r\t| l f |\r\tl := self floor.\r\tf := self - l.\r\t^ (l signedRandomNoise * f) smoothInterpolateTo: ((l+1.0) signedRandomNoise * (f-1.0)) at: f"},{"name":"days","linesOfCode":2,"sourceCode":"days\r \r \t^ Duration days: self"},{"name":"nanoSecond","linesOfCode":4,"sourceCode":"nanoSecond\r\t\"1 nanoSecond printString >>> '0:00:00:00.000000001'\"\r\t\"(1 milliSecond + 1 nanoSecond) printString >>> '0:00:00:00.001000001'\"\r \r \t^ self nanoSeconds\r "},{"name":"nthRoot:","linesOfCode":3,"sourceCode":"nthRoot: aPositiveInteger\r\t\"Answer the nth root of the receiver.\"\r\r\tself subclassResponsibility"},{"name":"closeTo:","linesOfCode":4,"sourceCode":"closeTo: num\r\t\"Tell whether the receiver and arguments are close from each.\"\r\r\tnum isFloat ifTrue: [ ^ num closeTo: self asFloat ].\r\t^ [ self = num ] onErrorDo: [ false ]"},{"name":"stonOn:","linesOfCode":2,"sourceCode":"stonOn: stonWriter\r\tstonWriter writeFloat: self asFloat"},{"name":"printShowingDecimalPlaces:","linesOfCode":15,"sourceCode":"printShowingDecimalPlaces: placesDesired\r\t\"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point. Here are some examples:\"\r\t\r\t\"(23 printShowingDecimalPlaces: 2) >>> '23.00'\"\r\t\"(23.5698 printShowingDecimalPlaces: 2) >>> '23.57'\"\r\t\"(-234.567 printShowingDecimalPlaces: 5) >>> '-234.56700'\"\r\t\"(23.4567 printShowingDecimalPlaces: 0) >>> '23'\"\r\t\"(-23.4567 printShowingDecimalPlaces: 0) >>> '-23'\"\r\t\"(100000000 printShowingDecimalPlaces: 1) >>> '100000000.0'\"\r\t\"(0.98 printShowingDecimalPlaces: 5) >>> '0.98000'\"\r\t\"(-0.98 printShowingDecimalPlaces: 2) >>> '-0.98'\"\r\t\"(2.567 printShowingDecimalPlaces: 2) >>> '2.57'\"\r\t\"(-2.567 printShowingDecimalPlaces: 2) >>> '-2.57'\"\r\t\"(0 printShowingDecimalPlaces: 2) >>> '0.00'\"\r\r\t^String new: placesDesired + 10 streamContents: [:aStream |\r\t\tself printOn: aStream showingDecimalPlaces: placesDesired]"},{"name":"minutes","linesOfCode":4,"sourceCode":"minutes\r\t\"2 minutes printString >>> '0:00:02:00'\"\r\t\"(1 hour + 2 minutes) printString >>> '0:01:02:00'\"\r \r \t^ Duration minutes: self"},{"name":"cos","linesOfCode":3,"sourceCode":"cos\r\t\"The receiver represents an angle measured in radians. Answer its cosine.\"\r\r\t^self asFloat cos"},{"name":"printOn:base:","linesOfCode":4,"sourceCode":"printOn: aStream base: base\r\t\"This method should print a representation of the number for the given base,\r\texcluding the base prefix (and the letter r for radix)\"\r\t\r\tself subclassResponsibility"},{"name":"log:","linesOfCode":3,"sourceCode":"log: aNumber \r\t\"Answer the log base aNumber of the receiver.\"\r\r\t^self ln / aNumber ln"},{"name":"adaptToFraction:andSend:","linesOfCode":3,"sourceCode":"adaptToFraction: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a Fraction, convert us and evaluate exprBlock.\"\r\t^ self subclassResponsibility"},{"name":"asFloat","linesOfCode":3,"sourceCode":"asFloat\r\t\"Answer a floating-point number approximating the receiver.\"\r\r\tself subclassResponsibility"},{"name":"-","linesOfCode":3,"sourceCode":"- aNumber \r\t\"Answer the difference between the receiver and aNumber.\"\r\r\tself subclassResponsibility"},{"name":"multiplyWithAngle:","linesOfCode":2,"sourceCode":"multiplyWithAngle: aGAngle \r\t^ (aGAngle radians * self) radians"},{"name":"asFloatFromNormalizedSByte","linesOfCode":2,"sourceCode":"asFloatFromNormalizedSByte\r\t^ self asFloat / 16r7F min: 1.0 max: -1.0"},{"name":"multiplyWithVector:","linesOfCode":2,"sourceCode":"multiplyWithVector: aGVector \r\t^ (aGVector coordinates * self) asGVector"},{"name":"week","linesOfCode":2,"sourceCode":"week\r \r \t^ self weeks\r "},{"name":"asSmallPositiveDegrees","linesOfCode":3,"sourceCode":"asSmallPositiveDegrees\r\t\"Return the receiver normalized to lie within the range (0, 360)\"\r\r\t^self \\\\ 360"},{"name":"raisedTo:","linesOfCode":21,"sourceCode":"raisedTo: aNumber \r\t\"Answer the receiver raised to aNumber.\"\r\t\r\t\"(2 raisedTo: 8) >>> 256\"\r\t\"(8 raisedTo: 2) >>> 64\"\r\t\"(2 raisedTo: (1/12)) >>> 1.0594630943592953\"\r\t\"(2 raisedTo: -1) >>> (1/2)\"\r\r\taNumber isInteger ifTrue: [\r\t\t\"Do the special case of integer power\"\r\t\t^ self raisedToInteger: aNumber].\r\taNumber isFraction ifTrue: [\r\t\t\"Special case for fraction power\"\r\t\t^ self raisedToFraction: aNumber].\r\tself < 0 ifTrue: [\r\t\t^ ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].\r\t0 = aNumber ifTrue: [^ self class one].\t\"Special case of exponent=0\"\r\t1 = aNumber ifTrue: [^ self].\t\"Special case of exponent=1\"\r\t0 = self ifTrue: [\t\t\t\t\"Special case of self = 0\"\r\t\taNumber < 0\r\t\t\tifTrue: [^ (ZeroDivide dividend: 1) signal]\r\t\t\tifFalse: [^ self]].\r\t^ (aNumber * self ln) exp\t\t\"Otherwise use logarithms\""},{"name":"defaultLabel","linesOfCode":3,"sourceCode":"defaultLabel\r\t\"Answer the default label to be used for an Inspector window on the receiver.\"\r\r\t^ super defaultLabel, ': ', self printString"},{"name":"degrees","linesOfCode":2,"sourceCode":"degrees\r\t^ GAngle degrees: self"},{"name":"degreeCos","linesOfCode":3,"sourceCode":"degreeCos\r\t\"Answer the cosine of the receiver taken as an angle in degrees.\"\r\t\r\t^ (90 - (180 + self \\\\ 360 - 180) abs) degreesToRadians sin"},{"name":"cubicHemiteCurve","linesOfCode":2,"sourceCode":"cubicHemiteCurve\r\t^ self * self * (3.0 - (2.0*self))"},{"name":"signedRandomNoise","linesOfCode":2,"sourceCode":"signedRandomNoise\r\t^ self randomNoise * 2.0 - 1.0\r"},{"name":"hour","linesOfCode":2,"sourceCode":"hour\r \r \t^ self hours"},{"name":"//","linesOfCode":5,"sourceCode":"// aNumber \r\t\"Integer quotient defined by division with truncation toward negative \r\tinfinity. 9//4 = 2, -9//4 = -3. -0.9//0.4 = -3. \\\\ answers the remainder \r\tfrom this division.\"\r\r\t^(self / aNumber) floor"},{"name":"printOn:","linesOfCode":2,"sourceCode":"printOn: aStream\r\tself printOn: aStream base: 10"},{"name":"storeOn:base:","linesOfCode":4,"sourceCode":"storeOn: aStream base: base\r\t\"This method should print a representation of the number for the given base,\r\tincluding the base prefix (with letter r for radix)\"\r\t\r\t^self subclassResponsibility"},{"name":"years","linesOfCode":2,"sourceCode":"years\r \r \t^ Duration years: self"},{"name":"to:count:","linesOfCode":5,"sourceCode":"to: step count: count\r\t\"Answer an Interval from the receiver up to the argument, stop, \r\tincrementing by step.\"\r\r\tcount = 1 ifTrue: [ ^ Array with: self ].\r\t\r\t^ self to: step by: (step - self) / (count - 1)"},{"name":"floorModule:","linesOfCode":2,"sourceCode":"floorModule: period\r\t^ self - ((self / period) floor * period)"},{"name":"productFuzzyOr:","linesOfCode":2,"sourceCode":"productFuzzyOr: other\r\t^ self + other - (self * other)"},{"name":"**","linesOfCode":7,"sourceCode":"** exponent \r\t\" A shortcut method for raisedTo: \"\r\t\r\t\"2 ** 8 >>> 256\"\r\t\"8 ** 2 >>> 64\"\r\t\"2 ** (1/12) >>> 1.0594630943592953\"\r\t\"2 ** -1 >>> (1/2)\"\r\t\r\t^ self raisedTo: exponent"},{"name":"floor","linesOfCode":8,"sourceCode":"floor\r\t\"Answer the integer nearest the receiver toward negative infinity.\"\r\r\t| truncation |\r\ttruncation := self truncated.\r\tself >= 0 ifTrue: [^truncation].\r\tself = truncation\r\t\tifTrue: [^truncation]\r\t\tifFalse: [^truncation - 1]"},{"name":"negated","linesOfCode":3,"sourceCode":"negated\r\t\"Answer a Number that is the negation of the receiver.\"\r\r\t^0 - self"},{"name":"round:","linesOfCode":5,"sourceCode":"round: numberOfWishedDecimal\r\t\"Round the decimal part of the receiver to be limited to the number of wished decimal. Only leave a fixed amount of decimal\"\r   < expr: 10.12345 round: 2 result: 10.12 >\r\t< expr: 10.199999999 round: 2 result: 10.2 > \r\t^ self subclassResponsibility"},{"name":"asFloatFromNormalizedSShort","linesOfCode":2,"sourceCode":"asFloatFromNormalizedSShort\r\t^ self asFloat / 16r7FFF.0 min: 1.0 max: -1.0"},{"name":"asVisualizationColor","linesOfCode":2,"sourceCode":"asVisualizationColor\r\t^ Color r: self g: self b: self"},{"name":"fuzzyXor:","linesOfCode":2,"sourceCode":"fuzzyXor: other\r\t^ ((1.0 - self) min: other) fuzzyOr: (self min: (1.0 - other))"},{"name":"arcCos","linesOfCode":4,"sourceCode":"arcCos \r\t\"The receiver is the cosine of an angle. Answer the angle measured in \r\tradians.\"\r\r\t^self asFloat arcCos"},{"name":"isNaN","linesOfCode":2,"sourceCode":"isNaN\r\t^ false"},{"name":"isZero","linesOfCode":2,"sourceCode":"isZero\r\t^self = 0"},{"name":"productFuzzyAnd:","linesOfCode":2,"sourceCode":"productFuzzyAnd: other\r\t^ self * other"},{"name":"copySignTo:","linesOfCode":5,"sourceCode":"copySignTo: aNumber\r\t\"Return a number with same magnitude as aNumber and same sign as self.\"\r\r\t^ self signBit = 0\r\t\tifTrue: [aNumber abs]\r\t\tifFalse: [aNumber abs negated]."},{"name":"gtInspectorHash","linesOfCode":2,"sourceCode":"gtInspectorHash\r\r\t^ self hash"},{"name":"odd","linesOfCode":3,"sourceCode":"odd\r\t\"Answer whether the receiver is an odd number.\"\r\r\t^self even == false"},{"name":"nanoSeconds","linesOfCode":4,"sourceCode":"nanoSeconds\r\t\"2 nanoSeconds printString >>> '0:00:00:00.000000002'\"\r\t\"(1 milliSecond + 2 nanoSeconds) printString >>> '0:00:00:00.001000002'\"\r \r \t^ Duration nanoSeconds: self."},{"name":"adaptToInteger:andSend:","linesOfCode":3,"sourceCode":"adaptToInteger: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock.\"\r\t^ self subclassResponsibility"},{"name":"adaptToCollection:andSend:","linesOfCode":4,"sourceCode":"adaptToCollection: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a Collection, return a Collection of\r\tthe results of each element combined with me in that expression.\"\r\r\t^ rcvr collect: [:element | element perform: selector with: self]"},{"name":"<=>","linesOfCode":2,"sourceCode":"<=> other\r\t^ (self - other) sign"},{"name":"signedValueNoise","linesOfCode":2,"sourceCode":"signedValueNoise\r\t^ self valueNoise * 2.0 - 1.0"},{"name":"/","linesOfCode":3,"sourceCode":"/ aNumber \r\t\"Answer the result of dividing the receiver by aNumber.\"\r\r\tself subclassResponsibility"},{"name":"floorLog:","linesOfCode":3,"sourceCode":"floorLog: radix\r\t\"Answer the floor of the log base radix of the receiver.\"\r\r\t^(self log: radix) floor"},{"name":"encodeGraphForMessagePackWith:","linesOfCode":2,"sourceCode":"encodeGraphForMessagePackWith: encoder\r\t^ self asFloat"},{"name":"fractionalBrownianMotionOctaves:lacunarity:gain:with:","linesOfCode":13,"sourceCode":"fractionalBrownianMotionOctaves: octaves lacunarity: lacunarity gain: gain with: aBlock\r\t| result currentCoord amplitude amplitudeSum |\r\tresult := 0.0.\r\tcurrentCoord := self.\r\tamplitude := 0.5.\r\tamplitudeSum := 0.0.\r\t\r\t1 to: octaves do: [ :i |\r\t\tresult := result + (aBlock noiseValueAt: currentCoord withAmplitude: amplitude).\r\t\tcurrentCoord := currentCoord * lacunarity.\r\t\tamplitudeSum := amplitudeSum + amplitude.\r\t\tamplitude := amplitude * gain\r\t].\r\r\t^ result / amplitudeSum\r"},{"name":"turbulence","linesOfCode":2,"sourceCode":"turbulence\r\t^ self turbulenceScales: 4"},{"name":"detentBy:atMultiplesOf:snap:","linesOfCode":13,"sourceCode":"detentBy: detent atMultiplesOf: grid snap: snap\r\t\"Map all values that are within detent/2 of any multiple of grid to that multiple.  Otherwise, if snap is true, return self, meaning that the values in the dead zone will never be returned.  If snap is false, then expand the range between dead zones so that it covers the range between multiples of the grid, and scale the value by that factor.\"\r\t| r1 r2 |\r\tr1 := self roundTo: grid.  \"Nearest multiple of grid\"\r\t(self roundTo: detent) = r1 ifTrue: [^ r1].  \"Snap to that multiple...\"\r\tsnap ifTrue: [^ self].  \"...or return self\"\r\r\tr2 := self < r1  \"Nearest end of dead zone\"\r\t\tifTrue: [r1 - (detent asFloat/2)]\r\t\tifFalse: [r1 + (detent asFloat/2)].\r\t\"Scale values between dead zones to fill range between multiples\"\r\t^ r1 + ((self - r2) * grid asFloat / (grid - detent))\r\"\r\t(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: true] \t(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: false]\r\t(3.9 to: 4.1 by: 0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: true] \t(-3.9 to: -4.1 by: -0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: false]\r\""},{"name":"truncateTo:","linesOfCode":11,"sourceCode":"truncateTo: aNumber \r\t\"Answer the next multiple of aNumber toward zero that is nearest the receiver.\"\r\t\"(3.1479 truncateTo: 0.01) >>>  3.14\"\r   \"(3.1479 truncateTo: 0.1) >>>  3.1\"\r\t\"(1923 truncateTo: 10) >>>  1920\"\r\t\"(1929 truncateTo: 10) >>>  1920\"\r\t\"(-1929 truncateTo: 10) >>>  -1920\"\r\t\"(3.1479 truncateTo: 0.005) >>>  3.145\"\r\t\"(-3.1479 truncateTo: 0.01) >>>  -3.14\"\r             \r\t^(self quo: aNumber) * aNumber"},{"name":"percent","linesOfCode":2,"sourceCode":"percent\r\r\t^ self / 100"},{"name":"hours","linesOfCode":2,"sourceCode":"hours\r \r \t^ Duration hours: self"},{"name":"to:do:","linesOfCode":9,"sourceCode":"to: stop do: aBlock \r\t\"Normally compiled in-line, and therefore not overridable.\r\tEvaluate aBlock for each element of the interval (self to: stop by: 1).\"\r\t| nextValue |\r\tnextValue := self.\r\t[nextValue <= stop]\r\t\twhileTrue: \r\t\t\t[aBlock value: nextValue.\r\t\t\tnextValue := nextValue + 1]"},{"name":"productFuzzyNot","linesOfCode":2,"sourceCode":"productFuzzyNot\r\t^ self fuzzyNot"},{"name":"smoothInterpolateTo:at:","linesOfCode":2,"sourceCode":"smoothInterpolateTo: aNumber at: param\r\t^ self interpolateTo: aNumber at: param cubicHemiteCurve"},{"name":"ceiling","linesOfCode":8,"sourceCode":"ceiling\r       \"Answer the integer nearest the receiver toward  infinity.\"\r\r       | truncation |\r       truncation := self truncated.\r       self <= 0 ifTrue: [ ^ truncation ].\r       ^ self = truncation\r               ifTrue: [ truncation ]\r               ifFalse: [ truncation + 1 ]"},{"name":"tan","linesOfCode":4,"sourceCode":"tan\r\t\"The receiver represents an angle measured in radians. Answer its \r\ttangent.\"\r\r\t^self asFloat tan"},{"name":"","linesOfCode":1,"sourceCode":"\r\t^ self * Float pi"},{"name":"seconds","linesOfCode":4,"sourceCode":"seconds\r\r\t\"2 seconds printString >>> '0:00:00:02'\"\r\t\"(1 minute + 2 seconds) printString >>> '0:00:01:02'\"\r \r \t^ Duration seconds: self"},{"name":"sign","linesOfCode":5,"sourceCode":"sign\r\t\"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.\"\r\r\tself > 0 ifTrue: [^1].\r\tself < 0 ifTrue: [^-1].\r\t^0"},{"name":"\\\\","linesOfCode":7,"sourceCode":"\\\\ aNumber \r\t\"modulo. Remainder defined in terms of //. Answer a Number with the \r\tsame sign as aNumber.\"\r\t\r\t\"9 \\\\ 4 >>> 1\"\r\t\"-9 \\\\ 4 >>> 3\"\r\t\"9 \\\\ -4 >>> -3\"\r\r\t^self - (self // aNumber * aNumber)"},{"name":"productFuzzyXor:","linesOfCode":2,"sourceCode":"productFuzzyXor: other\r\t^ ((1.0 - self) * other) productFuzzyOr: self * (1.0 - other)"},{"name":"valueNoise","linesOfCode":4,"sourceCode":"valueNoise\r\t| lower |\r\tlower := self floor.\r\t^ lower randomNoise interpolateTo: (lower + 1.0) randomNoise at: (self - lower) cubicHemiteCurve"},{"name":"storeOn:","linesOfCode":2,"sourceCode":"storeOn: aStream \r\tself printOn: aStream"},{"name":"%","linesOfCode":7,"sourceCode":"% aNumber \r\t\"modulo. Remainder defined in terms of //. Answer a Number with the \r\tsame sign as aNumber.\"\r\t\r\t\"9 % 4 >>> 1\"\r\t\"-9 % 4 >>> 3\"\r\t\"9 % -4 >>> -3\"\r\t\r\t\r\t^ self \\\\ aNumber"},{"name":"raisedToInteger:","linesOfCode":15,"sourceCode":"raisedToInteger: anInteger\r\r\t\"The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must\r\tbe handled as an indeterminate form.\r\tI take the first context because that's the way that was previously handled.\r\tMaybe further discussion is required on this topic.\"\r\t\r\t|bitProbe result|\r\r\tanInteger negative ifTrue: [^(self raisedToInteger: anInteger negated) reciprocal].\r\tbitProbe := 1 bitShift: anInteger highBit - 1.\r \tresult := self class one.\r  \t[\r\t\t(anInteger bitAnd: bitProbe) = 0 ifFalse: [result := result * self].\r       bitProbe := bitProbe bitShift: -1.\r\t\tbitProbe > 0 ]\r\twhileTrue: [result := result * result].\r\t\r\t^result"},{"name":"to:by:","linesOfCode":4,"sourceCode":"to: stop by: step\r\t\"Answer an Interval from the receiver up to the argument, stop, \r\tincrementing by step.\"\r\r\t^Interval from: self to: stop by: step"},{"name":"asSmallAngleDegrees","linesOfCode":7,"sourceCode":"asSmallAngleDegrees\r\t\"Return the receiver normalized to lie within the range (-180, 180)\"\r\r\t| pos |\r\tpos := self \\\\ 360.\r\tpos > 180 ifTrue: [pos := pos - 360].\r\t^ pos\r\r\"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallAngleDegrees]\""},{"name":"exp","linesOfCode":3,"sourceCode":"exp\r\t\"Answer the exponential of the receiver as a floating point number.\"\r\r\t^self asFloat exp"},{"name":"arcTan","linesOfCode":4,"sourceCode":"arcTan\r\t\"The receiver is the tangent of an angle. Answer the angle measured in \r\tradians.\"\r\r\t^self asFloat arcTan"},{"name":"u","linesOfCode":1,"sourceCode":"u\r\t^ self castTo: UInt32"},{"name":"randomNoise","linesOfCode":2,"sourceCode":"randomNoise\r\t^ self floor randomNoiseHashNormalized\r\t"},{"name":"linearStepFrom:to:","linesOfCode":4,"sourceCode":"linearStepFrom: leftEdge to: rightEdge\r\tself <= leftEdge ifTrue: [ ^ 0.0 ].\r\tself >= rightEdge ifTrue: [ ^ 1.0 ].\r\t\r\t^ ((self - leftEdge) / (rightEdge - leftEdge))"},{"name":"sqrt","linesOfCode":3,"sourceCode":"sqrt\r\t\"Answer the square root of the receiver.\"\r\r\tself subclassResponsibility"},{"name":"milliSecond","linesOfCode":4,"sourceCode":"milliSecond\r\t\"1 milliSecond printString >>> '0:00:00:00.001'\"\r\t\"(1 second + 1 milliSecond) printString >>> '0:00:00:01.001'\"\r\t\r \t^ self milliSeconds\r "},{"name":"day","linesOfCode":2,"sourceCode":"day\r \r \t^ self days"},{"name":"divideWithAngle:","linesOfCode":2,"sourceCode":"divideWithAngle: aGAngle \r\t^ (aGAngle radians / self) radians"},{"name":"asFloatFromNormalizedUShort","linesOfCode":2,"sourceCode":"asFloatFromNormalizedUShort\r\t^ self asFloat / 65535.0"},{"name":"negative","linesOfCode":3,"sourceCode":"negative\r\t\"Answer whether the receiver is mathematically negative.\"\r\r\t^ self < 0"},{"name":"positive","linesOfCode":4,"sourceCode":"positive\r\t\"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).\r\tSee also strictlyPositive\"\r\r\t^ self >= 0"},{"name":"asInteger","linesOfCode":4,"sourceCode":"asInteger\r\t\"Round me towards nearest integer closer to zero.\"\r\t\"This violates the ANSI standard, but the system depends on this\"\r\r\t^self truncated "},{"name":"stepEdge:","linesOfCode":2,"sourceCode":"stepEdge: edge\r\t^ self < edge ifTrue: [0.0] ifFalse: [ 1.0 ]"},{"name":"turbulenceScales:","linesOfCode":2,"sourceCode":"turbulenceScales: scale\r\t^ self fractionalBrownianMotionOctaves: scale lacunarity: 2.0 gain: 0.5 with: #signedGradientNoise\r"},{"name":"printStringBase:","linesOfCode":7,"sourceCode":"printStringBase: base\r\t\"Return a String representation of this number in base b.\"\r\t\"(10 printStringBase: 10) >>> '10'\"\r\t\"(-10 printStringBase: 10) >>> '-10'\"\r\t\"(10 printStringBase: 2) >>> '1010'\"\r\t\"(10 printStringBase: 16) >>> 'A'\"\r\t\r\t^ String streamContents: [:strm | self printOn: strm base: base]"},{"name":"roundUpTo:","linesOfCode":9,"sourceCode":"roundUpTo: aNumber \r\t\"Answer the next multiple of aNumber toward infinity that is nearest the receiver.\r\tExamples:\r               3.1479 roundUpTo: 0.01 -> 3.15\r               3.1479 roundUpTo: 0.1 -> 3.2\r               1923 roundUpTo: 10 -> 1930\r               3.1479 roundUpTo: 0.005 -> 3.15\r               -3.1479 roundUpTo: 0.01 -> -3.14\"\r\r\t^(self / aNumber) ceiling * aNumber"},{"name":"fractionalBrownianMotionOctaves:lacunarity:gain:tiledWith:with:","linesOfCode":15,"sourceCode":"fractionalBrownianMotionOctaves: octaves lacunarity: lacunarity gain: gain tiledWith: tilingPeriod with: aBlock\r\t| result currentCoord amplitude currentTilingPeriod amplitudeSum |\r\tresult := 0.0.\r\tcurrentCoord := self.\r\tcurrentTilingPeriod := tilingPeriod.\r\tamplitude := 0.5.\r\tamplitudeSum := 0.0.\r\t\r\t1 to: octaves do: [ :i |\r\t\tresult := result + (aBlock noiseValueAt: currentCoord withAmplitude: amplitude).\r\t\tcurrentCoord := currentCoord * lacunarity.\r\t\tcurrentTilingPeriod := currentTilingPeriod*lacunarity.\r\t\tamplitudeSum := amplitudeSum + amplitude.\r\t\tamplitude = amplitude * gain\r\t].\r\r\t^ result / amplitudeSum\r"},{"name":"asMargin","linesOfCode":2,"sourceCode":"asMargin\r\t^ Margin fromNumber: self."},{"name":"stonContainSubObjects","linesOfCode":2,"sourceCode":"stonContainSubObjects \r\t^ false"},{"name":"year","linesOfCode":2,"sourceCode":"year\r \r \t^self years"},{"name":"reduce","linesOfCode":3,"sourceCode":"reduce\r    \"If self is close to an integer, return that integer\"\r    ^ self"},{"name":"arcTan:","linesOfCode":4,"sourceCode":"arcTan: denominator\r\t\"The receiver is the tangent of an angle. Answer the angle measured in \r\tradians.\"\r\r\t^ self asFloat arcTan: denominator"},{"name":"gradientNoise","linesOfCode":2,"sourceCode":"gradientNoise\r\t^ self signedGradientNoise * 0.5 + 0.5"},{"name":"weeks","linesOfCode":2,"sourceCode":"weeks\r \r \t^ Duration weeks: self"},{"name":"degreeSin","linesOfCode":3,"sourceCode":"degreeSin\r\t\"Answer the sine of the receiver taken as an angle in degrees.\"\r\t\r\t^(90 - self) degreeCos"},{"name":"fuzzyAnd:","linesOfCode":2,"sourceCode":"fuzzyAnd: other\r\t^ self min: other"},{"name":"rem:","linesOfCode":4,"sourceCode":"rem: aNumber \r\t\"Remainder defined in terms of quo:. Answer a Number with the same \r\tsign as self. e.g. 9 rem: 4 = 1, -9 rem: 4 = -1. 0.9 rem: 0.4 = 0.1.\"\r\r\t^self - ((self quo: aNumber) * aNumber)"},{"name":"ln","linesOfCode":3,"sourceCode":"ln\r\t\"Answer the natural log of the receiver.\"\r\r\t^self asFloat ln"},{"name":"llvmPrintSpecializedMetadataValueOn:","linesOfCode":2,"sourceCode":"llvmPrintSpecializedMetadataValueOn: aStream\r\tself printOn: aStream"},{"name":"isInfinite","linesOfCode":2,"sourceCode":"isInfinite\r\r\t^ false"},{"name":"floorFract","linesOfCode":2,"sourceCode":"floorFract\r\t^ self - self floor"},{"name":"squared","linesOfCode":3,"sourceCode":"squared\r\t\"Answer the receiver multiplied by itself.\"\r\r\t^self * self"},{"name":"radiansToDegrees","linesOfCode":5,"sourceCode":"radiansToDegrees\r\t\"The receiver is assumed to represent radians. Answer the conversion to \r\tdegrees.\"\r\t\r\t\"Float pi radiansToDegrees >>> 180.0\"\r\r\t^self asFloat radiansToDegrees"},{"name":"stringForReadout","linesOfCode":2,"sourceCode":"stringForReadout\r\t^ self rounded printString"},{"name":"radians","linesOfCode":2,"sourceCode":"radians\r\t^ GAngle radians: self"},{"name":"to:","linesOfCode":4,"sourceCode":"to: stop\r\t\"Answer an Interval from the receiver up to the argument, stop, \r\tincrementing by 1.\"\r\r\t^Interval from: self to: stop by: 1"},{"name":"closeTo:precision:","linesOfCode":4,"sourceCode":"closeTo: num precision: aPrecision\r\t\"are these two numbers close?\"\r\r\tnum isFloat ifTrue: [ ^ num closeTo: self asFloat precision: aPrecision ].\r\t^ [ self = num ] onErrorDo: [ false ]"},{"name":"neoJsonOn:","linesOfCode":2,"sourceCode":"neoJsonOn: neoJSONWriter\r\tneoJSONWriter writeFloat: self asFloat"},{"name":"addAssignToFloatArray:","linesOfCode":2,"sourceCode":"addAssignToFloatArray: aFloatArray\r\t^ aFloatArray primAddScalar: self asFloat"},{"name":"floatDivide:","linesOfCode":8,"sourceCode":"floatDivide: divisor\r\tdivisor = 0 ifTrue: [ \r\t\t^ self = 0 ifTrue: [ Float nan ]\r\t\t\tifFalse: [ self positive\r\t\t\t\t\tifTrue: [ Float infinity ]\r\t\t\t\t\tifFalse: [ Float negativeInfinity ]]\r\t].\r\r\t^ self asFloat / divisor asFloat"},{"name":"asSeconds","linesOfCode":2,"sourceCode":"asSeconds\r\t^ Duration milliSeconds: self * 1000"},{"name":"asFloatFromNormalizedUByte","linesOfCode":2,"sourceCode":"asFloatFromNormalizedUByte\r\t^ self asFloat / 255.0"},{"name":"interpolateTo:at:","linesOfCode":2,"sourceCode":"interpolateTo: aNumber at: param\r    ^  self * (1 - param) + (aNumber * param)"},{"name":"even","linesOfCode":3,"sourceCode":"even\r\t\"Answer whether the receiver is an even number.\"\r\r\t^self \\\\ 2 = 0"},{"name":"fractionPart","linesOfCode":3,"sourceCode":"fractionPart\r\t\"Added for ANSI compatibility\"\r\t^self - self integerPart"},{"name":"fractionalBrownianMotionOctaves:lacunarity:with:","linesOfCode":2,"sourceCode":"fractionalBrownianMotionOctaves: octaves lacunarity: lacunarity with: aBlock\r\t^ self fractionalBrownianMotionOctaves: octaves lacunarity: lacunarity gain: lacunarity reciprocal with: aBlock"},{"name":"fuzzyNot","linesOfCode":2,"sourceCode":"fuzzyNot\r\t^ 1.0 - self"},{"name":"smoothStepFrom:to:","linesOfCode":4,"sourceCode":"smoothStepFrom: leftEdge to: rightEdge\r\tself <= leftEdge ifTrue: [ ^ 0.0 ].\r\tself >= rightEdge ifTrue: [ ^ 1.0 ].\r\t\r\t^ ((self - leftEdge) / (rightEdge - leftEdge)) cubicHemiteCurve"},{"name":"truncated","linesOfCode":3,"sourceCode":"truncated\r\t\"Answer an integer nearest the receiver toward zero.\"\r\r\t^self quo: 1"},{"name":"sign:","linesOfCode":3,"sourceCode":"sign: aNumber\r \t\"Return a Number with the same sign as aNumber\"\r \r \t^ aNumber copySignTo: self."},{"name":"slvmEncodeAsSExpression","linesOfCode":2,"sourceCode":"slvmEncodeAsSExpression\r\t^ self"},{"name":"rounded","linesOfCode":7,"sourceCode":"rounded\r\t\"Answer the integer nearest the receiver.\"\r\t\r\t\"1.4 rounded >>> 1\"\r\t\"1.5 rounded >>> 2\"\r\t\"2 rounded >>> 2\"\r\t\"-1.5 rounded >>> -2\"\r\r\t^(self + (self sign / 2)) truncated"},{"name":"degreesToRadians","linesOfCode":4,"sourceCode":"degreesToRadians\r\t\"The receiver is assumed to represent degrees. Answer the conversion to \r\tradians.\"\r\r\t^self asFloat degreesToRadians"},{"name":",","linesOfCode":2,"sourceCode":", aNumber\r\t^ GPoint x: self y: aNumber"},{"name":"integerPart","linesOfCode":3,"sourceCode":"integerPart\r\t\"Added for ANSI compatibility\"\r\t^self truncated"},{"name":"signBit","linesOfCode":4,"sourceCode":"signBit\r\t\"Answer 1 if the receiver is negative, zero otherwise.\"\r\r\tself < 0 ifTrue: [^1].\r\t^0"},{"name":"minute","linesOfCode":4,"sourceCode":"minute\r\t\"1 minute printString >>> '0:00:01:00'\"\r\t\"(1 hour + 1 minute) printString >>> '0:01:01:00'\"\r \r \t^ self minutes\r "},{"name":"*","linesOfCode":3,"sourceCode":"* aNumber \r\t\"Answer the result of multiplying the receiver by aNumber.\"\r\r\tself subclassResponsibility"},{"name":"to:by:do:","linesOfCode":16,"sourceCode":"to: stop by: step do: aBlock \r\t\"Normally compiled in-line, and therefore not overridable.\r\tEvaluate aBlock for each element of the interval (self to: stop by: \rstep).\"\r\t| nextValue |\r\tnextValue := self.\r\tstep = 0 ifTrue: [self error: 'step must be non-zero'].\r\tstep < 0\r\t\tifTrue: [[stop <= nextValue]\r\t\t\t\twhileTrue: \r\t\t\t\t\t[aBlock value: nextValue.\r\t\t\t\t\tnextValue := nextValue + step]]\r\t\tifFalse: [[stop >= nextValue]\r\t\t\t\twhileTrue: \r\t\t\t\t\t[aBlock value: nextValue.\r\t\t\t\t\tnextValue := nextValue + step]]"},{"name":"asNumber","linesOfCode":2,"sourceCode":"asNumber\r\t^ self"},{"name":"printOn:showingDecimalPlaces:","linesOfCode":12,"sourceCode":"printOn: aStream showingDecimalPlaces: placesDesired\r\t\"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator.\"\r\r\t| rounder rounded roundedFractionPart |\r\tplacesDesired <= 0 ifTrue: [^ self rounded printOn: aStream].\r\trounder := 10 raisedToInteger: placesDesired.\r\trounded := self roundTo: rounder reciprocal.\r\trounded negative ifTrue: [aStream nextPut: $-].\r\trounded := rounded abs.\r\trounded integerPart truncated printOn: aStream.\r\taStream nextPut: $..\r\troundedFractionPart := (rounded fractionPart * rounder) truncated.\r\troundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true"},{"name":"log","linesOfCode":3,"sourceCode":"log\r\t\"Answer the base-10 log of the receiver.\"\r\r\t^self asFloat log"},{"name":"=~","linesOfCode":2,"sourceCode":"=~ aNumber \r\t^((self - aNumber) abs) < Number epsilon."},{"name":"adaptToFloat:andSend:","linesOfCode":3,"sourceCode":"adaptToFloat: rcvr andSend: selector \r\t\"If I am involved in arithmetic with a Float, convert me to a Float.\"\r\t^ rcvr perform: selector with: self asFloat"},{"name":"f","linesOfCode":1,"sourceCode":"f\r\t^ self castTo: Float32"},{"name":"quo:","linesOfCode":6,"sourceCode":"quo: aNumber \r\t\"Integer quotient defined by division with truncation toward zero. \r\t\r\t(-9 quo: 4) = -2.\r\t(-0.9 quo: 0.4) = -2. \r\t\r\trem: answers the remainder from this division.\"\r\r\t^(self / aNumber) truncated"},{"name":"asDuration","linesOfCode":2,"sourceCode":"asDuration\r \r \t^ Duration seconds: self asInteger\r "},{"name":"adaptToPoint:andSend:","linesOfCode":3,"sourceCode":"adaptToPoint: rcvr andSend: selector\r\t\"If I am involved in arithmetic with a Point, convert me to a Point.\"\r\t^ rcvr perform: selector with: self@self"},{"name":"reciprocal","linesOfCode":8,"sourceCode":"reciprocal\r\t\"Returns the reciprocal of self.\r\tIn case self is 0 the / signals ZeroDivide\"\r\t\r\t\"1/2 reciprocal >>> 2\"\r\t\"2 reciprocal >>> (1/2)\"\r\t\"1.25 reciprocal >>> 0.8\"\r\t\"-2 reciprocal >>> (-1/2)\"\r\t\r\t^1 / self"},{"name":"sin","linesOfCode":3,"sourceCode":"sin\r\t\"The receiver represents an angle measured in radians. Answer its sine.\"\r\r\t^self asFloat sin"},{"name":"asScaledDecimal:","linesOfCode":3,"sourceCode":"asScaledDecimal: scale \r\t\"Answer the receiver converted to a ScaledDecimal.\"\r\t\r\t^ ScaledDecimal newFromNumber: self scale: scale"},{"name":"storeStringBase:","linesOfCode":5,"sourceCode":"storeStringBase: base\r\t\"Returns a string representation of the receiver in base 16 in a way that executing it will return the receiver.\"\r\t\"(10 storeStringBase: 16) >>> '16rA'\"\r\t\"(10 storeStringBase: 10) >>> '10'\"\r\r\t^ String streamContents: [:strm | self storeOn: strm base: base]"},{"name":"asSLVMMessagePackSerializableObject","linesOfCode":2,"sourceCode":"asSLVMMessagePackSerializableObject\r\t^ self asFloat"},{"name":"fuzzyOr:","linesOfCode":2,"sourceCode":"fuzzyOr: other\r\t^ self max: other"},{"name":"abs","linesOfCode":6,"sourceCode":"abs\r\t\"Answer a Number that is the absolute value (positive magnitude) of the \r\treceiver.\"\r\r\tself < 0\r\t\tifTrue: [^self negated]\r\t\tifFalse: [^self]"},{"name":"asScaledDecimal","linesOfCode":4,"sourceCode":"asScaledDecimal\r\t\"Answer a scaled decimal number approximating the receiver.\"\r\t#Numeric.\r\r\t^ self asScaledDecimal: 8\r"},{"name":"+","linesOfCode":3,"sourceCode":"+ aNumber \r\t\"Answer the sum of the receiver and aNumber.\"\r\r\tself subclassResponsibility"},{"name":"raisedToFraction:","linesOfCode":9,"sourceCode":"raisedToFraction: aFraction\r\tself isZero\r\t\tifTrue:\r\t\t\t[aFraction negative ifTrue: [^ (ZeroDivide dividend: 1) signal].\r\t\t\t^self].\r\tself negative ifFalse: [^(self ln * aFraction) exp].\r\taFraction denominator even\r\t\tifTrue: [^ ArithmeticError signal: 'nth root only defined for positive Integer n.'].\r\t^(self negated ln * aFraction) exp negated"},{"name":"milliSeconds","linesOfCode":4,"sourceCode":"milliSeconds\r\r\t\"2 milliSeconds printString >>> '0:00:00:00.002'\"\r\t\"(1 second + 2 milliSeconds) printString >>> '0:00:00:01.002'\"\r\t\r \t^ Duration milliSeconds: self\r "},{"name":"second","linesOfCode":4,"sourceCode":"second\r\t\"1 second printString >>> '0:00:00:01'\"\r\t\"(1 minute + 1 second) printString >>> '0:00:01:01'\"\r\t\r \t^ self seconds\r "},{"name":"isNumber","linesOfCode":2,"sourceCode":"isNumber\r\t^ true"},{"name":"adaptToFloat:andCompare:","linesOfCode":14,"sourceCode":"adaptToFloat: rcvr andCompare: selector \r\t\"If I am involved in comparison with a Float, convert rcvr to a\r\tFraction. This way, no bit is lost and comparison is exact.\"\r\t\r\trcvr isFinite\r\t\tifFalse: [\r\t\t\tselector == #= ifTrue: [^false].\r\t\t\tselector == #~= ifTrue: [^true].\r\t\t\trcvr isNaN ifTrue: [^ false].\r\t\t\t(selector = #< or: [selector = #'<='])\r\t\t\t\tifTrue: [^ rcvr positive not].\r\t\t\t(selector = #> or: [selector = #'>='])\r\t\t\t\tifTrue: [^ rcvr positive].\r\t\t\t^self error: 'unknow comparison selector'].\r\r\t^ rcvr asTrueFraction perform: selector with: self"},{"name":"roundTo:","linesOfCode":3,"sourceCode":"roundTo: quantum \r\t\"Answer the nearest number that is a multiple of quantum.\"\r\r\t^(self / quantum) rounded * quantum"},{"name":"@","linesOfCode":6,"sourceCode":"@ y \r\t\"Primitive. Answer a Point whose x value is the receiver and whose y \r\tvalue is the argument. Optional. No Lookup. See Object documentation \r\twhatIsAPrimitive.\"\r\r\t<primitive: 18>\r\t^Point x: self y: y"},{"name":"isDivisibleBy:","linesOfCode":4,"sourceCode":"isDivisibleBy: aNumber\r\taNumber = 0 ifTrue: [^ false].\r\taNumber isInteger ifFalse: [^ false].\r\t^ (self \\\\ aNumber) = 0"},{"name":"asPoint","linesOfCode":5,"sourceCode":"asPoint\r\t\"Answer a Point with the receiver as both coordinates; often used to \r\tsupply the same value in two dimensions, as with symmetrical gridding \r\tor scaling.\"\r\r\t^self @ self"}],"meta":{"name":"Number class","instanceVariables":[],"methods":[{"name":"readScaledDecimal:fractionPart:digits:base:sign:from:","linesOfCode":23,"sourceCode":"readScaledDecimal: integerPart fractionPart: fractionPart digits: fractionDigits base: base sign: sign from: aStream \r\t\"Complete creation of a ScaledDecimal, reading scale from aStream. Answer\r\ta ScaledDecimal, or nil if parsing fails.\r\t<number>s[<scale>]\"\r\r\t| scale decimalMultiplier decimalFraction |\r\taStream atEnd ifTrue: [^ nil].\r\t(aStream next == $s) ifFalse: [^ nil].\r\t\"<number>s<scale>\"\r\t(aStream atEnd not and: [aStream peek digitValue between: 0 and: 9])\r\t\tifTrue: [scale := Integer readFrom: aStream]\r\t\tifFalse: [^ nil].\r\tscale \r\t\tifNil: [\"<number>s\"\r\t\t\tfractionDigits = 0\r\t\t\t\tifTrue: [\"<integer>s\"\r\t\t\t\t\tscale := 0]\r\t\t\t\tifFalse: [\"<integer>.<fraction>s\"\r\t\t\t\t\tscale := fractionDigits]].\r\tfractionPart \r\t\tifNil: [^integerPart * sign asScaledDecimal: scale]\r\t\tifNotNil: [decimalMultiplier := base raisedTo: fractionDigits.\r\t\t\tdecimalFraction := integerPart * decimalMultiplier + fractionPart * sign / decimalMultiplier.\r\t\t\t^decimalFraction asScaledDecimal: scale]"},{"name":"readExponent:base:from:","linesOfCode":14,"sourceCode":"readExponent: baseValue base: base from: aStream\r\t\"Complete creation of a number, reading exponent from aStream. Answer the\r\tnumber, or nil if parsing fails.\r\t<number>(e|d|q)<exponent>>\"\r\r\t| sign exp value |\r\t('edq' includes: aStream next) ifFalse: [^ nil].\r\tsign := ((aStream peek) == $-)\r\t\tifTrue: [aStream next. -1]\r\t\tifFalse: [1].\r\t(aStream atEnd or: [(aStream peek digitValue between: 0 and: 9) not])\r\t\tifTrue: [^ nil]. \"Avoid throwing an error\"\r\texp := (Integer readFrom: aStream base: 10) * sign.\r\tvalue := baseValue * (base raisedTo: exp).\r\t^ value\r"},{"name":"one","linesOfCode":2,"sourceCode":"one\r\r\t^1"},{"name":"readRemainderOf:from:base:withSign:","linesOfCode":41,"sourceCode":"readRemainderOf: integerPart from: aStream base: base withSign: sign \r\t\"Read optional fractional part and exponent or decimal scale, and return the final result\"\r\t\"Number readFrom: '3r-22.2'\"\r\r\t| value fractionDigits fracpos fractionPart fraction pos v foundDecimal |\r\tvalue := integerPart.\r\tfractionDigits := 0.\r\tfoundDecimal := false.\r\t(aStream peekFor: $.)\r\t\tifTrue: [\"<integer>.<fraction>\"\r\t\t\tfoundDecimal := true.\r\t\t\t(aStream atEnd not\r\t\t\t\t\tand: [aStream peek digitValue between: 0 and: base - 1])\r\t\t\t\tifTrue: [fracpos := aStream position.\r\t\t\t\t\tfractionPart := Integer readFrom: aStream base: base.\r\t\t\t\t\tfraction := fractionPart asFloat\r\t\t\t\t\t\t\t\t/ (base raisedTo: aStream position - fracpos).\r\t\t\t\t\tfractionDigits := aStream position - fracpos.\r\t\t\t\t\tvalue := value asFloat + fraction]].\r\r\tpos := aStream position.\r\t(v := self readScaledDecimal: integerPart\r\t\t\tfractionPart: fractionPart\r\t\t\tdigits: fractionDigits\r\t\t\tbase: base\r\t\t\tsign: sign\r\t\t\tfrom: aStream)\r\t\tifNil: [aStream position: pos]\r\t\tifNotNil: [^ v \"<number>s<scale>>\"].\r\r\tpos := aStream position.\r\t(v := self readExponent: value base: base from: aStream)\r\t\tifNil: [aStream position: pos.\r\t\t\t(foundDecimal and: [fractionDigits = 0])\r\t\t\t\tifTrue: [\"oops - just <integer>.\"\r\t\t\t\t\t\t\taStream skip: -1.\r\t\t\t\t\t\t\t\"un-gobble the period\"\r\t\t\t\t\t\t\t^ value * sign]]\r\t\tifNotNil: [value := v \"<number>(e|d|q)<exponent>>\"].\r\r\t(value isFloat\r\t\t\tand: [value = 0.0\r\t\t\t\t\tand: [sign = -1]])\r\t\tifTrue: [^ Float negativeZero]\r\t\tifFalse: [^ value * sign]"},{"name":"settingInputWidgetForNode:","linesOfCode":2,"sourceCode":"settingInputWidgetForNode: aSettingNode\r\t^ aSettingNode inputWidgetForNumber"},{"name":"readFrom:ifFail:","linesOfCode":8,"sourceCode":"readFrom: stringOrStream ifFail: aBlock\r\t\"Answer a number as described on aStream.  The number may\r\tbe any accepted Smalltalk literal Number format.\r\tIt can include a leading radix specification, as in 16rFADE.\r\tIt can as well be NaN, Infinity or -Infinity for conveniency.\r\tIf input does not represent a valid number, then execute fail block\r\tand leave the stream positioned before offending character\"\r\t\r\t^(NumberParser on: stringOrStream) failBlock: aBlock; nextNumber"},{"name":"new","linesOfCode":4,"sourceCode":"new\r\r\tself == Number ifTrue: [\r\t\t^ self error: 'Number is an abstract class.  Make a concrete subclass.'].\r\t^ super new"},{"name":"squeezeNumberOutOfString:ifFail:","linesOfCode":8,"sourceCode":"squeezeNumberOutOfString: stringOrStream ifFail: aBlock\r\t\"Try and find a number in this string. First, look if the string \r\tstarts with a number. Then, see if it ends with a number. Then,\r\tremove a character from the front and see if the remaining \r\tstring makes a number. Repeat the process until no characters\r\tare left or the number has been found. As soon as a number is\r\tfound, it is returned. Otherwise, the method fails.\"\r\t^ NumberParser squeezeNumberOutOfString: stringOrStream onError: aBlock"},{"name":"epsilon","linesOfCode":2,"sourceCode":"epsilon\r\t^ 0.00001"},{"name":"squeezeNumberOutOfString:","linesOfCode":8,"sourceCode":"squeezeNumberOutOfString: stringOrStream\r\t\"Try and find a number in this string. First, look if the string \r\tstarts with a number. Then, see if it ends with a number. Then,\r\tremove a character from the front and see if the remaining \r\tstring makes a number. Repeat the process until no characters\r\tare left or the number has been found. As soon as a number is\r\tfound, it is returned. Otherwise, the method fails.\"\r\t^ NumberParser squeezeNumberOutOfString: stringOrStream"},{"name":"readFrom:base:","linesOfCode":4,"sourceCode":"readFrom: stringOrStream base: base\r\t\"Answer a number as described on aStream in the given number base.\r\tIf stringOrStream does not start with a valid number description, answer 0 for backward compatibility. This is not clever and should better be changed.\"\r\r\t^(NumberParser on: stringOrStream) nextNumberBase: base"},{"name":"canonicalArgumentName","linesOfCode":2,"sourceCode":"canonicalArgumentName\r\r\t^ 'aNumber'."},{"name":"readFrom:","linesOfCode":7,"sourceCode":"readFrom: stringOrStream \r\t\"Answer a number as described on aStream.  The number may\r\tbe any accepted Smalltalk literal Number format.\r\tIt can include a leading radix specification, as in 16rFADE.\r\tIt can as well be NaN, Infinity or -Infinity for conveniency.\r\tIf stringOrStream does not start with a valid number description, fail.\"\r\t\r\t^(NumberParser on: stringOrStream) nextNumber"}],"meta":null}}]},{"name":"Collections-Abstract-Tests","classes":[{"name":"TPutBasicTest","instanceVariables":[],"methods":[{"name":"anIndex","linesOfCode":3,"sourceCode":"anIndex\r\" return an index in nonEmpty bounds\"\r\t^ self explicitRequirement"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ self explicitRequirement"},{"name":"testAtPutTwoValues","linesOfCode":4,"sourceCode":"testAtPutTwoValues\r\t\r\tself nonEmpty at: self anIndex put: self aValue.\r\tself nonEmpty at: self anIndex put: self anotherValue.\r\tself assert: (self nonEmpty at: self anIndex) = self anotherValue."},{"name":"testAtPut","linesOfCode":3,"sourceCode":"testAtPut\r\t\r\tself nonEmpty at: self anIndex put: self aValue.\r\tself assert: (self nonEmpty at: self anIndex) = self aValue.\r\t"},{"name":"anotherValue","linesOfCode":3,"sourceCode":"anotherValue\r\" return a value ( not eual to 'aValue' ) to put into nonEmpty \"\r\t^ self explicitRequirement"},{"name":"test0FixturePutTest","linesOfCode":9,"sourceCode":"test0FixturePutTest\r\tself aValue.\r\tself anotherValue.\r\r\tself anIndex.\r\tself nonEmpty isDictionary ifFalse: [ self assert: (self anIndex >= 1 & self anIndex) <= self nonEmpty size ].\r\r\tself empty.\r\tself assertEmpty: self empty.\r\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty"},{"name":"testAtPutOutOfBounds","linesOfCode":2,"sourceCode":"testAtPutOutOfBounds\r\t\r\tself should: [self empty at: self anIndex put: self aValue] raise: Error\r\t"},{"name":"aValue","linesOfCode":3,"sourceCode":"aValue\r\" return a value to put into nonEmpty\"\r\t^ self explicitRequirement"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^self explicitRequirement."}],"meta":{"name":"TPutBasicTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TEmptySequenceableTest","instanceVariables":[],"methods":[{"name":"testSequenceIfNotEmptyifEmpty","linesOfCode":2,"sourceCode":"testSequenceIfNotEmptyifEmpty\r\r\tself assert: (self nonEmpty ifEmpty: [false] ifNotEmpty: [:s | (self accessValuePutInOn: s) = self valuePutIn])"},{"name":"valuePutIn","linesOfCode":3,"sourceCode":"valuePutIn\r\t\"the value that we will put in the non empty collection\"\r\t\r\t^ #x"},{"name":"testSequenceIfNotEmpty","linesOfCode":3,"sourceCode":"testSequenceIfNotEmpty\r\r\tself assert: (self nonEmpty \r\t\t\t\t\tifNotEmpty: [:s | self accessValuePutInOn: s]) = self valuePutIn"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r\t^ self explicitRequirement"},{"name":"accessValuePutInOn:","linesOfCode":3,"sourceCode":"accessValuePutInOn: s\r\r\t\"return access the element put in the non-empty collection\"\r\t\r\t^ s perform: self selectorToAccessValuePutIn"},{"name":"accessValuePutIn","linesOfCode":3,"sourceCode":"accessValuePutIn\r\t\"return access the element put in the non-empty collection\"\r\t\r\t^ self perform: self selectorToAccessValuePutIn"},{"name":"selectorToAccessValuePutIn","linesOfCode":3,"sourceCode":"selectorToAccessValuePutIn\r\t\"return the selector of the method that should be invoked to access an element\"\r\t\r\t^ self explicitRequirement"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r\t^ self explicitRequirement"},{"name":"test0FixtureEmptySequenceableTest","linesOfCode":5,"sourceCode":"test0FixtureEmptySequenceableTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself empty.\r\tself assertEmpty: self empty"}],"meta":{"name":"TEmptySequenceableTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TRemoveTest","instanceVariables":[],"methods":[{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\" return a collection without equal elements \"\r\tself explicitRequirement"},{"name":"testRemoveAllError","linesOfCode":5,"sourceCode":"testRemoveAllError\r\t| el aSubCollection |\r\tel := self elementNotIn.\r\taSubCollection := self nonEmptyWithoutEqualElements copyWith: el.\r\r\tself should: [ self nonEmptyWithoutEqualElements removeAll: aSubCollection ] raise: Error"},{"name":"testRemoveIfAbsent","linesOfCode":5,"sourceCode":"testRemoveIfAbsent\r \r\t| el res |\r\tel := self elementNotIn.\r\tres := self nonEmptyWithoutEqualElements remove: el ifAbsent: [ 33 ].\r\tself assert: res equals: 33"},{"name":"testRemoveElementReallyRemovesElement","linesOfCode":5,"sourceCode":"testRemoveElementReallyRemovesElement\r\r\t| size |\r\tsize := self nonEmptyWithoutEqualElements size.\r\tself nonEmptyWithoutEqualElements remove: self nonEmptyWithoutEqualElements anyOne.\r\tself assert: size - 1 equals: self nonEmptyWithoutEqualElements size"},{"name":"testRemoveElementThatExists","linesOfCode":5,"sourceCode":"testRemoveElementThatExists\r\r\t| el res |\r\tel := self nonEmptyWithoutEqualElements anyOne.\r\tres := self nonEmptyWithoutEqualElements remove: el.\r\tself assert: res == el"},{"name":"test0FixtureTRemoveTest","linesOfCode":12,"sourceCode":"test0FixtureTRemoveTest\r\t| duplicate |\r\tself empty.\r\tself nonEmptyWithoutEqualElements.\r\tself denyEmpty: self nonEmptyWithoutEqualElements.\r\tduplicate := true.\r\tself nonEmptyWithoutEqualElements detect: [ :each | (self nonEmptyWithoutEqualElements occurrencesOf: each) > 1 ] ifNone: [ duplicate := false ].\r\tself deny: duplicate.\r\tself elementNotIn.\r\tself assertEmpty: self empty.\r\tself denyEmpty: self nonEmptyWithoutEqualElements.\r\tself deny: (self nonEmptyWithoutEqualElements includes: self elementNotIn)"},{"name":"testRemoveAllSuchThat","linesOfCode":7,"sourceCode":"testRemoveAllSuchThat\r\r\t| el aSubCollection |\r\tel := self nonEmptyWithoutEqualElements anyOne.\r\taSubCollection := self nonEmptyWithoutEqualElements copyWithout: el.\r\tself nonEmptyWithoutEqualElements removeAllSuchThat: [ :each | aSubCollection includes: each ].\r\t\r\tself assert: self nonEmptyWithoutEqualElements size equals: 1.\r\tself nonEmptyWithoutEqualElements do: [ :each | self assert: each equals: el ]"},{"name":"testRemoveElementFromEmpty","linesOfCode":4,"sourceCode":"testRemoveElementFromEmpty\r\r\tself \r\t\tshould: [ self empty remove: self nonEmptyWithoutEqualElements anyOne ]\r\t\traise: Error"},{"name":"testRemoveAllFoundIn","linesOfCode":7,"sourceCode":"testRemoveAllFoundIn\r\r\t| el aSubCollection   |\r\tel := self nonEmptyWithoutEqualElements anyOne.\r\taSubCollection := (self nonEmptyWithoutEqualElements copyWithout: el) copyWith: self elementNotIn.\r\tself nonEmptyWithoutEqualElements removeAllFoundIn: aSubCollection.\r\t\r\tself assert: self nonEmptyWithoutEqualElements size equals: 1.\r\tself nonEmptyWithoutEqualElements do: [ :each | self assert: each equals: el ]"},{"name":"testRemoveAll","linesOfCode":8,"sourceCode":"testRemoveAll\r\t| el aSubCollection collection |\r\tcollection := self nonEmptyWithoutEqualElements.\r\tel := collection anyOne.\r\taSubCollection := collection copyWithout: el.\r\tcollection removeAll: aSubCollection.\r\tself assert: collection size = 1.\r\tself nonEmptyWithoutEqualElements do: [ :each | self assert: each = el ]"},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\" return an element not included in nonEmptyWithoutEqualElements\"\r\tself explicitRequirement"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement"}],"meta":{"name":"TRemoveTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TBeginsEndsWith","instanceVariables":[],"methods":[{"name":"testsEndsWith","linesOfCode":4,"sourceCode":"testsEndsWith\r\t\r\tself assert: (self nonEmpty endsWith: self nonEmpty copyWithoutFirst).\r\tself assert: (self nonEmpty endsWith: self nonEmpty).\r\tself deny: (self nonEmpty endsWith: (self nonEmpty copyWith: self nonEmpty first))"},{"name":"testsBeginsWithEmpty","linesOfCode":3,"sourceCode":"testsBeginsWithEmpty\r\t\r\tself deny: (self nonEmpty beginsWith:(self empty)).\r\tself deny: (self empty beginsWith:(self nonEmpty))\r"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\tself explicitRequirement."},{"name":"test0FixtureBeginsEndsWithTest","linesOfCode":6,"sourceCode":"test0FixtureBeginsEndsWithTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself assert: self nonEmpty size > 1.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"testsBeginsWith","linesOfCode":4,"sourceCode":"testsBeginsWith\r\t\r\tself assert: (self nonEmpty beginsWith: (self nonEmpty copyUpTo: self nonEmpty last)).\r\tself assert: (self nonEmpty beginsWith: self nonEmpty).\r\tself deny: (self nonEmpty beginsWith: (self nonEmpty copyWith: self nonEmpty first))"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement."},{"name":"testsEndsWithEmpty","linesOfCode":3,"sourceCode":"testsEndsWithEmpty\r\t\r\tself deny: (self nonEmpty endsWith: self empty).\r\tself deny: (self empty endsWith: self nonEmpty)\r\t"}],"meta":{"name":"TBeginsEndsWith classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TAddForUniquenessTest","instanceVariables":[],"methods":[{"name":"test0FixtureAddForUniquenessTest","linesOfCode":6,"sourceCode":"test0FixtureAddForUniquenessTest\r\tself element.\r\tself collectionWithElement.\r\tself assert: (self collectionWithElement includes: self element).\r\tself collectionWithoutElement.\r\tself deny: (self collectionWithoutElement includes: self element)"},{"name":"testTAddIfNotPresentWithElementAlreadyIn","linesOfCode":8,"sourceCode":"testTAddIfNotPresentWithElementAlreadyIn\r\r\t| added oldSize |\r\toldSize := self collectionWithElement size.\r\tself assert: (self collectionWithElement includes: self element).\r\r\tadded := self collectionWithElement addIfNotPresent: self element.\r\t\r\tself assert: added = self element.\r\tself assert: (self collectionWithElement includes: self element).\r\tself assert: self collectionWithElement size = oldSize."},{"name":"testTAddIfNotPresentWithNewElement","linesOfCode":8,"sourceCode":"testTAddIfNotPresentWithNewElement\r\t| added oldSize |\r\toldSize := self collectionWithoutElement size.\r\tself deny: (self collectionWithoutElement includes: self element).\r\tadded := self collectionWithoutElement addIfNotPresent: self element.\r\tself assert: added = self element.\r\tself assert: (self collectionWithoutElement includes: self element).\r\tself assert: self collectionWithoutElement size = (oldSize + 1)"},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ self explicitRequirement"},{"name":"testAddAlreadyThereDoesNotCount","linesOfCode":8,"sourceCode":"testAddAlreadyThereDoesNotCount\r\r\t| added oldSize |\r\toldSize := self collectionWithElement size.\r\tself assert: (self collectionWithElement includes: self element).\r\r\tadded := self collectionWithElement add: self element.\r\t\r\tself assert: added = self element.\r\tself assert: (self collectionWithElement includes: self element).\r\tself assert: self collectionWithElement size = oldSize."},{"name":"testAddNewElementIncrementsSize","linesOfCode":8,"sourceCode":"testAddNewElementIncrementsSize\r\t| added oldSize |\r\toldSize := self collectionWithoutElement size.\r\tself deny: (self collectionWithoutElement includes: self element).\r\tadded := self collectionWithoutElement add: self element.\r\tself assert: added = self element.\r\tself assert: (self collectionWithoutElement includes: self element).\r\tself assert: self collectionWithoutElement size = (oldSize + 1)"},{"name":"collectionWithoutElement","linesOfCode":3,"sourceCode":"collectionWithoutElement\r\t\" return a collection that does not include 'element' \"\r\t^ self explicitRequirement"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\" return a collection already including 'element'    \"\r\t^ self explicitRequirement"}],"meta":{"name":"TAddForUniquenessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TPrintTest","instanceVariables":[],"methods":[{"name":"testPrintOn","linesOfCode":20,"sourceCode":"testPrintOn\r\t| aStream result allElementsAsString tmp |\r\tresult:=''.\r\taStream:= ReadWriteStream on: result.\r\ttmp:= OrderedCollection new.\r\tself nonEmpty do: [:each | tmp add: each asString].\r\t\r\tself nonEmpty printOn: aStream .\r\tallElementsAsString:=(result findBetweenSubstrings: ' ' ).\r\t1 to: allElementsAsString size do:\r\t\t[:i | \r\t\ti=1\r\t\t\tifTrue:[\r\t\t\tself accessCollection class name first isVowel \r\t\t\t\tifTrue:[self assert: (allElementsAsString at:i)='an' ]\r\t\t\t\tifFalse:[self assert: (allElementsAsString at:i)='a'].].\r\t\ti=2\r\t\t\tifTrue:[self assert: (allElementsAsString at:i)=self accessCollection class name].\r\t\ti>2\r\t\t\tifTrue:[self assert: (tmp occurrencesOf:(allElementsAsString at:i))=(allElementsAsString  occurrencesOf:(allElementsAsString at:i)).].\t\r\t\t\t]."},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r self explicitRequirement"},{"name":"testPrintOnDelimiterLast","linesOfCode":17,"sourceCode":"testPrintOnDelimiterLast\r\r\t| aStream result allElementsAsString tmp |\r\tresult:=''.\r\taStream:= ReadWriteStream on: result.\r\ttmp:= OrderedCollection new.\r\tself nonEmpty do: [:each | tmp add: each asString].\r\t\r\tself nonEmpty printOn: aStream delimiter: ', ' last: 'and'.\r\t\r\tallElementsAsString:=(result findBetweenSubstrings: ', ' ).\r\t1 to: allElementsAsString size do:\r\t\t[:i | \r\t\ti<(allElementsAsString size-1 )\r\t\t\tifTrue: [self assert: (tmp occurrencesOf: (allElementsAsString at:i))=(allElementsAsString  occurrencesOf: (allElementsAsString at:i))].\r\t\ti=(allElementsAsString size-1)\r\t\t\tifTrue:[ self deny: (allElementsAsString at:i)=('and')asString].\r\t\ti=(allElementsAsString size)\r\t\t\tifTrue: [self assert: (tmp occurrencesOf: (allElementsAsString at:i))=(allElementsAsString  occurrencesOf: (allElementsAsString at:i))].\r\t\t\t]."},{"name":"testPrintNameOn","linesOfCode":8,"sourceCode":"testPrintNameOn\r\r\t| aStream result |\r\tresult:=''.\r\taStream:= ReadWriteStream on: result.\r\tself nonEmpty printNameOn: aStream.\r\tself nonEmpty class name first isVowel\r\t\tifTrue:[ self assert: aStream contents =('an ',self nonEmpty class name ) ]\r\t\tifFalse:[self assert: aStream contents =('a ',self nonEmpty class name)]."},{"name":"testPrintElementsOn","linesOfCode":12,"sourceCode":"testPrintElementsOn\r\r\t| aStream result allElementsAsString tmp |\r\tresult:=''.\r\taStream:= ReadWriteStream on: result.\r\ttmp:= OrderedCollection new.\r\tself nonEmpty do: [:each | tmp add: each asString].\r\t\r\tself nonEmpty printElementsOn: aStream .\r\tallElementsAsString:=(result findBetweenSubstrings: ' ' ).\r\t1 to: allElementsAsString size do:\r\t\t[:i | \r\t\tself assert: (tmp occurrencesOf:(allElementsAsString at:i))=(allElementsAsString  occurrencesOf:(allElementsAsString at:i)).\r\t\t\t]."},{"name":"testPrintOnDelimiter","linesOfCode":10,"sourceCode":"testPrintOnDelimiter\r\t\r\t| result allElementsAsString tmp |\r\t\r\tresult := String streamContents: [ :aStream |\r\t\ttmp := OrderedCollection new.\r\t\tself nonEmpty do: [:each | tmp add: each asString].\r\t\tself nonEmpty printOn: aStream delimiter: ', ' ].\r\t\r\tallElementsAsString := (result findBetweenSubstrings: ', ').\r\t\r\t1 to: allElementsAsString size do:\r\t\t[:i | \r\t\tself assert: (tmp occurrencesOf:(allElementsAsString at:i)) equals: (allElementsAsString  occurrencesOf:(allElementsAsString at:i)) ]."},{"name":"test0FixturePrintTest","linesOfCode":3,"sourceCode":"test0FixturePrintTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty"}],"meta":{"name":"TPrintTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TAsStringCommaAndDelimiterTest","instanceVariables":[],"methods":[{"name":"testAsCommaStringOne","linesOfCode":5,"sourceCode":"testAsCommaStringOne\r\t\r\tself nonEmpty1Element do: \r\t\t[:each | \r\t\tself assert: each asString =self nonEmpty1Element  asCommaString.\r\t\tself assert: each asString=self nonEmpty1Element  asCommaStringAnd.].\r\r\t"},{"name":"testAsStringOnDelimiterEmpty","linesOfCode":2,"sourceCode":"testAsStringOnDelimiterEmpty\r\tself assert: (String streamContents: [ :emptyStream | self empty asStringOn: emptyStream delimiter: ', ' ]) equals: ''\r"},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^ self explicitRequirement "},{"name":"testAsCommaStringMore","linesOfCode":21,"sourceCode":"testAsCommaStringMore\r\r\t| result resultAnd allElementsAsString tmp |\r\tresult:= self nonEmpty asCommaString .\r\tresultAnd:= self nonEmpty asCommaStringAnd .\r\ttmp :=OrderedCollection new. \r\tself nonEmpty do: [ :each | tmp add: each asString].\r\r\t\"verifying result  :\"\r\tallElementsAsString := (result findBetweenSubstrings: ', ' ).\r\tallElementsAsString do:\r\t\t[:each |\r\t\tself assert: (tmp occurrencesOf: each)=(allElementsAsString occurrencesOf: each).\r\t\t].\r\t\r\t\"verifying esultAnd :\"\r\tallElementsAsString:=(resultAnd findBetweenSubstrings: ', ' ).\r\t1 to: allElementsAsString size do:\r\t\t[:i | \r\t\ti<(allElementsAsString size-1 ) | (i= allElementsAsString size)\r\t\t\tifTrue: [self assert: (tmp occurrencesOf:(allElementsAsString at:i))=(allElementsAsString  occurrencesOf:(allElementsAsString at:i))].\r\t\ti=(allElementsAsString size-1)\r\t\t\tifTrue:[ self assert: (allElementsAsString at:i)=('and')].\r\t\t\t]."},{"name":"test0FixtureAsStringCommaAndDelimiterTest","linesOfCode":7,"sourceCode":"test0FixtureAsStringCommaAndDelimiterTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself empty.\r\tself assertEmpty: self empty.\r\tself nonEmpty1Element.\r\tself assert: self nonEmpty1Element size = 1"},{"name":"testAsStringOnDelimiterOne","linesOfCode":10,"sourceCode":"testAsStringOnDelimiterOne\r\r\t| delim oneItemStream result |\r\r\tdelim := ', '.\r\tresult:=''.\r\toneItemStream := ReadWriteStream on: result.\r\tself nonEmpty1Element  asStringOn: oneItemStream delimiter: delim.\r\toneItemStream  do:\r\t\t[:each1 |\r\t\tself nonEmpty1Element do: [:each2 |self assert: each1 = (each2 asString) ]\r\t\t ].\r\t\r"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ self explicitRequirement "},{"name":"testAsStringOnDelimiterLastEmpty","linesOfCode":2,"sourceCode":"testAsStringOnDelimiterLastEmpty\r\tself assert: (String streamContents: [ :emptyStream | self empty asStringOn: emptyStream delimiter: ', ' last: 'and' ]) equals: ''"},{"name":"testAsStringOnDelimiterLastOne","linesOfCode":10,"sourceCode":"testAsStringOnDelimiterLastOne\r\r\t| delim oneItemStream result |\r\t\r\tdelim := ', '.\r\tresult:=''.\r\toneItemStream := ReadWriteStream on: result.\r\tself nonEmpty1Element  asStringOn: oneItemStream delimiter: delim last: 'and'.\r\toneItemStream  do:\r\t\t[:each1 |\r\t\tself nonEmpty1Element do: [:each2 |self assert: each1 = (each2 asString) ]\r\t\t ].\r\t\r\r"},{"name":"testAsCommaStringEmpty","linesOfCode":3,"sourceCode":"testAsCommaStringEmpty\r\r\tself assert: self empty asCommaString = ''.\r\tself assert: self empty asCommaStringAnd = ''.\r\t\r"},{"name":"testAsStringOnDelimiterMore","linesOfCode":13,"sourceCode":"testAsStringOnDelimiterMore\r\r\t| delim multiItemStream result allElementsAsString tmp |\r\t\r\t\r\tdelim := ', '.\r\tresult:=''.\r\ttmp:= self nonEmpty collect:[:each | each asString].\r\tmultiItemStream := ReadWriteStream on:result.\r\tself nonEmpty  asStringOn: multiItemStream delimiter: delim.\r\tresult := multiItemStream contents.\r\tallElementsAsString := (result findBetweenSubstrings: delim ).\r\ttmp do:\r\t\t[:each |\r\t\tself assert: (tmp occurrencesOf: each)=(allElementsAsString occurrencesOf: each).\r\t\t]."},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ self explicitRequirement "},{"name":"testAsStringOnDelimiterLastMore","linesOfCode":13,"sourceCode":"testAsStringOnDelimiterLastMore\r\r\t| delim multiItemStream result last allElementsAsString tmp |\r\t\r\tdelim := ', '.\r\tlast := ' and '.\r\tresult:=''.\r\ttmp := self nonEmpty collect: [:each | each asString].\r\tmultiItemStream := ReadWriteStream on:result.\r\tself nonEmpty  asStringOn: multiItemStream delimiter: delim last: last.\r\tresult := multiItemStream contents.\r\tallElementsAsString:=(result findBetweenSubstrings: delim ).\r\ttmp do:[:each |\r\t\tself assert: (tmp occurrencesOf: each) = (allElementsAsString occurrencesOf: each)].\r\tself assert: ((allElementsAsString at: (allElementsAsString size - 1))=('and'))"}],"meta":{"name":"TAsStringCommaAndDelimiterTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TConvertTest","instanceVariables":[],"methods":[{"name":"testAsBag","linesOfCode":2,"sourceCode":"testAsBag\r\r\tself assertSameContents: self collectionWithoutEqualElements whenConvertedTo: Bag"},{"name":"testAsArray","linesOfCode":4,"sourceCode":"testAsArray\r\r\tself \r\t\tassertSameContents: self collectionWithoutEqualElements\r\t\twhenConvertedTo: Array"},{"name":"test0FixtureTConvertTest","linesOfCode":9,"sourceCode":"test0FixtureTConvertTest\r\t\"A collection of number without equal elements:\"\r\r\t| res |\r\tself collectionWithoutEqualElements.\r\tres := true.\r\tself collectionWithoutEqualElements\r\t\tdetect: [ :each | (self collectionWithoutEqualElements occurrencesOf: each) > 1 ]\r\t\tifNone: [ res := false ].\r\tself assert: res = false"},{"name":"testAsOrderedCollection","linesOfCode":2,"sourceCode":"testAsOrderedCollection\r\t\r\tself assertSameContents: self collectionWithoutEqualElements whenConvertedTo: OrderedCollection"},{"name":"testAsSet","linesOfCode":3,"sourceCode":"testAsSet\r \t\"Test with a collection without equal elements\"\r\t\r\tself assertSameContents: self collectionWithoutEqualElements whenConvertedTo: Set\r\t"},{"name":"integerCollectionWithoutEqualElements","linesOfCode":3,"sourceCode":"integerCollectionWithoutEqualElements\r\" return a collection of integer without equal elements\"\r\t^ self explicitRequirement"},{"name":"testAsIdentitySet","linesOfCode":5,"sourceCode":"testAsIdentitySet\r\t\"Test with a collection without equal elements :\"\r\r\tself \r\t\tassertSameContents: self collectionWithoutEqualElements\r\t\twhenConvertedTo: IdentitySet\r"},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\" return a collection without equal elements\"\r\t^ self explicitRequirement"},{"name":"assertSameContents:whenConvertedTo:","linesOfCode":4,"sourceCode":"assertSameContents: aCollection whenConvertedTo: aClass\r\r\t| result |\r\tresult := self assertNonDuplicatedContents: aCollection whenConvertedTo: aClass.\r\tself assert: result size equals: aCollection size"},{"name":"testAsByteArray","linesOfCode":10,"sourceCode":"testAsByteArray\r\r\t| res |\r\tself integerCollectionWithoutEqualElements.\r\tself integerCollectionWithoutEqualElements do: [ :each | self assert: each class = SmallInteger ].\r\tres := true.\r\tself integerCollectionWithoutEqualElements\r\t\tdetect: [ :each | (self integerCollectionWithoutEqualElements occurrencesOf: each) > 1 ]\r\t\tifNone: [ res := false ].\r\tself assert: res = false.\r\tself assertSameContents: self integerCollectionWithoutEqualElements whenConvertedTo: ByteArray"},{"name":"assertNonDuplicatedContents:whenConvertedTo:","linesOfCode":8,"sourceCode":"assertNonDuplicatedContents: aCollection whenConvertedTo: aClass\r\r\t| result |\r\tresult := aCollection perform: ('as' , aClass name) asSymbol.\r\tself assert: (result class includesBehavior: aClass).\r\tresult do: \r\t\t[ :each | \r\t\tself assert: (aCollection occurrencesOf: each) equals: (result occurrencesOf: each) ].\r\t^ result"},{"name":"assertNoDuplicates:whenConvertedTo:","linesOfCode":5,"sourceCode":"assertNoDuplicates: aCollection whenConvertedTo: aClass\r\r\t| result |\r\tresult := self collectionWithEqualElements asIdentitySet.\r\tself assert: (result class includesBehavior: IdentitySet).\r\tself collectionWithEqualElements do: [ :initial | self assert: (result occurrencesOf: initial) equals: 1 ]"}],"meta":{"name":"TConvertTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TSizeTest","instanceVariables":[],"methods":[{"name":"sizeCollection","linesOfCode":3,"sourceCode":"sizeCollection\r\t\"Answers a collection not empty\"\r\t^ self explicitRequirement"},{"name":"test0TSizeTest","linesOfCode":5,"sourceCode":"test0TSizeTest\r\tself empty.\r\tself sizeCollection.\r\tself assertEmpty: self empty.\r\tself denyEmpty: self sizeCollection"},{"name":"testSize","linesOfCode":6,"sourceCode":"testSize\r\r\t| size |\r\tself assert: self empty size = 0.\r\tsize := 0.\r\tself sizeCollection do: [ :each | size := size + 1].\r\t\r\tself assert: self sizeCollection size = size."},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ self explicitRequirement"}],"meta":{"name":"TSizeTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopySequenceableWithOrWithoutSpecificElements","instanceVariables":[],"methods":[{"name":"testForceToPaddingStartWith","linesOfCode":11,"sourceCode":"testForceToPaddingStartWith\r\r\t| result element |\r\telement := self nonEmpty at: self indexInNonEmpty .\r\tresult := self nonEmpty forceTo: (self nonEmpty size+2) paddingStartWith: ( element ).\r\t\r\t\"verify content of 'result' : \"\r\t1 to: 2   do:\r\t\t[:i | self assert: ( element ) = ( result at:(i) ) ].\r\t\r\t3 to: result size do:\r\t\t[:i | self assert: ( result at:i ) = ( self nonEmpty at:(i-2) ) ].\r\r\t\"verify size of 'result' :\"\r\tself assert: result size = (self nonEmpty size + 2)."},{"name":"testCopyWithSequenceable","linesOfCode":9,"sourceCode":"testCopyWithSequenceable\r\r\t| result index element |\r\tindex := self indexInNonEmpty.\r\telement := self nonEmpty at: index.\r\tresult := self nonEmpty copyWith: (element ).\r\t\r\tself assert: result size equals: (self nonEmpty size + 1).\r\tself assert: result last equals: element.\r\t\r\t1 to: (result size - 1) do:\r\t\t[ :i | self assert: (result at: i) equals: ( self nonEmpty at: i)]"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\tself explicitRequirement"},{"name":"testCopyWithoutIndex","linesOfCode":11,"sourceCode":"testCopyWithoutIndex\r\r\t| result index |\t\r\tindex := self indexInNonEmpty.\r\tresult := self nonEmpty copyWithoutIndex: index.\r\t\r\t\"Verify content of result\"\r\tresult withIndexDo: \r\t\t[:element :i | \r\t\t i <  index ifTrue: [ self assert: element equals: (self nonEmpty at: i) ].\r\t\t i >= index ifTrue: [ self assert: element equals: (self nonEmpty at: (i + 1)) ]].\r\t\r\t\"Verify size of result\"\r\tself assert: result size equals: (self nonEmpty size - 1)"},{"name":"indexInNonEmpty","linesOfCode":3,"sourceCode":"indexInNonEmpty\r\t\"Return an index between bounds of 'nonEmpty'\"\r\r\t^self explicitRequirement"},{"name":"testForceToPaddingWith","linesOfCode":11,"sourceCode":"testForceToPaddingWith\r\r\t| result element |\r\telement := self nonEmpty at: self indexInNonEmpty.\r\tresult := self nonEmpty forceTo: (self nonEmpty size + 2) paddingWith: element.\r\t\r\t\"Verify content of 'result'\"\r\tself nonEmpty withIndexDo:\r\t\t[:el :index | self assert: el equals: (result at: index) ].\r\t\r\t(result size - 1) to: result size do:\r\t\t[:i | self assert: (result at:i) equals: element ].\r\r\t\"Verify size of 'result'\"\r\tself assert: result size equals: self nonEmpty size + 2"},{"name":"testCopyWithFirst","linesOfCode":10,"sourceCode":"testCopyWithFirst\r\r\t| index element result |\r\tindex:= self indexInNonEmpty .\r\telement:= self nonEmpty at: index.\r\t\r\tresult := self nonEmpty copyWithFirst: element.\t\r\t\r\tself assert: result size = (self nonEmpty size + 1).\r\tself assert: result first = element .\r\t\r\t2 to: result size do:\r\t[ :i |\r\tself assert: (result at: i) = ( self nonEmpty at: ( i - 1 ))]."},{"name":"testCopyWithoutFirst","linesOfCode":6,"sourceCode":"testCopyWithoutFirst\r\r\t| result |\r\tresult := self nonEmpty copyWithoutFirst.\r\t\r\tself assert: result size equals: (self nonEmpty size - 1).\r\t\r\tresult withIndexDo: \r\t\t[:el :i | self assert: (result at: i) equals: (self nonEmpty at: (i + 1))]"},{"name":"test0FixtureCopyWithOrWithoutSpecificElementsTest","linesOfCode":6,"sourceCode":"test0FixtureCopyWithOrWithoutSpecificElementsTest\r\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself indexInNonEmpty.\r\tself assert: self indexInNonEmpty > 0.\r\tself assert: self indexInNonEmpty <= self nonEmpty size"}],"meta":{"name":"TCopySequenceableWithOrWithoutSpecificElements classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIndexAccess","instanceVariables":[],"methods":[{"name":"testIndexOfStartingAtIfAbsent","linesOfCode":16,"sourceCode":"testIndexOfStartingAtIfAbsent\r\r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 2\r\t\t\tifAbsent: [ 99 ]) equals: 99.\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 1\r\t\t\tifAbsent: [ 99 ]) equals: 1.\r\tself assert: (collection \r\t\t\tindexOf: self elementNotInForIndexAccessing\r\t\t\tstartingAt: 1\r\t\t\tifAbsent: [ 99 ]) equals: 99"},{"name":"testIdentityIndexOfIAbsent","linesOfCode":8,"sourceCode":"testIdentityIndexOfIAbsent\r\t| collection element |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection identityIndexOf: element ifAbsent: [ 0 ]) \r\t     equals: 1.\r\r\tself assert: (collection identityIndexOf: self elementNotInForIndexAccessing ifAbsent: [ 55 ]) \r\t\t  equals: 55"},{"name":"testLastIndexOf","linesOfCode":6,"sourceCode":"testLastIndexOf\r\r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection lastIndexOf: element) = 1.\r\tself assert: (collection lastIndexOf: self elementNotInForIndexAccessing) = 0"},{"name":"testIndexOfSubCollectionStartingAt","linesOfCode":12,"sourceCode":"testIndexOfSubCollectionStartingAt\r\r\t| subcollection index collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\tsubcollection := self collectionMoreThan1NoDuplicates.\r\tindex := collection \r\t\tindexOfSubCollection: subcollection\r\t\tstartingAt: 1.\r\tself assert: index equals: 1.\r\tindex := collection \r\t\tindexOfSubCollection: subcollection\r\t\tstartingAt: 2.\r\tself assert: index equals: 0"},{"name":"testIndexOfSubCollectionStartingAtIfAbsent","linesOfCode":10,"sourceCode":"testIndexOfSubCollectionStartingAtIfAbsent\r\t| absent subcollection collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\tsubcollection := self collectionMoreThan1NoDuplicates.\r\tabsent := false.\r\tcollection indexOfSubCollection: subcollection startingAt: 1 ifAbsent: [ absent := true ].\r\tself deny: absent.\r\tabsent := false.\r\tcollection indexOfSubCollection: subcollection startingAt: 2 ifAbsent: [ absent := true ].\r\tself assert: absent"},{"name":"testIndexOfStartingAt","linesOfCode":16,"sourceCode":"testIndexOfStartingAt\r\r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 2\r\t\t\tifAbsent: [ 99 ]) equals: 99.\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 1\r\t\t\tifAbsent: [ 99 ]) equals: 1.\r\tself assert: (collection \r\t\t\tindexOf: self elementNotInForIndexAccessing\r\t\t\tstartingAt: 1\r\t\t\tifAbsent: [ 99 ]) equals: 99"},{"name":"testIdentityIndexOf","linesOfCode":5,"sourceCode":"testIdentityIndexOf\r\r\t| collection element |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection identityIndexOf: element) equals: (collection indexOf: element)"},{"name":"testIndexOfIfAbsent","linesOfCode":9,"sourceCode":"testIndexOfIfAbsent\r\r\t| collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\tself assert: (collection \r\t\t\tindexOf: collection first\r\t\t\tifAbsent: [ 33 ]) equals: 1.\r\tself assert: (collection \r\t\t\tindexOf: self elementNotInForIndexAccessing\r\t\t\tifAbsent: [ 33 ]) equals: 33"},{"name":"testIndexOf","linesOfCode":9,"sourceCode":"testIndexOf\r\r\t| tmp index collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\ttmp := collection size.\r\tcollection reverseDo: \r\t\t[ :each | \r\t\teach = self elementInForIndexAccessing ifTrue: [ index := tmp ].\r\t\ttmp := tmp - 1 ].\r\tself assert: (collection indexOf: self elementInForIndexAccessing) equals: index"},{"name":"testLastIndexOfIfAbsent","linesOfCode":10,"sourceCode":"testLastIndexOfIfAbsent\r\r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection first.\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tifAbsent: [ 99 ]) equals: 1.\r\tself assert: (collection \r\t\t\tlastIndexOf: self elementNotInForIndexAccessing\r\t\t\tifAbsent: [ 99 ]) equals: 99"},{"name":"elementInForIndexAccessing","linesOfCode":3,"sourceCode":"elementInForIndexAccessing\r\" return an element included in 'collectionMoreThan1NoDuplicates' \"\r\tself explicitRequirement"},{"name":"elementNotInForIndexAccessing","linesOfCode":3,"sourceCode":"elementNotInForIndexAccessing\r\" return an element not included in 'collectionMoreThan1NoDuplicates' \"\r\tself explicitRequirement"},{"name":"testLastIndexOfStartingAt","linesOfCode":16,"sourceCode":"testLastIndexOfStartingAt\r\r\t| element collection |\r\tcollection := self collectionMoreThan1NoDuplicates.\r\telement := collection last.\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tstartingAt: collection size\r\t\t\tifAbsent: [ 99 ]) equals: collection size.\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tstartingAt: collection size - 1\r\t\t\tifAbsent: [ 99 ]) equals: 99.\r\tself assert: (collection \r\t\t\tlastIndexOf: self elementNotInForIndexAccessing\r\t\t\tstartingAt: collection size\r\t\t\tifAbsent: [ 99 ]) equals: 99"},{"name":"test0FixtureIndexAccessTest","linesOfCode":13,"sourceCode":"test0FixtureIndexAccessTest\r\t| res |\r\tself collectionMoreThan1NoDuplicates.\r\tself assert: self collectionMoreThan1NoDuplicates size > 1.\r\tres := true.\r\tself collectionMoreThan1NoDuplicates\r\t\tdetect: [ :each | (self collectionMoreThan1NoDuplicates occurrencesOf: each) > 1 ]\r\t\tifNone: [ res := false ].\r\tself assert: res = false.\r\tself elementInForIndexAccessing.\r\tself assert: (self collectionMoreThan1NoDuplicates includes: self elementInForIndexAccessing).\r\tself elementNotInForIndexAccessing.\r\tself deny: (self collectionMoreThan1NoDuplicates includes: self elementNotInForIndexAccessing)"},{"name":"collectionMoreThan1NoDuplicates","linesOfCode":3,"sourceCode":"collectionMoreThan1NoDuplicates\r\t\" return a collection of size > 1 without equal elements\"\r\tself explicitRequirement"}],"meta":{"name":"TIndexAccess classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIncludesForIdentityCollectionsTest","instanceVariables":[],"methods":[{"name":"testIdentityIncludesForIdentityCollections","linesOfCode":7,"sourceCode":"testIdentityIncludesForIdentityCollections\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\t| collection element |\r\tcollection := self identityCollectionWithElementsCopyNotIdentical .\r\telement := collection anyOne copy.\r\tself deny: (collection identityIncludes: element)"},{"name":"testIncludesAnyOfForIdentityCollections","linesOfCode":7,"sourceCode":"testIncludesAnyOfForIdentityCollections\r\r\t| collection copyCollection |\r\tcollection := self identityCollectionWithElementsCopyNotIdentical .\r\tcopyCollection := OrderedCollection new.\r\tcollection do: [ :each | copyCollection add: each copy ].\r\tself deny: (collection includesAny: copyCollection).\r\tself assert: (collection includesAny: {  (collection anyOne)  })"},{"name":"test0FixtureInludesForIdentityCollectionsTest","linesOfCode":3,"sourceCode":"test0FixtureInludesForIdentityCollectionsTest\r\tself identityCollectionWithElementsCopyNotIdentical.\r\tself identityCollectionWithElementsCopyNotIdentical do: [ :each | self deny: each == each copy ]"},{"name":"identityCollectionWithElementsCopyNotIdentical","linesOfCode":3,"sourceCode":"identityCollectionWithElementsCopyNotIdentical\r\t\" return a collection including elements for which #copy return a new object \"\r\t^ self explicitRequirement"},{"name":"testIncludesForIdentityCollections","linesOfCode":7,"sourceCode":"testIncludesForIdentityCollections\r\r\t| collection element elementCopy |\r\tcollection := self identityCollectionWithElementsCopyNotIdentical .\r\telement := collection anyOne.\r\telementCopy := element copy.\r\tself assert: (collection includes: element).\r\tself deny: (collection includes: elementCopy)"},{"name":"testIncludesAllOfForIdentityCollections","linesOfCode":8,"sourceCode":"testIncludesAllOfForIdentityCollections\r\r\t| collection copyCollection |\r\tcollection := self identityCollectionWithElementsCopyNotIdentical .\r\tcopyCollection := OrderedCollection new.\r\tcollection do: [ :each | copyCollection add: each copy ].\r\tself assert: (collection includesAll: collection).\r\tself deny: (collection includesAll: copyCollection).\r\tself deny: (collection includesAll: {  (copyCollection anyOne)  })"}],"meta":{"name":"TIncludesForIdentityCollectionsTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopyPartOfSequenceable","instanceVariables":[],"methods":[{"name":"testCopyAfterLast","linesOfCode":10,"sourceCode":"testCopyAfterLast\r\r\t| result index collection |\r\tcollection := self collectionWithoutEqualElements .\r\tindex:= self indexInForCollectionWithoutDuplicates .\r\tresult := collection copyAfterLast: (collection  at:index ).\r\t\r\t\"Verify content\"\r\tresult withIndexDo: \r\t\t[:el :i | self assert: (collection at: (i + index )) equals: (result at: i)].\r\r\t\"Verify size\"\r\tself assert: result size equals: (collection size - index)"},{"name":"testCopyUpToLast","linesOfCode":9,"sourceCode":"testCopyUpToLast\r\r\t| result index collection |\r\tcollection := self collectionWithoutEqualElements.\r\tindex:= self indexInForCollectionWithoutDuplicates.\r\tresult := collection copyUpToLast: (collection at:index).\r\t\r\t\"Verify content\"\r\tresult withIndexDo: [:el :i| self assert: (collection at:i) equals: (result at: i)].\r\t\r\t\"Verify size\"\r\tself assert: result size equals: (index-1)"},{"name":"testCopyAfterEmpty","linesOfCode":4,"sourceCode":"testCopyAfterEmpty\r\t| result |\r\tresult := self empty copyAfter: self collectionWithoutEqualElements first.\r\tself assertEmpty: result"},{"name":"testCopyAfterLastEmpty","linesOfCode":4,"sourceCode":"testCopyAfterLastEmpty\r\t| result |\r\tresult := self empty copyAfterLast: self collectionWithoutEqualElements first.\r\tself assertEmpty: result"},{"name":"testCopyUpTo","linesOfCode":9,"sourceCode":"testCopyUpTo\r\r\t| result index collection |\r\tcollection := self collectionWithoutEqualElements.\r\tindex:= self indexInForCollectionWithoutDuplicates.\r\tresult := collection   copyUpTo: (collection  at:index).\r\t\r\t\"Verify content\"\r\tresult withIndexDo: [:el :i| self assert: (collection at:i) equals: (result at:i)].\r\t\r\t\"Verify size\"\r\tself assert: result size equals: (index-1)\r\t"},{"name":"collectionWithoutEqualElements","linesOfCode":3,"sourceCode":"collectionWithoutEqualElements\r\r\" return a collection not including equal elements \"\r\tself explicitRequirement"},{"name":"testCopyAfter","linesOfCode":10,"sourceCode":"testCopyAfter\r\t| result index collection |\r\tcollection := self collectionWithoutEqualElements .\r\tindex:= self indexInForCollectionWithoutDuplicates .\r\tresult := collection   copyAfter: (collection  at:index ).\r\t\r\t\"Verify content\"\r\tresult withIndexDo: \r\t\t[:e :i | self assert: (collection at: (i + index )) equals: (result at: i)].\r\r\t\"Verify size\"\r\tself assert: result size equals: (collection size - index)"},{"name":"testCopyEmptyMethod","linesOfCode":5,"sourceCode":"testCopyEmptyMethod\r\t| result |\r\tresult := self collectionWithoutEqualElements copyEmpty.\r\tself assertEmpty: result.\r\tself assert: result class equals: self nonEmpty class"},{"name":"testCopyUpToEmpty","linesOfCode":4,"sourceCode":"testCopyUpToEmpty\r\t| result |\r\tresult := self empty copyUpTo: self collectionWithoutEqualElements first.\r\tself assertEmpty: result"},{"name":"testCopyFromTo","linesOfCode":10,"sourceCode":"testCopyFromTo\r\t| result  index collection |\r\tcollection := self collectionWithoutEqualElements .\r\tindex :=self indexInForCollectionWithoutDuplicates .\r\tresult := collection   copyFrom: index  to: collection  size .\r\t\r\t\"Verify content\"\r\tresult withIndexDo: \r\t\t[:el :i | self assert: (result at:i) equals: (collection  at: (i + index - 1))].\r\t\r\t\"Verify size\"\r\tself assert: result size equals: (collection  size - index + 1)"},{"name":"indexInForCollectionWithoutDuplicates","linesOfCode":3,"sourceCode":"indexInForCollectionWithoutDuplicates\r\" return an index between 'collectionWithoutEqualsElements'  bounds\"\r\tself explicitRequirement"},{"name":"test0FixtureCopyPartOfSequenceableTest","linesOfCode":7,"sourceCode":"test0FixtureCopyPartOfSequenceableTest\r\tself collectionWithoutEqualElements.\r\tself collectionWithoutEqualElements do: [ :each | self assert: (self collectionWithoutEqualElements occurrencesOf: each) = 1 ].\r\tself indexInForCollectionWithoutDuplicates.\r\tself assert: (self indexInForCollectionWithoutDuplicates > 0 & self indexInForCollectionWithoutDuplicates) < self collectionWithoutEqualElements size.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement"},{"name":"testCopyUpToLastEmpty","linesOfCode":4,"sourceCode":"testCopyUpToLastEmpty\r\t| result |\r\tresult := self empty copyUpToLast: self collectionWithoutEqualElements first.\r\tself assertEmpty: result"}],"meta":{"name":"TCopyPartOfSequenceable classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TSequencedElementAccessTest","instanceVariables":[],"methods":[{"name":"testAtIfAbsent","linesOfCode":12,"sourceCode":"testAtIfAbsent\r\r\t| absent |\r\tabsent := false.\r\tself moreThan4Elements \r\t\tat: self moreThan4Elements size + 1\r\t\tifAbsent: [ absent := true ].\r\tself assert: absent = true.\r\tabsent := false.\r\tself moreThan4Elements \r\t\tat: self moreThan4Elements size\r\t\tifAbsent: [ absent := true ].\r\tself assert: absent = false"},{"name":"testMiddle","linesOfCode":2,"sourceCode":"testMiddle\r\r\tself assert: self moreThan4Elements middle equals: (self moreThan4Elements at: self moreThan4Elements size // 2 + 1)"},{"name":"testAtWrap","linesOfCode":11,"sourceCode":"testAtWrap\r\t\"\r\tself assert: (self accessCollection at: 1) = 1.\r\tself assert: (self accessCollection at: 2) = 2.\r\t\"\r\t\r\t| index |\r\tindex := self moreThan4Elements indexOf: self elementInForElementAccessing.\r\tself assert: (self moreThan4Elements atWrap: index) = self elementInForElementAccessing.\r\tself assert: (self moreThan4Elements atWrap: index + self moreThan4Elements size) = self elementInForElementAccessing.\r\tself assert: (self moreThan4Elements atWrap: index - self moreThan4Elements size) = self elementInForElementAccessing.\r\tself assert: (self moreThan4Elements atWrap: 1 + self moreThan4Elements size) = (self moreThan4Elements at: 1)"},{"name":"testAtLast","linesOfCode":5,"sourceCode":"testAtLast\r\r\t| index |\r\tself assert: (self moreThan4Elements atLast: 1) = self moreThan4Elements last.\r\r\tindex := self moreThan4Elements indexOf: self elementInForElementAccessing.\r\tself assert: (self moreThan4Elements atLast: index) = (self moreThan4Elements at: self moreThan4Elements size - index + 1)"},{"name":"testLast","linesOfCode":2,"sourceCode":"testLast\r\r\tself assert: self moreThan4Elements last equals: (self moreThan4Elements at: self moreThan4Elements size)"},{"name":"testAtAll","linesOfCode":10,"sourceCode":"testAtAll\r\t\"\tself flag: #theCollectionshouldbe102030intheFixture.\r\t\r\tself assert: (self accessCollection atAll: #(2 1)) first = self accessCollection second.\r\tself assert: (self accessCollection atAll: #(2)) first = self accessCollection second.\"\r\t| result |\r\tresult := self moreThan4Elements atAll: #(2 1 2 ).\r\tself assert: (result at: 1) = (self moreThan4Elements at: 2).\r\tself assert: (result at: 2) = (self moreThan4Elements at: 1).\r\tself assert: (result at: 3) = (self moreThan4Elements at: 2).\r\tself assert: (self moreThan4Elements atAll: #()) = self moreThan4Elements species new"},{"name":"testFirstSecondThird","linesOfCode":5,"sourceCode":"testFirstSecondThird\r\r\tself assert: self moreThan4Elements first equals: (self moreThan4Elements at: 1).\r\tself assert: self moreThan4Elements second equals: (self moreThan4Elements at: 2).\r\tself assert: self moreThan4Elements third equals: (self moreThan4Elements at: 3).\r\tself assert: self moreThan4Elements fourth equals: (self moreThan4Elements at: 4)"},{"name":"subCollectionNotIn","linesOfCode":3,"sourceCode":"subCollectionNotIn\r\" return a collection for which at least one element is not included in 'moreThan4Elements' \"\r\tself explicitRequirement"},{"name":"testBeforeIfAbsent","linesOfCode":8,"sourceCode":"testBeforeIfAbsent\r\r\tself assert: (self moreThan4Elements \r\t\t\tbefore: (self moreThan4Elements at: 1)\r\t\t\tifAbsent: [ 99 ]) = 99.\r\t\t\t\r\tself assert: (self moreThan4Elements \r\t\t\tbefore: (self moreThan4Elements at: 2)\r\t\t\tifAbsent: [ 99 ]) = (self moreThan4Elements at: 1)"},{"name":"testAtLastIfAbsent","linesOfCode":7,"sourceCode":"testAtLastIfAbsent\r\r\tself assert: (self moreThan4Elements \r\t\t\tatLast: 1\r\t\t\tifAbsent: [ nil ]) = self moreThan4Elements last.\r\tself assert: (self moreThan4Elements \r\t\t\tatLast: self moreThan4Elements size + 1\r\t\t\tifAbsent: [ 222 ]) = 222"},{"name":"testBefore","linesOfCode":8,"sourceCode":"testBefore\r\r\tself assert: (self moreThan4Elements before: (self moreThan4Elements at: 2)) = (self moreThan4Elements at: 1).\r\tself \r\t\tshould: [ self moreThan4Elements before: (self moreThan4Elements at: 1) ]\r\t\traise: Error.\r\tself \r\t\tshould: [ self moreThan4Elements before: 66 ]\r\t\traise: Error"},{"name":"elementNotInForElementAccessing","linesOfCode":3,"sourceCode":"elementNotInForElementAccessing\r\" return an element not included in 'moreThan4Elements' \"\r\tself explicitRequirement"},{"name":"testAfterIfAbsent","linesOfCode":10,"sourceCode":"testAfterIfAbsent\r\r\tself assert: (self moreThan4Elements \r\t\t\tafter: (self moreThan4Elements at: 1)\r\t\t\tifAbsent: [ 33 ]) = (self moreThan4Elements at: 2).\r\tself assert: (self moreThan4Elements \r\t\t\tafter: (self moreThan4Elements at: self moreThan4Elements size)\r\t\t\tifAbsent: [ 33 ]) = 33.\r\tself assert: (self moreThan4Elements \r\t\t\tafter: self elementNotInForElementAccessing\r\t\t\tifAbsent: [ 33 ]) = 33"},{"name":"testAtLastError","linesOfCode":4,"sourceCode":"testAtLastError\r\r\tself \r\t\tshould: [ self moreThan4Elements atLast: self moreThan4Elements size + 1 ]\r\t\traise: Error"},{"name":"testAt","linesOfCode":8,"sourceCode":"testAt\r\t\"\r\tself assert: (self accessCollection at: 1) = 1.\r\tself assert: (self accessCollection at: 2) = 2.\r\t\"\r\t\r\t| index |\r\tindex := self moreThan4Elements indexOf: self elementInForElementAccessing.\r\tself assert: (self moreThan4Elements at: index) = self elementInForElementAccessing"},{"name":"testAfter","linesOfCode":9,"sourceCode":"testAfter\r\r\tself assert: (self moreThan4Elements after: (self moreThan4Elements at: 1)) = (self moreThan4Elements at: 2).\r\tself \r\t\tshould: \r\t\t\t[ self moreThan4Elements after: (self moreThan4Elements at: self moreThan4Elements size) ]\r\t\traise: Error.\r\tself \r\t\tshould: [ self moreThan4Elements after: self elementNotInForElementAccessing ]\r\t\traise: Error"},{"name":"moreThan4Elements","linesOfCode":3,"sourceCode":"moreThan4Elements\r\r\" return a collection including at leat 4 elements\"\r\tself explicitRequirement"},{"name":"elementInForElementAccessing","linesOfCode":3,"sourceCode":"elementInForElementAccessing\r\" return an element inculded in 'moreThan4Elements'\"\r\tself explicitRequirement"},{"name":"test0FixtureSequencedElementAccessTest","linesOfCode":9,"sourceCode":"test0FixtureSequencedElementAccessTest\r\r\tself moreThan4Elements.\r\tself assert: self moreThan4Elements size >= 4.\r\tself subCollectionNotIn.\r\tself subCollectionNotIn detect: [ :each | (self moreThan4Elements includes: each) not ] ifNone: [ self assert: false ].\r\tself elementNotInForElementAccessing.\r\tself deny: (self moreThan4Elements includes: self elementNotInForElementAccessing).\r\tself elementInForElementAccessing.\r\tself assert: (self moreThan4Elements includes: self elementInForElementAccessing)"},{"name":"testAtPin","linesOfCode":4,"sourceCode":"testAtPin\r\r\tself assert: (self moreThan4Elements atPin: 2) = self moreThan4Elements second.\r\tself assert: (self moreThan4Elements atPin: 99) = self moreThan4Elements last.\r\tself assert: (self moreThan4Elements atPin: -99) = self moreThan4Elements first"},{"name":"testAtRandom","linesOfCode":4,"sourceCode":"testAtRandom\r\r\t| result |\r\tresult := self nonEmpty atRandom.\r\tself assert: (self nonEmpty includes: result)"},{"name":"testAtOutOfBounds","linesOfCode":7,"sourceCode":"testAtOutOfBounds\r\r\tself \r\t\tshould: [ self moreThan4Elements at: self moreThan4Elements size + 1 ]\r\t\traise: Error.\r\tself \r\t\tshould: [ self moreThan4Elements at: -1 ]\r\t\traise: Error"}],"meta":{"name":"TSequencedElementAccessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TRemoveForMultiplenessTest","instanceVariables":[],"methods":[{"name":"testRemoveElementThatExistsTwice","linesOfCode":9,"sourceCode":"testRemoveElementThatExistsTwice\r\r\t| size |\r\tsize := self nonEmpty size.\r\tself assert: (self nonEmpty includes: self elementTwiceIn).\r\tself nonEmpty remove: self elementTwiceIn.\r\tself assert: size - 1 = self nonEmpty size.\r\t\r\tself assert: (self nonEmpty includes: self elementTwiceIn).\r\tself nonEmpty remove: self elementTwiceIn.\r\tself assert: size - 2 = self nonEmpty size"},{"name":"testRemoveElementReallyRemovesElement","linesOfCode":5,"sourceCode":"testRemoveElementReallyRemovesElement\r \r\t| size |\r\tsize := self nonEmptyWithoutEqualElements size.\r\tself nonEmptyWithoutEqualElements remove: self nonEmptyWithoutEqualElements anyOne.\r\tself assert: size - 1 = self nonEmptyWithoutEqualElements size"},{"name":"testRemoveElementThatExists","linesOfCode":5,"sourceCode":"testRemoveElementThatExists\r \r\t| el res |\r\tel := self nonEmptyWithoutEqualElements anyOne.\r\tres := self nonEmptyWithoutEqualElements remove: el.\r\tself assert: res == el"},{"name":"testRemoveAllSuchThat","linesOfCode":7,"sourceCode":"testRemoveAllSuchThat\r\r\t| el aSubCollection |\r\tel := self nonEmptyWithoutEqualElements anyOne.\r\taSubCollection := self nonEmptyWithoutEqualElements copyWithout: el.\r\tself nonEmptyWithoutEqualElements removeAllSuchThat: [ :each | aSubCollection includes: each ].\r\tself assert: self nonEmptyWithoutEqualElements size = 1.\r\tself nonEmptyWithoutEqualElements do: [ :each | self assert: each = el ]"},{"name":"testRemoveElementFromEmpty","linesOfCode":5,"sourceCode":"testRemoveElementFromEmpty\r\t \r\tself \r\t\tshould: [ self empty remove: self nonEmptyWithoutEqualElements anyOne ]\r\t\traise: Error"},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\" return an element not included in nonEmptyWithoutEqualElements\"\r\tself explicitRequirement"},{"name":"elementTwiceIn","linesOfCode":2,"sourceCode":"elementTwiceIn\r\t^ self explicitRequirement"},{"name":"nonEmptyWithoutEqualElements","linesOfCode":3,"sourceCode":"nonEmptyWithoutEqualElements\r\" return a collection without equal elements \"\r\tself explicitRequirement"},{"name":"testRemoveAllError","linesOfCode":5,"sourceCode":"testRemoveAllError\r\t| el aSubCollection |\r\tel := self elementNotIn.\r\taSubCollection := self nonEmptyWithoutEqualElements copyWith: el.\r\tself should: [ self nonEmptyWithoutEqualElements removeAll: aSubCollection ] raise: Error"},{"name":"testRemoveIfAbsent","linesOfCode":4,"sourceCode":"testRemoveIfAbsent\r\t| res |\r\tres := self nonEmptyWithoutEqualElements remove: self elementNotIn ifAbsent: [ 33 ].\r\tself assert: res equals: 33"},{"name":"test0FixtureTRemoveTest","linesOfCode":12,"sourceCode":"test0FixtureTRemoveTest\r\t| duplicate |\r\tself empty.\r\tself nonEmptyWithoutEqualElements.\r\tself denyEmpty: self nonEmptyWithoutEqualElements.\r\tduplicate := true.\r\tself nonEmptyWithoutEqualElements detect: [ :each | (self nonEmptyWithoutEqualElements occurrencesOf: each) > 1 ] ifNone: [ duplicate := false ].\r\tself assert: duplicate = false.\r\tself elementNotIn.\r\tself assertEmpty: self empty.\r\tself denyEmpty: self nonEmptyWithoutEqualElements.\r\tself deny: (self nonEmptyWithoutEqualElements includes: self elementNotIn)"},{"name":"testRemoveAllFoundIn","linesOfCode":7,"sourceCode":"testRemoveAllFoundIn\r\t| el aSubCollection |\r\tel := self nonEmptyWithoutEqualElements anyOne.\r\taSubCollection := (self nonEmptyWithoutEqualElements copyWithout: el) copyWith: self elementNotIn.\r\tself nonEmptyWithoutEqualElements removeAllFoundIn: aSubCollection.\r\tself assert: self nonEmptyWithoutEqualElements size = 1.\r\tself nonEmptyWithoutEqualElements do: [ :each | self assert: each = el ]"},{"name":"testRemoveAll","linesOfCode":8,"sourceCode":"testRemoveAll\r\t| el aSubCollection collection |\r\tcollection := self nonEmptyWithoutEqualElements.\r\tel := collection anyOne.\r\taSubCollection := collection copyWithout: el.\r\tcollection removeAll: aSubCollection.\r\tself assert: collection size = 1.\r\tself nonEmptyWithoutEqualElements do: [ :each | self assert: each = el ]"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement"}],"meta":{"name":"TRemoveForMultiplenessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopySequenceableWithReplacement","instanceVariables":[],"methods":[{"name":"testCopyReplaceFromToWithInsertion","linesOfCode":23,"sourceCode":"testCopyReplaceFromToWithInsertion\r\t| result  indexOfSubcollection |\r\t\r\tindexOfSubcollection := (self firstIndexesOf: self oldSubCollection  in:  self collectionWith1TimeSubcollection) at: 1. \r\t\r\tresult := self collectionWith1TimeSubcollection  copyReplaceFrom: indexOfSubcollection  to: ( indexOfSubcollection - 1 ) with: self replacementCollection .\r\t\r\t\"verify content of 'result' : \"\r\t\"first part of 'result'' : '\"\r\t\r\t1 to: (indexOfSubcollection -1) do: \r\t\t[\r\t\t:i | \r\t\tself assert: (self collectionWith1TimeSubcollection  at:i)=(result at: i)\r\t\t].\r\t\r\t\" middle part containing replacementCollection : \"\r\tindexOfSubcollection  to: (indexOfSubcollection  + self replacementCollection size-1) do: \r\t\t[\r\t\t:i |\r\t\tself assert: ( result at: i )=(self replacementCollection at: ( i - indexOfSubcollection +1 ))\r\t\t].\r\t\r\t\" end part :\"\r\t(indexOfSubcollection  + self replacementCollection size) to: (result size) do:\r\t\t[:i|\r\t\tself assert: (result at: i)=(self collectionWith1TimeSubcollection  at: (i-self replacementCollection size))].\r\t\r\t\" verify size: \"\t\r\tself assert: result size=(self collectionWith1TimeSubcollection  size + self replacementCollection size).\r\t\r\r\t\r\r\t\r\t"},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\" return a collection that will be used to replace 'oldSubcollection' in ' collectionWith1TimeSubcollection'  \" \r\tself explicitRequirement"},{"name":"test0FixtureCopyWithReplacementTest","linesOfCode":5,"sourceCode":"test0FixtureCopyWithReplacementTest\r\tself replacementCollection.\r\tself oldSubCollection.\r\tself collectionWith1TimeSubcollection.\r\tself assert: (self howMany: self oldSubCollection in: self collectionWith1TimeSubcollection) = 1"},{"name":"testCopyReplaceAllWith1Occurrence","linesOfCode":27,"sourceCode":"testCopyReplaceAllWith1Occurrence\r\t| result  firstIndexesOfOccurrence index endPartIndexResult endPartIndexCollection |\r\t\r\tresult := self collectionWith1TimeSubcollection  copyReplaceAll: self oldSubCollection with: self replacementCollection .\r\t\r\t\"detecting indexes of olSubCollection\"\r\tfirstIndexesOfOccurrence  := self firstIndexesOf: self oldSubCollection in: self collectionWith1TimeSubcollection .\r\tindex:= firstIndexesOfOccurrence at: 1.\r\t\r\t\"verify content of 'result' : \"\r\t\"first part of 'result'' : '\"\r\r\t1 to: (index -1) do: \r\t\t[\r\t\t:i |  \r\t\tself assert: (self collectionWith1TimeSubcollection  at:i)=(result at: i)\r\t\t].\r\r\t\" middle part containing replacementCollection : \"\r\t\r\tindex to: (index + self replacementCollection size-1) do: \r\t\t[\r\t\t:i |\r\t\tself assert: ( result at: i )=(self replacementCollection at: ( i - index + 1 ))\r\t\t].\r\t\r\t\" end part :\"\r\t\r\tendPartIndexResult :=  index + self replacementCollection  size .\r\tendPartIndexCollection :=   index + self oldSubCollection size  .\r\t\r\t1 to: (result size - endPartIndexResult - 1 ) do:\r\t\t[ \r\t\t:i |\r\t\tself assert: (result at: ( endPartIndexResult + i - 1 ) ) = (self collectionWith1TimeSubcollection  at: ( endPartIndexCollection + i - 1 ) ).\r\t\t].\r\t\r\t\r\t"},{"name":"oldSubCollection","linesOfCode":4,"sourceCode":"oldSubCollection\r\" return a subCollection included in collectionWith1TimeSubcollection .\rex :   subCollection := #( 2 3 4) and collectionWith1TimeSubcollection := #(1 2 3 4 5)\"\r\tself explicitRequirement"},{"name":"collectionWith1TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith1TimeSubcollection\r\" return a collection including 'oldSubCollection'  only one time \"\r\tself explicitRequirement"},{"name":"howMany:in:","linesOfCode":15,"sourceCode":"howMany: aSubCollection in: collection\r\" return an integer representing how many time 'subCollection'  appears in 'collection'  \"\r\t| tmp nTime |\r\ttmp := collection.\r\tnTime:= 0.\r\t\r\t[tmp isEmpty ]whileFalse:\r\t\t[\r\t\t(tmp beginsWith: aSubCollection)\r\t\t\tifTrue: [ \t\r\t\t\t\tnTime := nTime + 1.\r\t\t\t\t1 to: aSubCollection size do: [:i | tmp := tmp copyWithoutFirst.]\r\t\t\t\t]\r\t\t\tifFalse: [tmp := tmp copyWithoutFirst.]\r\t\t ].\r\t\r\t^ nTime.\r\t"},{"name":"collectionWith2TimeSubcollection","linesOfCode":3,"sourceCode":"collectionWith2TimeSubcollection\r\" return a collection including 'oldSubCollection'  two or many time \"\r\tself explicitRequirement"},{"name":"testCopyReplaceAllWithManyOccurrence","linesOfCode":29,"sourceCode":"testCopyReplaceAllWithManyOccurrence\r\t| result firstIndexesOfOccurrence resultBetweenPartIndex collectionBetweenPartIndex diff |\r\t\" testing fixture here as this method may be not used for collection that can't contain equals element :\"\r\tself collectionWith2TimeSubcollection.\r\tself assert: (self howMany: self oldSubCollection in: self collectionWith2TimeSubcollection) = 2.\t\" test :\"\r\tdiff := self replacementCollection size - self oldSubCollection size.\r\tresult := self collectionWith2TimeSubcollection copyReplaceAll: self oldSubCollection with: self replacementCollection.\t\"detecting indexes of olSubCollection\"\r\tfirstIndexesOfOccurrence := self firstIndexesOf: self oldSubCollection in: self collectionWith2TimeSubcollection.\t\" verifying that replacementCollection has been put in places of oldSubCollections \"\r\tfirstIndexesOfOccurrence\r\t\tdo: [ :each | \r\t\t\t(firstIndexesOfOccurrence indexOf: each) = 1\r\t\t\t\tifTrue: [ each to: self replacementCollection size do: [ :i | self assert: (result at: i) = (self replacementCollection at: i - each + 1) ] ]\r\t\t\t\tifFalse: [ each + diff to: self replacementCollection size do: [ :i | self assert: (result at: i) = (self replacementCollection at: i - each + 1) ] ] ].\t\" verifying that the 'between' parts correspond to the initial collection : \"\r\t1 to: firstIndexesOfOccurrence size do: [ :i | \r\t\ti = 1\r\t\t\tifTrue: [ 1 to: (firstIndexesOfOccurrence at: i) - 1 do: [ :j | self assert: (result at: i) = (self collectionWith2TimeSubcollection at: i) ] ]\r\t\t\tifFalse: [ \r\t\t\t\tresultBetweenPartIndex := (firstIndexesOfOccurrence at: i - 1) + self replacementCollection size.\r\t\t\t\tcollectionBetweenPartIndex := (firstIndexesOfOccurrence at: i - 1) + self oldSubCollection size.\r\t\t\t\t1 to: (firstIndexesOfOccurrence at: i) - collectionBetweenPartIndex - 1 do: [ :j | \r\t\t\t\t\tself\r\t\t\t\t\t\tassert:\r\t\t\t\t\t\t\t(result at: resultBetweenPartIndex + i - 1)\r\t\t\t\t\t\t\t\t= (self collectionWith2TimeSubcollection at: collectionBetweenPartIndex + i - 1) ] ]\t\" specific comportement for the begining of the collection :\"\t\" between parts till the end : \" ].\t\"final part :\"\r\t1 to: self collectionWith2TimeSubcollection size - (firstIndexesOfOccurrence last + self oldSubCollection size) do: [ :i | \r\t\tself\r\t\t\tassert:\r\t\t\t\t(result at: firstIndexesOfOccurrence last + self replacementCollection size - 1 + i)\r\t\t\t\t\t= (self collectionWith2TimeSubcollection at: firstIndexesOfOccurrence last + self oldSubCollection size - 1 + i) ]"},{"name":"testCopyReplaceFromToWith","linesOfCode":25,"sourceCode":"testCopyReplaceFromToWith\r\t| result  indexOfSubcollection lastIndexOfOldSubcollection lastIndexOfReplacementCollection |\r\t\r\tindexOfSubcollection := (self firstIndexesOf: self oldSubCollection  in:  self collectionWith1TimeSubcollection) at: 1. \r\tlastIndexOfOldSubcollection := indexOfSubcollection + self oldSubCollection size -1.\r\tlastIndexOfReplacementCollection := indexOfSubcollection + self replacementCollection  size -1.\r\t\r\tresult := self collectionWith1TimeSubcollection  copyReplaceFrom: indexOfSubcollection  to: lastIndexOfOldSubcollection   with: self replacementCollection .\r\t\r\t\"verify content of 'result' : \"\r\t\"first part of 'result'  \"\r\t\r\t1 to: (indexOfSubcollection  - 1) do: \r\t\t[ \r\t\t:i | \r\t\tself assert: (self collectionWith1TimeSubcollection  at:i) = (result at: i)\r\t\t].\r\t\r\t\" middle part containing replacementCollection : \"\r\t\r\t(indexOfSubcollection ) to: ( lastIndexOfReplacementCollection  ) do: \r\t\t[\r\t\t:i |\r\t\tself assert: (result at: i)=(self replacementCollection at: (i - indexOfSubcollection +1))\r\t\t].\r\t\r\t\" end part :\"\r\t1 to: (result size - lastIndexOfReplacementCollection   ) do:\r\t\t[ \r\t\t:i |\r\t\tself assert: (result at: ( lastIndexOfReplacementCollection  + i  ) ) = (self collectionWith1TimeSubcollection  at: ( lastIndexOfOldSubcollection  + i  ) ).\r\t\t].\r\t\r\t\r\t\r\r\t\r\t"},{"name":"firstIndexesOf:in:","linesOfCode":22,"sourceCode":"firstIndexesOf: aSubCollection in: collection\r\" return an OrderedCollection with the first indexes of the occurrences of subCollection in  collection \"\r\t| tmp result currentIndex |\r\ttmp:= collection.\r\tresult:= OrderedCollection new.\r\tcurrentIndex := 1.\r\t\r\t[tmp isEmpty ]whileFalse:\r\t\t[\r\t\t(tmp beginsWith: aSubCollection)\r\t\t\tifTrue: [ \t\r\t\t\t\tresult add: currentIndex.\r\t\t\t\t1 to: aSubCollection size do: \r\t\t\t\t\t[:i | \r\t\t\t\t\ttmp := tmp copyWithoutFirst.\r\t\t\t\t\tcurrentIndex := currentIndex + 1]\r\t\t\t\t]\r\t\t\tifFalse: [\r\t\t\t\ttmp := tmp copyWithoutFirst.\r\t\t\t\tcurrentIndex := currentIndex +1.\r\t\t\t\t]\r\t\t ].\r\t\r\t^ result.\r\t"}],"meta":{"name":"TCopySequenceableWithReplacement classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TConvertAsSortedTest","instanceVariables":[],"methods":[{"name":"test0FixtureConverAsSortedTest","linesOfCode":3,"sourceCode":"test0FixtureConverAsSortedTest\r\tself collectionWithSortableElements.\r\tself denyEmpty: self collectionWithSortableElements"},{"name":"testAsSortedArray","linesOfCode":7,"sourceCode":"testAsSortedArray\r\r\t| result collection |\r\tcollection := self collectionWithSortableElements .\r\tresult := collection  asArray sort.\r\tself assert: (result class includesBehavior: Array).\r\tself assert: result isSorted.\r\tself assert: result size = collection size"},{"name":"testAsSortedCollectionWithSortBlock","linesOfCode":10,"sourceCode":"testAsSortedCollectionWithSortBlock\r\r\t| result tmp |\r\tresult := self collectionWithSortableElements  asSortedCollection: [:a :b | a > b ].\r\tself assert: (result class includesBehavior: SortedCollection).\r\tresult do: \r\t\t[ :each | \r\t\tself assert: (self collectionWithSortableElements occurrencesOf: each) equals: (result occurrencesOf: each) ].\r\tself assert: result size equals: self collectionWithSortableElements  size.\r\ttmp:=result at: 1.\r\tresult do: [:each| self assert: tmp >= each. tmp := each ] \r\t"},{"name":"testAsSortedCollection","linesOfCode":9,"sourceCode":"testAsSortedCollection\r\r\t| aCollection result |\r\taCollection := self collectionWithSortableElements .\r\tresult := aCollection asSortedCollection.\r\t\r\tself assert: (result class includesBehavior: SortedCollection).\r\tresult do: \r\t\t[ :each | \r\t\tself assert: (aCollection occurrencesOf: each) = (result occurrencesOf: each) ].\r\t\r\tself assert: result size = aCollection size"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\" return a collection elements that can be sorte ( understanding message ' < '  or ' > ')\"\r\t^ self explicitRequirement"}],"meta":{"name":"TConvertAsSortedTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TRemoveByIndexTest","instanceVariables":[],"methods":[{"name":"testRemoveLast","linesOfCode":8,"sourceCode":"testRemoveLast\r\r\t| collection element result oldSize |\r\tcollection := self collectionWith5Elements .\r\telement := collection last.\r\toldSize := collection size.\r\r\tresult := collection removeLast.\r\tself assert: result equals: element .\r\tself assert: collection size equals: (oldSize - 1)"},{"name":"collectionWith5Elements","linesOfCode":3,"sourceCode":"collectionWith5Elements\r\" return a collection of size 5 including 5 elements\"\rself explicitRequirement"},{"name":"testRemoveFirstNElements","linesOfCode":8,"sourceCode":"testRemoveFirstNElements\r\r\t| collection elements result oldSize |\r\tcollection := self collectionWith5Elements .\r\telements := { collection first. collection at:2 }.\r\toldSize := collection size.\r\r\tresult := collection removeFirst: 2.\r\tself assert: result equals: elements .\r\tself assert: collection size equals: (oldSize - 2)"},{"name":"testRemoveAt","linesOfCode":8,"sourceCode":"testRemoveAt\r\r\t| collection element result oldSize |\r\tcollection := self collectionWith5Elements .\r\telement := collection at: 3.\r\toldSize := collection size.\r\r\tresult := collection removeAt: 3.\r\tself assert: result equals: element.\r\tself assert: collection size equals: (oldSize - 1)."},{"name":"testRemoveAtNotPresent","linesOfCode":2,"sourceCode":"testRemoveAtNotPresent\r\r\tself should: [self empty removeAt: 2] raise: Error"},{"name":"testRemoveLastNElements","linesOfCode":8,"sourceCode":"testRemoveLastNElements\r\r\t| collection result oldSize elements |\r\tcollection := self collectionWith5Elements .\r\telements := { collection at: 4. collection last }.\r\toldSize := collection size.\r\r\tresult := (collection removeLast: 2).\r\tself assert: result equals: elements.\r\tself assert: collection size equals: (oldSize - 2)"},{"name":"test0FixtureRemoveByIndexTest","linesOfCode":3,"sourceCode":"test0FixtureRemoveByIndexTest\r\r\tself collectionWith5Elements.\r\tself assert: self collectionWith5Elements size = 5"},{"name":"testRemoveFirstNotPresent","linesOfCode":2,"sourceCode":"testRemoveFirstNotPresent\r\r\tself should: [self empty removeFirst] raise: Error"},{"name":"testRemoveFirstNElementsNotPresent","linesOfCode":2,"sourceCode":"testRemoveFirstNElementsNotPresent\r\r\tself should: [self empty removeFirst: 2] raise: Error"},{"name":"testRemoveFirst","linesOfCode":8,"sourceCode":"testRemoveFirst\r\r\t| collection element result oldSize |\r\tcollection := self collectionWith5Elements.\r\telement := collection first.\r\toldSize := collection size.\r\r\tresult := collection removeFirst.\r\tself assert: result equals: element .\r\tself assert: collection size equals: (oldSize - 1)"},{"name":"testRemoveLastNotPresent","linesOfCode":2,"sourceCode":"testRemoveLastNotPresent\r\r\tself should: [self empty removeLast] raise: Error"},{"name":"empty","linesOfCode":3,"sourceCode":"empty\r\" return an empty collection\"\rself explicitRequirement"},{"name":"testRemoveLastNElementsNElements","linesOfCode":2,"sourceCode":"testRemoveLastNElementsNElements\r\r\tself should: [self empty removeLast: 2] raise: Error"}],"meta":{"name":"TRemoveByIndexTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"SplitJoinTest","instanceVariables":[],"methods":[{"name":"testSplitOrderedCollectionOnOrderedCollection","linesOfCode":3,"sourceCode":"testSplitOrderedCollectionOnOrderedCollection\r\tself assert: (((1 to: 10) asOrderedCollection) splitOn: ((4 to: 5) asOrderedCollection))\r\t\tequals: {(1 to: 3) asOrderedCollection . (6 to: 10) asOrderedCollection} asOrderedCollection.\r"},{"name":"testSplitJoinStringOnString","linesOfCode":3,"sourceCode":"testSplitJoinStringOnString\r\tself assert: ('oo' join: ('ow' split: 'how now brown cow?'))\r\t\tequals: 'hoo noo broon coo?'"},{"name":"testSplitStringOnSubstring","linesOfCode":3,"sourceCode":"testSplitStringOnSubstring\r\tself assert: ('the banana man can can bananas' splitOn: 'an')\r\t\tequals: #('the b' '' 'a m' ' c' ' c' ' b' '' 'as') asOrderedCollection"},{"name":"testSplitStringOnChar","linesOfCode":3,"sourceCode":"testSplitStringOnChar\r\tself assert: ('does eat oats and lambs eat oats' splitOn: Character space)\r\t\tequals: #('does' 'eat' 'oats' 'and' 'lambs' 'eat' 'oats') asOrderedCollection"},{"name":"testJoinStringUsingChar","linesOfCode":3,"sourceCode":"testJoinStringUsingChar\r\tself assert: ('splitjoin' joinUsing: $-)\r\t\tequals: 's-p-l-i-t-j-o-i-n'"},{"name":"testSplitSortedCollectionOnSortedCollection","linesOfCode":3,"sourceCode":"testSplitSortedCollectionOnSortedCollection\r\tself assert: (((1 to: 10) asSortedCollection) splitOn: ((4 to: 5) asSortedCollection))\r\t\tequals: {(1 to: 3) asSortedCollection . (6 to: 10) asSortedCollection} asOrderedCollection.\r\r"},{"name":"testSplitArrayOnElement","linesOfCode":3,"sourceCode":"testSplitArrayOnElement\r\tself assert: ((1 to: 10) asArray splitOn: 4)\r\t\tequals: #(#(1 2 3) #(5 6 7 8 9 10)) asOrderedCollection\r"},{"name":"testSplitJoinOnSequence","linesOfCode":3,"sourceCode":"testSplitJoinOnSequence\r\tself assert: (#(6 6 6) join: (#(3 4) split: #(1 2 3 4 5)))\r\t\tequals: #(1 2 6 6 6 5)"},{"name":"testJoinArrayUsingOrderedCollection","linesOfCode":3,"sourceCode":"testJoinArrayUsingOrderedCollection\r\tself assert: ((1 to: 4) joinUsing: #(8 9) asOrderedCollection)\r\t\tequals: #(1 8 9 2 8 9 3 8 9 4) asOrderedCollection"},{"name":"testSplitOrderedCollectionOnElement","linesOfCode":3,"sourceCode":"testSplitOrderedCollectionOnElement\r\tself assert: (((1 to: 10) asOrderedCollection) splitOn: 4)\r\t\tequals: {(1 to: 3) asOrderedCollection . (5 to: 10) asOrderedCollection} asOrderedCollection.\r"},{"name":"testJoinStringUsingString","linesOfCode":3,"sourceCode":"testJoinStringUsingString\r\tself assert: ('bda' joinUsing: 'an')\r\t\tequals: 'bandana'"},{"name":"testJoinArrayUsingObject","linesOfCode":3,"sourceCode":"testJoinArrayUsingObject\r\tself assert: ((1 to: 4) joinUsing: 0)\r\t\tequals: #(1 0 2 0 3 0 4)"},{"name":"testJoinArrayUsingArray","linesOfCode":3,"sourceCode":"testJoinArrayUsingArray\r\tself assert: ((1 to: 4) joinUsing: #(8 9))\r\t\tequals: #(1 8 9 2 8 9 3 8 9 4)"},{"name":"testJoinArrayUsingString","linesOfCode":3,"sourceCode":"testJoinArrayUsingString\r\tself assert: ((1 to: 4) joinUsing: '--')\r\t\tequals: '1--2--3--4'"},{"name":"testJoinUsingLastOnArrayOfStrings","linesOfCode":4,"sourceCode":"testJoinUsingLastOnArrayOfStrings\r\tself\r\t\tassert: (#('Pharo is modern' 'open source' 'highly portable' 'fast' 'full-featured' ) joinUsing: ', ' last: ' and ')\r\t\tequals: 'Pharo is modern, open source, highly portable, fast and full-featured'"},{"name":"testSplitStringOnBlock","linesOfCode":3,"sourceCode":"testSplitStringOnBlock\r\tself assert: ('foobar' splitOn: [:ch | 'aeiou' includes: ch])\r\t\tequals: #('f' '' 'b' 'r') asOrderedCollection"},{"name":"testSplitArrayOnSequence","linesOfCode":3,"sourceCode":"testSplitArrayOnSequence\r\tself assert: ((1 to: 10) asArray splitOn: (4 to: 5))\r\t\tequals: #(#(1 2 3) #(6 7 8 9 10)) asOrderedCollection\r"},{"name":"testJoinArrayUsingSortedCollection","linesOfCode":3,"sourceCode":"testJoinArrayUsingSortedCollection\r\tself assert: ((1 to: 4) joinUsing: #(8 9) asSortedCollection)\r\t\tequals: #(1 8 9 2 8 9 3 8 9 4) asSortedCollection"},{"name":"testSplitJoinBoundaryCases","linesOfCode":9,"sourceCode":"testSplitJoinBoundaryCases\r\t\"Empty splitter, joiner or sequence.\"\r\tself assert: (#() join: (#() split: #())) equals: #().\r\tself assert: ('' join: ('' split: '')) equals: ''.\r\tself assert: ('' join: #('')) equals: ''. \r\r\t\"Overlapping splitters, or at end of sequence\"\r\tself assert: ('an' join: ('an' split: 'banana')) equals: 'banana'.\r\tself assert: ('na' join: ('na' split: 'banana')) equals: 'banana'.\r\tself assert: ('ana' join: ('ana' split: 'banana')) equals: 'banana'.\r"},{"name":"testSplitArrayOnBlock","linesOfCode":3,"sourceCode":"testSplitArrayOnBlock\r\tself assert: ((1 to: 10) asArray splitOn: [:n| n even])\r\t\tequals: #(#(1) #(3) #(5) #(7) #(9) #()) asOrderedCollection"},{"name":"testSplitJoinStringOnChar","linesOfCode":3,"sourceCode":"testSplitJoinStringOnChar\r\tself assert: ($: join: (Character space split: 'how now brown cow?'))\r\t\tequals: 'how:now:brown:cow?'"},{"name":"testJoinUsingLastOnArray","linesOfCode":9,"sourceCode":"testJoinUsingLastOnArray\r\t\r\t{\t{  1. 2. 3 } \t-> '1, 2 and 3' .\r\t\t{  1. 2 } \t-> '1 and 2' .\r\t\t{  1 } \t\t-> '1' .\r\t\t{  }\t\t\t-> ''.\r\t} \tasDictionary keysAndValuesDo: \r\t\t[ \t:testCollection :resultString |\r\t\t\tself\t assert: ( testCollection joinUsing: ', ' last: ' and ') equals: resultString. \r\t\t]\r"},{"name":"testSplitJoinOnElement","linesOfCode":3,"sourceCode":"testSplitJoinOnElement\r\tself assert: (0 join: (3 split: #(1 2 3 4 5)))\r\t\tequals: #(1 2 0 4 5)"},{"name":"testSplitJoinIdentity","linesOfCode":8,"sourceCode":"testSplitJoinIdentity\r\t| array string |\r\tarray := #(5 1 4 1 3 1 2 1).\r\tstring := 'how now brown cow'.\r\tself assert: (1 join: (1 split: array)) equals: array.\r\tself assert: (#(1 3) join: (#(1 3) split: array)) equals: array.\r\tself assert: ($o join: ($o split: string)) equals: string.\r\tself assert: ('ow' join: ('ow' split: string)) equals: string."},{"name":"testSplitSortedCollectionOnElement","linesOfCode":3,"sourceCode":"testSplitSortedCollectionOnElement\r\tself assert: (((1 to: 10) asSortedCollection) splitOn: 4)\r\t\tequals: {(1 to: 3) asSortedCollection . (5 to: 10) asSortedCollection} asOrderedCollection.\r"},{"name":"testJoinArrayUsingChar","linesOfCode":3,"sourceCode":"testJoinArrayUsingChar\r\tself assert: ((1 to: 4) joinUsing: $:)\r\t\tequals:  '1:2:3:4'"}],"meta":{"name":"SplitJoinTest class","instanceVariables":[],"methods":[{"name":"packageNamesUnderTest","linesOfCode":3,"sourceCode":"packageNamesUnderTest\r\t<ignoreForCoverage>\r\t^ #('SplitJoin')"},{"name":"documentation","linesOfCode":50,"sourceCode":"documentation\r\t<ignoreForCoverage>\r\t\"self showDocumentation\"\r\t\r\t^ '\"This package provides functionality for splitting and joining strings similarly to that offered by Perl, Python and Ruby. In addition, split and join work for any kind of sequence, and offer the possibility to split strings using regular expressions.\r\rSuppose object A is a SequenceableCollection of elements of type T (let''s call its type S[T]), and B is a splitter of type either T or S[T]. Then A splitOn: B yields an object C of type OC[S[T]] (OC=OrderedCollection). B can be either an element or a subsequence, so:\"\r\r\t''abracadabra'' splitOn: $b.\r\t\"-> an OrderedCollection(''a'' ''racada'' ''ra'')\"\r\r\t''abracadabra'' splitOn: ''ca''.\r\t\"-> an OrderedCollection(''abra'' ''dabra'')\"\r\r\"A splitOn: B is the same as B split: A, so:\"\r\r\t''ab'' split: ''abracadabra''.\r\t\"-> an OrderedCollection('''' ''racad'' ''ra'')\"\r\r\"joinUsing: and join: are the inverse of splitOn: and split:. You may use either of the forms:\r\tC joinUsing: B\ror:\r\tB join: C\rThe result is normally the same type as the joiner. If the joiner (B) is of type S[T] and C is of type OC[S[T]] or Array[S[T]], the result is also of type S[T]. For example:\"\r\r\t'' loves '' join: #(''john'' ''jane'' ''jack'').\r\t\"-> ''john loves jane loves jack''\"\r\r\"An object that is not a sequence can also be used as a joiner, in which case the final result is an array. Also the collection being joined may contain elements that are not sequences, in which case they are treated as singleton arrays.\"\r\r\t1 join: ''hello''.\r\t\"-> #($h 1 $e 1 $l 1 $l 1 $o)\"\r\r\"Note that in the case of characters and strings being used as joiners, the result is always a string.\"\r\r\"In general:\r\t((A splitOn: B) joinUsing: B) = A\ror:\r\t(B join: (B split: A)) = A\rso:\"\r\r\t(''r'' join: (''r'' split: ''abracadabra'')) = ''abracadabra''.\r\t\"->  true\"\r\r\"Although the main application is for Strings, split and join will work for any kinds of SequenceableCollections, including Arrays and Intervals.\"\r\r\t[:n | n isPrime] split: (2 to: 20).\r\t\"-> an OrderedCollection(#() #() #(4) #(6) #(8 9 10) #(12) #(14 15 16) #(18) #(20))\"\r\r\"In addition, the following special cases are supported:\r\r- split an S[T] using a block of type T->Boolean:\"\r\r\t''abracadabra'' splitOn: [:x | ''bc'' includes: x].\r\t\"-> an OrderedCollection(''a'' ''ra'' ''ada'' ''ra'')\"\r\r\"- split a String using a regex:\"\r\r\t''abracadabra'' splitOn: ''[bcdr]+'' asRegex.\r\t\"-> an OrderedCollection(''a'' ''a'' ''a'' ''a'' ''a'')\"\r\r\"- join all elements of an S[T] yielding another S[T]: '' ''- \"\r\r\t''abracadabra'' joinUsing: '':''.\r\t\" -> ''a:b:r:a:c:a:d:a:b:r:a''\"\r\r\"Note that in these cases the rule that (B join: (B split: A)) = A does not hold, either because B maps to different elements, or because there is no A to start with.\"\r\r\t$: join: (1 to: 4).\r\t\"-> ''1:2:3:4''\"\r\r\"Finally, there is the convenient utility method joinUsing:last:, used as follows:\"\r\r\t(1 to: 5) joinUsing: '', '' last: '' and ''.\r\t\"-> ''1, 2, 3, 4 and 5''\"\r\r\"This package merges and generalizes functionality from the Join package by Keith Hodges and the RubyShards package by Damien Pollet and Oscar Nierstrasz. \"\r'"}],"meta":null}},{"name":"TEnumeratingTest","instanceVariables":[],"methods":[{"name":"testFlatCollectAsWithEmptyCollection","linesOfCode":4,"sourceCode":"testFlatCollectAsWithEmptyCollection\r\r\tself \r\t\tassert: (self empty flatCollect: [ :x | { x }, { x } ] as: IdentitySet) \r\t\tequals: self empty asIdentitySet"},{"name":"collectionOfCollectionsOfStrings","linesOfCode":2,"sourceCode":"collectionOfCollectionsOfStrings\r\t^self explicitRequirement."},{"name":"testFlatCollectAs","linesOfCode":10,"sourceCode":"testFlatCollectAs\r\r\tself \r\t\tassert: (self simpleCollection flatCollect: [ :x | { x }, { x } ] as: IdentitySet) \r\t\tequals: self simpleCollection asIdentitySet.\r\tself\r\t\tassert: (#(foo bar baz) flatCollect: #yourself as: String)\r\t\tequals: 'foobarbaz'.\r\tself \r\t\tassert: (#(#(1 2) #(4 3)) flatCollect: #yourself as: Array)\r\t\tequals: #(1 2 4 3)"},{"name":"collectionOfCollectionsOfInts","linesOfCode":2,"sourceCode":"collectionOfCollectionsOfInts\r\t^self explicitRequirement."},{"name":"testFlatCollect","linesOfCode":12,"sourceCode":"testFlatCollect\r\r\tself assert: (self simpleCollection flatCollect: [ :x | { x } ]) equals: self simpleCollection.\r\tself assert: (self simpleCollection flatCollect: [ :x | { x } ]) species = self simpleCollection species.\r\t\r\tself \r\t\tassert: (self collectionOfCollectionsOfInts flatCollect: [ :x | { x } ]) \r\t\tequals: self collectionOfCollectionsOfInts.\r\tself \r\t\tassert: (self collectionWithCharacters flatCollect: [ :x | { x } ]) \r\t\tequals: self collectionWithCharacters.\r\tself \r\t\tassert: (self collectionOfCollectionsOfStrings flatCollect: [ :x | { x } ]) \r\t\tequals: self collectionOfCollectionsOfStrings"},{"name":"testFlattened","linesOfCode":5,"sourceCode":"testFlattened\r\r\tself assert: self simpleCollection flattened equals: #(1 8 3).\r\tself assert: self collectionOfCollectionsOfInts flattened equals: #( 1 2 3 4 5 6 ).\r\tself assert: self collectionWithCharacters flattened equals: #($a $x $d $c $m).\r\tself assert: self collectionOfCollectionsOfStrings flattened equals: #('foo' 'bar' 'zorg')."},{"name":"simpleCollection","linesOfCode":2,"sourceCode":"simpleCollection\r\t^self explicitRequirement."},{"name":"testFlatCollectAsSet","linesOfCode":4,"sourceCode":"testFlatCollectAsSet\r\r\tself \r\t\tassert: (self simpleCollection flatCollectAsSet: [ :x | { x }, { x } ]) \r\t\tequals: self simpleCollection asSet"},{"name":"collectionWithCharacters","linesOfCode":2,"sourceCode":"collectionWithCharacters\r\t^self explicitRequirement."}],"meta":{"name":"TEnumeratingTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopySequenceableSameContents","instanceVariables":[],"methods":[{"name":"testShuffled","linesOfCode":7,"sourceCode":"testShuffled\r\t| result |\r\tresult := self nonEmpty shuffled .\r\t\r\t\"verify content of 'result: '\"\r\tresult do: [:each | self assert: (self nonEmpty occurrencesOf: each)=(result occurrencesOf: each)].\r\t\"verify size of 'result' :\"\r\tself assert: result size=self nonEmpty size."},{"name":"testReversed","linesOfCode":8,"sourceCode":"testReversed\r\r\t| result |\r\tresult := self nonEmpty reversed.\r\t\r\t\"Verify content\"\r\tresult withIndexDo:\r\t\t[:el :i | self assert: el equals: (self nonEmpty at: (self nonEmpty size - i + 1))].\r\r\t\"Verify size\"\r\tself assert: result size=self nonEmpty size."},{"name":"testShallowCopy","linesOfCode":8,"sourceCode":"testShallowCopy\r\r\t| result |\r\tresult := self nonEmpty shallowCopy.\r\t\r\t\"Verfy content\"\r\tself nonEmpty withIndexDo:\r\t\t[:el :i | self assert: (result at:i) equals: (self nonEmpty at:i)].\r\t\r\t\"Verify size\"\r\tself assert: result size equals: self nonEmpty size."},{"name":"testReverse","linesOfCode":9,"sourceCode":"testReverse\r\r\t| result |\r\tresult := self nonEmpty reversed.\t\r\t\"verify content of 'result: '\"\r\t1 to: result size do:\r\t\t[:i | self assert: ((result at: i) \r\t\t\t= (self nonEmpty at: (self nonEmpty size - i + 1)))].\r\t\"verify size of 'result' :\"\r\tself assert: result size=self nonEmpty size"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\tself explicitRequirement"},{"name":"test0FixtureCopySameContentsTest","linesOfCode":5,"sourceCode":"test0FixtureCopySameContentsTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"testShallowCopyEmpty","linesOfCode":4,"sourceCode":"testShallowCopyEmpty\r\t| result |\r\tresult := self empty shallowCopy.\r\tself assertEmpty: result"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement"},{"name":"collectionWithSortableElements","linesOfCode":3,"sourceCode":"collectionWithSortableElements\r\t\" return a collection only including elements that can be sorted (understanding '<' )\"\r\tself explicitRequirement"}],"meta":{"name":"TCopySequenceableSameContents classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIterateSequencedReadableTest","instanceVariables":[],"methods":[{"name":"nonEmptyMoreThan1Element","linesOfCode":3,"sourceCode":"nonEmptyMoreThan1Element\r\" return a collection that doesn't includes equal elements' and doesn't include nil elements'\" \r\t^self explicitRequirement."},{"name":"testDo","linesOfCode":1,"sourceCode":"testDo"},{"name":"testReverseDo","linesOfCode":7,"sourceCode":"testReverseDo\r\t| result |\r\tresult := OrderedCollection new.\r\tself nonEmpty reverseDo: [: each | result add: each].\r\t\r\t1 to: result size do:\r\t\t[:i|\r\t\tself assert: (result at: i)=(self nonEmpty at:(self nonEmpty size-i+1))]"},{"name":"testWithCollectError","linesOfCode":2,"sourceCode":"testWithCollectError\r\r\tself should: [ self nonEmptyMoreThan1Element with: self empty collect:[:a :b | ]] raise: Error"},{"name":"testFromToDo","linesOfCode":7,"sourceCode":"testFromToDo\r\t\r\t| result |\r\tresult:= OrderedCollection new.\r\t\r\tself nonEmptyMoreThan1Element from: 1 to: (self nonEmptyMoreThan1Element size -1) do: [:each | result add: each].\r\t\r\t1 to: (self nonEmptyMoreThan1Element  size -1) do:\r\t\t[:i | self assert: (self nonEmptyMoreThan1Element at:i) = (result at:i) ].\r\r\tself assert: result size = (self nonEmptyMoreThan1Element size - 1)."},{"name":"testFindLastNotIn","linesOfCode":4,"sourceCode":"testFindLastNotIn\r\r\t| result |\t\r\tresult := self empty findFirst: [:each | true ].\r\t\r\tself assert: result equals: 0"},{"name":"test0FixtureIterateSequencedReadableTest","linesOfCode":9,"sourceCode":"test0FixtureIterateSequencedReadableTest\r\t| res |\r\tself nonEmptyMoreThan1Element.\r\tself assert: self nonEmptyMoreThan1Element size > 1.\r\r\tself empty.\r\tself assertEmpty: self empty.\r\r\tres := true.\r\tself nonEmptyMoreThan1Element detect: [ :each | (self nonEmptyMoreThan1Element occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself deny: res"},{"name":"testAllButLastDo","linesOfCode":8,"sourceCode":"testAllButLastDo\r\t\r\t| result |\r\tresult:= OrderedCollection  new.\r\t\r\tself nonEmptyMoreThan1Element  allButLastDo: [:each | result add: each].\r\t\r\t1 to: (result size) do:\r\t\t[:i|\r\t\tself assert: (self nonEmptyMoreThan1Element  at:(i ))=(result at:i)].\r\t\r\tself assert: result size=(self nonEmptyMoreThan1Element  size-1)"},{"name":"testKeysAndValuesDoEmpty","linesOfCode":5,"sourceCode":"testKeysAndValuesDoEmpty\r\t| result |\r\tresult := OrderedCollection new.\r\r\tself empty keysAndValuesDo: [ :i :value | result add: value + i ].\r\r\tself assertEmpty: result"},{"name":"testReverseDoEmpty","linesOfCode":5,"sourceCode":"testReverseDoEmpty\r\t| result |\r\tresult := OrderedCollection new.\r\tself empty reverseDo: [ :each | result add: each ].\r\r\tself assertEmpty: result"},{"name":"testKeysAndValuesDo","linesOfCode":23,"sourceCode":"testKeysAndValuesDo\r\t\"| result |\r\tresult:= OrderedCollection new.\r\t\r\tself nonEmptyMoreThan1Element  keysAndValuesDo: \r\t\t[:i :value|\r\t\tresult add: (value+i)].\r\t\r\t1 to: result size do:\r\t\t[:i|\r\t\tself assert: (result at:i)=((self nonEmptyMoreThan1Element at:i)+i)]\"\r\t|  indexes elements |\r\tindexes := OrderedCollection new.\r\telements := OrderedCollection new.\r\t\r\tself nonEmptyMoreThan1Element  keysAndValuesDo: \r\t\t[:i :value|\r\t\tindexes  add: (i).\r\t\telements add: value].\r\t\r\t(1 to: self nonEmptyMoreThan1Element size )do:\r\t\t[ :i |\r\t\tself assert: (indexes at: i) equals: i.\r\t\tself assert: (elements at: i) equals: (self nonEmptyMoreThan1Element at: i).\t\r\t\t].\r\t\r\tself assert: indexes size equals: elements size. \r\tself assert: indexes size equals: self nonEmptyMoreThan1Element size \r\t\r\t"},{"name":"testWithDoError","linesOfCode":2,"sourceCode":"testWithDoError\r\t\r\tself should: [self nonEmptyMoreThan1Element with: self empty do:[:a :b | ]] raise: Error"},{"name":"testGroupsOfAtATimeCollect","linesOfCode":10,"sourceCode":"testGroupsOfAtATimeCollect\r\t| groupsOf2 |\r\tself assertEmpty: (self empty groupsOf: 2 atATimeCollect: [ :x | x ]).\r\tself assertEmpty: (self empty groupsOf: 2 atATimeCollect: #yourself).\r\t\r\tgroupsOf2 := self nonEmptyMoreThan1Element groupsOf: 2 atATimeCollect: [ :x | x ].\r\t\r\tself assert: groupsOf2 size equals: self nonEmptyMoreThan1Element size // 2.\r\tself assert: (groupsOf2 allSatisfy: [ :array | array size = 2 ]).\r\t\r\tgroupsOf2 := self nonEmptyMoreThan1Element groupsOf: 3 atATimeCollect: #yourself.\r\t\r\tself assert: groupsOf2 size equals: self nonEmptyMoreThan1Element size // 3.\r\tself assert: (groupsOf2 allSatisfy: [ :array | array size = 3 ])."},{"name":"testPairsCollect","linesOfCode":8,"sourceCode":"testPairsCollect\r\t| index result |\r\tindex := 0.\r\r\tresult := self nonEmptyMoreThan1Element\r\t\tpairsCollect: [ :each1 :each2 | \r\t\t\tself assert: (self nonEmptyMoreThan1Element indexOf: each2) equals: (index := index + 2).\r\t\t\t(self nonEmptyMoreThan1Element indexOf: each2) = ((self nonEmptyMoreThan1Element indexOf: each1) + 1) ].\r\r\tresult do: [ :each | self assert: each ]"},{"name":"testWithDo","linesOfCode":10,"sourceCode":"testWithDo\r\t\r\t| firstCollection secondCollection index |\r\r\tfirstCollection := self nonEmptyMoreThan1Element.\r\tsecondCollection := firstCollection copy.\r\tindex := 0.\r\t\r\tfirstCollection  with: secondCollection do:\r\t\t[:a :b |\r\t\tindex := index + 1.\r\t\tself assert: (firstCollection at: index) equals:  a. \r\t\tself assert: (secondCollection at: index) equals: b ]\r\t\r\t"},{"name":"testWithIndexCollect","linesOfCode":10,"sourceCode":"testWithIndexCollect\r\t\r\t| result index collection |\r\tindex := 0.\r\tcollection := self nonEmptyMoreThan1Element .\r\tresult := collection  withIndexCollect: [:each :i | \r\t\tself assert: i equals: (index := index + 1).\t\r\t\tself assert: i equals: (collection  indexOf: each).\r\t\teach ]. \r\t\r\tresult withIndexDo: [:el :i | self assert: (result at:i) equals: (collection at: i)].\r\tself assert: result size equals: collection size "},{"name":"testAllButFirstDo","linesOfCode":8,"sourceCode":"testAllButFirstDo\r\t\r\t| result |\r\tresult:= OrderedCollection  new.\r\t\r\tself nonEmptyMoreThan1Element  allButFirstDo: [:each | result add: each].\r\t\r\t1 to: (result size) do:\r\t\t[:i|\r\t\tself assert: (self nonEmptyMoreThan1Element  at:(i +1))=(result at:i)].\r\t\r\tself assert: result size=(self nonEmptyMoreThan1Element size-1)"},{"name":"testPairsDo","linesOfCode":11,"sourceCode":"testPairsDo\r\r\t| index |\r\tindex:=1.\r\t\r\tself nonEmptyMoreThan1Element  pairsDo: \r\t\t[:each1 :each2 | \r\t\tself assert: (self nonEmptyMoreThan1Element at:index) equals: each1.\r\t\tself assert: (self nonEmptyMoreThan1Element at:(index+1)) equals: each2.\r\t\tindex := index + 2 ].\r\t\r\tself nonEmptyMoreThan1Element size odd\r\t\tifTrue:[ self assert: index equals: self nonEmptyMoreThan1Element size ]\r\t\tifFalse:[ self assert: index equals: (self nonEmptyMoreThan1Element size+1) ]"},{"name":"testDetectSequenced","linesOfCode":6,"sourceCode":"testDetectSequenced\r\t\"Testing that detect keep the first element returning true for sequenceable collections\"\r\r\t| element result |\r\telement := self nonEmptyMoreThan1Element at: 1.\r\tresult := self nonEmptyMoreThan1Element  detect: [:each | each notNil ].\r\tself assert: result equals: element "},{"name":"testFindFirst","linesOfCode":5,"sourceCode":"testFindFirst\r\r\t| element result |\r\telement := self nonEmptyMoreThan1Element at: 1.\r\tresult := self nonEmptyMoreThan1Element findFirst: [:each | each = element].\r\t\r\tself assert: result equals: 1 "},{"name":"testWithCollect","linesOfCode":13,"sourceCode":"testWithCollect\r\t\r\t| result firstCollection secondCollection index  |\r\r\tfirstCollection := self nonEmptyMoreThan1Element.\r\tsecondCollection := firstCollection copy.\r\tindex := 0.\r\t\r\tresult := firstCollection  with: secondCollection collect:\r\t\t[:a :b |\r\t\t( index := index + 1).\r\t\tself assert: (firstCollection at: index) equals:  a. \r\t\tself assert: (secondCollection at: index) equals:  b.\r\t\tb].\r\t\r\tresult withIndexDo: [:el :i | self assert: (result at:i) equals: (secondCollection  at: i)].\r\tself assert: result size = secondCollection size"},{"name":"testFindFirstNotIn","linesOfCode":4,"sourceCode":"testFindFirstNotIn\r\r\t| result |\t\r\tresult := self empty findFirst: [:each | true ].\r\t\r\tself assert: result equals: 0"},{"name":"testReverseWithDo","linesOfCode":10,"sourceCode":"testReverseWithDo\r\t\r\t| firstCollection secondCollection index |\r\r\tfirstCollection := self nonEmptyMoreThan1Element.\r\tsecondCollection := firstCollection copy.\r\tindex := firstCollection size.\r\t\r\tfirstCollection  reverseWith: secondCollection do:\r\t\t[:a :b |\r\t\r\t\tself assert: (firstCollection at: index) equals: a. \r\t\tself assert: (secondCollection at: index) equals: b.\r\t\t\t(index := index - 1)]\r\t\r\t\r\t"},{"name":"testCollectFromTo","linesOfCode":10,"sourceCode":"testCollectFromTo\r\t\r\t| result |\r\tresult:=self nonEmptyMoreThan1Element \r\t\tcollect: [ :each | each ]\r\t\tfrom: 1\r\t\tto: (self nonEmptyMoreThan1Element size - 1).\r\t\t\r\t1 to: result size\r\t\tdo: [ :i | self assert: (self nonEmptyMoreThan1Element at: i) = (result at: i) ].\r\tself assert: result size = (self nonEmptyMoreThan1Element size - 1)"},{"name":"testFindLast","linesOfCode":5,"sourceCode":"testFindLast\r\r\t| element result |\r\telement := self nonEmptyMoreThan1Element at: self nonEmptyMoreThan1Element size.\r\tresult := self nonEmptyMoreThan1Element findLast: [:each | each =element].\r\t\r\tself assert: result equals: self nonEmptyMoreThan1Element size"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^self explicitRequirement."},{"name":"testWithIndexDo","linesOfCode":14,"sourceCode":"testWithIndexDo\r\r\t|  indexes elements |\r\tindexes:= OrderedCollection new.\r\telements := OrderedCollection new.\r\t\r\tself nonEmptyMoreThan1Element withIndexDo: \r\t\t[:value :i  |\r\t\t\tindexes  add: (i).\r\t\t\telements add: value ].\r\t\r\tself nonEmptyMoreThan1Element withIndexDo: \r\t\t[:el :i |\r\t\t\tself assert: (indexes at: i) equals: i.\r\t\t\tself assert: (elements at: i) equals: el ].\r\t\r\tself assert: indexes size equals: elements size. \r\tself assert: indexes size equals: self nonEmptyMoreThan1Element size\r\t"}],"meta":{"name":"TIterateSequencedReadableTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TStructuralEqualityTest","instanceVariables":[],"methods":[{"name":"testEqualSignIsTrueForNonIdenticalButEqualCollections","linesOfCode":9,"sourceCode":"testEqualSignIsTrueForNonIdenticalButEqualCollections\r\t\t\r\tself assert: self empty equals: self empty copy. \r\tself assert: self empty copy equals: self empty.\r\tself assert: self empty copy equals: self empty copy.\r\t\t\r\tself assert: self nonEmpty equals: self nonEmpty copy. \r\tself assert: self nonEmpty copy equals: self nonEmpty.\r\tself assert: self nonEmpty copy equals: self nonEmpty copy"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r\t^ self explicitRequirement"},{"name":"testEqualSignOfIdenticalCollectionObjects","linesOfCode":3,"sourceCode":"testEqualSignOfIdenticalCollectionObjects\r\t\r\tself assert: self empty equals: self empty. \r\tself assert: self nonEmpty equals: self nonEmpty \r\t"},{"name":"test0TStructuralEqualityTest","linesOfCode":5,"sourceCode":"test0TStructuralEqualityTest\r\tself empty.\r\tself nonEmpty.\r\tself assertEmpty: self empty.\r\tself denyEmpty: self nonEmpty"},{"name":"testEqualSign","linesOfCode":2,"sourceCode":"testEqualSign\r \r\tself deny: (self empty = self nonEmpty)"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r\t^ self explicitRequirement"}],"meta":{"name":"TStructuralEqualityTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TSetArithmetic","instanceVariables":[],"methods":[{"name":"anotherElementOrAssociationIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationIn\r\t\" return an element (or an association for Dictionary ) present  in 'collection' \"\r\t^ self explicitRequirement"},{"name":"testDifference","linesOfCode":8,"sourceCode":"testDifference\r\t\"Answer the set theoretic difference of two collections.\"\r\r\t| difference |\r\tself assertEmpty: (self collectionWithoutEqualElements difference: self collectionWithoutEqualElements).\r\tself assertEmpty: (self empty difference: self collectionWithoutEqualElements).\r\tdifference := self collectionWithoutEqualElements difference: self empty.\r\tself assert: difference size = self collectionWithoutEqualElements size.\r\tself collectionWithoutEqualElements do: [ :each | self assert: (difference includes: each) ]"},{"name":"testIntersectionBasic","linesOfCode":5,"sourceCode":"testIntersectionBasic\r\t| inter |\r\tinter := self collection intersection: (self collectionClass with: self anotherElementOrAssociationIn).\r\tself denyEmpty: inter.\r\tself assert: (inter includes: self anotherElementOrAssociationIn value)"},{"name":"anotherElementOrAssociationNotIn","linesOfCode":3,"sourceCode":"anotherElementOrAssociationNotIn\r\t\" return an element (or an association for Dictionary )not present  in 'collection' \"\r\t^ self explicitRequirement"},{"name":"containsAll:of:andOf:","linesOfCode":4,"sourceCode":"containsAll: union of: one andOf: another\r\t\t\t\r\tself assert: (one allSatisfy: [:each | union includes: each]).\r\tself assert: (another allSatisfy: [:each | union includes: each])"},{"name":"testIntersectionTwoSimilarElementsInIntersection","linesOfCode":5,"sourceCode":"testIntersectionTwoSimilarElementsInIntersection\r\r\t| inter |\r\tinter := self collection intersection: (self collectionClass with: self anotherElementOrAssociationIn).\r\tself assert: (self collection occurrencesOf: self anotherElementOrAssociationIn) equals: self numberOfSimilarElementsInIntersection.\r\tself assert: (inter includes: self anotherElementOrAssociationIn value)"},{"name":"testIntersectionEmpty","linesOfCode":6,"sourceCode":"testIntersectionEmpty\r\t| inter |\r\tinter := self empty intersection: self empty.\r\tself assertEmpty: inter.\r\tinter := self empty intersection: self collection.\r\tself assert: inter equals: self empty"},{"name":"testIntersectionItself","linesOfCode":6,"sourceCode":"testIntersectionItself\r\t\r\t| result |\r\tresult := self collectionWithoutEqualElements intersection: self collectionWithoutEqualElements.\r\tself assert: result size equals: self collectionWithoutEqualElements size.\r\tself collectionWithoutEqualElements do: [ :each|\r\t\tself assert: (result includes: each) ].\r\t"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ self explicitRequirement"},{"name":"testUnionOfEmpties","linesOfCode":2,"sourceCode":"testUnionOfEmpties\r\tself assertEmpty: (self empty union: self empty)"},{"name":"test0FixtureSetAritmeticTest","linesOfCode":10,"sourceCode":"test0FixtureSetAritmeticTest\r\tself collection.\r\tself denyEmpty: self collection.\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself anotherElementOrAssociationNotIn.\r\tself collection isDictionary\r\t\tifTrue: [ self deny: (self collection associations includes: self anotherElementOrAssociationNotIn key) ]\r\t\tifFalse: [ self deny: (self collection includes: self anotherElementOrAssociationNotIn) ].\r\tself collectionClass"},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass\r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ self explicitRequirement"},{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\r\t^ self explicitRequirement"},{"name":"testDifferenceWithSeparateCollection","linesOfCode":12,"sourceCode":"testDifferenceWithSeparateCollection\r\t\"Answer the set theoretic difference of two collections.\"\r\r\t| res separateCol |\t\r\tseparateCol := self collectionClass with: self anotherElementOrAssociationNotIn.\r\tres := self collectionWithoutEqualElements difference: separateCol.\r\t\r\tself deny: (res includes: self anotherElementOrAssociationNotIn).\r\tself assert: res size equals: self collectionWithoutEqualElements size.\r\t\r\tself collectionWithoutEqualElements do: [ :each|\r\t\tself assert: (res includes: each)].\r\t\r\tres := separateCol difference: self collection.\r\tself deny: (res includes: self collection anyOne).\r\tself assert: res equals: separateCol"},{"name":"numberOfSimilarElementsInIntersection","linesOfCode":2,"sourceCode":"numberOfSimilarElementsInIntersection\r\r\t^ self collection occurrencesOf: self anotherElementOrAssociationIn"},{"name":"testDifferenceWithNonNullIntersection","linesOfCode":10,"sourceCode":"testDifferenceWithNonNullIntersection\r\t\"Answer the set theoretic difference of two collections. \r\t \t#(1 2 3) difference: #(2 4) ->  #(1 3)\"\r\t\r\t| res overlapping |\r\toverlapping := self collectionClass \r\t\twith: self anotherElementOrAssociationNotIn\r\t\twith: self anotherElementOrAssociationIn.\r\tres := self collection difference: overlapping.\r\tself deny: (res includes: self anotherElementOrAssociationIn).\r\toverlapping do: [ :each | self deny: (res includes: each) ]"},{"name":"testUnion","linesOfCode":8,"sourceCode":"testUnion\r\t\r\t| union |\r\tunion := self empty union: self nonEmpty.\r\tself containsAll: union of: self empty andOf: self nonEmpty.\r\tunion := self nonEmpty union: self empty.\r\tself containsAll: union of: self empty andOf: self nonEmpty.\r\tunion := self collection union: self nonEmpty.\r\tself containsAll: union of: self collection andOf: self nonEmpty."}],"meta":{"name":"TSetArithmetic classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopyPreservingIdentityTest","instanceVariables":[],"methods":[{"name":"testCopyReturnsIdentity","linesOfCode":4,"sourceCode":"testCopyReturnsIdentity\r\t\r\t| copy | \r\tcopy := self nonEmpty copy.\r\tself assert: self nonEmpty == copy.\r\t"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\tself explicitRequirement"}],"meta":{"name":"TCopyPreservingIdentityTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TConcatenationEqualElementsRemovedTest","instanceVariables":[],"methods":[{"name":"testConcatenationWithEmpty","linesOfCode":4,"sourceCode":"testConcatenationWithEmpty\r\t| result |\r\tresult := self firstCollection , self empty.\r\tself assert: result = self firstCollection"},{"name":"testConcatenationWithDuplicate","linesOfCode":7,"sourceCode":"testConcatenationWithDuplicate\r\r\r| collection1 collection2 result |\rcollection1 := self firstCollection .\rcollection2 := self firstCollection  .\rresult := collection1 , collection2.\r\rcollection1 do:[ :each | self assert: (result includes: each)].\rself assert: result size = collection1 size."},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\tself explicitRequirement"},{"name":"testConcatenation","linesOfCode":7,"sourceCode":"testConcatenation\r\r| collection1 collection2 result |\rcollection1 := self firstCollection .\rcollection2 := self secondCollection .\rresult := collection1 , collection2.\r\rcollection1 do:[ :each | self assert: (result includes: each)].\rcollection2 do:[ :each | self assert: (result includes: each)].\r"},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\tself explicitRequirement"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement."},{"name":"test0FixtureConcatenationTest","linesOfCode":7,"sourceCode":"test0FixtureConcatenationTest\r\tself firstCollection.\r\tself denyEmpty: self firstCollection.\r\tself firstCollection.\r\tself denyEmpty: self firstCollection.\r\tself empty.\r\tself assertEmpty: self empty"}],"meta":{"name":"TConcatenationEqualElementsRemovedTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIdentityAddTest","instanceVariables":[],"methods":[{"name":"collection","linesOfCode":2,"sourceCode":"collection\r\t^ self explicitRequirement"},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ self explicitRequirement"},{"name":"equalNotIdenticalElement","linesOfCode":2,"sourceCode":"equalNotIdenticalElement\r\t^ self element copy"},{"name":"testIdentityAdd","linesOfCode":7,"sourceCode":"testIdentityAdd\r\t| added |\r\tself collection add: self element.\r\tself deny: (self collection includes: self equalNotIdenticalElement).\r\t\r\tadded := self collection add: self equalNotIdenticalElement.\r\tself assert: added == self equalNotIdenticalElement.\r\tself assert: (self collection includes: self equalNotIdenticalElement)"}],"meta":{"name":"TIdentityAddTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TOccurrencesForIdentityCollectionsTest","instanceVariables":[],"methods":[{"name":"identityCollectionWithElementsCopyNotIdentical","linesOfCode":3,"sourceCode":"identityCollectionWithElementsCopyNotIdentical\r\" return a collection including elements for which #copy return a new object \"\r^ self explicitRequirement"},{"name":"test0FixtureOccurrencesForIdentityCollectionsTest","linesOfCode":3,"sourceCode":"test0FixtureOccurrencesForIdentityCollectionsTest\r\tself identityCollectionWithElementsCopyNotIdentical.\r\tself identityCollectionWithElementsCopyNotIdentical do: [ :each | self deny: each copy == each ]"},{"name":"testOccurrencesOfForIdentityCollections","linesOfCode":6,"sourceCode":"testOccurrencesOfForIdentityCollections\r\r| collection element elementCopy |\rcollection := self identityCollectionWithElementsCopyNotIdentical .\relement := collection anyOne.\relementCopy := element copy.\r\rself assert: (collection occurrencesOf: elementCopy ) = 0."}],"meta":{"name":"TOccurrencesForIdentityCollectionsTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TReplacementSequencedTest","instanceVariables":[],"methods":[{"name":"secondIndex","linesOfCode":3,"sourceCode":"secondIndex\r\t\"Return an index between 'nonEmpty' bounds that is > to 'first index'\"\r\t\r\t^self explicitRequirement"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^self explicitRequirement"},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\t\"Return a collection that will be put into 'nonEmpty'\"\r\t\r\t^ self replacementCollectionSameSize, self \treplacementCollectionSameSize   "},{"name":"newElement","linesOfCode":3,"sourceCode":"newElement\r\t\"Return an element that will be put in the collection in place of another\"\r\r\tself explicitRequirement"},{"name":"testReplaceAllWith","linesOfCode":9,"sourceCode":"testReplaceAllWith\r\t| result collection oldElement newElement oldOccurrences |\r\tcollection := self nonEmpty.\r\tresult := collection copy.\r\toldElement := self elementInForReplacement.\r\tnewElement := self newElement.\r\toldOccurrences := (result occurrencesOf: oldElement) + (result occurrencesOf: newElement).\r\tresult replaceAll: oldElement with: newElement.\r\t\r\tself assert: oldOccurrences equals: (result occurrencesOf: newElement)"},{"name":"testReplaceFromToWithStartingAt","linesOfCode":18,"sourceCode":"testReplaceFromToWithStartingAt\r\t| result repStart collection replacementCollec firstInd secondInd |\r\tcollection := self nonEmpty.\r\tresult := collection copy.\r\treplacementCollec := self replacementCollectionSameSize.\r\tfirstInd := self firstIndex.\r\tsecondInd := self secondIndex.\r\trepStart := replacementCollec size - (secondInd - firstInd + 1) + 1.\r\tresult replaceFrom: firstInd to: secondInd with: replacementCollec startingAt: repStart.\r\t\r\t\"Verify content of 'result'\"\r\t\r\t\"First part of 'result'\" \t\r\t1 to: (firstInd - 1) do: [:i | self assert: (collection at:i) equals: (result at: i) ].\r\t\r\t\"Middle part containing replacementCollection\"\t\r\tfirstInd to: (replacementCollec size - repStart +1) do: \r\t\t[:i| self assert: (result at: i) equals: (replacementCollec at: (repStart + (i - firstInd))) ].\r\t\r\t\"End part\"\r\t(firstInd + replacementCollec size) to: (result size) do:\r\t\t[ :i | self assert: (result at: i) equals: (collection at: (secondInd + 1 - (firstInd + replacementCollec size) + i)) ]"},{"name":"testOFixtureReplacementSequencedTest","linesOfCode":14,"sourceCode":"testOFixtureReplacementSequencedTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\r\tself elementInForReplacement.\r\tself assert: (self nonEmpty includes: self elementInForReplacement).\r\r\tself newElement.\r\r\tself firstIndex.\r\tself assert: (self firstIndex >= 1 & self firstIndex) <= self nonEmpty size.\r\r\tself secondIndex.\r\tself assert: (self secondIndex >= 1 & self secondIndex) <= self nonEmpty size.\r\r\tself assert: self firstIndex <= self secondIndex.\r\r\tself replacementCollection.\r\r\tself replacementCollectionSameSize.\r\tself assert: self secondIndex - self firstIndex + 1 equals: self replacementCollectionSameSize size"},{"name":"firstIndex","linesOfCode":3,"sourceCode":"firstIndex\r\t\"Return an index between 'nonEmpty' bounds that is < to 'second index'\"\r\t\r\t^self explicitRequirement"},{"name":"replacementCollectionSameSize","linesOfCode":3,"sourceCode":"replacementCollectionSameSize\r\t\"Return a collection of size (secondIndex - firstIndex + 1)\"\r\t\r\t^self explicitRequirement"},{"name":"testReplaceFromToWith","linesOfCode":18,"sourceCode":"testReplaceFromToWith\r\t| result collection replacementCollec firstInd secondInd |\r\tcollection := self nonEmpty .\r\treplacementCollec := self replacementCollectionSameSize.\r\tfirstInd := self firstIndex.\r\tsecondInd := self secondIndex.\r\tresult := collection copy.\r\tresult replaceFrom: firstInd to: secondInd with: replacementCollec.\r\t\r\t\"Verify content of 'result'\"\r\r\t\"First part of 'result'\"\t\r\t1 to: (firstInd - 1) do: [:i | self assert: (collection at:i) equals: (result at: i) ].\r\t\r\t\"Middle part containing replacementCollection\"\t\r\tfirstInd to: (firstInd + replacementCollec size - 1) do: \r\t\t[:i | self assert: (result at: i) equals: (replacementCollec at: (i - firstInd + 1)) ].\r\t\r\t\"End part\"\r\t(firstInd + replacementCollec size) to: (result size) do:\r\t\t[:i|\r\t\tself assert: (result at: i) equals: (collection at: (secondInd + 1 - (firstInd + replacementCollec size) + i)) ]"},{"name":"elementInForReplacement","linesOfCode":3,"sourceCode":"elementInForReplacement\r\t\"Return an element included in 'nonEmpty'\"\r\r\t^ self nonEmpty anyOne"}],"meta":{"name":"TReplacementSequencedTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIncludesWithIdentityCheckTest","instanceVariables":[],"methods":[{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotIn).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotIn)"},{"name":"testIncludesAnyAllThere","linesOfCode":4,"sourceCode":"testIncludesAnyAllThere\r\r\tself deny: (self nonEmpty includesAny: self empty).\r\tself assert: (self nonEmpty includesAny: { self nonEmpty anyOne }).\r\tself assert: (self nonEmpty includesAny: self nonEmpty)"},{"name":"collectionWithCopyNonIdentical","linesOfCode":3,"sourceCode":"collectionWithCopyNonIdentical\r\t\" return a collection that include elements for which 'copy' return a different object (this is not the case of SmallInteger)\"\r\t^ self explicitRequirement"},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\"return an element not included in 'nonEmpty' \"\r\r\t^ self explicitRequirement"},{"name":"testIdentityIncludes","linesOfCode":7,"sourceCode":"testIdentityIncludes\r\t\" test the comportement in presence of elements 'includes' but not 'identityIncludes' \"\r\t\" can not be used by collections that can't include elements for wich copy doesn't return another instance \"\r\t| collection anElement |\r\t\r\tcollection := self collectionWithCopyNonIdentical.\r\tanElement := collection anyOne copy.\r\r\tself deny: (collection identityIncludes: anElement)"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ self explicitRequirement"},{"name":"test0FixtureIncludeWithIdentityTest","linesOfCode":5,"sourceCode":"test0FixtureIncludeWithIdentityTest\r\r\t| anElement |\r\tself collectionWithCopyNonIdentical.\r\tanElement := self collectionWithCopyNonIdentical anyOne.\r\tself deny: anElement == anElement copy"},{"name":"testIncludesAllNoneThere","linesOfCode":3,"sourceCode":"testIncludesAllNoneThere\r\r\tself deny: (self empty includesAll: self nonEmpty).\r\tself deny: (self nonEmpty includesAll: { self elementNotIn. self anotherElementNotIn })"},{"name":"anotherElementNotIn","linesOfCode":3,"sourceCode":"anotherElementNotIn\r\" return an element different of 'elementNotIn'  not included in 'nonEmpty' \"\r\t^ self explicitRequirement"},{"name":"testIdentityIncludesNonSpecificComportement","linesOfCode":6,"sourceCode":"testIdentityIncludesNonSpecificComportement\r\t\"Test the same comportement than #includes:\"\r\t\r\t| collection |\t\r\tcollection := self nonEmpty.\r\t\r\tself deny: (collection identityIncludes: self elementNotIn).\r\tself assert: (collection identityIncludes: collection anyOne)\r"},{"name":"test0FixtureIncludeTest","linesOfCode":14,"sourceCode":"test0FixtureIncludeTest\r\t| anElementIn |\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself elementNotIn.\r\tanElementIn := true.\r\tself nonEmpty detect: [ :each | each = self elementNotIn ] ifNone: [ anElementIn := false ].\r\tself deny: anElementIn.\r\tself anotherElementNotIn.\r\tanElementIn := true.\r\tself nonEmpty detect: [ :each | each = self anotherElementNotIn ] ifNone: [ anElementIn := false ].\r\tself deny: anElementIn.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"testIncludesElementIsThere","linesOfCode":2,"sourceCode":"testIncludesElementIsThere\r\t\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne)"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ self explicitRequirement"},{"name":"testIncludesAnyNoneThere","linesOfCode":3,"sourceCode":"testIncludesAnyNoneThere\r\t\r\tself deny: (self nonEmpty includesAny: self empty).\r\tself deny: (self nonEmpty includesAny: { self elementNotIn. self anotherElementNotIn })"}],"meta":{"name":"TIncludesWithIdentityCheckTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIterateTest","instanceVariables":[],"methods":[{"name":"testCollectThenSelectOnEmpty","linesOfCode":2,"sourceCode":"testCollectThenSelectOnEmpty\r\tself assertEmpty: (self empty collect: [ :e | self fail ] thenSelect: [ :e | self fail ])"},{"name":"testRejectAllThenCollect","linesOfCode":4,"sourceCode":"testRejectAllThenCollect\r\t| result |\r\tresult := self collectionWithoutNilElements reject: [ :each | each notNil ] thenCollect: [ :each | self fail ].\r\r\tself assertEmpty: result"},{"name":"testSelectThenDoOnEmpty","linesOfCode":2,"sourceCode":"testSelectThenDoOnEmpty\r\tself assertEmpty: (self empty select: [ :e | self fail ] thenDo: [ self fail ])"},{"name":"testInjectInto","linesOfCode":6,"sourceCode":"testInjectInto\r\t|result|\r\tresult:= self collectionWithoutNilElements \r\t\tinject: 0\r\t\tinto: [:inj :ele | ele notNil ifTrue: [ inj + 1 ]].\r\t\r\tself assert: self collectionWithoutNilElements size = result ."},{"name":"testAllSatisfy","linesOfCode":9,"sourceCode":"testAllSatisfy\r\r\t| element |\r\t\" when all element  satisfy the condition, should return true : \"\r\tself assert: ( self collectionWithoutNilElements  allSatisfy: [:each | (each notNil) ] ).\r\t\r\t\" when all element don't satisfy the condition, should return false : \"\r\tself deny: ( self collectionWithoutNilElements  allSatisfy: [:each | (each notNil) not ] ).\r\t\r\t\" when only one element doesn't satisfy the condition' should return false'\"\r\telement := self collectionWithoutNilElements anyOne.\r\tself deny: ( self collectionWithoutNilElements  allSatisfy: [:each | (each = element) not] )."},{"name":"test0FixtureIterateTest","linesOfCode":7,"sourceCode":"test0FixtureIterateTest\r\t| res |\r\tself collectionWithoutNilElements.\r\tself assert: (self collectionWithoutNilElements occurrencesOf: nil) = 0.\r\tres := true.\r\tself collectionWithoutNilElements detect: [ :each | (self collectionWithoutNilElements occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself deny: res"},{"name":"testDetect","linesOfCode":6,"sourceCode":"testDetect\r\r\t| res element |\r\telement := self collectionWithoutNilElements anyOne .\r\t \r\tres := self collectionWithoutNilElements  detect: [:each | each = element].\r\tself assert: (res  = element).\r\r\t\r\t"},{"name":"testSelectThenDo","linesOfCode":17,"sourceCode":"testSelectThenDo\r\r\t| result index selectIndex |\r\t\r\tindex := 0.\r\tselectIndex := 0.\r\t\r\tresult := self collectionWithoutNilElements \r\t\tselect: [ :each | \r\t\t\tselectIndex := selectIndex + 1.\r\t\t\t\"reject the first element\"\r\t\t\tselectIndex > 1 ]\r\t\tthenDo: [ :each | \r\t\t\tself assert: each notNil.\r\t\t\tindex := index + 1]\t.\r\t\t\t\r\tself assert: result equals: self collectionWithoutNilElements.\r\tself assert: selectIndex equals: self collectionWithoutNilElements size.\r\tself assert: index equals: self collectionWithoutNilElements size - 1.\r\t "},{"name":"testDetectIfNone","linesOfCode":7,"sourceCode":"testDetectIfNone\r\r\t| res element |\r\tres := self collectionWithoutNilElements  detect: [:each | each notNil not] ifNone: [100].\r\tself assert: res  = 100.\r\t\r\telement := self collectionWithoutNilElements anyOne.\r\tres := self collectionWithoutNilElements  detect: [:each | each = element] ifNone: [100].\r\tself assert: res  = element.\r\r\t\r\t"},{"name":"testAllSatisfyEmpty","linesOfCode":2,"sourceCode":"testAllSatisfyEmpty\r\r\tself assert: ( self empty allSatisfy: [:each | false]).\r\t"},{"name":"testBasicCollectEmpty","linesOfCode":4,"sourceCode":"testBasicCollectEmpty\r\t| res |\r\tres := self empty collect: [ :each | each class ].\r\tself assertEmpty: res"},{"name":"testRejectNoReject","linesOfCode":4,"sourceCode":"testRejectNoReject\r\r\t| res |\r\tres := self collectionWithoutNilElements  reject: [:each | each notNil not].\r\tself assert: res size = self collectionWithoutNilElements size.\r\t"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\tself explicitRequirement"},{"name":"testRejectThenCollectEmpty","linesOfCode":2,"sourceCode":"testRejectThenCollectEmpty\r\tself assertEmpty: (self empty reject: [ :e | self fail ] thenCollect: [ :each | self fail ])"},{"name":"testNoneSatisfyEmpty","linesOfCode":2,"sourceCode":"testNoneSatisfyEmpty\r\r\tself assert: ( self empty noneSatisfy: [:each | false]).\r\t"},{"name":"testBasicCollectThenDo","linesOfCode":12,"sourceCode":"testBasicCollectThenDo\r\r\t| result index |\r\tindex := 0.\r\tresult := self collectionWithoutNilElements \r\t\tcollect: [ :each | nil ]\r\t\tthenDo: [ :each | \r\t\t\tself assert: each isNil.\r\t\t\tindex := index + 1]\t.\r\t\t\t\r\tself assert: result equals: self collectionWithoutNilElements.\r\tself assert: index equals: self collectionWithoutNilElements size.\r\t "},{"name":"testRejectEmpty","linesOfCode":4,"sourceCode":"testRejectEmpty\r\r\t| res |\r\tres := self empty reject: [:each | each odd].\r\tself assert: res size = self empty size\r\t"},{"name":"testDoWithout","linesOfCode":9,"sourceCode":"testDoWithout\r\t\r\t| res element collection |\r\tcollection := self collectionWithoutNilElements .\t\r\tres := OrderedCollection new.  \r\telement := self collectionWithoutNilElements anyOne .\r\tcollection  do: [:each | res add: each] without: element  .\r\t\" verifying result :\"\r\tself assert: res size = (collection  size - (collection  occurrencesOf: element)).\r\tres do: [:each | self assert: (collection occurrencesOf: each) = ( res occurrencesOf: each ) ].\r\t"},{"name":"testSelectThenCollect","linesOfCode":22,"sourceCode":"testSelectThenCollect\r\r\t| result index selectIndex pivot |\r\t\r\tindex := 0.\r\tselectIndex := 0.\r\tpivot := self collectionWithoutNilElements anyOne.\r\t\r\tresult := self collectionWithoutNilElements \r\t\tselect: [ :each | \r\t\t\tselectIndex := selectIndex + 1.\r\t\t\t\"reject the first element\"\r\t\t\tselectIndex > 1 ]\r\t\tthenCollect: [ :each | \r\t\t\tself assert: each notNil.\r\t\t\tindex := index + 1.\r\t\t\tpivot ].\r\t\t\t\r\tself assert: result ~= self collectionWithoutNilElements.\r\tself assert: selectIndex equals: self collectionWithoutNilElements size.\r\tself assert: index equals: self collectionWithoutNilElements size - 1.\r\t\r\tself assert: (self collectionWithoutNilElements occurrencesOf: pivot) equals: 1.\r\t\"should be > 1 for standard collection and = 1 for those that do not allow exact duplicates\"\r\tself assert: (result occurrencesOf: pivot) >= 1.\r\t "},{"name":"testNoneSatisfy","linesOfCode":5,"sourceCode":"testNoneSatisfy\r\r\t| element |\r\tself assert: ( self collectionWithoutNilElements  noneSatisfy: [:each | each notNil not ] ).\r\telement := self collectionWithoutNilElements anyOne.\r\tself deny: ( self collectionWithoutNilElements  noneSatisfy: [:each | (each = element)not ] )."},{"name":"testDo2","linesOfCode":20,"sourceCode":"testDo2\r\t\"dc: Bad test, it assumes that a new instance of #speciesClass allows addition with #add:. This is not the case of Interval for which species is Array.\"\r\t\"res := self speciesClass new.  \r\tself collection do: [:each | res add: each class].\r\tself assert: res = self result. \"\r\t| collection cptElementsViewed cptElementsIn |\r\tcollection := self collectionWithoutNilElements.\r\tcptElementsViewed := 0.\r\tcptElementsIn := OrderedCollection new.\r\tcollection do: \r\t\t[ :each | \r\t\tcptElementsViewed := cptElementsViewed + 1.\r\t\t\" #do doesn't iterate with the same objects than those in the collection for FloatArray( I don' t know why ) . That's why I use #includes: and not #identityIncludes:  '\"\r\t\t(collection includes: each) ifTrue: [\r\t\t\t\" the collection used doesn't include equal elements. Therefore each element viewed should not have been viewed before \"\r\t\t\t( cptElementsIn includes: each ) ifFalse: [ cptElementsIn add: each ] .\r\t\t\t]. \r\t\t].\r\tself assert: cptElementsViewed = collection size.\r\tself assert: cptElementsIn size  = collection size.\r\t\r\t"},{"name":"testSumNumbers","linesOfCode":5,"sourceCode":"testSumNumbers\r\t|result|\r\tresult:= self collectionWithoutNilElements \r\t\tsumNumbers: [ :ele | ele notNil ifTrue: [ 1 ] ifFalse: [ 0 ]].\r\t\r\tself assert: self collectionWithoutNilElements size = result"},{"name":"testCollectThenDoOnEmpty","linesOfCode":2,"sourceCode":"testCollectThenDoOnEmpty\r\tself assertEmpty: (self empty collect: [ :e | self fail ] thenDo: [ self fail ])"},{"name":"testRejectThenDo","linesOfCode":17,"sourceCode":"testRejectThenDo\r\r\t| result index rejectIndex |\r\t\r\tindex := 0.\r\trejectIndex := 0.\r\t\r\tresult := self collectionWithoutNilElements \r\t\treject: [ :each | \r\t\t\trejectIndex := rejectIndex + 1.\r\t\t\t\"reject the first element\"\r\t\t\trejectIndex = 1 ]\r\t\tthenDo: [ :each | \r\t\t\tself assert: each notNil.\r\t\t\tindex := index + 1]\t.\r\t\t\t\r\tself assert: result equals: self collectionWithoutNilElements.\r\tself assert: rejectIndex equals: self collectionWithoutNilElements size.\r\tself assert: index equals: self collectionWithoutNilElements size - 1.\r\t "},{"name":"testSelectNoneThenCollect","linesOfCode":4,"sourceCode":"testSelectNoneThenCollect\r\t| result |\r\tresult := self collectionWithoutNilElements select: [ :each | each isNil ] thenCollect: [ :each | self fail ].\r\r\tself assertEmpty: result"},{"name":"testSelect","linesOfCode":7,"sourceCode":"testSelect\r\r\t| result element |\r\tresult := self collectionWithoutNilElements select: [ :each | each notNil].\r\tself assert: result size equals: self collectionWithoutNilElements size.\r\t\r\telement := self collectionWithoutNilElements anyOne.\r\tresult := self collectionWithoutNilElements select: [ :each | (each = element) not].\r\tself assert: result size equals: (self collectionWithoutNilElements size - 1).\r\t"},{"name":"testBasicCollect","linesOfCode":10,"sourceCode":"testBasicCollect\r\r\t| res index |\r\tindex := 0.\r\tres := self collectionWithoutNilElements collect: [ :each | \r\t\tindex := index + 1.\r\t\teach ].\r\t\r\tres do: [ :each | \r\t\tself assert: (self collectionWithoutNilElements occurrencesOf: each) = (res occurrencesOf: each)].\r\tself assert: index equals: self collectionWithoutNilElements size.\r\t "},{"name":"testSelectOnEmpty","linesOfCode":2,"sourceCode":"testSelectOnEmpty\r\tself assertEmpty: (self empty select: [ :e | self fail ])"},{"name":"testDoSeparatedBy","linesOfCode":16,"sourceCode":"testDoSeparatedBy\r\t| string expectedString beforeFirst |\r\t\r\tstring := ''.\r\tself collectionWithoutNilElements  \r\t\tdo: [ :each | string := string , each asString ]\r\t\tseparatedBy: [ string := string , '|' ].\r\t\t\r\texpectedString := ''.\r\tbeforeFirst := true.\r\tself collectionWithoutNilElements  do: \r\t\t[ :each | \r\t\tbeforeFirst = true \r\t\t\tifTrue: [ beforeFirst := false ]\r\t\t\tifFalse: [ expectedString := expectedString , '|' ].\r\t\texpectedString := expectedString , each asString ].\r\tself assert: expectedString = string"},{"name":"testRejectThenDoOnEmpty","linesOfCode":2,"sourceCode":"testRejectThenDoOnEmpty\r\tself assertEmpty: (self empty reject: [ :e | self fail ] thenDo: [ self fail ])"},{"name":"testAnySastify","linesOfCode":9,"sourceCode":"testAnySastify\r\r\t| element |\r\t\" when all elements satisty the condition, should return true :\"\r\tself assert: ( self collectionWithoutNilElements anySatisfy: [:each | each notNil ]).\r\t\r\t\" when only one element satisfy the condition, should return true :\"\r\telement := self collectionWithoutNilElements anyOne.\r\tself assert: ( self collectionWithoutNilElements  anySatisfy: [:each | (each = element)  ]   ).\r\t\r\t\" when all elements don't satisty the condition, should return false :\"\r\tself deny: ( self collectionWithoutNilElements anySatisfy: [:each | (each notNil) not ]).\r"},{"name":"testSelectNoneThenDo","linesOfCode":6,"sourceCode":"testSelectNoneThenDo\r\t| result |\r\t\r\tresult := self collectionWithoutNilElements \r\t\tselect: [ :each | each isNil ] \r\t\tthenDo: [ self fail ].\r\t\r\tself assert: result equals: self collectionWithoutNilElements"},{"name":"testRejectThenCollect","linesOfCode":22,"sourceCode":"testRejectThenCollect\r\r\t| result index selectIndex pivot |\r\t\r\tindex := 0.\r\tselectIndex := 0.\r\tpivot := self collectionWithoutNilElements anyOne.\r\t\r\tresult := self collectionWithoutNilElements \r\t\treject: [ :each | \r\t\t\tselectIndex := selectIndex + 1.\r\t\t\t\"reject the first element\"\r\t\t\tselectIndex = 1 ]\r\t\tthenCollect: [ :each | \r\t\t\tself assert: each notNil.\r\t\t\tindex := index + 1.\r\t\t\tpivot ].\r\t\t\t\r\tself assert: result ~= self collectionWithoutNilElements.\r\tself assert: selectIndex equals: self collectionWithoutNilElements size.\r\tself assert: index equals: self collectionWithoutNilElements size - 1.\r\t\r\tself assert: (self collectionWithoutNilElements occurrencesOf: pivot) equals: 1.\r\t\"should be > 1 for standard collection and = 1 for those that do not allow exact duplicates\"\r\tself assert: (result occurrencesOf: pivot) >= 1.\r\t "},{"name":"testReject","linesOfCode":7,"sourceCode":"testReject\r\r\t| res element |\r\tres := self collectionWithoutNilElements reject: [:each | each notNil not].\r\tself assert: res size = self collectionWithoutNilElements size.\r\t\r\telement := self collectionWithoutNilElements anyOne.\r\tres := self collectionWithoutNilElements  reject: [:each | each = element].\r\tself assert: res size = (self collectionWithoutNilElements size - 1).\r\t\r\t\r\t"},{"name":"testCollectOnEmpty","linesOfCode":2,"sourceCode":"testCollectOnEmpty\r\tself assertEmpty: (self empty collect: [ :e | self fail ])"},{"name":"testSelectThenCollectOnEmpty","linesOfCode":2,"sourceCode":"testSelectThenCollectOnEmpty\r\tself assertEmpty: (self empty select: [ :e | self fail ] thenCollect: [ self fail ])"},{"name":"testRejectAllThenDo","linesOfCode":6,"sourceCode":"testRejectAllThenDo\r\t| result |\r\t\r\tresult := self collectionWithoutNilElements \r\t\treject: [ :each | each notNil ] \r\t\tthenDo: [ :each | self fail ].\r\t\r\tself assert: result equals: self collectionWithoutNilElements"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\tself explicitRequirement"}],"meta":{"name":"TIterateTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TSequencedConcatenationTest","instanceVariables":[],"methods":[{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement"},{"name":"testConcatenationWithEmpty","linesOfCode":9,"sourceCode":"testConcatenationWithEmpty\r\t| result |\r\tresult:= self empty,self secondCollection .\r\t\r\t1 to: self secondCollection size do:\r\t\t[:i | \r\t\tself assert: (self secondCollection at:i)= (result at:i).\r\t\t].\r\t\"size : \"\r\tself assert: result size = ( self secondCollection size)."},{"name":"testNewStreamContentsReturnsCollectionOfCorrectSize","linesOfCode":10,"sourceCode":"testNewStreamContentsReturnsCollectionOfCorrectSize\r\t| result item originalSize |\r\toriginalSize := 10.\r\titem := self firstCollection first.\r\tresult := self collectionClass\r\t\tnew: originalSize\r\t\tstreamContents: [ :stream | \r\t\t\t1 to: originalSize + 1 do: [ :each | stream nextPut: item ].\r\t\t\tstream position: originalSize ].\r\tself assert: result size equals: originalSize"},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\tself explicitRequirement"},{"name":"testConcatenation","linesOfCode":16,"sourceCode":"testConcatenation\r\t| result index |\r\tresult:= self firstCollection,self secondCollection .\r\t\"first part : \"\r\tindex := 1.\r\tself firstCollection do: \r\t\t[:each | \r\t\tself assert: (self firstCollection at: index)=each.\r\t\tindex := index+1.].\r\t\"second part : \"\r\t1 to: self secondCollection size do:\r\t\t[:i | \r\t\tself assert: (self secondCollection at:i)= (result at:index).\r\t\tindex:=index+1].\r\t\"size : \"\r\tself assert: result size = (self firstCollection size + self secondCollection size)."},{"name":"test0FixtureSequencedConcatenationTest","linesOfCode":5,"sourceCode":"test0FixtureSequencedConcatenationTest\r\tself empty.\r\tself assertEmpty: self empty.\r\tself firstCollection.\r\tself secondCollection"},{"name":"testStreamContentsSized","linesOfCode":12,"sourceCode":"testStreamContentsSized\r\t| result |\r\tresult:= self collectionClass new: 1 streamContents: [ :s|\r\t\ts \r\t\t\tnextPutAll: self firstCollection;\r\t\t\tnextPutAll: self secondCollection ].\r\tself assert: result equals: self firstCollection, self secondCollection.\r\t\r\tresult:= self collectionClass new: 1000 streamContents: [ :s|\r\t\ts \r\t\t\tnextPutAll: self firstCollection;\r\t\t\tnextPutAll: self secondCollection ].\r\tself assert: result equals: self firstCollection, self secondCollection."},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\tself explicitRequirement"},{"name":"testStreamContentsProtocol","linesOfCode":7,"sourceCode":"testStreamContentsProtocol\r\t| result |\r\tresult:= self collectionClass << [ :s|\r\t\ts \r\t\t\tnextPutAll: self firstCollection;\r\t\t\tnextPutAll: self secondCollection ].\r\tself assert: result equals: self firstCollection, self secondCollection."},{"name":"testStreamContents","linesOfCode":7,"sourceCode":"testStreamContents\r\t| result |\r\tresult:= self collectionClass streamContents: [ :s|\r\t\ts \r\t\t\tnextPutAll: self firstCollection;\r\t\t\tnextPutAll: self secondCollection ].\r\tself assert: result equals: self firstCollection, self secondCollection."}],"meta":{"name":"TSequencedConcatenationTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TAsStringCommaAndDelimiterSequenceableTest","instanceVariables":[],"methods":[{"name":"testAsCommaStringOne","linesOfCode":5,"sourceCode":"testAsCommaStringOne\r\t\r\t\"self assert: self oneItemCol asCommaString = '1'.\r\tself assert: self oneItemCol asCommaStringAnd = '1'.\"\r\r\tself assert: self nonEmpty1Element asCommaString = (self nonEmpty1Element first asString).\r\tself assert: self nonEmpty1Element asCommaStringAnd = (self nonEmpty1Element first asString)\r\t"},{"name":"testAsStringOnDelimiterEmpty","linesOfCode":2,"sourceCode":"testAsStringOnDelimiterEmpty\r\r\tself assert: (String streamContents: [ :emptyStream | self empty asStringOn: emptyStream delimiter: ', ' ]) equals: ''"},{"name":"nonEmpty1Element","linesOfCode":3,"sourceCode":"nonEmpty1Element\r\" return a collection of size 1 including one element\"\r\t^ self explicitRequirement "},{"name":"testAsCommaStringMore","linesOfCode":33,"sourceCode":"testAsCommaStringMore\r\r\t\"self assert: self oneTwoThreeItemCol asCommaString = '1, 2, 3'.\r\tself assert: self oneTwoThreeItemCol asCommaStringAnd = '1, 2 and 3'\"\r\r\t| result resultAnd index allElementsAsString |\r\tresult:= self nonEmpty asCommaString .\r\tresultAnd:= self nonEmpty asCommaStringAnd .\r \r\tindex := 1.\r\t(result findBetweenSubstrings: ',' )do:\r\t\t[:each |\r\t\tindex = 1\r\t\t\tifTrue: [self assert: each= ((self nonEmpty at:index)asString)]\r\t\t\tifFalse: [self assert: each= (' ',(self nonEmpty at:index) asString)].\r\t\tindex:=index+1\r\t\t].\r\t\r\t\"verifying esultAnd :\"\r\tallElementsAsString:=(resultAnd findBetweenSubstrings: ',' ).\r\t1 to: allElementsAsString size do:\r\t\t[:i | \r\t\ti<(allElementsAsString size )\r\t\t\tifTrue: [\r\t\t\ti = 1\r\t\t\t\tifTrue:[self assert: (allElementsAsString at:i)=((self nonEmpty at:i) asString)]\r\t\t\t\tifFalse:[self assert: (allElementsAsString at:i)=(' ',(self nonEmpty at:i) asString)]\r\t\t\t\t].\r\t\ti=(allElementsAsString size)\r\t\t\tifTrue:[ \r\t\t\ti = 1\r\t\t\t\tifTrue:[self assert: (allElementsAsString at:i)=( (self nonEmpty at:i ) asString ,' and ', (self nonEmpty at: ( i + 1) ) asString )]\r\t\t\t\tifFalse:[self assert: (allElementsAsString at:i)=( ' ' , (self nonEmpty at:i ) asString ,' and ', (self nonEmpty at: ( i + 1) ) asString )]\r\t\t\t\t].\r\t\t\r\t\t\r\t\t\t]."},{"name":"test0FixtureAsStringCommaAndDelimiterTest","linesOfCode":7,"sourceCode":"test0FixtureAsStringCommaAndDelimiterTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself empty.\r\tself assertEmpty: self empty.\r\tself nonEmpty1Element.\r\tself assert: self nonEmpty1Element size = 1"},{"name":"testAsStringOnDelimiterOne","linesOfCode":7,"sourceCode":"testAsStringOnDelimiterOne\r\r\t| delim oneItemStream result |\r\tdelim := ', '.\r\tresult := ''.\r\toneItemStream := ReadWriteStream on: result.\r\tself nonEmpty1Element  asStringOn: oneItemStream delimiter: delim.\r\toneItemStream do:[:each | self assert: each = (self nonEmpty1Element first asString)]\r\t\r\r\t"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ self explicitRequirement "},{"name":"testAsStringOnDelimiterLastEmpty","linesOfCode":2,"sourceCode":"testAsStringOnDelimiterLastEmpty\r\r\tself assert: (String streamContents: [ :emptyStream | self empty asStringOn: emptyStream delimiter: ', ' last: 'and' ]) equals: ''"},{"name":"testAsStringOnDelimiterLastOne","linesOfCode":7,"sourceCode":"testAsStringOnDelimiterLastOne\r\r\t| delim oneItemStream result |\t\r\tdelim := ', '.\r\tresult:=''.\r\toneItemStream := ReadWriteStream on: result.\r\tself nonEmpty1Element  asStringOn: oneItemStream delimiter: delim last: 'and'.\r\toneItemStream do:[:each | self assert: each = (self nonEmpty1Element first asString)]\r\t\r\r\t"},{"name":"testAsCommaStringEmpty","linesOfCode":3,"sourceCode":"testAsCommaStringEmpty\r\r\tself assert: self empty asCommaString = ''.\r\tself assert: self empty asCommaStringAnd = ''\r\t\r"},{"name":"testAsStringOnDelimiterMore","linesOfCode":12,"sourceCode":"testAsStringOnDelimiterMore\r\r\t| delim multiItemStream result index |\r\tdelim := ', '.\r\tresult := ''.\r\tmultiItemStream := ReadWriteStream on: result.\r\tself nonEmpty  asStringOn: multiItemStream delimiter: delim.\r\tresult := multiItemStream contents.\r\tindex:=1.\r\t(result findBetweenSubstrings: delim)do:\r\t\t[:each |\r\t\t\tself assert: each= ((self nonEmpty at:index) asString).\r\t\t\tindex:=index+1 ]"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ self explicitRequirement "},{"name":"testAsStringOnDelimiterLastMore","linesOfCode":17,"sourceCode":"testAsStringOnDelimiterLastMore\r\r\t| delim multiItemStream result last allElementsAsString |\r\t\r\tdelim := ', '.\r\tlast := ' and '.\r\tresult:=''.\r\tmultiItemStream := ReadWriteStream on:result.\r\tself nonEmpty  asStringOn: multiItemStream delimiter: delim last: last.\r\tresult := multiItemStream contents.\r\tallElementsAsString:=(result findBetweenSubstrings: delim ).\r\t1 to: allElementsAsString size do:\r\t\t[:i | \r\t\ti<(allElementsAsString size-1 )\r\t\t\tifTrue: [self assert: (allElementsAsString at:i)=((self nonEmpty at:i)asString)].\r\t\ti=(allElementsAsString size-1)\r\t\t\tifTrue:[ self deny: (allElementsAsString at:i)=(last)asString].\r\t\ti=(allElementsAsString size)\r\t\t\tifTrue: [self assert: (allElementsAsString at:i)=((self nonEmpty at:(i-1))asString)]]\r"}],"meta":{"name":"TAsStringCommaAndDelimiterSequenceableTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCreationWithTest","instanceVariables":[],"methods":[{"name":"testOfSize","linesOfCode":4,"sourceCode":"testOfSize\r\t\r\t| aCol |\r\taCol := self collectionClass ofSize: 3.\r\tself assert: aCol size equals: 3.\r"},{"name":"testWithWith","linesOfCode":8,"sourceCode":"testWithWith\r\t\r\t| aCol collection element1 element2 |\r\tcollection := self collectionMoreThan5Elements asOrderedCollection copyFrom: 1 to: 2.\r\telement1 := collection at: 1.\r\telement2 := collection at: 2.\r\t\r\taCol := self collectionClass with: element1  with: element2 .\r\tself assert: (aCol occurrencesOf: element1 ) equals: (collection occurrencesOf: element1).\r\tself assert: (aCol occurrencesOf: element2 ) equals: (collection occurrencesOf: element2) \r\t\r\t"},{"name":"testWithWithWithWith","linesOfCode":5,"sourceCode":"testWithWithWithWith\r\t\r\t| aCol collection |\r\tcollection := self collectionMoreThan5Elements asOrderedCollection copyFrom: 1 to: 4.\r\taCol := self collectionClass with: (collection at:1) with: (collection at:2) with: (collection at: 3) with: (collection at: 4).\r\r\t1 to: 3 do: [ :i | self assert: (aCol occurrencesOf: (collection at: i)) equals: (collection occurrencesOf: (collection at: i)) ]"},{"name":"collectionClass","linesOfCode":3,"sourceCode":"collectionClass \r\t\"Return the class to be used to create instances of the class tested\"\r\t\r\t^ self explicitRequirement"},{"name":"testWithWithWith","linesOfCode":9,"sourceCode":"testWithWithWith\r\t\r\t| aCol collection |\r\tcollection := self collectionMoreThan5Elements asOrderedCollection copyFrom:1 to: 3 .\r\taCol := self collectionClass \r\t\t\t\t\t\twith: (collection at: 1) \r\t\t\t\t\t\twith: (collection at: 2) \r\t\t\t\t\t\twith: (collection at: 3).\r\r\t1 to: 3 do: [ :i | \r\t\tself assert: (aCol occurrencesOf: (collection at: i)) equals: (collection occurrencesOf: (collection at: i)) ]"},{"name":"testWith","linesOfCode":5,"sourceCode":"testWith\r\t\r\t| aCol anElement |\r\tanElement := self collectionMoreThan5Elements anyOne.\r\taCol := self collectionClass with: anElement.\r\tself assert: (aCol includes: anElement)."},{"name":"test0FixtureCreationWithTest","linesOfCode":3,"sourceCode":"test0FixtureCreationWithTest\r\r\tself collectionMoreThan5Elements.\r\tself assert: self collectionMoreThan5Elements size >= 5"},{"name":"testWithAll","linesOfCode":6,"sourceCode":"testWithAll\r\r\t| aCol collection |\r\tcollection := self collectionMoreThan5Elements asOrderedCollection.\r\taCol := self collectionClass withAll: collection.\r\t\r\tcollection do: [ :each | self assert: (aCol occurrencesOf: each ) equals: ( collection occurrencesOf: each ) ].\r\t\r\tself assert: aCol size equals: collection size"},{"name":"testWithWithWithWithWith","linesOfCode":10,"sourceCode":"testWithWithWithWithWith\r\t\r\t| aCol collection |\r\tcollection := self collectionMoreThan5Elements asOrderedCollection copyFrom: 1 to: 5.\r\taCol := self collectionClass \r\t\t\t\t\t\twith: (collection at: 1) \r\t\t\t\t\t\twith: (collection at: 2) \r\t\t\t\t\t\twith: (collection at: 3) \r\t\t\t\t\t\twith: (collection at: 4) \r\t\t\t\t\t\twith: (collection at: 5).\r\r\t1 to: 3 do: [ :i | self assert: (aCol occurrencesOf: (collection at: i)) equals: (collection occurrencesOf: (collection at: i)) ]"},{"name":"collectionMoreThan5Elements","linesOfCode":3,"sourceCode":"collectionMoreThan5Elements\r\" return a collection including at least 5 elements\"\r\t\r\t^ self explicitRequirement"}],"meta":{"name":"TCreationWithTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TGrowableTest","instanceVariables":[],"methods":[{"name":"test0FixtureRequirementsOfTGrowableTest","linesOfCode":9,"sourceCode":"test0FixtureRequirementsOfTGrowableTest\r\tself empty.\r\tself nonEmpty.\r\tself element.\r\tself elementNotIn.\r\tself assertEmpty: self empty.\r\tself denyEmpty: self nonEmpty.\r\tself assert: (self nonEmpty includes: self element).\r\tself deny: (self nonEmpty includes: self elementNotIn)"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty \r\r\t^ self explicitRequirement"},{"name":"element","linesOfCode":2,"sourceCode":"element\r\r\t^ self explicitRequirement "},{"name":"testAddEmptyGrows","linesOfCode":5,"sourceCode":"testAddEmptyGrows\r\t\r\t| oldSize |\r\toldSize := self empty size.\r\tself empty add: self element.\r\tself assert: (self empty size) = (oldSize + 1)."},{"name":"elementNotIn","linesOfCode":2,"sourceCode":"elementNotIn\r\t\r\t^ self explicitRequirement"},{"name":"testAddNonEmptyGrowsWhenNewElement","linesOfCode":5,"sourceCode":"testAddNonEmptyGrowsWhenNewElement\r\t\r\t| oldSize |\r\toldSize := self nonEmpty size.\r\t\r\tself nonEmpty add: self elementNotIn.\r\tself assert: (self nonEmpty size) > oldSize."},{"name":"empty","linesOfCode":2,"sourceCode":"empty \r\r\t^ self explicitRequirement"}],"meta":{"name":"TGrowableTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TPutTest","instanceVariables":[],"methods":[{"name":"testAtLastPut","linesOfCode":5,"sourceCode":"testAtLastPut\r\r\t| index |\r\tindex := self indexArray anyOne.\t\r\tself nonEmpty atLast: index put: self aValue.\t\r\r\tself assert: (self nonEmpty at: (self nonEmpty size + 1 - index)) equals: self aValue"},{"name":"valueArray","linesOfCode":9,"sourceCode":"valueArray\r\" return a collection (with the same size than 'indexArray' )of values to be put in 'nonEmpty'  at indexes in 'indexArray' \"\r\t| result |\r\tresult := Array new: self indexArray size.\r\t1 to: result size do:\r\t\t[:i |\r\t\tresult at:i put: (self aValue ).\r\t\t].\r\t^ result."},{"name":"testAtWrapPut","linesOfCode":12,"sourceCode":"testAtWrapPut\r\t \r\t| index |\r\tindex := self indexArray anyOne.\r\t\r\tself nonEmpty atWrap: 0 put: self aValue.\r\tself assert: self nonEmpty last equals: self aValue.\r\t\r\tself nonEmpty atWrap: (self nonEmpty size + 1) put: self aValue.\r\tself assert: self nonEmpty first equals: self aValue.\r\t\r\tself nonEmpty atWrap: index put: self aValue.\r\tself assert: (self nonEmpty at: index) equals: self aValue.\r\t\r\tself nonEmpty atWrap: (self nonEmpty size + index) put: self aValue .\r\tself assert: (self nonEmpty at: index) equals: self aValue."},{"name":"testAtAllPut","linesOfCode":4,"sourceCode":"testAtAllPut\r \r\tself nonEmpty atAll: self indexArray put: self aValue.\r\t\r\tself indexArray do:\r\t\t[:i | self assert: (self nonEmpty at: i) equals: self aValue ]\r\t"},{"name":"test0FixturePutOneOrMoreElementsTest","linesOfCode":12,"sourceCode":"test0FixturePutOneOrMoreElementsTest\r\tself aValue.\r\r\r\tself indexArray.\r\tself indexArray\r\t\tdo: [ :each | \r\t\t\tself assert: each class = SmallInteger.\r\t\t\tself assert: (each >= 1 & each) <= self nonEmpty size ].\r\r\tself assert: self indexArray size = self valueArray size.\r\r\tself empty.\r\tself assertEmpty: self empty.\r\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ self explicitRequirement"},{"name":"indexArray","linesOfCode":3,"sourceCode":"indexArray\r\" return a Collection including indexes between bounds of 'nonEmpty' \"\r\r\tself explicitRequirement."},{"name":"testSwapWith","linesOfCode":7,"sourceCode":"testSwapWith\r \r\t| result index |\r\tindex := self indexArray anyOne.\r\tresult:= self nonEmpty copy .\r\tresult swap: index with: 1.\r\tself assert: (result at: index) = (self nonEmpty at:1).\r\tself assert: (result at: 1) = (self nonEmpty at: index).\r\t"},{"name":"testFromToPut","linesOfCode":9,"sourceCode":"testFromToPut\r\t\r\t| collection index |\r\tindex := self indexArray anyOne.\r\tcollection := self nonEmpty copy.\r\tcollection from: 1 to: index  put: self aValue..\r\t1 to: index do:\r\t\t[:i | self assert: (collection at: i)= self aValue].\r\t(index +1) to: collection size do:\r\t\t[:i | self assert: (collection at:i)= (self nonEmpty at:i)]."},{"name":"testAtAllPutAll","linesOfCode":6,"sourceCode":"testAtAllPutAll\r\r\t| aValueArray |\r\taValueArray := self valueArray .\r\tself nonEmpty atAll: self indexArray putAll: aValueArray  .\r\t\r\tself indexArray withIndexDo: [:element :index |\r\t\tself assert: (self nonEmpty at: element) equals: (aValueArray  at: index) ]"},{"name":"testAtAllIndexesPut","linesOfCode":3,"sourceCode":"testAtAllIndexesPut\r\t\r\tself nonEmpty atAllPut: self aValue.\r\tself nonEmpty do:[ :each| self assert: each = self aValue].\r\t"},{"name":"aValue","linesOfCode":3,"sourceCode":"aValue\r\" return a value to put into nonEmpty\"\r\t^ self explicitRequirement"}],"meta":{"name":"TPutTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TConcatenationTest","instanceVariables":[],"methods":[{"name":"testConcatenationWithEmpty","linesOfCode":4,"sourceCode":"testConcatenationWithEmpty\r\t| result |\r\tresult := self firstCollection , self empty.\r\tself assert: result = self firstCollection"},{"name":"testConcatenationWithDuplicate","linesOfCode":7,"sourceCode":"testConcatenationWithDuplicate\r\r\r| collection1 collection2 result |\rcollection1 := self firstCollection .\rcollection2 := self firstCollection .\rresult := collection1 , collection2.\r\rresult do: [ :each | self assert: (result occurrencesOf: each) = (( collection1 occurrencesOf: each ) + ( collection2 occurrencesOf: each ) ). ].\rself assert: result size = (collection1 size * 2)"},{"name":"firstCollection","linesOfCode":3,"sourceCode":"firstCollection\r\" return a collection that will be the first part of the concatenation\"\r\tself explicitRequirement"},{"name":"testConcatenation","linesOfCode":13,"sourceCode":"testConcatenation\r\r\"| collection1 collection2 result |\rcollection1 := self firstCollection .\rcollection2 := self secondCollection .\rresult := collection1 , collection2.\r\rcollection1 do:[ :each | self assert: (result includes: each)].\rcollection2 do:[ :each | self assert: (result includes: each)].\"\r\r| collection1 collection2 result |\rcollection1 := self firstCollection .\rcollection2 := self secondCollection .\rresult := collection1 , collection2.\r\rresult do: [ :each | self assert: (result occurrencesOf: each) = (( collection1 occurrencesOf: each ) + ( collection2 occurrencesOf: each ) ). ].\rself assert: result size = (collection1 size + collection2 size)"},{"name":"secondCollection","linesOfCode":3,"sourceCode":"secondCollection\r\" return a collection that will be the second part of the concatenation\"\r\tself explicitRequirement"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement."},{"name":"test0FixtureConcatenationTest","linesOfCode":7,"sourceCode":"test0FixtureConcatenationTest\r\tself firstCollection.\r\tself denyEmpty: self firstCollection.\r\tself firstCollection.\r\tself denyEmpty: self firstCollection.\r\tself empty.\r\tself assertEmpty: self empty"}],"meta":{"name":"TConcatenationTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCloneTest","instanceVariables":[],"methods":[{"name":"testCopyCreatesNewObject","linesOfCode":5,"sourceCode":"testCopyCreatesNewObject\r\t \r\t\r\t| copy | \r\tcopy := self nonEmpty copy.\r\tself deny: self nonEmpty == copy.\r\t"},{"name":"testCopyEmpty","linesOfCode":2,"sourceCode":"testCopyEmpty\r\tself assertEmpty: self empty copy"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\t^ self explicitRequirement"},{"name":"testCopyNonEmpty","linesOfCode":6,"sourceCode":"testCopyNonEmpty\r\t| copy |\r\tcopy := self nonEmpty copy.\r\tself denyEmpty: copy.\r\tself assert: copy size = self nonEmpty size.\r\tself nonEmpty do: [ :each | copy includes: each ]"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\r\t^ self explicitRequirement"},{"name":"test0FixtureCloneTest","linesOfCode":5,"sourceCode":"test0FixtureCloneTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself empty.\r\tself assertEmpty: self empty"}],"meta":{"name":"TCloneTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TOccurrencesTest","instanceVariables":[],"methods":[{"name":"testOccurrencesOfEmpty","linesOfCode":4,"sourceCode":"testOccurrencesOfEmpty\r\t| result |\r\tresult := self empty occurrencesOf: self collectionWithoutEqualElements anyOne.\r\tself assert: result equals: 0"},{"name":"elementNotInForOccurrences","linesOfCode":3,"sourceCode":"elementNotInForOccurrences\r\" return an element notIncluded in #collectionWithoutEqualElements\"\r\tself explicitRequirement"},{"name":"test0FixtureOccurrencesTest","linesOfCode":13,"sourceCode":"test0FixtureOccurrencesTest\r\t| tmp |\r\tself empty.\r\tself assertEmpty: self empty.\r\tself collectionWithoutEqualElements.\r\tself denyEmpty: self collectionWithoutEqualElements.\r\ttmp := OrderedCollection new.\r\tself collectionWithoutEqualElements\r\t\tdo: [ :each | \r\t\t\tself deny: (tmp includes: each).\r\t\t\ttmp add: each ].\r\tself elementNotInForOccurrences.\r\tself deny: (self collectionWithoutEqualElements includes: self elementNotInForOccurrences)"},{"name":"collectionWithoutEqualElements","linesOfCode":2,"sourceCode":"collectionWithoutEqualElements\r\tself explicitRequirement"},{"name":"testOccurrencesOfNotIn","linesOfCode":4,"sourceCode":"testOccurrencesOfNotIn\r\r\t| result |\r\tresult := self collectionWithoutEqualElements occurrencesOf: self elementNotInForOccurrences.\r\tself assert: result equals: 0"},{"name":"testOccurrencesOf","linesOfCode":4,"sourceCode":"testOccurrencesOf\r\t| collection |\r\tcollection := self collectionWithoutEqualElements .\r\t\r\tcollection do: [ :each | self assert: (collection occurrencesOf: each) equals: 1 ]"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement"}],"meta":{"name":"TOccurrencesTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopySequenceableWithReplacementForSorted","instanceVariables":[],"methods":[{"name":"testCopyReplaceAllWithForSorted","linesOfCode":10,"sourceCode":"testCopyReplaceAllWithForSorted\r\t| collection result |\r\tcollection := self collectionOfSize5.\r\r\t\"Testing that elements to be replaced are removed from the copy :\"\r\tresult := collection copyReplaceAll: collection with: self empty.\r\tself assertEmpty: result.\r\r\t\"Testing that replacement elements  are all put into the copy :\"\r\tresult := collection copyReplaceAll: collection with: self replacementCollection.\r\tself replacementCollection do: [ :each | self assert: (result occurrencesOf: each) equals: (self replacementCollection occurrencesOf: each) ].\r\r\tself assert: result size equals: self replacementCollection size"},{"name":"test0FixtureCopyWithReplacementForSorted","linesOfCode":7,"sourceCode":"test0FixtureCopyWithReplacementForSorted\r\tself collectionOfSize5.\r\tself assert: self collectionOfSize5 size = 5.\r\tself replacementCollection.\r\tself denyEmpty: self replacementCollection.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"replacementCollection","linesOfCode":3,"sourceCode":"replacementCollection\r\" return a collection including elements of type 'collectionOfSize5' elements'type\"\rself explicitRequirement"},{"name":"testCopyFromToWithForSorted","linesOfCode":10,"sourceCode":"testCopyFromToWithForSorted\r\t| collection result |\r\tcollection := self collectionOfSize5.\r\r\t\"Testing that elements to be replaced are removed from the copy :\"\r\tresult := collection copyReplaceFrom: 1 to: collection size with: self empty.\r\tself assertEmpty: result.\r\r\t\"Testing that replacement elements  are all put into the copy :\"\r\tresult := collection copyReplaceFrom: 1 to: collection size with: self replacementCollection.\r\tself replacementCollection do: [ :each | self assert: (result occurrencesOf: each) equals: (self replacementCollection occurrencesOf: each) ].\r\r\tself assert: result size equals: self replacementCollection size"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\rself explicitRequirement."},{"name":"collectionOfSize5","linesOfCode":3,"sourceCode":"collectionOfSize5\r\" return a collection of size 5\"\rself explicitRequirement"}],"meta":{"name":"TCopySequenceableWithReplacementForSorted classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIndexAccessForMultipliness","instanceVariables":[],"methods":[{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals .\r(others elements of the collection are not equal to those elements)\"\r\tself explicitRequirement"},{"name":"testIdentityIndexOfIAbsentDuplicate","linesOfCode":12,"sourceCode":"testIdentityIndexOfIAbsentDuplicate\r\r\t| collection element elementCopy |\r\tcollection := self collectionWithNonIdentitySameAtEndAndBegining.\r\telement := collection last.\r\telementCopy := element copy.\r\tself deny: element == elementCopy.\r\tself assert: (collection \r\t\t\tidentityIndexOf: element\r\t\t\tifAbsent: [ 0 ]) equals: collection size.\r\tself assert: (collection \r\t\t\tidentityIndexOf: elementCopy\r\t\t\tifAbsent: [ 55 ]) equals: 55"},{"name":"collectionWithNonIdentitySameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithNonIdentitySameAtEndAndBegining\r\t\" return a collection with elements at end and begining equals only with classic equality (they are not the same object).\r(others elements of the collection are not equal to those elements)\"\r\tself explicitRequirement"},{"name":"test0FixtureIndexAccessFotMultipliness","linesOfCode":7,"sourceCode":"test0FixtureIndexAccessFotMultipliness\r\r\tself collectionWithSameAtEndAndBegining.\r\tself assert: self collectionWithSameAtEndAndBegining first = self collectionWithSameAtEndAndBegining last.\r\tself assert: self collectionWithSameAtEndAndBegining size > 1.\r\t1 to: self collectionWithSameAtEndAndBegining size do: [ :i | \r\t\ti > 1 & (i < self collectionWithSameAtEndAndBegining size)\r\t\t\tifTrue: [ self deny: (self collectionWithSameAtEndAndBegining at: i) = self collectionWithSameAtEndAndBegining first ] ]"},{"name":"testIdentityIndexOfDuplicate","linesOfCode":12,"sourceCode":"testIdentityIndexOfDuplicate\r\r\t| collection element |\r\t\"testing fixture here as this method may not be used by some collections testClass\"\r\tself collectionWithNonIdentitySameAtEndAndBegining.\r\tcollection := self collectionWithNonIdentitySameAtEndAndBegining.\r\tself assert: collection first equals: collection last.\r\tself deny: collection first == collection last.\r\tcollection withIndexDo: [:el :i | \r\t\ti > 1 & (i < collection size)\r\t\t\tifTrue: [ self deny: (collection at: i) = collection first ] ].\r\telement := collection last.\t\" floatCollectionWithSameAtEndAndBegining first and last elements are equals but are not the same object\"\r\tself assert: (collection identityIndexOf: element) equals: collection size"},{"name":"testIndexOfDuplicate","linesOfCode":7,"sourceCode":"testIndexOfDuplicate\r\r\t| collection element |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection last.\r\r\t\" floatCollectionWithSameAtEndAndBegining first and last elements are equals \r\t'indexOf: should return the position of the first occurrence :'\"\r\tself assert: (collection indexOf: element) equals: 1"},{"name":"testLastIndexOfStartingAtDuplicate","linesOfCode":14,"sourceCode":"testLastIndexOfStartingAtDuplicate\r\r\t| collection element |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection last.\r\r\t\" floatCollectionWithSameAtEndAndBegining first and last elements are equals \r\t'lastIndexOf:ifAbsent:startingAt: should return the position of the last occurrence :'\"\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tstartingAt: collection size\r\t\t\tifAbsent: [ 55 ]) equals: collection size.\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tstartingAt: collection size - 1\r\t\t\tifAbsent: [ 55 ]) equals: 1"},{"name":"testLastIndexOfIfAbsentDuplicate","linesOfCode":9,"sourceCode":"testLastIndexOfIfAbsentDuplicate\r\r\t| collection element |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection first.\r\r\t\"floatCollectionWithSameAtEndAndBegining first and last elements are equals \r\t'lastIndexOf: should return the position of the last occurrence :'\"\r\tself assert: (collection \r\t\t\tlastIndexOf: element\r\t\t\tifAbsent: [ 55 ]) equals: collection size"},{"name":"testLastIndexOfDuplicate","linesOfCode":7,"sourceCode":"testLastIndexOfDuplicate\r\r\t| collection element |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection first.\r\r\t\" floatCollectionWithSameAtEndAndBegining first and last elements are equals \r\t'lastIndexOf: should return the position of the last occurrence :'\"\r\tself assert: (collection lastIndexOf: element) equals: collection size"},{"name":"testIndexOfStartingAtDuplicate","linesOfCode":14,"sourceCode":"testIndexOfStartingAtDuplicate\r\r\t| collection element |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection last.\r\r\t\"floatCollectionWithSameAtEndAndBegining first and last elements are equals \r\t'indexOf:ifAbsent:startingAt:' should return the position of the first occurrence\"\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 1\r\t\t\tifAbsent: [ 55 ]) equals: 1.\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tstartingAt: 2\r\t\t\tifAbsent: [ 55 ]) equals: collection size"},{"name":"testIndexOfIfAbsentDuplicate","linesOfCode":9,"sourceCode":"testIndexOfIfAbsentDuplicate\r\r\t| collection element |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection last.\r\r\t\" floatCollectionWithSameAtEndAndBegining first and last elements are equals \r\t'indexOf:ifAbsent: should return the position of the first occurrence :'\"\r\tself assert: (collection \r\t\t\tindexOf: element\r\t\t\tifAbsent: [ 55 ]) equals: 1"}],"meta":{"name":"TIndexAccessForMultipliness classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TSubCollectionAccess","instanceVariables":[],"methods":[{"name":"testLastNElements","linesOfCode":8,"sourceCode":"testLastNElements\r\r\t| result |\r\tresult := self moreThan3Elements last: self moreThan3Elements size - 1.\r\tresult withIndexDo: [:el :i | self assert: el equals: (self moreThan3Elements at: i + 1) ].\r\tself assert: result size equals: (self moreThan3Elements size - 1).\r\tself \r\t\tshould: [ self moreThan3Elements last: self moreThan3Elements size + 1 ]\r\t\traise: Error"},{"name":"moreThan3Elements","linesOfCode":3,"sourceCode":"moreThan3Elements\r\t\" return a collection including atLeast 3 elements\"\r\tself explicitRequirement"},{"name":"testFirstNElements","linesOfCode":6,"sourceCode":"testFirstNElements\r\r\t| result |\r\tresult := self moreThan3Elements first: self moreThan3Elements size - 1.\r\tresult withIndexDo: [:el :i | self assert: el equals: (self moreThan3Elements at: i) ].\r\t\r\tself assert: result size equals: (self moreThan3Elements size - 1).\r\tself should: [ self moreThan3Elements first: self moreThan3Elements size + 1 ] raise: SubscriptOutOfBounds"},{"name":"testAllButFirst","linesOfCode":6,"sourceCode":"testAllButFirst\r\r\t| abf col |\r\tcol := self moreThan3Elements.\r\tabf := col allButFirst.\r\tself deny: abf first = col first.\r\tself assert: abf size + 1 = col size"},{"name":"testAllButLastNElements","linesOfCode":6,"sourceCode":"testAllButLastNElements\r\r\t| allButLast collection |\r\tcollection := self moreThan3Elements.\r\tallButLast := collection allButLast: 2.\r\tallButLast withIndexDo: [:el :i | self assert: el equals: (collection at: i) ].\r\tself assert: allButLast size + 2 equals: collection size"},{"name":"testAllButLast","linesOfCode":6,"sourceCode":"testAllButLast\r\r\t| abf col |\r\tcol := self moreThan3Elements.\r\tabf := col allButLast.\r\tself deny: abf last = col last.\r\tself assert: abf size + 1 equals: col size"},{"name":"testAllButFirstNElements","linesOfCode":7,"sourceCode":"testAllButFirstNElements\r\r\t| allButFirst collection |\r\tcollection := self moreThan3Elements.\r\tallButFirst := collection allButFirst: 2.\r\tallButFirst withIndexDo: \r\t\t [:el :i | self assert: el equals: (collection at: i + 2) ].\r\tself assert: allButFirst size + 2 equals: collection size"},{"name":"test0FixtureSubcollectionAccessTest","linesOfCode":3,"sourceCode":"test0FixtureSubcollectionAccessTest\r\r\tself moreThan3Elements.\r\tself assert: self moreThan3Elements size > 2"}],"meta":{"name":"TSubCollectionAccess classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TConvertAsSetForMultiplinessTest","instanceVariables":[],"methods":[{"name":"testAsSetWithEqualsElements","linesOfCode":5,"sourceCode":"testAsSetWithEqualsElements\r\t| result |\r\tresult := self withEqualElements asSet.\r\tself withEqualElements do: [ :each | self assert: (result occurrencesOf: each) = 1 ].\r\tself assert: result class = Set"},{"name":"test0FixtureTConvertAsSetForMultiplinessTest","linesOfCode":7,"sourceCode":"test0FixtureTConvertAsSetForMultiplinessTest\r\t\"a collection  with equal elements:\"\r\r\t| res |\r\tself withEqualElements.\r\tres := true.\r\tself withEqualElements detect: [ :each | (self withEqualElements occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself assert: res = true"},{"name":"testAsIdentitySetWithEqualsElements","linesOfCode":6,"sourceCode":"testAsIdentitySetWithEqualsElements\r\t| result collection |\r\tcollection := self withEqualElements .\r\tresult := collection asIdentitySet.\r\tcollection do: [ :each | self assert: (result occurrencesOf: each) = 1 ].\r\tself assert: result class = IdentitySet."},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\" return a collection  including equal elements (classic equality)\"\r\t^ self explicitRequirement"}],"meta":{"name":"TConvertAsSetForMultiplinessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TSequencedStructuralEqualityTest","instanceVariables":[],"methods":[{"name":"testEqualSignIsTrueForEmptyButNonIdenticalCollections","linesOfCode":5,"sourceCode":"testEqualSignIsTrueForEmptyButNonIdenticalCollections\r\t\r\tself assert: self empty equals: self empty copy. \r\tself assert: self empty copy equals: self empty.\r\tself assert: self empty copy equals: self empty copy\r\t\t\r"},{"name":"testEqualSignForSequenceableCollections","linesOfCode":4,"sourceCode":"testEqualSignForSequenceableCollections\r\r\tself deny: (self nonEmpty = self nonEmpty asSet). \r\tself deny: (self nonEmpty reversed = self nonEmpty).\r\tself deny: (self nonEmpty = self nonEmpty reversed)"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r\t^ self explicitRequirement"},{"name":"test0TStructuralEqualityTest","linesOfCode":5,"sourceCode":"test0TStructuralEqualityTest\r\tself empty.\r\tself nonEmpty.\r\tself assertEmpty: self empty.\r\tself denyEmpty: self nonEmpty"},{"name":"testEqualSign","linesOfCode":2,"sourceCode":"testEqualSign\r \r\tself deny: (self empty = self nonEmpty)"},{"name":"testHasEqualElementsIsTrueForNonIdenticalButEqualCollections","linesOfCode":9,"sourceCode":"testHasEqualElementsIsTrueForNonIdenticalButEqualCollections\r\t\t\r\tself assert: (self empty hasEqualElements: self empty copy). \r\tself assert: (self empty copy hasEqualElements: self empty).\r\tself assert: (self empty copy hasEqualElements: self empty copy).\r\t\t\r\tself assert: (self nonEmpty hasEqualElements: self nonEmpty copy). \r\tself assert: (self nonEmpty copy hasEqualElements: self nonEmpty).\r\tself assert: (self nonEmpty copy hasEqualElements: self nonEmpty copy) "},{"name":"testHasEqualElementsOfIdenticalCollectionObjects","linesOfCode":3,"sourceCode":"testHasEqualElementsOfIdenticalCollectionObjects\r\t\r\tself assert: (self empty hasEqualElements: self empty). \r\tself assert: (self nonEmpty hasEqualElements: self nonEmpty)\r\t"},{"name":"test0TSequencedStructuralEqualityTest","linesOfCode":2,"sourceCode":"test0TSequencedStructuralEqualityTest\r\r\tself nonEmpty at: 1\t\"Ensures #nonEmpty is sequenceable\""},{"name":"testHasEqualElements","linesOfCode":5,"sourceCode":"testHasEqualElements\r\r\tself deny: (self empty hasEqualElements: self nonEmpty).\r\tself deny: (self nonEmpty hasEqualElements: self nonEmpty asSet). \r\tself deny: (self nonEmpty reversed hasEqualElements: self nonEmpty).\r\tself deny: (self nonEmpty hasEqualElements: self nonEmpty reversed)"},{"name":"testEqualSignOfIdenticalCollectionObjects","linesOfCode":3,"sourceCode":"testEqualSignOfIdenticalCollectionObjects\r\t\r\tself assert: self empty equals: self empty. \r\tself assert: self nonEmpty equals: self nonEmpty \r\t"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r\t^ self explicitRequirement"},{"name":"testEqualSignIsTrueForNonIdenticalButEqualCollections","linesOfCode":9,"sourceCode":"testEqualSignIsTrueForNonIdenticalButEqualCollections\r\t\t\r\tself assert: self empty equals: self empty copy. \r\tself assert: self empty copy equals: self empty.\r\tself assert: self empty copy equals: self empty copy.\r\t\t\r\tself assert: self nonEmpty equals: self nonEmpty copy. \r\tself assert: self nonEmpty copy equals: self nonEmpty.\r\tself assert: self nonEmpty copy equals: self nonEmpty copy"}],"meta":{"name":"TSequencedStructuralEqualityTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TPrintOnSequencedTest","instanceVariables":[],"methods":[{"name":"testPrintOn","linesOfCode":17,"sourceCode":"testPrintOn\r\r\t| aStream result allElementsAsString |\r\tresult := ''.\r\taStream := ReadWriteStream on: result.\r\t\r\tself nonEmpty printOn: aStream .\r\tallElementsAsString:=(result findBetweenSubstrings: ' ' ).\r\tallElementsAsString withIndexDo: \r\t\t[:el :i | \r\t\ti=1\r\t\t\tifTrue:[\r\t\t\t\tself accessCollection class name first isVowel \r\t\t\t\t\tifTrue:[self assert: el equals: 'an' ]\r\t\t\t\t\tifFalse:[self assert: el equals: 'a'].].\r\t\ti=2\r\t\t\tifTrue:[self assert: el equals: self accessCollection class name].\r\t\ti>2\r\t\t\tifTrue:[self assert: (allElementsAsString at:i)=((self nonEmpty at:i)asString)]]"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r self explicitRequirement"},{"name":"testPrintOnDelimiterLast","linesOfCode":14,"sourceCode":"testPrintOnDelimiterLast\r\r\t| aStream result allElementsAsString |\r\tresult:=''.\r\taStream:= ReadWriteStream on: result.\r\t\r\tself nonEmpty printOn: aStream delimiter: ', ' last: 'and'.\r\t\r\tallElementsAsString:=(result findBetweenSubstrings: ', ').\r\tallElementsAsString withIndexDo: \r\t\t[:el :i | \r\t\ti<(allElementsAsString size-1 )\r\t\t\tifTrue: [self assert: (allElementsAsString at:i) equals: ((self nonEmpty at:i)asString)].\r\t\ti=(allElementsAsString size-1)\r\t\t\tifTrue:[ self deny: (allElementsAsString at:i) equals: ('and')asString].\r\t\ti=(allElementsAsString size)\r\t\t\tifTrue: [self assert: (allElementsAsString at:i) equals: ((self nonEmpty at:(i-1))asString)]]"},{"name":"testPrintNameOn","linesOfCode":8,"sourceCode":"testPrintNameOn\r\r\t| aStream result |\r\tresult := ''.\r\taStream := ReadWriteStream on: result.\r\t\r\tself nonEmpty printNameOn: aStream.\r\r\tself nonEmpty class name first isVowel\r\t\tifTrue:[ self assert: aStream contents equals: ('an ',self nonEmpty class name ) ]\r\t\tifFalse:[ self assert: aStream contents equals: ('a ',self nonEmpty class name)]."},{"name":"testPrintElementsOn","linesOfCode":8,"sourceCode":"testPrintElementsOn\r\r\t| aStream result allElementsAsString |\r\tresult := ''.\r\taStream := ReadWriteStream on: result.\r\t\r\tself nonEmpty printElementsOn: aStream.\r\tallElementsAsString:=(result findBetweenSubstrings: ' ').\r\tallElementsAsString withIndexDo: \r\t\t[:el :i | self assert: el equals: ((self nonEmpty at: i)asString) ]"},{"name":"testPrintOnDelimiter","linesOfCode":8,"sourceCode":"testPrintOnDelimiter\r\r\t| aStream result allElementsAsString |\r\tresult := ''.\r\taStream := ReadWriteStream on: result.\r\t\r\tself nonEmpty printOn: aStream delimiter: ', '.\r\t\r\tallElementsAsString := (result findBetweenSubstrings: ', ' ).\r\tallElementsAsString withIndexDo: \r\t\t[:el :i |  self assert: el equals: ((self nonEmpty at:i)asString)]"},{"name":"test0FixturePrintTest","linesOfCode":2,"sourceCode":"test0FixturePrintTest\r\r\tself nonEmpty"}],"meta":{"name":"TPrintOnSequencedTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TAddTest","instanceVariables":[],"methods":[{"name":"testTAddWithOccurrences","linesOfCode":9,"sourceCode":"testTAddWithOccurrences\r\t| added oldSize collection anElement |\r\tcollection := self collectionWithElement.\r\tanElement := self element.\r\toldSize := collection size.\r\tadded := collection add: anElement withOccurrences: 5.\r\t\r\tself assert: added == anElement.\t\"test for identiy because #add: has not reason to copy its parameter.\"\r\tself assert: (collection includes: anElement).\r\tself assert: collection size equals: (oldSize + 5)"},{"name":"testTAddIfNotPresentWithElementAlreadyIn","linesOfCode":9,"sourceCode":"testTAddIfNotPresentWithElementAlreadyIn\r\r\t| added oldSize collection anElement |\r\tcollection := self collectionWithElement.\r\toldSize := collection size.\r\tanElement := self element.\r\tself assert: (collection includes: anElement).\r\t\r\tadded := collection addIfNotPresent: anElement.\r\t\r\tself assert: added == anElement .\t\"test for identiy because #add: has not reason to copy its parameter.\"\r\tself assert: collection size equals: oldSize"},{"name":"testTAddIfNotPresentWithNewElement","linesOfCode":9,"sourceCode":"testTAddIfNotPresentWithNewElement\r\r\t| added oldSize collection elem |\r\tcollection := self otherCollection.\r\toldSize := collection size.\r\telem := self element.\r\tself deny: (collection includes: elem ).\r\t\r\tadded := collection  addIfNotPresent: elem .\r\tself assert: added == elem . \"test for identiy because #add: has not reason to copy its parameter.\"\r\tself assert: collection size equals: (oldSize + 1).\r\r\t"},{"name":"testTAddTwice","linesOfCode":11,"sourceCode":"testTAddTwice\r\r\t| added oldSize collection anElement |\r\tcollection := self collectionWithElement.\r\tanElement := self element.\r\toldSize := collection size.\r\tadded := collection \r\t\tadd: anElement;\r\t\tadd: anElement.\r\tself assert: added == anElement.\t\"test for identiy because #add: has not reason to copy its parameter.\"\r\tself assert: (collection includes: anElement).\r\tself assert: collection size equals: (oldSize + 2)"},{"name":"element","linesOfCode":3,"sourceCode":"element\r\t\"Returns an object that can be added to the collection returned by #collection.\"\r\t^ self explicitRequirement"},{"name":"testTAddAll","linesOfCode":7,"sourceCode":"testTAddAll\r\r\t| added collection toBeAdded |\r\tcollection := self collectionWithElement.\r\ttoBeAdded := self otherCollection.\r\tadded := collection addAll: toBeAdded.\r\tself assert: added == toBeAdded .\t\"test for identiy because #addAll: has not reason to copy its parameter.\"\r\tself assert: (collection includesAll: toBeAdded )"},{"name":"testTAdd","linesOfCode":7,"sourceCode":"testTAdd\r\t| added collection |\r\tcollection := self otherCollection.\r\tadded := collection add: self element.\r\t\r\tself assert: added == self element.\t\"test for identiy because #add: has not reason to copy its parameter.\"\r\tself assert: (collection includes: self element)\t.\r\tself assert: (self collectionWithElement includes: self element).\r\t\r\t"},{"name":"collectionWithElement","linesOfCode":3,"sourceCode":"collectionWithElement\r\t\"Returns a collection that already includes what is returned by #element.\"\r\t^ self explicitRequirement"},{"name":"test0FixtureRequirementsOfTAddTest","linesOfCode":6,"sourceCode":"test0FixtureRequirementsOfTAddTest\r\r\tself collectionWithElement.\r\tself otherCollection.\r\tself element.\r\tself assert: (self collectionWithElement includes: self element).\r\tself deny: (self otherCollection includes: self element)"},{"name":"otherCollection","linesOfCode":3,"sourceCode":"otherCollection\r\t\"Returns a collection that does not include what is returned by #element.\"\r\t^ self explicitRequirement"}],"meta":{"name":"TAddTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TIncludesTest","instanceVariables":[],"methods":[{"name":"testIncludesElementIsNotThere","linesOfCode":4,"sourceCode":"testIncludesElementIsNotThere\r\t\r\tself deny: (self nonEmpty includes: self elementNotIn).\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne).\r\tself deny: (self empty includes: self elementNotIn)"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ self explicitRequirement"},{"name":"testIncludesAllNoneThere","linesOfCode":3,"sourceCode":"testIncludesAllNoneThere\r\r\tself deny: (self empty includesAll: self nonEmpty ).\r\tself deny: (self nonEmpty includesAll: { self elementNotIn. self anotherElementNotIn })"},{"name":"testIncludesAnyAllThere","linesOfCode":4,"sourceCode":"testIncludesAnyAllThere\r\r\tself deny: (self nonEmpty includesAny: self empty).\r\tself assert: (self nonEmpty includesAny: { self nonEmpty anyOne }).\r\tself assert: (self nonEmpty includesAny: self nonEmpty)."},{"name":"anotherElementNotIn","linesOfCode":3,"sourceCode":"anotherElementNotIn\r\" return an element different of 'elementNotIn'  not included in 'nonEmpty' \"\r\t^ self explicitRequirement"},{"name":"testIdentityIncludesNonSpecificComportement","linesOfCode":6,"sourceCode":"testIdentityIncludesNonSpecificComportement\r\t\"Test the same comportement than #includes:\"\r\t\r\t| collection |\t\r\tcollection := self nonEmpty.\r\t\r\tself deny: (collection identityIncludes: self elementNotIn).\r\tself assert: (collection identityIncludes: collection anyOne)\r"},{"name":"test0FixtureIncludeTest","linesOfCode":14,"sourceCode":"test0FixtureIncludeTest\r\t| anElementIn |\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself elementNotIn.\r\tanElementIn := true.\r\tself nonEmpty detect: [ :each | each = self elementNotIn ] ifNone: [ anElementIn := false ].\r\tself deny: anElementIn.\r\tself anotherElementNotIn.\r\tanElementIn := true.\r\tself nonEmpty detect: [ :each | each = self anotherElementNotIn ] ifNone: [ anElementIn := false ].\r\tself deny: anElementIn.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"testIncludesElementIsThere","linesOfCode":2,"sourceCode":"testIncludesElementIsThere\r\t\r\tself assert: (self nonEmpty includes: self nonEmpty anyOne)."},{"name":"elementNotIn","linesOfCode":3,"sourceCode":"elementNotIn\r\"return an element not included in 'nonEmpty' \"\r\r\t^ self explicitRequirement"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ self explicitRequirement"},{"name":"testIncludesAnyNoneThere","linesOfCode":3,"sourceCode":"testIncludesAnyNoneThere\r\t\r\tself deny: (self nonEmpty includesAny: self empty).\r\tself deny: (self nonEmpty includesAny: { self elementNotIn. self anotherElementNotIn })"}],"meta":{"name":"TIncludesTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TOccurrencesForMultiplinessTest","instanceVariables":[],"methods":[{"name":"collectionWithEqualElements","linesOfCode":3,"sourceCode":"collectionWithEqualElements\r\" return a collecition including atLeast two elements equal\"\r\r^ self explicitRequirement."},{"name":"testOccurrencesOfForMultipliness","linesOfCode":5,"sourceCode":"testOccurrencesOfForMultipliness\r\r\t| collection elem |\r\tcollection := self collectionWithEqualElements.\r\telem := self elementTwiceInForOccurrences.\r\r\tself assert: (collection occurrencesOf: elem ) equals: 2.  "},{"name":"testOccurrencesOfEmpty","linesOfCode":4,"sourceCode":"testOccurrencesOfEmpty\r\r\t| result |\r\tresult := self empty occurrencesOf: (self collectionWithoutEqualElements anyOne).\r\tself assert: result equals: 0"},{"name":"elementNotInForOccurrences","linesOfCode":3,"sourceCode":"elementNotInForOccurrences\r\" return an element notIncluded in #collectionWithoutEqualElements\"\r\tself explicitRequirement"},{"name":"test0FixtureOccurrencesTest","linesOfCode":13,"sourceCode":"test0FixtureOccurrencesTest\r\t| tmp |\r\tself empty.\r\tself assertEmpty: self empty.\r\tself collectionWithoutEqualElements.\r\tself denyEmpty: self collectionWithoutEqualElements.\r\ttmp := OrderedCollection new.\r\tself collectionWithoutEqualElements\r\t\tdo: [ :each | \r\t\t\tself deny: (tmp includes: each).\r\t\t\ttmp add: each ].\r\tself elementNotInForOccurrences.\r\tself deny: (self collectionWithoutEqualElements includes: self elementNotInForOccurrences)"},{"name":"collectionWithoutEqualElements","linesOfCode":2,"sourceCode":"collectionWithoutEqualElements\r\tself explicitRequirement"},{"name":"testOccurrencesOfNotIn","linesOfCode":4,"sourceCode":"testOccurrencesOfNotIn\r\r\t| result |\r\tresult := self collectionWithoutEqualElements occurrencesOf: self elementNotInForOccurrences.\r\tself assert: result equals: 0"},{"name":"test0FixtureOccurrencesForMultiplinessTest","linesOfCode":11,"sourceCode":"test0FixtureOccurrencesForMultiplinessTest\r\t| cpt |\r\tself collectionWithEqualElements.\r\tself collectionWithEqualElements.\r\tself elementTwiceInForOccurrences.\r\tself elementTwiceInForOccurrences.\r\tself collectionWithEqualElements.\r\tcpt := 0. \" testing with identity check ( == ) so that identy collections can use this trait : \"\r\tself collectionWithEqualElements do: [ :each | \r\t\teach == self elementTwiceInForOccurrences ifTrue: [ cpt := cpt + 1 ] ].\r\tself assert: cpt = 2"},{"name":"testOccurrencesOf","linesOfCode":4,"sourceCode":"testOccurrencesOf\r\t| collection |\r\tcollection := self collectionWithoutEqualElements .\r\t\r\tcollection do: [ :each | self assert: (collection occurrencesOf: each) equals: 1 ]"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself explicitRequirement"},{"name":"elementTwiceInForOccurrences","linesOfCode":3,"sourceCode":"elementTwiceInForOccurrences\r\" return an element included exactly two time in # collectionWithEqualElements\"\r^ self explicitRequirement"}],"meta":{"name":"TOccurrencesForMultiplinessTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"CollectionRootTest","instanceVariables":[],"methods":[{"name":"testDetectIfFoundWhenSomethingIsFoundIgnoringTheFoundObject","linesOfCode":6,"sourceCode":"testDetectIfFoundWhenSomethingIsFoundIgnoringTheFoundObject\r\t\"The foundBlock can be a zero argument block ignoring the object found\"\r\r\t| wasFound |\r\twasFound := false.\r\tself collectionWithoutNilElements detect: [ :each | each notNil ] ifFound: [ wasFound := true ].\r\tself assert: wasFound"},{"name":"element","linesOfCode":2,"sourceCode":"element\r\t^ 3"},{"name":"sizeCollection","linesOfCode":3,"sourceCode":"sizeCollection\r\t\"Answers a collection not empty\"\r\t^ self subclassResponsibility"},{"name":"testDetectIfFoundIfNoneWhenSomethingIsFound","linesOfCode":12,"sourceCode":"testDetectIfFoundIfNoneWhenSomethingIsFound\r\t| wasFound foundObject |\r\tfoundObject := nil.\r\twasFound := self collectionWithoutNilElements\r\t\tdetect: [ :each | each notNil ]\r\t\tifFound: [ :element | \r\t\t\tfoundObject := element.\r\t\t\ttrue ]\r\t\tifNone: [ false ].\r\tself\r\t\tassert: wasFound;\r\t\tassert: (self collectionWithoutNilElements includes: foundObject)"},{"name":"testRejectNoReject","linesOfCode":5,"sourceCode":"testRejectNoReject\r\t| res collection |\r\tcollection := self collectionWithoutNilElements.\r\tres := collection reject: [ :each | each isNil ].\r\tself assert: res size equals: collection size"},{"name":"collectionWithoutNilElements","linesOfCode":3,"sourceCode":"collectionWithoutNilElements\r\" return a collection that doesn't includes a nil element  and that doesn't includes equal elements'\"\r\tself subclassResponsibility"},{"name":"elementTwiceIn","linesOfCode":2,"sourceCode":"elementTwiceIn\r\t^ 1 \"12332312322\""},{"name":"doWithoutNumber","linesOfCode":2,"sourceCode":"doWithoutNumber\r\r\t^ 2"},{"name":"testDetectIfFoundIfNoneWhenSomethingIsFoundIgnoringTheFoundObject","linesOfCode":5,"sourceCode":"testDetectIfFoundIfNoneWhenSomethingIsFoundIgnoringTheFoundObject\r\t\"The foundBlock can be a zero argument block ignoring the object found\"\r\r\t| wasFound |\r\twasFound := self collectionWithoutNilElements detect: [ :each | each notNil ] ifFound: [ true ] ifNone: [ false ].\r\tself assert: wasFound"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\r\tself subclassResponsibility"},{"name":"testDetectIfFoundWhenSomethingIsFound","linesOfCode":12,"sourceCode":"testDetectIfFoundWhenSomethingIsFound\r\t| wasFound foundObject |\r\twasFound := false.\r\tfoundObject := nil.\r\tself collectionWithoutNilElements\r\t\tdetect: [ :each | each notNil ]\r\t\tifFound: [ :element | \r\t\t\tfoundObject := element.\r\t\t\twasFound := true ].\r\tself\r\t\tassert: wasFound;\r\t\tassert: (self collectionWithoutNilElements includes: foundObject)\r"},{"name":"expectedElementByDetect","linesOfCode":2,"sourceCode":"expectedElementByDetect\r\r\t^ -2"},{"name":"testDetectIfFoundWhenNobodyIsFound","linesOfCode":5,"sourceCode":"testDetectIfFoundWhenNobodyIsFound\r\t| wasFound |\r\twasFound := false.\r\tself collectionWithoutNilElements detect: [ :each | each isNil ] ifFound: [ wasFound := true ].\r\tself deny: wasFound"},{"name":"testDetectIfFoundIfNoneWhenNobodyIsFound","linesOfCode":4,"sourceCode":"testDetectIfFoundIfNoneWhenNobodyIsFound\r\t| wasFound |\r\twasFound := self collectionWithoutNilElements detect: [ :each | each isNil ] ifFound: [ true ] ifNone: [ false ].\r\tself deny: wasFound"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\tself subclassResponsibility"}],"meta":{"name":"CollectionRootTest class","instanceVariables":[],"methods":[{"name":"isAbstract","linesOfCode":2,"sourceCode":"isAbstract\r\r\t^ self name = #CollectionRootTest"}],"meta":null}},{"name":"TSortTest","instanceVariables":[],"methods":[{"name":"testSorted","linesOfCode":10,"sourceCode":"testSorted\r\t| result tmp unsorted |\r\tunsorted := self unsortedCollection.\r\tresult := unsorted sorted.\r\tself deny: unsorted == result.\r\ttmp := result at: 1.\r\tresult\r\t\tdo: [ :each | \r\t\t\tself assert: each >= tmp.\r\t\t\ttmp := each ]"},{"name":"test0SortingArrayedTest","linesOfCode":15,"sourceCode":"test0SortingArrayedTest\r\t| tmp sorted |\r\t\" an unsorted collection of number \"\r\tself unsortedCollection.\r\tself unsortedCollection do: [ :each | each isNumber ].\r\tsorted := true.\r\tself unsortedCollection pairsDo: [ :each1 :each2 | each2 < each1 ifTrue: [ sorted := false ] ].\r\tself deny: sorted.\t\" a collection of number sorted in an ascending order\"\r\tself sortedInAscendingOrderCollection.\r\tself sortedInAscendingOrderCollection do: [ :each | each isNumber ].\r\ttmp := self sortedInAscendingOrderCollection at: 1.\r\tself sortedInAscendingOrderCollection\r\t\tdo: [ :each | \r\t\t\tself assert: each >= tmp.\r\t\t\ttmp := each ]"},{"name":"testSortUsingSortBlock","linesOfCode":6,"sourceCode":"testSortUsingSortBlock\r\t| result tmp |\r\tresult := self unsortedCollection sort: [:a :b | a>b].\r\ttmp := result at: 1.\r\tresult do:\r\t\t[:each | self assert: each<=tmp. tmp:= each. ]."},{"name":"sortedInAscendingOrderCollection","linesOfCode":3,"sourceCode":"sortedInAscendingOrderCollection\r\t\"Return a collection sorted in ascending order\"\r\t^ self explicitRequirement\r\t"},{"name":"testIsSortedBy","linesOfCode":3,"sourceCode":"testIsSortedBy\r\tself assert: (self sortedInAscendingOrderCollection isSortedBy: [:a :b | a<b]).\r\tself deny: (self sortedInAscendingOrderCollection isSortedBy: [:a :b | a>b]).\r"},{"name":"unsortedCollection","linesOfCode":3,"sourceCode":"unsortedCollection\r\"Return a collection that is not yet sorted\"\r\t^self explicitRequirement"},{"name":"testSort","linesOfCode":6,"sourceCode":"testSort\r\t| result tmp |\r\tresult := self unsortedCollection sort.\r\ttmp := result at: 1.\r\tresult do:\r\t\t[:each | self assert: each>=tmp. tmp:= each. ]."},{"name":"testIsSorted","linesOfCode":3,"sourceCode":"testIsSorted\r\tself assert: self sortedInAscendingOrderCollection isSorted.\r\tself deny: self unsortedCollection isSorted"},{"name":"testSortedUsingBlock","linesOfCode":6,"sourceCode":"testSortedUsingBlock\r\t| result tmp |\r\tresult := self unsortedCollection sorted:  [:a :b | a>b]..\r\ttmp := result at: 1.\r\tresult do:\r\t\t[:each | self assert: each<=tmp. tmp:= each. ]."}],"meta":{"name":"TSortTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TAddForIdentityCollectionsTest","instanceVariables":[],"methods":[{"name":"testTAddIfNotPresentWithElementCopy","linesOfCode":11,"sourceCode":"testTAddIfNotPresentWithElementCopy\r\" test specific to IdentityCollections for wich #addIfNotPresent should use == check insted of =.\"\r\t| added oldSize collection element elementCopy |\r\tcollection := self identityCollectionWithElementsCopyNotIdentical   .\r\toldSize := collection  size.\r\t\r\telement := collection  anyOne .\r\telementCopy := element copy.\r\tself deny: (collection  includes: elementCopy ).\r\t\r\tadded := collection  addIfNotPresent: elementCopy  .\r\tself assert: added == elementCopy . \"test for identiy because #add: has not reason to copy its parameter.\"\r\tself assert: (collection  size = (oldSize + 1)).\r\r\t"},{"name":"identityCollectionWithElementsCopyNotIdentical","linesOfCode":3,"sourceCode":"identityCollectionWithElementsCopyNotIdentical\r\t\"Returns a collection including elements for which #copy doesn't return the same object.\"\r\t^ self explicitRequirement"},{"name":"test0FixtureAddForIdentityCollectionsTest","linesOfCode":3,"sourceCode":"test0FixtureAddForIdentityCollectionsTest\r\t\r\tself identityCollectionWithElementsCopyNotIdentical.\r\tself identityCollectionWithElementsCopyNotIdentical  do: [ : each | self deny: each == each copy ]."}],"meta":{"name":"TAddForIdentityCollectionsTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopyTest","instanceVariables":[],"methods":[{"name":"collectionNotIncluded","linesOfCode":3,"sourceCode":"collectionNotIncluded\r\" return a collection for wich each element is not included in 'nonEmpty' \"\r\t^ self explicitRequirement"},{"name":"testCopyEmptyWithout","linesOfCode":5,"sourceCode":"testCopyEmptyWithout\r\r\t| res |\r\tres := self empty copyWithout: self elementToAdd.\r\tself assert: res size equals: self empty size.\r\tself deny: (res includes: self elementToAdd)"},{"name":"testCopyEmptyWith","linesOfCode":6,"sourceCode":"testCopyEmptyWith\r\r\t| res anElement |\r\tanElement := self elementToAdd.\r\tres := self empty copyWith: anElement.\r\tself assert: res size equals: (self empty size + 1).\r\tself assert: (res includes: (anElement value))"},{"name":"testCopyNonEmptyWithout","linesOfCode":11,"sourceCode":"testCopyNonEmptyWithout\r\t\r\t| res anElementOfTheCollection |\r\tanElementOfTheCollection :=  self nonEmpty anyOne.\r\tres := (self nonEmpty copyWithout: anElementOfTheCollection).\r\t\"here we do not test the size since for a non empty set we would get a problem.\r\tThen in addition copy is not about duplicate management. The element should \r\tbe in at the end.\"\r\tself deny: (res includes: anElementOfTheCollection).\r\tself nonEmpty do:\r\t\t[:each | (each = anElementOfTheCollection) \r\t\t\t\t\tifFalse: [self assert: (res includes: each)]]\r\t\r"},{"name":"testCopyNotSame","linesOfCode":5,"sourceCode":"testCopyNotSame\r\t\"A copy of a collection should always be of the same class as the instance it copies\"\r\t\r\t| copy | \r\tcopy := self nonEmpty copy.\r\tself deny: copy  == self nonEmpty"},{"name":"test0CopyTest","linesOfCode":11,"sourceCode":"test0CopyTest\r\tself empty.\r\tself assertEmpty: self empty.\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself collectionWithElementsToRemove.\r\tself denyEmpty: self collectionWithElementsToRemove.\r\tself collectionWithElementsToRemove do: [ :each | self assert: (self nonEmpty includes: each) ].\r\tself elementToAdd.\r\tself deny: (self nonEmpty includes: self elementToAdd).\r\tself collectionNotIncluded do: [ :each | self deny: (self nonEmpty includes: each) ]"},{"name":"testCopyNonEmptyWith","linesOfCode":9,"sourceCode":"testCopyNonEmptyWith\r\r\t| res anElement |\r\tanElement := self elementToAdd .\r\tres := self nonEmpty copyWith: anElement.\r\t\"Here we do not test the size since for a non empty set we would get a problem.\r\tThen in addition copy is not about duplicate management. The element should \r\tbe in at the end.\"\r\tself assert: (res includes: (anElement value)).\r\tself nonEmpty do: [ :each | res includes: each ]"},{"name":"testCopyNonEmptyWithoutAllNotIncluded","linesOfCode":7,"sourceCode":"testCopyNonEmptyWithoutAllNotIncluded\r\r\t| res |\r\tres := self nonEmpty copyWithoutAll: self collectionNotIncluded.\r\t\"here we do not test the size since for a non empty set we would get a problem.\r\tThen in addition copy is not about duplicate management. The element should \r\tbe in at the end.\"\r\tself nonEmpty do: [ :each | self assert: (res includes: each) ]"},{"name":"collectionWithElementsToRemove","linesOfCode":3,"sourceCode":"collectionWithElementsToRemove\r\" return a collection of elements included in 'nonEmpty'  \"\r\t^ self explicitRequirement"},{"name":"elementToAdd","linesOfCode":3,"sourceCode":"elementToAdd\r\" return an element of type 'nonEmpy' elements'type'  not  yet included in nonEmpty\" \r\t^ self explicitRequirement"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t^ self explicitRequirement"},{"name":"testCopyNonEmptyWithoutNotIncluded","linesOfCode":7,"sourceCode":"testCopyNonEmptyWithoutNotIncluded\r\r\t| res |\r\tres := self nonEmpty copyWithout: self elementToAdd.\r\t\"here we do not test the size since for a non empty set we would get a problem.\r\tThen in addition copy is not about duplicate management. The element should \r\tbe in at the end.\"\r\tself nonEmpty do: [ :each | self assert: (res includes: each) ]"},{"name":"testCopyNonEmptyWithoutAll","linesOfCode":10,"sourceCode":"testCopyNonEmptyWithoutAll\r\r\t| res |\r\tres := self nonEmpty copyWithoutAll: self collectionWithElementsToRemove.\r\t\"here we do not test the size since for a non empty set we would get a problem.\r\tThen in addition copy is not about duplicate management. The element should \r\tbe in at the end.\"\r\tself collectionWithElementsToRemove do: [ :each | self deny: (res includes: (each)) ].\r\tself nonEmpty do: \r\t\t[ :each | \r\t\t(self collectionWithElementsToRemove includes: each) ifFalse: [ self assert: (res includes: each) ] ]"},{"name":"testCopyEmptyWithoutAll","linesOfCode":5,"sourceCode":"testCopyEmptyWithoutAll\r\r\t| res |\r\tres := self empty copyWithoutAll: self collectionWithElementsToRemove.\r\tself assert: res size equals: self empty size.\r\tself collectionWithElementsToRemove do: [ :each | self deny: (res includes: each) ]"},{"name":"testCopyEquals","linesOfCode":5,"sourceCode":"testCopyEquals\r\t\"A copy should be equivalent to the things it's a copy of.\"\r\t\r\t| copy | \r\tcopy := self nonEmpty copy.\r\tself assert: copy equals: self nonEmpty"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t^ self explicitRequirement"},{"name":"testCopySameClass","linesOfCode":5,"sourceCode":"testCopySameClass\r\t\"A copy of a collection should always be of the same class as the instance it copies\"\r\t\r\t| copy | \r\tcopy := self empty copy.\r\tself assert: copy class == self empty class"}],"meta":{"name":"TCopyTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TCopyPartOfSequenceableForMultipliness","instanceVariables":[],"methods":[{"name":"testCopyUpToWithDuplicate","linesOfCode":9,"sourceCode":"testCopyUpToWithDuplicate\r\t| result element collection |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection last.\r\r\t\"collectionWithSameAtEndAndBegining first and last elements are equals.\r \t 'copyUpTo:' should copy until the first occurrence\"\r\tresult := collection copyUpTo: element.\r\r\t\"Verify content\"\r\tself assertEmpty: result"},{"name":"collectionWithSameAtEndAndBegining","linesOfCode":4,"sourceCode":"collectionWithSameAtEndAndBegining\r\" return a collection with elements at end and begining equals .\r(others elements of the collection are not equal to those elements)\"\r\tself explicitRequirement"},{"name":"testCopyAfterLastWithDuplicate","linesOfCode":9,"sourceCode":"testCopyAfterLastWithDuplicate\r\t| result element collection |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection first.\r\r\t\"collectionWithSameAtEndAndBegining first and last elements are equals.\r\t'copyAfter:' should copy after the last occurrence of element :\"\r\tresult := collection copyAfterLast: element.\r\r\t\"Verify content\"\r\tself assertEmpty: result"},{"name":"testCopyUpToLastWithDuplicate","linesOfCode":11,"sourceCode":"testCopyUpToLastWithDuplicate\r\r\t| result element  collection |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection first.\r\t\r\t\"collectionWithSameAtEndAndBegining first and last elements are equals.\r\t'copyUpToLast:' should copy until the last occurrence :\"\r\tresult := collection copyUpToLast: (element ).\r\t\r\t\"Verify content\"\r\tresult withIndexDo: \r\t\t[:el :i | self assert: (result at: i) equals: (collection at: i) ].\r\t\r\tself assert: result size equals: (collection size - 1)\r\r"},{"name":"testCopyAfterWithDuplicate","linesOfCode":12,"sourceCode":"testCopyAfterWithDuplicate\r\r\t| result element  collection |\r\tcollection := self collectionWithSameAtEndAndBegining.\r\telement := collection last.\r\t\r\t\"collectionWithSameAtEndAndBegining first and last elements are equals.\r\t'copyAfter:' should copy after the first occurrence:\"\r\tresult := collection   copyAfter: (element ).\r\t\r\t\"Verifying content\"\r\tresult withIndexDo: \r\t\t[:e :i | self assert: (collection at: (i + 1 )) equals: (result at: (i)) ].\r\r\t\"Verify size\"\r\tself assert: result size equals: (collection size - 1)."},{"name":"test0FixtureCopyPartOfForMultipliness","linesOfCode":7,"sourceCode":"test0FixtureCopyPartOfForMultipliness\r\r\tself collectionWithSameAtEndAndBegining.\r\tself assert: self collectionWithSameAtEndAndBegining first = self collectionWithSameAtEndAndBegining last.\r\tself assert: self collectionWithSameAtEndAndBegining size > 1.\r\t1 to: self collectionWithSameAtEndAndBegining size do: [ :i | \r\t\ti > 1 & (i < self collectionWithSameAtEndAndBegining size)\r\t\t\tifTrue: [ self deny: (self collectionWithSameAtEndAndBegining at: i) = self collectionWithSameAtEndAndBegining first ] ]"}],"meta":{"name":"TCopyPartOfSequenceableForMultipliness classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TEmptyTest","instanceVariables":[],"methods":[{"name":"testIfNotEmpty","linesOfCode":4,"sourceCode":"testIfNotEmpty\r\tself empty ifNotEmpty: [ self assert: false ].\r\tself nonEmpty ifNotEmpty: [ self assert: true ].\r\tself assert: (self nonEmpty ifNotEmpty: [ :s | s ]) = self nonEmpty"},{"name":"nonEmpty","linesOfCode":2,"sourceCode":"nonEmpty\r\t\r\t^ self explicitRequirement"},{"name":"test0FixtureEmptyTest","linesOfCode":5,"sourceCode":"test0FixtureEmptyTest\r\tself nonEmpty.\r\tself denyEmpty: self nonEmpty.\r\tself empty.\r\tself assertEmpty: self empty"},{"name":"testIsEmptyOrNil","linesOfCode":3,"sourceCode":"testIsEmptyOrNil\r\tself assert: self empty isEmptyOrNil.\r\tself deny: self nonEmpty isEmptyOrNil"},{"name":"testIfEmptyifNotEmpty","linesOfCode":3,"sourceCode":"testIfEmptyifNotEmpty\r\tself assert: (self empty ifEmpty: [ true ] ifNotEmpty: [ false ]).\r\tself assert: (self nonEmpty ifEmpty: [ false ] ifNotEmpty: [ true ])"},{"name":"testIfNotEmptyifEmpty","linesOfCode":3,"sourceCode":"testIfNotEmptyifEmpty\r\tself assert: (self empty ifNotEmpty: [ false ] ifEmpty: [ true ]).\r\tself assert: (self nonEmpty ifNotEmpty: [ true ] ifEmpty: [ false ])"},{"name":"testIsEmpty","linesOfCode":3,"sourceCode":"testIsEmpty\r\tself assert: self empty isEmpty.\r\tself deny: self nonEmpty isEmpty"},{"name":"testNotEmpty","linesOfCode":3,"sourceCode":"testNotEmpty\r\tself assert: self nonEmpty notEmpty.\r\tself deny: self empty notEmpty"},{"name":"empty","linesOfCode":2,"sourceCode":"empty\r\t\r\t^ self explicitRequirement"},{"name":"testIfEmpty","linesOfCode":3,"sourceCode":"testIfEmpty\r\tself nonEmpty ifEmpty: [ self assert: false ].\r\tself empty ifEmpty: [ self assert: true ]"}],"meta":{"name":"TEmptyTest classTrait","instanceVariables":[],"methods":[],"meta":null}},{"name":"TConvertAsSetForMultiplinessIdentityTest","instanceVariables":[],"methods":[{"name":"elementsCopyNonIdenticalWithoutEqualElements","linesOfCode":4,"sourceCode":"elementsCopyNonIdenticalWithoutEqualElements\r\t\" return a collection that does niot incllude equal elements ( classic equality )\r\tall elements included are elements for which copy is not identical to the element  \"\r\t^ self explicitRequirement"},{"name":"test0FixtureTConvertAsSetForMultiplinessTest","linesOfCode":7,"sourceCode":"test0FixtureTConvertAsSetForMultiplinessTest\r\t\"a collection  with equal elements:\"\r\r\t| res |\r\tself withEqualElements.\r\tres := true.\r\tself withEqualElements detect: [ :each | (self withEqualElements occurrencesOf: each) > 1 ] ifNone: [ res := false ].\r\tself assert: res = true"},{"name":"testAsIdentitySetWithoutIdentityEqualsElements","linesOfCode":10,"sourceCode":"testAsIdentitySetWithoutIdentityEqualsElements\r\r\t| result collection |\r\tcollection := self collectionWithCopy.\r\tresult := collection asIdentitySet.\r\t\" no elements should have been removed as no elements are equels with Identity equality\"\r\tself assert: result size = collection size.\r\tcollection do: \r\t\t[ :each | \r\t\t(collection occurrencesOf: each) = (result asOrderedCollection occurrencesOf: each) ].\r\tself assert: result class = IdentitySet"},{"name":"withEqualElements","linesOfCode":3,"sourceCode":"withEqualElements\r\t\" return a collection  including equal elements (classic equality)\"\r\t^ self explicitRequirement"},{"name":"testAsSetWithEqualsElements","linesOfCode":5,"sourceCode":"testAsSetWithEqualsElements\r\r\t| result |\r\tresult := self withEqualElements asSet.\r\tself withEqualElements do: [ :each | self assert: (result occurrencesOf: each) = 1 ].\r\tself assert: result class = Set"},{"name":"testAsIdentitySetWithIdentityEqualsElements","linesOfCode":14,"sourceCode":"testAsIdentitySetWithIdentityEqualsElements\r\r\t| result |\r\tresult := self collectionWithIdentical asIdentitySet.\r\t\" Only one element should have been removed as two elements are equals with Identity equality\"\r\tself assert: result size = (self collectionWithIdentical size - 1).\r\tself collectionWithIdentical do: \r\t\t[ :each | \r\t\t(self collectionWithIdentical occurrencesOf: each) > 1 \r\t\t\tifTrue: \r\t\t\t\t[ \"the two elements equals only with classic equality shouldn't 'have been removed\"\r\t\t\t\tself assert: (result asOrderedCollection occurrencesOf: each) = 1\r\t\t\t\t\" the other elements are still here\" ]\r\t\t\tifFalse: [ self assert: (result asOrderedCollection occurrencesOf: each) = 1 ] ].\r\tself assert: result class = IdentitySet"},{"name":"test0FixtureAsSetForIdentityMultiplinessTest","linesOfCode":11,"sourceCode":"test0FixtureAsSetForIdentityMultiplinessTest\r\t\"A collection (of elements for which copy is not identical ) without equal elements:\"\r\r\t| anElement res |\r\tself elementsCopyNonIdenticalWithoutEqualElements.\r\tanElement := self elementsCopyNonIdenticalWithoutEqualElements anyOne.\r\tself deny: anElement copy == anElement.\r\tres := true.\r\tself elementsCopyNonIdenticalWithoutEqualElements\r\t\tdetect: [ :each | (self elementsCopyNonIdenticalWithoutEqualElements occurrencesOf: each) > 1 ]\r\t\tifNone: [ res := false ].\r\tself assert: res = false"},{"name":"testAsIdentitySetWithEqualsElements","linesOfCode":6,"sourceCode":"testAsIdentitySetWithEqualsElements\r\r\t| result collection |\r\tcollection := self withEqualElements .\r\tresult := collection asIdentitySet.\r\tcollection do: [ :each | self assert: (result occurrencesOf: each) = 1 ].\r\tself assert: result class = IdentitySet"},{"name":"collectionWithIdentical","linesOfCode":8,"sourceCode":"collectionWithIdentical\r\t\"Return a collection of type: 'self collectionWIithoutEqualsElements class containing two elements equals (with identity equality).\"\r\r\t| result collection anElement |\r\tcollection := OrderedCollection withAll: self elementsCopyNonIdenticalWithoutEqualElements.\r\tanElement := collection first.\r\tcollection add: anElement.\r\tresult := self elementsCopyNonIdenticalWithoutEqualElements class withAll: collection.\r\t^ result"},{"name":"collectionWithCopy","linesOfCode":8,"sourceCode":"collectionWithCopy\r\t\"Return a collection of type 'self collectionWIithoutEqualsElements class' containing no elements equals (with identity equality)\r\tbut 2 elements only equals with classic equality\"\r\t\r\t| result collection |\r\tcollection := OrderedCollection withAll: self elementsCopyNonIdenticalWithoutEqualElements.\r\tcollection add: collection first copy.\r\tresult := self elementsCopyNonIdenticalWithoutEqualElements class withAll: collection.\r\t^ result"}],"meta":{"name":"TConvertAsSetForMultiplinessIdentityTest classTrait","instanceVariables":[],"methods":[],"meta":null}}]}]}